const __vite__mapDeps = (i, m = __vite__mapDeps, d = (m.f || (m.f = ["assets/affiliate-program-Dp2yZnjm.js", "assets/CircleWithIcon-4Vl_lIvJ.js", "assets/SectionSubTitle-DcqbhBXy.js", "assets/conversations-DyraImN2.js", "assets/sendIcon-BUeZ5IT-.js", "assets/index-BSbdZU2V.js", "assets/v4-CQkTLCs1.js", "assets/dashboard-nxZ0TEun.js", "assets/UITooltip-Caz5Edsk.js", "assets/react-tooltip.min-DmRvuy-r.js", "assets/BotsProvider-IfGpE4IX.js", "assets/exchange-DRIoKPGm.js", "assets/chat.config-YtiWuMOA.js", "assets/botId-mZO8aHMT.js", "assets/UIStepsNav-UjcnDm2y.js", "assets/bots-CjeAdQfj.js", "assets/BotSettings-Ck9aGn3Y.js", "assets/my-bots-D_HzAKqj.js", "assets/new-bot-DSIteUrs.js", "assets/pricing-Dsv9dCiq.js", "assets/staking-BNE0v0-z.js", "assets/WalletStakeCard-o2oMMuoO.js", "assets/nft-generator-C8tP2uwe.js", "assets/migration-Be-njFAo.js", "assets/team-verification-xjsORUYn.js", "assets/UIAlert-Qer0weIY.js", "assets/build-agent-CS71JEu4.js", "assets/ai-marketplace-B9SUU8oe.js", "assets/ai-marketplace-1O2rEOWV.css", "assets/agi-B5CtDf5n.js", "assets/toolName-CSfs3Pwj.js"]))) => i.map(i => d[i]);
var ywe = Object.defineProperty;
var cz = t => {
    throw TypeError(t)
};
var wwe = (t, e, n) => e in t ? ywe(t, e, {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: n
}) : t[e] = n;
var Ie = (t, e, n) => wwe(t, typeof e != "symbol" ? e + "" : e, n),
    _R = (t, e, n) => e.has(t) || cz("Cannot " + n);
var W = (t, e, n) => (_R(t, e, "read from private field"), n ? n.call(t) : e.get(t)),
    _e = (t, e, n) => e.has(t) ? cz("Cannot add the same private member more than once") : e instanceof WeakSet ? e.add(t) : e.set(t, n),
    le = (t, e, n, r) => (_R(t, e, "write to private field"), r ? r.call(t, n) : e.set(t, n), n),
    De = (t, e, n) => (_R(t, e, "access private method"), n);
var s0 = (t, e, n, r) => ({
    set _(i) {
        le(t, e, i, n)
    },
    get _() {
        return W(t, e, r)
    }
});

function AX(t, e) {
    for (var n = 0; n < e.length; n++) {
        const r = e[n];
        if (typeof r != "string" && !Array.isArray(r)) {
            for (const i in r)
                if (i !== "default" && !(i in t)) {
                    const s = Object.getOwnPropertyDescriptor(r, i);
                    s && Object.defineProperty(t, i, s.get ? s : {
                        enumerable: !0,
                        get: () => r[i]
                    })
                }
        }
    }
    return Object.freeze(Object.defineProperty(t, Symbol.toStringTag, {
        value: "Module"
    }))
}(function() {
    const e = document.createElement("link").relList;
    if (e && e.supports && e.supports("modulepreload")) return;
    for (const i of document.querySelectorAll('link[rel="modulepreload"]')) r(i);
    new MutationObserver(i => {
        for (const s of i)
            if (s.type === "childList")
                for (const o of s.addedNodes) o.tagName === "LINK" && o.rel === "modulepreload" && r(o)
    }).observe(document, {
        childList: !0,
        subtree: !0
    });

    function n(i) {
        const s = {};
        return i.integrity && (s.integrity = i.integrity), i.referrerPolicy && (s.referrerPolicy = i.referrerPolicy), i.crossOrigin === "use-credentials" ? s.credentials = "include" : i.crossOrigin === "anonymous" ? s.credentials = "omit" : s.credentials = "same-origin", s
    }

    function r(i) {
        if (i.ep) return;
        i.ep = !0;
        const s = n(i);
        fetch(i.href, s)
    }
})();
var st = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};

function co(t) {
    return t && t.__esModule && Object.prototype.hasOwnProperty.call(t, "default") ? t.default : t
}

function Fu(t) {
    if (t.__esModule) return t;
    var e = t.default;
    if (typeof e == "function") {
        var n = function r() {
            return this instanceof r ? Reflect.construct(e, arguments, this.constructor) : e.apply(this, arguments)
        };
        n.prototype = e.prototype
    } else n = {};
    return Object.defineProperty(n, "__esModule", {
        value: !0
    }), Object.keys(t).forEach(function(r) {
        var i = Object.getOwnPropertyDescriptor(t, r);
        Object.defineProperty(n, r, i.get ? i : {
            enumerable: !0,
            get: function() {
                return t[r]
            }
        })
    }), n
}
var TX = {
        exports: {}
    },
    lT = {},
    IX = {
        exports: {}
    },
    Gn = {};
/**
 * @license React
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var aE = Symbol.for("react.element"),
    vwe = Symbol.for("react.portal"),
    bwe = Symbol.for("react.fragment"),
    _we = Symbol.for("react.strict_mode"),
    Ewe = Symbol.for("react.profiler"),
    xwe = Symbol.for("react.provider"),
    Swe = Symbol.for("react.context"),
    Cwe = Symbol.for("react.forward_ref"),
    Awe = Symbol.for("react.suspense"),
    Twe = Symbol.for("react.memo"),
    Iwe = Symbol.for("react.lazy"),
    uz = Symbol.iterator;

function Rwe(t) {
    return t === null || typeof t != "object" ? null : (t = uz && t[uz] || t["@@iterator"], typeof t == "function" ? t : null)
}
var RX = {
        isMounted: function() {
            return !1
        },
        enqueueForceUpdate: function() {},
        enqueueReplaceState: function() {},
        enqueueSetState: function() {}
    },
    OX = Object.assign,
    NX = {};

function S2(t, e, n) {
    this.props = t, this.context = e, this.refs = NX, this.updater = n || RX
}
S2.prototype.isReactComponent = {};
S2.prototype.setState = function(t, e) {
    if (typeof t != "object" && typeof t != "function" && t != null) throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");
    this.updater.enqueueSetState(this, t, e, "setState")
};
S2.prototype.forceUpdate = function(t) {
    this.updater.enqueueForceUpdate(this, t, "forceUpdate")
};

function PX() {}
PX.prototype = S2.prototype;

function g$(t, e, n) {
    this.props = t, this.context = e, this.refs = NX, this.updater = n || RX
}
var m$ = g$.prototype = new PX;
m$.constructor = g$;
OX(m$, S2.prototype);
m$.isPureReactComponent = !0;
var fz = Array.isArray,
    kX = Object.prototype.hasOwnProperty,
    y$ = {
        current: null
    },
    MX = {
        key: !0,
        ref: !0,
        __self: !0,
        __source: !0
    };

function DX(t, e, n) {
    var r, i = {},
        s = null,
        o = null;
    if (e != null)
        for (r in e.ref !== void 0 && (o = e.ref), e.key !== void 0 && (s = "" + e.key), e) kX.call(e, r) && !MX.hasOwnProperty(r) && (i[r] = e[r]);
    var a = arguments.length - 2;
    if (a === 1) i.children = n;
    else if (1 < a) {
        for (var l = Array(a), c = 0; c < a; c++) l[c] = arguments[c + 2];
        i.children = l
    }
    if (t && t.defaultProps)
        for (r in a = t.defaultProps, a) i[r] === void 0 && (i[r] = a[r]);
    return {
        $$typeof: aE,
        type: t,
        key: s,
        ref: o,
        props: i,
        _owner: y$.current
    }
}

function Owe(t, e) {
    return {
        $$typeof: aE,
        type: t.type,
        key: e,
        ref: t.ref,
        props: t.props,
        _owner: t._owner
    }
}

function w$(t) {
    return typeof t == "object" && t !== null && t.$$typeof === aE
}

function Nwe(t) {
    var e = {
        "=": "=0",
        ":": "=2"
    };
    return "$" + t.replace(/[=:]/g, function(n) {
        return e[n]
    })
}
var dz = /\/+/g;

function ER(t, e) {
    return typeof t == "object" && t !== null && t.key != null ? Nwe("" + t.key) : e.toString(36)
}

function VS(t, e, n, r, i) {
    var s = typeof t;
    (s === "undefined" || s === "boolean") && (t = null);
    var o = !1;
    if (t === null) o = !0;
    else switch (s) {
        case "string":
        case "number":
            o = !0;
            break;
        case "object":
            switch (t.$$typeof) {
                case aE:
                case vwe:
                    o = !0
            }
    }
    if (o) return o = t, i = i(o), t = r === "" ? "." + ER(o, 0) : r, fz(i) ? (n = "", t != null && (n = t.replace(dz, "$&/") + "/"), VS(i, e, n, "", function(c) {
        return c
    })) : i != null && (w$(i) && (i = Owe(i, n + (!i.key || o && o.key === i.key ? "" : ("" + i.key).replace(dz, "$&/") + "/") + t)), e.push(i)), 1;
    if (o = 0, r = r === "" ? "." : r + ":", fz(t))
        for (var a = 0; a < t.length; a++) {
            s = t[a];
            var l = r + ER(s, a);
            o += VS(s, e, n, l, i)
        } else if (l = Rwe(t), typeof l == "function")
            for (t = l.call(t), a = 0; !(s = t.next()).done;) s = s.value, l = r + ER(s, a++), o += VS(s, e, n, l, i);
        else if (s === "object") throw e = String(t), Error("Objects are not valid as a React child (found: " + (e === "[object Object]" ? "object with keys {" + Object.keys(t).join(", ") + "}" : e) + "). If you meant to render a collection of children, use an array instead.");
    return o
}

function Rx(t, e, n) {
    if (t == null) return t;
    var r = [],
        i = 0;
    return VS(t, r, "", "", function(s) {
        return e.call(n, s, i++)
    }), r
}

function Pwe(t) {
    if (t._status === -1) {
        var e = t._result;
        e = e(), e.then(function(n) {
            (t._status === 0 || t._status === -1) && (t._status = 1, t._result = n)
        }, function(n) {
            (t._status === 0 || t._status === -1) && (t._status = 2, t._result = n)
        }), t._status === -1 && (t._status = 0, t._result = e)
    }
    if (t._status === 1) return t._result.default;
    throw t._result
}
var ma = {
        current: null
    },
    GS = {
        transition: null
    },
    kwe = {
        ReactCurrentDispatcher: ma,
        ReactCurrentBatchConfig: GS,
        ReactCurrentOwner: y$
    };

function $X() {
    throw Error("act(...) is not supported in production builds of React.")
}
Gn.Children = {
    map: Rx,
    forEach: function(t, e, n) {
        Rx(t, function() {
            e.apply(this, arguments)
        }, n)
    },
    count: function(t) {
        var e = 0;
        return Rx(t, function() {
            e++
        }), e
    },
    toArray: function(t) {
        return Rx(t, function(e) {
            return e
        }) || []
    },
    only: function(t) {
        if (!w$(t)) throw Error("React.Children.only expected to receive a single React element child.");
        return t
    }
};
Gn.Component = S2;
Gn.Fragment = bwe;
Gn.Profiler = Ewe;
Gn.PureComponent = g$;
Gn.StrictMode = _we;
Gn.Suspense = Awe;
Gn.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = kwe;
Gn.act = $X;
Gn.cloneElement = function(t, e, n) {
    if (t == null) throw Error("React.cloneElement(...): The argument must be a React element, but you passed " + t + ".");
    var r = OX({}, t.props),
        i = t.key,
        s = t.ref,
        o = t._owner;
    if (e != null) {
        if (e.ref !== void 0 && (s = e.ref, o = y$.current), e.key !== void 0 && (i = "" + e.key), t.type && t.type.defaultProps) var a = t.type.defaultProps;
        for (l in e) kX.call(e, l) && !MX.hasOwnProperty(l) && (r[l] = e[l] === void 0 && a !== void 0 ? a[l] : e[l])
    }
    var l = arguments.length - 2;
    if (l === 1) r.children = n;
    else if (1 < l) {
        a = Array(l);
        for (var c = 0; c < l; c++) a[c] = arguments[c + 2];
        r.children = a
    }
    return {
        $$typeof: aE,
        type: t.type,
        key: i,
        ref: s,
        props: r,
        _owner: o
    }
};
Gn.createContext = function(t) {
    return t = {
        $$typeof: Swe,
        _currentValue: t,
        _currentValue2: t,
        _threadCount: 0,
        Provider: null,
        Consumer: null,
        _defaultValue: null,
        _globalName: null
    }, t.Provider = {
        $$typeof: xwe,
        _context: t
    }, t.Consumer = t
};
Gn.createElement = DX;
Gn.createFactory = function(t) {
    var e = DX.bind(null, t);
    return e.type = t, e
};
Gn.createRef = function() {
    return {
        current: null
    }
};
Gn.forwardRef = function(t) {
    return {
        $$typeof: Cwe,
        render: t
    }
};
Gn.isValidElement = w$;
Gn.lazy = function(t) {
    return {
        $$typeof: Iwe,
        _payload: {
            _status: -1,
            _result: t
        },
        _init: Pwe
    }
};
Gn.memo = function(t, e) {
    return {
        $$typeof: Twe,
        type: t,
        compare: e === void 0 ? null : e
    }
};
Gn.startTransition = function(t) {
    var e = GS.transition;
    GS.transition = {};
    try {
        t()
    } finally {
        GS.transition = e
    }
};
Gn.unstable_act = $X;
Gn.useCallback = function(t, e) {
    return ma.current.useCallback(t, e)
};
Gn.useContext = function(t) {
    return ma.current.useContext(t)
};
Gn.useDebugValue = function() {};
Gn.useDeferredValue = function(t) {
    return ma.current.useDeferredValue(t)
};
Gn.useEffect = function(t, e) {
    return ma.current.useEffect(t, e)
};
Gn.useId = function() {
    return ma.current.useId()
};
Gn.useImperativeHandle = function(t, e, n) {
    return ma.current.useImperativeHandle(t, e, n)
};
Gn.useInsertionEffect = function(t, e) {
    return ma.current.useInsertionEffect(t, e)
};
Gn.useLayoutEffect = function(t, e) {
    return ma.current.useLayoutEffect(t, e)
};
Gn.useMemo = function(t, e) {
    return ma.current.useMemo(t, e)
};
Gn.useReducer = function(t, e, n) {
    return ma.current.useReducer(t, e, n)
};
Gn.useRef = function(t) {
    return ma.current.useRef(t)
};
Gn.useState = function(t) {
    return ma.current.useState(t)
};
Gn.useSyncExternalStore = function(t, e, n) {
    return ma.current.useSyncExternalStore(t, e, n)
};
Gn.useTransition = function() {
    return ma.current.useTransition()
};
Gn.version = "18.3.1";
IX.exports = Gn;
var ae = IX.exports;
const Tu = co(ae),
    Mwe = AX({
        __proto__: null,
        default: Tu
    }, [ae]);
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var Dwe = ae,
    $we = Symbol.for("react.element"),
    Lwe = Symbol.for("react.fragment"),
    Bwe = Object.prototype.hasOwnProperty,
    Fwe = Dwe.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner,
    Uwe = {
        key: !0,
        ref: !0,
        __self: !0,
        __source: !0
    };

function LX(t, e, n) {
    var r, i = {},
        s = null,
        o = null;
    n !== void 0 && (s = "" + n), e.key !== void 0 && (s = "" + e.key), e.ref !== void 0 && (o = e.ref);
    for (r in e) Bwe.call(e, r) && !Uwe.hasOwnProperty(r) && (i[r] = e[r]);
    if (t && t.defaultProps)
        for (r in e = t.defaultProps, e) i[r] === void 0 && (i[r] = e[r]);
    return {
        $$typeof: $we,
        type: t,
        key: s,
        ref: o,
        props: i,
        _owner: Fwe.current
    }
}
lT.Fragment = Lwe;
lT.jsx = LX;
lT.jsxs = LX;
TX.exports = lT;
var J = TX.exports,
    cT = class {
        constructor() {
            this.listeners = new Set, this.subscribe = this.subscribe.bind(this)
        }
        subscribe(t) {
            return this.listeners.add(t), this.onSubscribe(), () => {
                this.listeners.delete(t), this.onUnsubscribe()
            }
        }
        hasListeners() {
            return this.listeners.size > 0
        }
        onSubscribe() {}
        onUnsubscribe() {}
    },
    uT = typeof window > "u" || "Deno" in globalThis;

function tu() {}

function jwe(t, e) {
    return typeof t == "function" ? t(e) : t
}

function Hwe(t) {
    return typeof t == "number" && t >= 0 && t !== 1 / 0
}

function zwe(t, e) {
    return Math.max(t + (e || 0) - Date.now(), 0)
}

function hz(t, e) {
    return typeof t == "function" ? t(e) : t
}

function Wwe(t, e) {
    return typeof t == "function" ? t(e) : t
}

function pz(t, e) {
    const {
        type: n = "all",
        exact: r,
        fetchStatus: i,
        predicate: s,
        queryKey: o,
        stale: a
    } = t;
    if (o) {
        if (r) {
            if (e.queryHash !== v$(o, e.options)) return !1
        } else if (!h_(e.queryKey, o)) return !1
    }
    if (n !== "all") {
        const l = e.isActive();
        if (n === "active" && !l || n === "inactive" && l) return !1
    }
    return !(typeof a == "boolean" && e.isStale() !== a || i && i !== e.state.fetchStatus || s && !s(e))
}

function gz(t, e) {
    const {
        exact: n,
        status: r,
        predicate: i,
        mutationKey: s
    } = t;
    if (s) {
        if (!e.options.mutationKey) return !1;
        if (n) {
            if (d_(e.options.mutationKey) !== d_(s)) return !1
        } else if (!h_(e.options.mutationKey, s)) return !1
    }
    return !(r && e.state.status !== r || i && !i(e))
}

function v$(t, e) {
    return ((e == null ? void 0 : e.queryKeyHashFn) || d_)(t)
}

function d_(t) {
    return JSON.stringify(t, (e, n) => NP(n) ? Object.keys(n).sort().reduce((r, i) => (r[i] = n[i], r), {}) : n)
}

function h_(t, e) {
    return t === e ? !0 : typeof t != typeof e ? !1 : t && e && typeof t == "object" && typeof e == "object" ? !Object.keys(e).some(n => !h_(t[n], e[n])) : !1
}

function BX(t, e) {
    if (t === e) return t;
    const n = mz(t) && mz(e);
    if (n || NP(t) && NP(e)) {
        const r = n ? t : Object.keys(t),
            i = r.length,
            s = n ? e : Object.keys(e),
            o = s.length,
            a = n ? [] : {};
        let l = 0;
        for (let c = 0; c < o; c++) {
            const u = n ? c : s[c];
            (!n && r.includes(u) || n) && t[u] === void 0 && e[u] === void 0 ? (a[u] = void 0, l++) : (a[u] = BX(t[u], e[u]), a[u] === t[u] && t[u] !== void 0 && l++)
        }
        return i === o && l === i ? t : a
    }
    return e
}

function xbt(t, e) {
    if (!e || Object.keys(t).length !== Object.keys(e).length) return !1;
    for (const n in t)
        if (t[n] !== e[n]) return !1;
    return !0
}

function mz(t) {
    return Array.isArray(t) && t.length === Object.keys(t).length
}

function NP(t) {
    if (!yz(t)) return !1;
    const e = t.constructor;
    if (e === void 0) return !0;
    const n = e.prototype;
    return !(!yz(n) || !n.hasOwnProperty("isPrototypeOf") || Object.getPrototypeOf(t) !== Object.prototype)
}

function yz(t) {
    return Object.prototype.toString.call(t) === "[object Object]"
}

function Vwe(t) {
    return new Promise(e => {
        setTimeout(e, t)
    })
}

function Gwe(t, e, n) {
    return typeof n.structuralSharing == "function" ? n.structuralSharing(t, e) : n.structuralSharing !== !1 ? BX(t, e) : e
}

function qwe(t, e, n = 0) {
    const r = [...t, e];
    return n && r.length > n ? r.slice(1) : r
}

function Kwe(t, e, n = 0) {
    const r = [e, ...t];
    return n && r.length > n ? r.slice(0, -1) : r
}
var FX = Symbol();

function UX(t, e) {
    return !t.queryFn && (e != null && e.initialPromise) ? () => e.initialPromise : !t.queryFn || t.queryFn === FX ? () => Promise.reject(new Error(`Missing queryFn: '${t.queryHash}'`)) : t.queryFn
}
var x1, F0, Cv, pX, Ywe = (pX = class extends cT {
        constructor() {
            super();
            _e(this, x1);
            _e(this, F0);
            _e(this, Cv);
            le(this, Cv, e => {
                if (!uT && window.addEventListener) {
                    const n = () => e();
                    return window.addEventListener("visibilitychange", n, !1), () => {
                        window.removeEventListener("visibilitychange", n)
                    }
                }
            })
        }
        onSubscribe() {
            W(this, F0) || this.setEventListener(W(this, Cv))
        }
        onUnsubscribe() {
            var e;
            this.hasListeners() || ((e = W(this, F0)) == null || e.call(this), le(this, F0, void 0))
        }
        setEventListener(e) {
            var n;
            le(this, Cv, e), (n = W(this, F0)) == null || n.call(this), le(this, F0, e(r => {
                typeof r == "boolean" ? this.setFocused(r) : this.onFocus()
            }))
        }
        setFocused(e) {
            W(this, x1) !== e && (le(this, x1, e), this.onFocus())
        }
        onFocus() {
            const e = this.isFocused();
            this.listeners.forEach(n => {
                n(e)
            })
        }
        isFocused() {
            var e;
            return typeof W(this, x1) == "boolean" ? W(this, x1) : ((e = globalThis.document) == null ? void 0 : e.visibilityState) !== "hidden"
        }
    }, x1 = new WeakMap, F0 = new WeakMap, Cv = new WeakMap, pX),
    jX = new Ywe,
    Av, U0, Tv, gX, Zwe = (gX = class extends cT {
        constructor() {
            super();
            _e(this, Av, !0);
            _e(this, U0);
            _e(this, Tv);
            le(this, Tv, e => {
                if (!uT && window.addEventListener) {
                    const n = () => e(!0),
                        r = () => e(!1);
                    return window.addEventListener("online", n, !1), window.addEventListener("offline", r, !1), () => {
                        window.removeEventListener("online", n), window.removeEventListener("offline", r)
                    }
                }
            })
        }
        onSubscribe() {
            W(this, U0) || this.setEventListener(W(this, Tv))
        }
        onUnsubscribe() {
            var e;
            this.hasListeners() || ((e = W(this, U0)) == null || e.call(this), le(this, U0, void 0))
        }
        setEventListener(e) {
            var n;
            le(this, Tv, e), (n = W(this, U0)) == null || n.call(this), le(this, U0, e(this.setOnline.bind(this)))
        }
        setOnline(e) {
            W(this, Av) !== e && (le(this, Av, e), this.listeners.forEach(r => {
                r(e)
            }))
        }
        isOnline() {
            return W(this, Av)
        }
    }, Av = new WeakMap, U0 = new WeakMap, Tv = new WeakMap, gX),
    W8 = new Zwe;

function Qwe(t) {
    return Math.min(1e3 * 2 ** t, 3e4)
}

function HX(t) {
    return (t ? ? "online") === "online" ? W8.isOnline() : !0
}
var zX = class extends Error {
    constructor(t) {
        super("CancelledError"), this.revert = t == null ? void 0 : t.revert, this.silent = t == null ? void 0 : t.silent
    }
};

function xR(t) {
    return t instanceof zX
}

function WX(t) {
    let e = !1,
        n = 0,
        r = !1,
        i, s, o;
    const a = new Promise((b, w) => {
            s = b, o = w
        }),
        l = b => {
            var w;
            r || (y(new zX(b)), (w = t.abort) == null || w.call(t))
        },
        c = () => {
            e = !0
        },
        u = () => {
            e = !1
        },
        f = () => jX.isFocused() && (t.networkMode === "always" || W8.isOnline()) && t.canRun(),
        h = () => HX(t.networkMode) && t.canRun(),
        g = b => {
            var w;
            r || (r = !0, (w = t.onSuccess) == null || w.call(t, b), i == null || i(), s(b))
        },
        y = b => {
            var w;
            r || (r = !0, (w = t.onError) == null || w.call(t, b), i == null || i(), o(b))
        },
        _ = () => new Promise(b => {
            var w;
            i = S => {
                (r || f()) && b(S)
            }, (w = t.onPause) == null || w.call(t)
        }).then(() => {
            var b;
            i = void 0, r || (b = t.onContinue) == null || b.call(t)
        }),
        C = () => {
            if (r) return;
            let b;
            const w = n === 0 ? t.initialPromise : void 0;
            try {
                b = w ? ? t.fn()
            } catch (S) {
                b = Promise.reject(S)
            }
            Promise.resolve(b).then(g).catch(S => {
                var E;
                if (r) return;
                const I = t.retry ? ? (uT ? 0 : 3),
                    P = t.retryDelay ? ? Qwe,
                    M = typeof P == "function" ? P(n, S) : P,
                    A = I === !0 || typeof I == "number" && n < I || typeof I == "function" && I(n, S);
                if (e || !A) {
                    y(S);
                    return
                }
                n++, (E = t.onFail) == null || E.call(t, n, S), Vwe(M).then(() => f() ? void 0 : _()).then(() => {
                    e ? y(S) : C()
                })
            })
        };
    return {
        promise: a,
        cancel: l,
        continue: () => (i == null || i(), a),
        cancelRetry: c,
        continueRetry: u,
        canStart: h,
        start: () => (h() ? C() : _().then(C), a)
    }
}

function Jwe() {
    let t = [],
        e = 0,
        n = a => {
            a()
        },
        r = a => {
            a()
        },
        i = a => setTimeout(a, 0);
    const s = a => {
            e ? t.push(a) : i(() => {
                n(a)
            })
        },
        o = () => {
            const a = t;
            t = [], a.length && i(() => {
                r(() => {
                    a.forEach(l => {
                        n(l)
                    })
                })
            })
        };
    return {
        batch: a => {
            let l;
            e++;
            try {
                l = a()
            } finally {
                e--, e || o()
            }
            return l
        },
        batchCalls: a => (...l) => {
            s(() => {
                a(...l)
            })
        },
        schedule: s,
        setNotifyFunction: a => {
            n = a
        },
        setBatchNotifyFunction: a => {
            r = a
        },
        setScheduler: a => {
            i = a
        }
    }
}
var na = Jwe(),
    S1, mX, VX = (mX = class {
        constructor() {
            _e(this, S1)
        }
        destroy() {
            this.clearGcTimeout()
        }
        scheduleGc() {
            this.clearGcTimeout(), Hwe(this.gcTime) && le(this, S1, setTimeout(() => {
                this.optionalRemove()
            }, this.gcTime))
        }
        updateGcTime(t) {
            this.gcTime = Math.max(this.gcTime || 0, t ? ? (uT ? 1 / 0 : 5 * 60 * 1e3))
        }
        clearGcTimeout() {
            W(this, S1) && (clearTimeout(W(this, S1)), le(this, S1, void 0))
        }
    }, S1 = new WeakMap, mX),
    Iv, Rv, lc, So, z6, C1, ou, $d, yX, Xwe = (yX = class extends VX {
        constructor(e) {
            super();
            _e(this, ou);
            _e(this, Iv);
            _e(this, Rv);
            _e(this, lc);
            _e(this, So);
            _e(this, z6);
            _e(this, C1);
            le(this, C1, !1), le(this, z6, e.defaultOptions), this.setOptions(e.options), this.observers = [], le(this, lc, e.cache), this.queryKey = e.queryKey, this.queryHash = e.queryHash, le(this, Iv, tve(this.options)), this.state = e.state ? ? W(this, Iv), this.scheduleGc()
        }
        get meta() {
            return this.options.meta
        }
        get promise() {
            var e;
            return (e = W(this, So)) == null ? void 0 : e.promise
        }
        setOptions(e) {
            this.options = { ...W(this, z6),
                ...e
            }, this.updateGcTime(this.options.gcTime)
        }
        optionalRemove() {
            !this.observers.length && this.state.fetchStatus === "idle" && W(this, lc).remove(this)
        }
        setData(e, n) {
            const r = Gwe(this.state.data, e, this.options);
            return De(this, ou, $d).call(this, {
                data: r,
                type: "success",
                dataUpdatedAt: n == null ? void 0 : n.updatedAt,
                manual: n == null ? void 0 : n.manual
            }), r
        }
        setState(e, n) {
            De(this, ou, $d).call(this, {
                type: "setState",
                state: e,
                setStateOptions: n
            })
        }
        cancel(e) {
            var r, i;
            const n = (r = W(this, So)) == null ? void 0 : r.promise;
            return (i = W(this, So)) == null || i.cancel(e), n ? n.then(tu).catch(tu) : Promise.resolve()
        }
        destroy() {
            super.destroy(), this.cancel({
                silent: !0
            })
        }
        reset() {
            this.destroy(), this.setState(W(this, Iv))
        }
        isActive() {
            return this.observers.some(e => Wwe(e.options.enabled, this) !== !1)
        }
        isDisabled() {
            return this.getObserversCount() > 0 && !this.isActive()
        }
        isStale() {
            return this.state.isInvalidated ? !0 : this.getObserversCount() > 0 ? this.observers.some(e => e.getCurrentResult().isStale) : this.state.data === void 0
        }
        isStaleByTime(e = 0) {
            return this.state.isInvalidated || this.state.data === void 0 || !zwe(this.state.dataUpdatedAt, e)
        }
        onFocus() {
            var n;
            const e = this.observers.find(r => r.shouldFetchOnWindowFocus());
            e == null || e.refetch({
                cancelRefetch: !1
            }), (n = W(this, So)) == null || n.continue()
        }
        onOnline() {
            var n;
            const e = this.observers.find(r => r.shouldFetchOnReconnect());
            e == null || e.refetch({
                cancelRefetch: !1
            }), (n = W(this, So)) == null || n.continue()
        }
        addObserver(e) {
            this.observers.includes(e) || (this.observers.push(e), this.clearGcTimeout(), W(this, lc).notify({
                type: "observerAdded",
                query: this,
                observer: e
            }))
        }
        removeObserver(e) {
            this.observers.includes(e) && (this.observers = this.observers.filter(n => n !== e), this.observers.length || (W(this, So) && (W(this, C1) ? W(this, So).cancel({
                revert: !0
            }) : W(this, So).cancelRetry()), this.scheduleGc()), W(this, lc).notify({
                type: "observerRemoved",
                query: this,
                observer: e
            }))
        }
        getObserversCount() {
            return this.observers.length
        }
        invalidate() {
            this.state.isInvalidated || De(this, ou, $d).call(this, {
                type: "invalidate"
            })
        }
        fetch(e, n) {
            var l, c, u;
            if (this.state.fetchStatus !== "idle") {
                if (this.state.data !== void 0 && (n != null && n.cancelRefetch)) this.cancel({
                    silent: !0
                });
                else if (W(this, So)) return W(this, So).continueRetry(), W(this, So).promise
            }
            if (e && this.setOptions(e), !this.options.queryFn) {
                const f = this.observers.find(h => h.options.queryFn);
                f && this.setOptions(f.options)
            }
            const r = new AbortController,
                i = f => {
                    Object.defineProperty(f, "signal", {
                        enumerable: !0,
                        get: () => (le(this, C1, !0), r.signal)
                    })
                },
                s = () => {
                    const f = UX(this.options, n),
                        h = {
                            queryKey: this.queryKey,
                            meta: this.meta
                        };
                    return i(h), le(this, C1, !1), this.options.persister ? this.options.persister(f, h, this) : f(h)
                },
                o = {
                    fetchOptions: n,
                    options: this.options,
                    queryKey: this.queryKey,
                    state: this.state,
                    fetchFn: s
                };
            i(o), (l = this.options.behavior) == null || l.onFetch(o, this), le(this, Rv, this.state), (this.state.fetchStatus === "idle" || this.state.fetchMeta !== ((c = o.fetchOptions) == null ? void 0 : c.meta)) && De(this, ou, $d).call(this, {
                type: "fetch",
                meta: (u = o.fetchOptions) == null ? void 0 : u.meta
            });
            const a = f => {
                var h, g, y, _;
                xR(f) && f.silent || De(this, ou, $d).call(this, {
                    type: "error",
                    error: f
                }), xR(f) || ((g = (h = W(this, lc).config).onError) == null || g.call(h, f, this), (_ = (y = W(this, lc).config).onSettled) == null || _.call(y, this.state.data, f, this)), this.isFetchingOptimistic || this.scheduleGc(), this.isFetchingOptimistic = !1
            };
            return le(this, So, WX({
                initialPromise: n == null ? void 0 : n.initialPromise,
                fn: o.fetchFn,
                abort: r.abort.bind(r),
                onSuccess: f => {
                    var h, g, y, _;
                    if (f === void 0) {
                        a(new Error(`${this.queryHash} data is undefined`));
                        return
                    }
                    try {
                        this.setData(f)
                    } catch (C) {
                        a(C);
                        return
                    }(g = (h = W(this, lc).config).onSuccess) == null || g.call(h, f, this), (_ = (y = W(this, lc).config).onSettled) == null || _.call(y, f, this.state.error, this), this.isFetchingOptimistic || this.scheduleGc(), this.isFetchingOptimistic = !1
                },
                onError: a,
                onFail: (f, h) => {
                    De(this, ou, $d).call(this, {
                        type: "failed",
                        failureCount: f,
                        error: h
                    })
                },
                onPause: () => {
                    De(this, ou, $d).call(this, {
                        type: "pause"
                    })
                },
                onContinue: () => {
                    De(this, ou, $d).call(this, {
                        type: "continue"
                    })
                },
                retry: o.options.retry,
                retryDelay: o.options.retryDelay,
                networkMode: o.options.networkMode,
                canRun: () => !0
            })), W(this, So).start()
        }
    }, Iv = new WeakMap, Rv = new WeakMap, lc = new WeakMap, So = new WeakMap, z6 = new WeakMap, C1 = new WeakMap, ou = new WeakSet, $d = function(e) {
        const n = r => {
            switch (e.type) {
                case "failed":
                    return { ...r,
                        fetchFailureCount: e.failureCount,
                        fetchFailureReason: e.error
                    };
                case "pause":
                    return { ...r,
                        fetchStatus: "paused"
                    };
                case "continue":
                    return { ...r,
                        fetchStatus: "fetching"
                    };
                case "fetch":
                    return { ...r,
                        ...eve(r.data, this.options),
                        fetchMeta: e.meta ? ? null
                    };
                case "success":
                    return { ...r,
                        data: e.data,
                        dataUpdateCount: r.dataUpdateCount + 1,
                        dataUpdatedAt: e.dataUpdatedAt ? ? Date.now(),
                        error: null,
                        isInvalidated: !1,
                        status: "success",
                        ...!e.manual && {
                            fetchStatus: "idle",
                            fetchFailureCount: 0,
                            fetchFailureReason: null
                        }
                    };
                case "error":
                    const i = e.error;
                    return xR(i) && i.revert && W(this, Rv) ? { ...W(this, Rv),
                        fetchStatus: "idle"
                    } : { ...r,
                        error: i,
                        errorUpdateCount: r.errorUpdateCount + 1,
                        errorUpdatedAt: Date.now(),
                        fetchFailureCount: r.fetchFailureCount + 1,
                        fetchFailureReason: i,
                        fetchStatus: "idle",
                        status: "error"
                    };
                case "invalidate":
                    return { ...r,
                        isInvalidated: !0
                    };
                case "setState":
                    return { ...r,
                        ...e.state
                    }
            }
        };
        this.state = n(this.state), na.batch(() => {
            this.observers.forEach(r => {
                r.onQueryUpdate()
            }), W(this, lc).notify({
                query: this,
                type: "updated",
                action: e
            })
        })
    }, yX);

function eve(t, e) {
    return {
        fetchFailureCount: 0,
        fetchFailureReason: null,
        fetchStatus: HX(e.networkMode) ? "fetching" : "paused",
        ...t === void 0 && {
            error: null,
            status: "pending"
        }
    }
}

function tve(t) {
    const e = typeof t.initialData == "function" ? t.initialData() : t.initialData,
        n = e !== void 0,
        r = n ? typeof t.initialDataUpdatedAt == "function" ? t.initialDataUpdatedAt() : t.initialDataUpdatedAt : 0;
    return {
        data: e,
        dataUpdateCount: 0,
        dataUpdatedAt: n ? r ? ? Date.now() : 0,
        error: null,
        errorUpdateCount: 0,
        errorUpdatedAt: 0,
        fetchFailureCount: 0,
        fetchFailureReason: null,
        fetchMeta: null,
        isInvalidated: !1,
        status: n ? "success" : "pending",
        fetchStatus: "idle"
    }
}
var yf, wX, nve = (wX = class extends cT {
        constructor(e = {}) {
            super();
            _e(this, yf);
            this.config = e, le(this, yf, new Map)
        }
        build(e, n, r) {
            const i = n.queryKey,
                s = n.queryHash ? ? v$(i, n);
            let o = this.get(s);
            return o || (o = new Xwe({
                cache: this,
                queryKey: i,
                queryHash: s,
                options: e.defaultQueryOptions(n),
                state: r,
                defaultOptions: e.getQueryDefaults(i)
            }), this.add(o)), o
        }
        add(e) {
            W(this, yf).has(e.queryHash) || (W(this, yf).set(e.queryHash, e), this.notify({
                type: "added",
                query: e
            }))
        }
        remove(e) {
            const n = W(this, yf).get(e.queryHash);
            n && (e.destroy(), n === e && W(this, yf).delete(e.queryHash), this.notify({
                type: "removed",
                query: e
            }))
        }
        clear() {
            na.batch(() => {
                this.getAll().forEach(e => {
                    this.remove(e)
                })
            })
        }
        get(e) {
            return W(this, yf).get(e)
        }
        getAll() {
            return [...W(this, yf).values()]
        }
        find(e) {
            const n = {
                exact: !0,
                ...e
            };
            return this.getAll().find(r => pz(n, r))
        }
        findAll(e = {}) {
            const n = this.getAll();
            return Object.keys(e).length > 0 ? n.filter(r => pz(e, r)) : n
        }
        notify(e) {
            na.batch(() => {
                this.listeners.forEach(n => {
                    n(e)
                })
            })
        }
        onFocus() {
            na.batch(() => {
                this.getAll().forEach(e => {
                    e.onFocus()
                })
            })
        }
        onOnline() {
            na.batch(() => {
                this.getAll().forEach(e => {
                    e.onOnline()
                })
            })
        }
    }, yf = new WeakMap, wX),
    wf, Ko, A1, vf, w0, vX, rve = (vX = class extends VX {
        constructor(e) {
            super();
            _e(this, vf);
            _e(this, wf);
            _e(this, Ko);
            _e(this, A1);
            this.mutationId = e.mutationId, le(this, Ko, e.mutationCache), le(this, wf, []), this.state = e.state || ive(), this.setOptions(e.options), this.scheduleGc()
        }
        setOptions(e) {
            this.options = e, this.updateGcTime(this.options.gcTime)
        }
        get meta() {
            return this.options.meta
        }
        addObserver(e) {
            W(this, wf).includes(e) || (W(this, wf).push(e), this.clearGcTimeout(), W(this, Ko).notify({
                type: "observerAdded",
                mutation: this,
                observer: e
            }))
        }
        removeObserver(e) {
            le(this, wf, W(this, wf).filter(n => n !== e)), this.scheduleGc(), W(this, Ko).notify({
                type: "observerRemoved",
                mutation: this,
                observer: e
            })
        }
        optionalRemove() {
            W(this, wf).length || (this.state.status === "pending" ? this.scheduleGc() : W(this, Ko).remove(this))
        }
        continue () {
            var e;
            return ((e = W(this, A1)) == null ? void 0 : e.continue()) ? ? this.execute(this.state.variables)
        }
        async execute(e) {
            var i, s, o, a, l, c, u, f, h, g, y, _, C, b, w, S, I, P, M, A;
            le(this, A1, WX({
                fn: () => this.options.mutationFn ? this.options.mutationFn(e) : Promise.reject(new Error("No mutationFn found")),
                onFail: (E, $) => {
                    De(this, vf, w0).call(this, {
                        type: "failed",
                        failureCount: E,
                        error: $
                    })
                },
                onPause: () => {
                    De(this, vf, w0).call(this, {
                        type: "pause"
                    })
                },
                onContinue: () => {
                    De(this, vf, w0).call(this, {
                        type: "continue"
                    })
                },
                retry: this.options.retry ? ? 0,
                retryDelay: this.options.retryDelay,
                networkMode: this.options.networkMode,
                canRun: () => W(this, Ko).canRun(this)
            }));
            const n = this.state.status === "pending",
                r = !W(this, A1).canStart();
            try {
                if (!n) {
                    De(this, vf, w0).call(this, {
                        type: "pending",
                        variables: e,
                        isPaused: r
                    }), await ((s = (i = W(this, Ko).config).onMutate) == null ? void 0 : s.call(i, e, this));
                    const $ = await ((a = (o = this.options).onMutate) == null ? void 0 : a.call(o, e));
                    $ !== this.state.context && De(this, vf, w0).call(this, {
                        type: "pending",
                        context: $,
                        variables: e,
                        isPaused: r
                    })
                }
                const E = await W(this, A1).start();
                return await ((c = (l = W(this, Ko).config).onSuccess) == null ? void 0 : c.call(l, E, e, this.state.context, this)), await ((f = (u = this.options).onSuccess) == null ? void 0 : f.call(u, E, e, this.state.context)), await ((g = (h = W(this, Ko).config).onSettled) == null ? void 0 : g.call(h, E, null, this.state.variables, this.state.context, this)), await ((_ = (y = this.options).onSettled) == null ? void 0 : _.call(y, E, null, e, this.state.context)), De(this, vf, w0).call(this, {
                    type: "success",
                    data: E
                }), E
            } catch (E) {
                try {
                    throw await ((b = (C = W(this, Ko).config).onError) == null ? void 0 : b.call(C, E, e, this.state.context, this)), await ((S = (w = this.options).onError) == null ? void 0 : S.call(w, E, e, this.state.context)), await ((P = (I = W(this, Ko).config).onSettled) == null ? void 0 : P.call(I, void 0, E, this.state.variables, this.state.context, this)), await ((A = (M = this.options).onSettled) == null ? void 0 : A.call(M, void 0, E, e, this.state.context)), E
                } finally {
                    De(this, vf, w0).call(this, {
                        type: "error",
                        error: E
                    })
                }
            } finally {
                W(this, Ko).runNext(this)
            }
        }
    }, wf = new WeakMap, Ko = new WeakMap, A1 = new WeakMap, vf = new WeakSet, w0 = function(e) {
        const n = r => {
            switch (e.type) {
                case "failed":
                    return { ...r,
                        failureCount: e.failureCount,
                        failureReason: e.error
                    };
                case "pause":
                    return { ...r,
                        isPaused: !0
                    };
                case "continue":
                    return { ...r,
                        isPaused: !1
                    };
                case "pending":
                    return { ...r,
                        context: e.context,
                        data: void 0,
                        failureCount: 0,
                        failureReason: null,
                        error: null,
                        isPaused: e.isPaused,
                        status: "pending",
                        variables: e.variables,
                        submittedAt: Date.now()
                    };
                case "success":
                    return { ...r,
                        data: e.data,
                        failureCount: 0,
                        failureReason: null,
                        error: null,
                        status: "success",
                        isPaused: !1
                    };
                case "error":
                    return { ...r,
                        data: void 0,
                        error: e.error,
                        failureCount: r.failureCount + 1,
                        failureReason: e.error,
                        isPaused: !1,
                        status: "error"
                    }
            }
        };
        this.state = n(this.state), na.batch(() => {
            W(this, wf).forEach(r => {
                r.onMutationUpdate(e)
            }), W(this, Ko).notify({
                mutation: this,
                type: "updated",
                action: e
            })
        })
    }, vX);

function ive() {
    return {
        context: void 0,
        data: void 0,
        error: null,
        failureCount: 0,
        failureReason: null,
        isPaused: !1,
        status: "idle",
        variables: void 0,
        submittedAt: 0
    }
}
var pl, W6, bX, sve = (bX = class extends cT {
    constructor(e = {}) {
        super();
        _e(this, pl);
        _e(this, W6);
        this.config = e, le(this, pl, new Map), le(this, W6, Date.now())
    }
    build(e, n, r) {
        const i = new rve({
            mutationCache: this,
            mutationId: ++s0(this, W6)._,
            options: e.defaultMutationOptions(n),
            state: r
        });
        return this.add(i), i
    }
    add(e) {
        const n = Ox(e),
            r = W(this, pl).get(n) ? ? [];
        r.push(e), W(this, pl).set(n, r), this.notify({
            type: "added",
            mutation: e
        })
    }
    remove(e) {
        var r;
        const n = Ox(e);
        if (W(this, pl).has(n)) {
            const i = (r = W(this, pl).get(n)) == null ? void 0 : r.filter(s => s !== e);
            i && (i.length === 0 ? W(this, pl).delete(n) : W(this, pl).set(n, i))
        }
        this.notify({
            type: "removed",
            mutation: e
        })
    }
    canRun(e) {
        var r;
        const n = (r = W(this, pl).get(Ox(e))) == null ? void 0 : r.find(i => i.state.status === "pending");
        return !n || n === e
    }
    runNext(e) {
        var r;
        const n = (r = W(this, pl).get(Ox(e))) == null ? void 0 : r.find(i => i !== e && i.state.isPaused);
        return (n == null ? void 0 : n.continue()) ? ? Promise.resolve()
    }
    clear() {
        na.batch(() => {
            this.getAll().forEach(e => {
                this.remove(e)
            })
        })
    }
    getAll() {
        return [...W(this, pl).values()].flat()
    }
    find(e) {
        const n = {
            exact: !0,
            ...e
        };
        return this.getAll().find(r => gz(n, r))
    }
    findAll(e = {}) {
        return this.getAll().filter(n => gz(e, n))
    }
    notify(e) {
        na.batch(() => {
            this.listeners.forEach(n => {
                n(e)
            })
        })
    }
    resumePausedMutations() {
        const e = this.getAll().filter(n => n.state.isPaused);
        return na.batch(() => Promise.all(e.map(n => n.continue().catch(tu))))
    }
}, pl = new WeakMap, W6 = new WeakMap, bX);

function Ox(t) {
    var e;
    return ((e = t.options.scope) == null ? void 0 : e.id) ? ? String(t.mutationId)
}

function wz(t) {
    return {
        onFetch: (e, n) => {
            var u, f, h, g, y;
            const r = e.options,
                i = (h = (f = (u = e.fetchOptions) == null ? void 0 : u.meta) == null ? void 0 : f.fetchMore) == null ? void 0 : h.direction,
                s = ((g = e.state.data) == null ? void 0 : g.pages) || [],
                o = ((y = e.state.data) == null ? void 0 : y.pageParams) || [];
            let a = {
                    pages: [],
                    pageParams: []
                },
                l = 0;
            const c = async () => {
                let _ = !1;
                const C = S => {
                        Object.defineProperty(S, "signal", {
                            enumerable: !0,
                            get: () => (e.signal.aborted ? _ = !0 : e.signal.addEventListener("abort", () => {
                                _ = !0
                            }), e.signal)
                        })
                    },
                    b = UX(e.options, e.fetchOptions),
                    w = async (S, I, P) => {
                        if (_) return Promise.reject();
                        if (I == null && S.pages.length) return Promise.resolve(S);
                        const M = {
                            queryKey: e.queryKey,
                            pageParam: I,
                            direction: P ? "backward" : "forward",
                            meta: e.options.meta
                        };
                        C(M);
                        const A = await b(M),
                            {
                                maxPages: E
                            } = e.options,
                            $ = P ? Kwe : qwe;
                        return {
                            pages: $(S.pages, A, E),
                            pageParams: $(S.pageParams, I, E)
                        }
                    };
                if (i && s.length) {
                    const S = i === "backward",
                        I = S ? ove : vz,
                        P = {
                            pages: s,
                            pageParams: o
                        },
                        M = I(r, P);
                    a = await w(P, M, S)
                } else {
                    const S = t ? ? s.length;
                    do {
                        const I = l === 0 ? o[0] ? ? r.initialPageParam : vz(r, a);
                        if (l > 0 && I == null) break;
                        a = await w(a, I), l++
                    } while (l < S)
                }
                return a
            };
            e.options.persister ? e.fetchFn = () => {
                var _, C;
                return (C = (_ = e.options).persister) == null ? void 0 : C.call(_, c, {
                    queryKey: e.queryKey,
                    meta: e.options.meta,
                    signal: e.signal
                }, n)
            } : e.fetchFn = c
        }
    }
}

function vz(t, {
    pages: e,
    pageParams: n
}) {
    const r = e.length - 1;
    return e.length > 0 ? t.getNextPageParam(e[r], e, n[r], n) : void 0
}

function ove(t, {
    pages: e,
    pageParams: n
}) {
    var r;
    return e.length > 0 ? (r = t.getPreviousPageParam) == null ? void 0 : r.call(t, e[0], e, n[0], n) : void 0
}
var Fi, j0, H0, Ov, Nv, z0, Pv, kv, _X, ave = (_X = class {
        constructor(t = {}) {
            _e(this, Fi);
            _e(this, j0);
            _e(this, H0);
            _e(this, Ov);
            _e(this, Nv);
            _e(this, z0);
            _e(this, Pv);
            _e(this, kv);
            le(this, Fi, t.queryCache || new nve), le(this, j0, t.mutationCache || new sve), le(this, H0, t.defaultOptions || {}), le(this, Ov, new Map), le(this, Nv, new Map), le(this, z0, 0)
        }
        mount() {
            s0(this, z0)._++, W(this, z0) === 1 && (le(this, Pv, jX.subscribe(async t => {
                t && (await this.resumePausedMutations(), W(this, Fi).onFocus())
            })), le(this, kv, W8.subscribe(async t => {
                t && (await this.resumePausedMutations(), W(this, Fi).onOnline())
            })))
        }
        unmount() {
            var t, e;
            s0(this, z0)._--, W(this, z0) === 0 && ((t = W(this, Pv)) == null || t.call(this), le(this, Pv, void 0), (e = W(this, kv)) == null || e.call(this), le(this, kv, void 0))
        }
        isFetching(t) {
            return W(this, Fi).findAll({ ...t,
                fetchStatus: "fetching"
            }).length
        }
        isMutating(t) {
            return W(this, j0).findAll({ ...t,
                status: "pending"
            }).length
        }
        getQueryData(t) {
            var n;
            const e = this.defaultQueryOptions({
                queryKey: t
            });
            return (n = W(this, Fi).get(e.queryHash)) == null ? void 0 : n.state.data
        }
        ensureQueryData(t) {
            const e = this.getQueryData(t.queryKey);
            if (e === void 0) return this.fetchQuery(t); {
                const n = this.defaultQueryOptions(t),
                    r = W(this, Fi).build(this, n);
                return t.revalidateIfStale && r.isStaleByTime(hz(n.staleTime, r)) && this.prefetchQuery(n), Promise.resolve(e)
            }
        }
        getQueriesData(t) {
            return W(this, Fi).findAll(t).map(({
                queryKey: e,
                state: n
            }) => {
                const r = n.data;
                return [e, r]
            })
        }
        setQueryData(t, e, n) {
            const r = this.defaultQueryOptions({
                    queryKey: t
                }),
                i = W(this, Fi).get(r.queryHash),
                s = i == null ? void 0 : i.state.data,
                o = jwe(e, s);
            if (o !== void 0) return W(this, Fi).build(this, r).setData(o, { ...n,
                manual: !0
            })
        }
        setQueriesData(t, e, n) {
            return na.batch(() => W(this, Fi).findAll(t).map(({
                queryKey: r
            }) => [r, this.setQueryData(r, e, n)]))
        }
        getQueryState(t) {
            var n;
            const e = this.defaultQueryOptions({
                queryKey: t
            });
            return (n = W(this, Fi).get(e.queryHash)) == null ? void 0 : n.state
        }
        removeQueries(t) {
            const e = W(this, Fi);
            na.batch(() => {
                e.findAll(t).forEach(n => {
                    e.remove(n)
                })
            })
        }
        resetQueries(t, e) {
            const n = W(this, Fi),
                r = {
                    type: "active",
                    ...t
                };
            return na.batch(() => (n.findAll(t).forEach(i => {
                i.reset()
            }), this.refetchQueries(r, e)))
        }
        cancelQueries(t = {}, e = {}) {
            const n = {
                    revert: !0,
                    ...e
                },
                r = na.batch(() => W(this, Fi).findAll(t).map(i => i.cancel(n)));
            return Promise.all(r).then(tu).catch(tu)
        }
        invalidateQueries(t = {}, e = {}) {
            return na.batch(() => {
                if (W(this, Fi).findAll(t).forEach(r => {
                        r.invalidate()
                    }), t.refetchType === "none") return Promise.resolve();
                const n = { ...t,
                    type: t.refetchType ? ? t.type ? ? "active"
                };
                return this.refetchQueries(n, e)
            })
        }
        refetchQueries(t = {}, e) {
            const n = { ...e,
                    cancelRefetch: (e == null ? void 0 : e.cancelRefetch) ? ? !0
                },
                r = na.batch(() => W(this, Fi).findAll(t).filter(i => !i.isDisabled()).map(i => {
                    let s = i.fetch(void 0, n);
                    return n.throwOnError || (s = s.catch(tu)), i.state.fetchStatus === "paused" ? Promise.resolve() : s
                }));
            return Promise.all(r).then(tu)
        }
        fetchQuery(t) {
            const e = this.defaultQueryOptions(t);
            e.retry === void 0 && (e.retry = !1);
            const n = W(this, Fi).build(this, e);
            return n.isStaleByTime(hz(e.staleTime, n)) ? n.fetch(e) : Promise.resolve(n.state.data)
        }
        prefetchQuery(t) {
            return this.fetchQuery(t).then(tu).catch(tu)
        }
        fetchInfiniteQuery(t) {
            return t.behavior = wz(t.pages), this.fetchQuery(t)
        }
        prefetchInfiniteQuery(t) {
            return this.fetchInfiniteQuery(t).then(tu).catch(tu)
        }
        ensureInfiniteQueryData(t) {
            return t.behavior = wz(t.pages), this.ensureQueryData(t)
        }
        resumePausedMutations() {
            return W8.isOnline() ? W(this, j0).resumePausedMutations() : Promise.resolve()
        }
        getQueryCache() {
            return W(this, Fi)
        }
        getMutationCache() {
            return W(this, j0)
        }
        getDefaultOptions() {
            return W(this, H0)
        }
        setDefaultOptions(t) {
            le(this, H0, t)
        }
        setQueryDefaults(t, e) {
            W(this, Ov).set(d_(t), {
                queryKey: t,
                defaultOptions: e
            })
        }
        getQueryDefaults(t) {
            const e = [...W(this, Ov).values()];
            let n = {};
            return e.forEach(r => {
                h_(t, r.queryKey) && (n = { ...n,
                    ...r.defaultOptions
                })
            }), n
        }
        setMutationDefaults(t, e) {
            W(this, Nv).set(d_(t), {
                mutationKey: t,
                defaultOptions: e
            })
        }
        getMutationDefaults(t) {
            const e = [...W(this, Nv).values()];
            let n = {};
            return e.forEach(r => {
                h_(t, r.mutationKey) && (n = { ...n,
                    ...r.defaultOptions
                })
            }), n
        }
        defaultQueryOptions(t) {
            if (t._defaulted) return t;
            const e = { ...W(this, H0).queries,
                ...this.getQueryDefaults(t.queryKey),
                ...t,
                _defaulted: !0
            };
            return e.queryHash || (e.queryHash = v$(e.queryKey, e)), e.refetchOnReconnect === void 0 && (e.refetchOnReconnect = e.networkMode !== "always"), e.throwOnError === void 0 && (e.throwOnError = !!e.suspense), !e.networkMode && e.persister && (e.networkMode = "offlineFirst"), e.enabled !== !0 && e.queryFn === FX && (e.enabled = !1), e
        }
        defaultMutationOptions(t) {
            return t != null && t._defaulted ? t : { ...W(this, H0).mutations,
                ...(t == null ? void 0 : t.mutationKey) && this.getMutationDefaults(t.mutationKey),
                ...t,
                _defaulted: !0
            }
        }
        clear() {
            W(this, Fi).clear(), W(this, j0).clear()
        }
    }, Fi = new WeakMap, j0 = new WeakMap, H0 = new WeakMap, Ov = new WeakMap, Nv = new WeakMap, z0 = new WeakMap, Pv = new WeakMap, kv = new WeakMap, _X),
    GX = ae.createContext(void 0),
    Sbt = t => {
        const e = ae.useContext(GX);
        if (!e) throw new Error("No QueryClient set, use QueryClientProvider to set one");
        return e
    },
    lve = ({
        client: t,
        children: e
    }) => (ae.useEffect(() => (t.mount(), () => {
        t.unmount()
    }), [t]), J.jsx(GX.Provider, {
        value: t,
        children: e
    }));
const cve = Symbol(),
    b$ = Symbol(),
    O5 = "a",
    M3 = "w";
let uve = (t, e) => new Proxy(t, e);
const PP = Object.getPrototypeOf,
    kP = new WeakMap,
    qX = t => t && (kP.has(t) ? kP.get(t) : PP(t) === Object.prototype || PP(t) === Array.prototype),
    V8 = t => typeof t == "object" && t !== null,
    fve = t => {
        if (Array.isArray(t)) return Array.from(t);
        const e = Object.getOwnPropertyDescriptors(t);
        return Object.values(e).forEach(n => {
            n.configurable = !0
        }), Object.create(PP(t), e)
    },
    _$ = t => t[b$] || t,
    KX = (t, e, n, r) => {
        if (!qX(t)) return t;
        let i = r && r.get(t);
        if (!i) {
            const l = _$(t);
            i = (c => Object.values(Object.getOwnPropertyDescriptors(c)).some(u => !u.configurable && !u.writable))(l) ? [l, fve(l)] : [l], r == null || r.set(t, i)
        }
        const [s, o] = i;
        let a = n && n.get(s);
        return a && a[1].f === !!o || (a = ((l, c) => {
            const u = {
                f: c
            };
            let f = !1;
            const h = (y, _) => {
                    if (!f) {
                        let C = u[O5].get(l);
                        if (C || (C = {}, u[O5].set(l, C)), y === M3) C[M3] = !0;
                        else {
                            let b = C[y];
                            b || (b = new Set, C[y] = b), b.add(_)
                        }
                    }
                },
                g = {
                    get: (y, _) => _ === b$ ? l : (h("k", _), KX(Reflect.get(y, _), u[O5], u.c, u.t)),
                    has: (y, _) => _ === cve ? (f = !0, u[O5].delete(l), !0) : (h("h", _), Reflect.has(y, _)),
                    getOwnPropertyDescriptor: (y, _) => (h("o", _), Reflect.getOwnPropertyDescriptor(y, _)),
                    ownKeys: y => (h(M3), Reflect.ownKeys(y))
                };
            return c && (g.set = g.deleteProperty = () => !1), [g, u]
        })(s, !!o), a[1].p = uve(o || s, a[0]), n && n.set(s, a)), a[1][O5] = e, a[1].c = n, a[1].t = r, a[1].p
    },
    YX = (t, e, n, r) => {
        if (Object.is(t, e)) return !1;
        if (!V8(t) || !V8(e)) return !0;
        const i = n.get(_$(t));
        if (!i) return !0;
        if (r) {
            const o = r.get(t);
            if (o && o.n === e) return o.g;
            r.set(t, {
                n: e,
                g: !1
            })
        }
        let s = null;
        try {
            for (const o of i.h || [])
                if (s = Reflect.has(t, o) !== Reflect.has(e, o), s) return s;
            if (i[M3] === !0) {
                if (s = ((o, a) => {
                        const l = Reflect.ownKeys(o),
                            c = Reflect.ownKeys(a);
                        return l.length !== c.length || l.some((u, f) => u !== c[f])
                    })(t, e), s) return s
            } else
                for (const o of i.o || [])
                    if (s = !!Reflect.getOwnPropertyDescriptor(t, o) != !!Reflect.getOwnPropertyDescriptor(e, o), s) return s;
            for (const o of i.k || [])
                if (s = YX(t[o], e[o], n, r), s) return s;
            return s === null && (s = !0), s
        } finally {
            r && r.set(t, {
                n: e,
                g: s
            })
        }
    },
    dve = t => qX(t) && t[b$] || null,
    bz = (t, e = !0) => {
        kP.set(t, e)
    },
    hve = (t, e, n) => {
        const r = [],
            i = new WeakSet,
            s = (o, a) => {
                if (i.has(o)) return;
                V8(o) && i.add(o);
                const l = V8(o) && e.get(_$(o));
                if (l) {
                    var c, u;
                    if ((c = l.h) == null || c.forEach(h => {
                            const g = `:has(${String(h)})`;
                            r.push(a ? [...a, g] : [g])
                        }), l[M3] === !0) {
                        const h = ":ownKeys";
                        r.push(a ? [...a, h] : [h])
                    } else {
                        var f;
                        (f = l.o) == null || f.forEach(h => {
                            const g = `:hasOwn(${String(h)})`;
                            r.push(a ? [...a, g] : [g])
                        })
                    }(u = l.k) == null || u.forEach(h => {
                        !("value" in (Object.getOwnPropertyDescriptor(o, h) || {})) || s(o[h], a ? [...a, h] : [h])
                    })
                } else a && r.push(a)
            };
        return s(t), r
    },
    G8 = {
        BASE_URL: "/",
        DEV: !1,
        MODE: "production",
        PROD: !0,
        SSR: !1,
        VITE_API_URL: "https://eros-ai.cloud:2053",
        VITE_USE_TEST_NET: "false",
        VITE_VERCEL_BRANCH_URL: "aix-frontend-master-git-main-vsmelovs-projects.vercel.app",
        VITE_VERCEL_ENV: "production",
        VITE_VERCEL_GIT_COMMIT_AUTHOR_LOGIN: "vsmelov",
        VITE_VERCEL_GIT_COMMIT_AUTHOR_NAME: "Smelov Vladimir",
        VITE_VERCEL_GIT_COMMIT_MESSAGE: `Merge pull request #30 from integratly-ai/demo

Demo`,
        VITE_VERCEL_GIT_COMMIT_REF: "main",
        VITE_VERCEL_GIT_COMMIT_SHA: "edaf5ff910dd6993ad55c4cb872e0cface55f0bc",
        VITE_VERCEL_GIT_PREVIOUS_SHA: "",
        VITE_VERCEL_GIT_PROVIDER: "github",
        VITE_VERCEL_GIT_PULL_REQUEST_ID: "",
        VITE_VERCEL_GIT_REPO_ID: "726885604",
        VITE_VERCEL_GIT_REPO_OWNER: "integratly-ai",
        VITE_VERCEL_GIT_REPO_SLUG: "aix-frontend",
        VITE_VERCEL_PROJECT_PRODUCTION_URL: "app.aigentx.xyz",
        VITE_VERCEL_URL: "aix-frontend-master-bh9gmn4rx-vsmelovs-projects.vercel.app"
    },
    SR = t => typeof t == "object" && t !== null,
    x0 = new WeakMap,
    v3 = new WeakSet,
    pve = (t = Object.is, e = (c, u) => new Proxy(c, u), n = c => SR(c) && !v3.has(c) && (Array.isArray(c) || !(Symbol.iterator in c)) && !(c instanceof WeakMap) && !(c instanceof WeakSet) && !(c instanceof Error) && !(c instanceof Number) && !(c instanceof Date) && !(c instanceof String) && !(c instanceof RegExp) && !(c instanceof ArrayBuffer), r = c => {
        switch (c.status) {
            case "fulfilled":
                return c.value;
            case "rejected":
                throw c.reason;
            default:
                throw c
        }
    }, i = new WeakMap, s = (c, u, f = r) => {
        const h = i.get(c);
        if ((h == null ? void 0 : h[0]) === u) return h[1];
        const g = Array.isArray(c) ? [] : Object.create(Object.getPrototypeOf(c));
        return bz(g, !0), i.set(c, [u, g]), Reflect.ownKeys(c).forEach(y => {
            if (Object.getOwnPropertyDescriptor(g, y)) return;
            const _ = Reflect.get(c, y),
                C = {
                    value: _,
                    enumerable: !0,
                    configurable: !0
                };
            if (v3.has(_)) bz(_, !1);
            else if (_ instanceof Promise) delete C.value, C.get = () => f(_);
            else if (x0.has(_)) {
                const [b, w] = x0.get(_);
                C.value = s(b, w(), f)
            }
            Object.defineProperty(g, y, C)
        }), Object.preventExtensions(g)
    }, o = new WeakMap, a = [1, 1], l = c => {
        if (!SR(c)) throw new Error("object required");
        const u = o.get(c);
        if (u) return u;
        let f = a[0];
        const h = new Set,
            g = ($, H = ++a[0]) => {
                f !== H && (f = H, h.forEach(K => K($, H)))
            };
        let y = a[1];
        const _ = ($ = ++a[1]) => (y !== $ && !h.size && (y = $, b.forEach(([H]) => {
                const K = H[1]($);
                K > f && (f = K)
            })), f),
            C = $ => (H, K) => {
                const te = [...H];
                te[1] = [$, ...te[1]], g(te, K)
            },
            b = new Map,
            w = ($, H) => {
                if ((G8 ? "production" : void 0) !== "production" && b.has($)) throw new Error("prop listener already exists");
                if (h.size) {
                    const K = H[3](C($));
                    b.set($, [H, K])
                } else b.set($, [H])
            },
            S = $ => {
                var H;
                const K = b.get($);
                K && (b.delete($), (H = K[1]) == null || H.call(K))
            },
            I = $ => (h.add($), h.size === 1 && b.forEach(([K, te], U) => {
                if ((G8 ? "production" : void 0) !== "production" && te) throw new Error("remove already exists");
                const m = K[3](C(U));
                b.set(U, [K, m])
            }), () => {
                h.delete($), h.size === 0 && b.forEach(([K, te], U) => {
                    te && (te(), b.set(U, [K]))
                })
            }),
            P = Array.isArray(c) ? [] : Object.create(Object.getPrototypeOf(c)),
            A = e(P, {
                deleteProperty($, H) {
                    const K = Reflect.get($, H);
                    S(H);
                    const te = Reflect.deleteProperty($, H);
                    return te && g(["delete", [H], K]), te
                },
                set($, H, K, te) {
                    const U = Reflect.has($, H),
                        m = Reflect.get($, H, te);
                    if (U && (t(m, K) || o.has(K) && t(m, o.get(K)))) return !0;
                    S(H), SR(K) && (K = dve(K) || K);
                    let v = K;
                    if (K instanceof Promise) K.then(T => {
                        K.status = "fulfilled", K.value = T, g(["resolve", [H], T])
                    }).catch(T => {
                        K.status = "rejected", K.reason = T, g(["reject", [H], T])
                    });
                    else {
                        !x0.has(K) && n(K) && (v = l(K));
                        const T = !v3.has(v) && x0.get(v);
                        T && w(H, T)
                    }
                    return Reflect.set($, H, v, te), g(["set", [H], K, m]), !0
                }
            });
        o.set(c, A);
        const E = [P, _, s, I];
        return x0.set(A, E), Reflect.ownKeys(c).forEach($ => {
            const H = Object.getOwnPropertyDescriptor(c, $);
            "value" in H && (A[$] = c[$], delete H.value, delete H.writable), Object.defineProperty(P, $, H)
        }), A
    }) => [l, x0, v3, t, e, n, r, i, s, o, a],
    [gve] = pve();

function Fo(t = {}) {
    return gve(t)
}

function Uu(t, e, n) {
    const r = x0.get(t);
    (G8 ? "production" : void 0) !== "production" && !r && console.warn("Please use proxy object");
    let i;
    const s = [],
        o = r[3];
    let a = !1;
    const c = o(u => {
        s.push(u), i || (i = Promise.resolve().then(() => {
            i = void 0, a && e(s.splice(0))
        }))
    });
    return a = !0, () => {
        a = !1, c()
    }
}

function q8(t, e) {
    const n = x0.get(t);
    (G8 ? "production" : void 0) !== "production" && !n && console.warn("Please use proxy object");
    const [r, i, s] = n;
    return s(r, i(), e)
}

function Eb(t) {
    return v3.add(t), t
}

function Dc(t, e, n, r) {
    let i = t[e];
    return Uu(t, () => {
        const s = t[e];
        Object.is(i, s) || n(i = s)
    })
}
var ZX = {
        exports: {}
    },
    QX = {};
/**
 * @license React
 * use-sync-external-store-shim.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var xb = ae;

function mve(t, e) {
    return t === e && (t !== 0 || 1 / t === 1 / e) || t !== t && e !== e
}
var yve = typeof Object.is == "function" ? Object.is : mve,
    wve = xb.useState,
    vve = xb.useEffect,
    bve = xb.useLayoutEffect,
    _ve = xb.useDebugValue;

function Eve(t, e) {
    var n = e(),
        r = wve({
            inst: {
                value: n,
                getSnapshot: e
            }
        }),
        i = r[0].inst,
        s = r[1];
    return bve(function() {
        i.value = n, i.getSnapshot = e, CR(i) && s({
            inst: i
        })
    }, [t, n, e]), vve(function() {
        return CR(i) && s({
            inst: i
        }), t(function() {
            CR(i) && s({
                inst: i
            })
        })
    }, [t]), _ve(n), n
}

function CR(t) {
    var e = t.getSnapshot;
    t = t.value;
    try {
        var n = e();
        return !yve(t, n)
    } catch {
        return !0
    }
}

function xve(t, e) {
    return e()
}
var Sve = typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u" ? xve : Eve;
QX.useSyncExternalStore = xb.useSyncExternalStore !== void 0 ? xb.useSyncExternalStore : Sve;
ZX.exports = QX;
var Cve = ZX.exports;
const Ave = co(Cve),
    Tve = {
        BASE_URL: "/",
        DEV: !1,
        MODE: "production",
        PROD: !0,
        SSR: !1,
        VITE_API_URL: "https://eros-ai.cloud:2053",
        VITE_USE_TEST_NET: "false",
        VITE_VERCEL_BRANCH_URL: "aix-frontend-master-git-main-vsmelovs-projects.vercel.app",
        VITE_VERCEL_ENV: "production",
        VITE_VERCEL_GIT_COMMIT_AUTHOR_LOGIN: "vsmelov",
        VITE_VERCEL_GIT_COMMIT_AUTHOR_NAME: "Smelov Vladimir",
        VITE_VERCEL_GIT_COMMIT_MESSAGE: `Merge pull request #30 from integratly-ai/demo

Demo`,
        VITE_VERCEL_GIT_COMMIT_REF: "main",
        VITE_VERCEL_GIT_COMMIT_SHA: "edaf5ff910dd6993ad55c4cb872e0cface55f0bc",
        VITE_VERCEL_GIT_PREVIOUS_SHA: "",
        VITE_VERCEL_GIT_PROVIDER: "github",
        VITE_VERCEL_GIT_PULL_REQUEST_ID: "",
        VITE_VERCEL_GIT_REPO_ID: "726885604",
        VITE_VERCEL_GIT_REPO_OWNER: "integratly-ai",
        VITE_VERCEL_GIT_REPO_SLUG: "aix-frontend",
        VITE_VERCEL_PROJECT_PRODUCTION_URL: "app.aigentx.xyz",
        VITE_VERCEL_URL: "aix-frontend-master-bh9gmn4rx-vsmelovs-projects.vercel.app"
    },
    {
        use: _z
    } = Tu,
    {
        useSyncExternalStore: Ive
    } = Ave,
    Rve = (t, e) => {
        const n = ae.useRef();
        ae.useEffect(() => {
            n.current = hve(t, e)
        }), ae.useDebugValue(n.current)
    },
    Ove = new WeakMap;

function JX(t, e) {
    const r = ae.useRef(),
        i = ae.useRef();
    let s = !0;
    const o = Ive(ae.useCallback(c => {
        const u = Uu(t, c);
        return c(), u
    }, [t, void 0]), () => {
        const c = q8(t, _z);
        try {
            if (!s && r.current && i.current && !YX(r.current, c, i.current, new WeakMap)) return r.current
        } catch {}
        return c
    }, () => q8(t, _z));
    s = !1;
    const a = new WeakMap;
    ae.useEffect(() => {
        r.current = o, i.current = a
    }), (Tve ? "production" : void 0) !== "production" && Rve(o, a);
    const l = ae.useMemo(() => new WeakMap, []);
    return KX(o, a, l, Ove)
}
const AR = "https://secure.web3modal.com",
    ah = {
        FOUR_MINUTES_MS: 24e4,
        TEN_SEC_MS: 1e4,
        ONE_SEC_MS: 1e3,
        SECURE_SITE: AR,
        SECURE_SITE_DASHBOARD: `${AR}/dashboard`,
        SECURE_SITE_FAVICON: `${AR}/images/favicon.png`,
        RESTRICTED_TIMEZONES: ["ASIA/SHANGHAI", "ASIA/URUMQI", "ASIA/CHONGQING", "ASIA/HARBIN", "ASIA/KASHGAR", "ASIA/MACAU", "ASIA/HONG_KONG", "ASIA/MACAO", "ASIA/BEIJING", "ASIA/HARBIN"],
        CONNECTOR_RDNS_MAP: {
            coinbaseWallet: "com.coinbase.wallet"
        }
    },
    Yt = {
        isMobile() {
            return typeof window < "u" ? !!(window.matchMedia("(pointer:coarse)").matches || /Android|webOS|iPhone|iPad|iPod|BlackBerry|Opera Mini/u.test(navigator.userAgent)) : !1
        },
        isAndroid() {
            const t = window.navigator.userAgent.toLowerCase();
            return Yt.isMobile() && t.includes("android")
        },
        isIos() {
            const t = window.navigator.userAgent.toLowerCase();
            return Yt.isMobile() && (t.includes("iphone") || t.includes("ipad"))
        },
        isClient() {
            return typeof window < "u"
        },
        isPairingExpired(t) {
            return t ? t - Date.now() <= ah.TEN_SEC_MS : !0
        },
        isAllowedRetry(t) {
            return Date.now() - t >= ah.ONE_SEC_MS
        },
        copyToClopboard(t) {
            navigator.clipboard.writeText(t)
        },
        getPairingExpiry() {
            return Date.now() + ah.FOUR_MINUTES_MS
        },
        getPlainAddress(t) {
            return t.split(":")[2]
        },
        async wait(t) {
            return new Promise(e => {
                setTimeout(e, t)
            })
        },
        debounce(t, e = 500) {
            let n;
            return (...r) => {
                function i() {
                    t(...r)
                }
                n && clearTimeout(n), n = setTimeout(i, e)
            }
        },
        isHttpUrl(t) {
            return t.startsWith("http://") || t.startsWith("https://")
        },
        formatNativeUrl(t, e) {
            if (Yt.isHttpUrl(t)) return this.formatUniversalUrl(t, e);
            let n = t;
            n.includes("://") || (n = t.replaceAll("/", "").replaceAll(":", ""), n = `${n}://`), n.endsWith("/") || (n = `${n}/`);
            const r = encodeURIComponent(e);
            return {
                redirect: `${n}wc?uri=${r}`,
                href: n
            }
        },
        formatUniversalUrl(t, e) {
            if (!Yt.isHttpUrl(t)) return this.formatNativeUrl(t, e);
            let n = t;
            n.endsWith("/") || (n = `${n}/`);
            const r = encodeURIComponent(e);
            return {
                redirect: `${n}wc?uri=${r}`,
                href: n
            }
        },
        openHref(t, e) {
            window.open(t, e, "noreferrer noopener")
        },
        async preloadImage(t) {
            const e = new Promise((n, r) => {
                const i = new Image;
                i.onload = n, i.onerror = r, i.crossOrigin = "anonymous", i.src = t
            });
            return Promise.race([e, Yt.wait(2e3)])
        },
        formatBalance(t, e) {
            var r;
            let n;
            if (t === "0") n = "0.000";
            else if (typeof t == "string") {
                const i = Number(t);
                i && (n = (r = i.toString().match(/^-?\d+(?:\.\d{0,3})?/u)) == null ? void 0 : r[0])
            }
            return n ? `${n} ${e}` : `0.000 ${e}`
        },
        isRestrictedRegion() {
            try {
                const {
                    timeZone: t
                } = new Intl.DateTimeFormat().resolvedOptions(), e = t.toUpperCase();
                return ah.RESTRICTED_TIMEZONES.includes(e)
            } catch {
                return !1
            }
        },
        getApiUrl() {
            return Yt.isRestrictedRegion() ? "https://api.web3modal.org" : "https://api.web3modal.com"
        },
        getBlockchainApiUrl() {
            return Yt.isRestrictedRegion() ? "https://rpc.walletconnect.org" : "https://rpc.walletconnect.com"
        },
        getAnalyticsUrl() {
            return Yt.isRestrictedRegion() ? "https://pulse.walletconnect.org" : "https://pulse.walletconnect.com"
        },
        getUUID() {
            return crypto != null && crypto.randomUUID ? crypto.randomUUID() : "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/gu, t => {
                const e = Math.random() * 16 | 0;
                return (t === "x" ? e : e & 3 | 8).toString(16)
            })
        },
        parseError(t) {
            var e, n;
            return typeof t == "string" ? t : typeof((n = (e = t == null ? void 0 : t.issues) == null ? void 0 : e[0]) == null ? void 0 : n.message) == "string" ? t.issues[0].message : t instanceof Error ? t.message : "Unknown error"
        }
    },
    gs = Fo({
        isConnected: !1
    }),
    hr = {
        state: gs,
        subscribe(t) {
            return Uu(gs, () => t(gs))
        },
        subscribeKey(t, e) {
            return Dc(gs, t, e)
        },
        setIsConnected(t) {
            gs.isConnected = t
        },
        setCaipAddress(t) {
            gs.caipAddress = t, gs.address = t ? Yt.getPlainAddress(t) : void 0
        },
        setBalance(t, e) {
            gs.balance = t, gs.balanceSymbol = e
        },
        setProfileName(t) {
            gs.profileName = t
        },
        setProfileImage(t) {
            gs.profileImage = t
        },
        setAddressExplorerUrl(t) {
            gs.addressExplorerUrl = t
        },
        resetAccount() {
            gs.isConnected = !1, gs.caipAddress = void 0, gs.address = void 0, gs.balance = void 0, gs.balanceSymbol = void 0, gs.profileName = void 0, gs.profileImage = void 0, gs.addressExplorerUrl = void 0
        }
    };
class E$ {
    constructor({
        baseUrl: e
    }) {
        this.baseUrl = e
    }
    async get({
        headers: e,
        ...n
    }) {
        const r = this.createUrl(n);
        return (await fetch(r, {
            method: "GET",
            headers: e
        })).json()
    }
    async getBlob({
        headers: e,
        ...n
    }) {
        const r = this.createUrl(n);
        return (await fetch(r, {
            method: "GET",
            headers: e
        })).blob()
    }
    async post({
        body: e,
        headers: n,
        ...r
    }) {
        const i = this.createUrl(r);
        return (await fetch(i, {
            method: "POST",
            headers: n,
            body: e ? JSON.stringify(e) : void 0
        })).json()
    }
    async put({
        body: e,
        headers: n,
        ...r
    }) {
        const i = this.createUrl(r);
        return (await fetch(i, {
            method: "PUT",
            headers: n,
            body: e ? JSON.stringify(e) : void 0
        })).json()
    }
    async delete({
        body: e,
        headers: n,
        ...r
    }) {
        const i = this.createUrl(r);
        return (await fetch(i, {
            method: "DELETE",
            headers: n,
            body: e ? JSON.stringify(e) : void 0
        })).json()
    }
    createUrl({
        path: e,
        params: n
    }) {
        const r = new URL(e, this.baseUrl);
        return n && Object.entries(n).forEach(([i, s]) => {
            s && r.searchParams.append(i, s)
        }), r
    }
}
const TR = "WALLETCONNECT_DEEPLINK_CHOICE",
    Ez = "@w3m/recent",
    xz = "@w3m/connected_wallet_image_url",
    Sz = "@w3m/connected_connector",
    ia = {
        setWalletConnectDeepLink({
            href: t,
            name: e
        }) {
            try {
                localStorage.setItem(TR, JSON.stringify({
                    href: t,
                    name: e
                }))
            } catch {
                console.info("Unable to set WalletConnect deep link")
            }
        },
        getWalletConnectDeepLink() {
            try {
                const t = localStorage.getItem(TR);
                if (t) return JSON.parse(t)
            } catch {
                console.info("Unable to get WalletConnect deep link")
            }
        },
        deleteWalletConnectDeepLink() {
            try {
                localStorage.removeItem(TR)
            } catch {
                console.info("Unable to delete WalletConnect deep link")
            }
        },
        setWeb3ModalRecent(t) {
            try {
                const e = ia.getRecentWallets();
                e.find(r => r.id === t.id) || (e.unshift(t), e.length > 2 && e.pop(), localStorage.setItem(Ez, JSON.stringify(e)))
            } catch {
                console.info("Unable to set Web3Modal recent")
            }
        },
        getRecentWallets() {
            try {
                const t = localStorage.getItem(Ez);
                return t ? JSON.parse(t) : []
            } catch {
                console.info("Unable to get Web3Modal recent")
            }
            return []
        },
        setConnectedWalletImageUrl(t) {
            try {
                localStorage.setItem(xz, t)
            } catch {
                console.info("Unable to set Connected Wallet Image Url")
            }
        },
        getConnectedWalletImageUrl() {
            try {
                return localStorage.getItem(xz)
            } catch {
                console.info("Unable to set Connected Wallet Image Url")
            }
        },
        setConnectedConnector(t) {
            try {
                localStorage.setItem(Sz, t)
            } catch {
                console.info("Unable to set Connected Connector")
            }
        },
        getConnectedConnector() {
            try {
                return localStorage.getItem(Sz)
            } catch {
                console.info("Unable to get Connected Connector")
            }
        }
    },
    o0 = Fo({
        walletImages: {},
        networkImages: {},
        connectorImages: {},
        tokenImages: {}
    }),
    Qw = {
        state: o0,
        subscribeNetworkImages(t) {
            return Uu(o0.networkImages, () => t(o0.networkImages))
        },
        subscribeKey(t, e) {
            return Dc(o0, t, e)
        },
        setWalletImage(t, e) {
            o0.walletImages[t] = e
        },
        setNetworkImage(t, e) {
            o0.networkImages[t] = e
        },
        setConnectorImage(t, e) {
            o0.connectorImages[t] = e
        },
        setTokenImage(t, e) {
            o0.tokenImages[t] = e
        }
    },
    ol = Fo({
        projectId: "",
        sdkType: "w3m",
        sdkVersion: "html-wagmi-undefined"
    }),
    _r = {
        state: ol,
        subscribeKey(t, e) {
            return Dc(ol, t, e)
        },
        setProjectId(t) {
            ol.projectId = t
        },
        setIncludeWalletIds(t) {
            ol.includeWalletIds = t
        },
        setExcludeWalletIds(t) {
            ol.excludeWalletIds = t
        },
        setFeaturedWalletIds(t) {
            ol.featuredWalletIds = t
        },
        setTokens(t) {
            ol.tokens = t
        },
        setTermsConditionsUrl(t) {
            ol.termsConditionsUrl = t
        },
        setPrivacyPolicyUrl(t) {
            ol.privacyPolicyUrl = t
        },
        setCustomWallets(t) {
            ol.customWallets = t
        },
        setEnableAnalytics(t) {
            ol.enableAnalytics = t
        },
        setSdkVersion(t) {
            ol.sdkVersion = t
        },
        setMetadata(t) {
            ol.metadata = t
        }
    },
    Rg = Fo({
        connectors: []
    }),
    Wr = {
        state: Rg,
        subscribeKey(t, e) {
            return Dc(Rg, t, e)
        },
        setConnectors(t) {
            Rg.connectors = t.map(e => Eb(e))
        },
        addConnector(t) {
            var e, n;
            if (Rg.connectors.push(Eb(t)), t.id === "w3mEmail") {
                const r = t,
                    i = q8(_r.state);
                (n = (e = r == null ? void 0 : r.provider) == null ? void 0 : e.syncDappData) == null || n.call(e, {
                    metadata: i.metadata,
                    sdkVersion: i.sdkVersion,
                    projectId: i.projectId
                })
            }
        },
        getEmailConnector() {
            return Rg.connectors.find(t => t.type === "EMAIL")
        },
        getAnnouncedConnectorRdns() {
            return Rg.connectors.filter(t => t.type === "ANNOUNCED").map(t => {
                var e;
                return (e = t.info) == null ? void 0 : e.rdns
            })
        },
        getConnectors() {
            return Rg.connectors
        }
    },
    N5 = Fo({
        open: !1,
        selectedNetworkId: void 0
    }),
    Sb = {
        state: N5,
        subscribe(t) {
            return Uu(N5, () => t(N5))
        },
        set(t) {
            Object.assign(N5, { ...N5,
                ...t
            })
        }
    },
    mo = Fo({
        supportsAllNetworks: !0,
        isDefaultCaipNetwork: !1
    }),
    Gi = {
        state: mo,
        subscribeKey(t, e) {
            return Dc(mo, t, e)
        },
        _getClient() {
            if (!mo._client) throw new Error("NetworkController client not set");
            return mo._client
        },
        setClient(t) {
            mo._client = Eb(t)
        },
        setCaipNetwork(t) {
            mo.caipNetwork = t, Sb.set({
                selectedNetworkId: t == null ? void 0 : t.id
            })
        },
        setDefaultCaipNetwork(t) {
            mo.caipNetwork = t, Sb.set({
                selectedNetworkId: t == null ? void 0 : t.id
            }), mo.isDefaultCaipNetwork = !0
        },
        setRequestedCaipNetworks(t) {
            mo.requestedCaipNetworks = t
        },
        async getApprovedCaipNetworksData() {
            const t = await this._getClient().getApprovedCaipNetworksData();
            mo.supportsAllNetworks = t.supportsAllNetworks, mo.approvedCaipNetworkIds = t.approvedCaipNetworkIds
        },
        async switchActiveNetwork(t) {
            await this._getClient().switchCaipNetwork(t), mo.caipNetwork = t
        },
        resetNetwork() {
            mo.isDefaultCaipNetwork || (mo.caipNetwork = void 0), mo.approvedCaipNetworkIds = void 0, mo.supportsAllNetworks = !0
        }
    },
    Nve = Yt.getApiUrl(),
    tf = new E$({
        baseUrl: Nve
    }),
    Pve = "40",
    Cz = "4",
    Go = Fo({
        page: 1,
        count: 0,
        featured: [],
        recommended: [],
        wallets: [],
        search: []
    }),
    Vn = {
        state: Go,
        subscribeKey(t, e) {
            return Dc(Go, t, e)
        },
        _getApiHeaders() {
            const {
                projectId: t,
                sdkType: e,
                sdkVersion: n
            } = _r.state;
            return {
                "x-project-id": t,
                "x-sdk-type": e,
                "x-sdk-version": n
            }
        },
        async _fetchWalletImage(t) {
            const e = `${tf.baseUrl}/getWalletImage/${t}`,
                n = await tf.getBlob({
                    path: e,
                    headers: Vn._getApiHeaders()
                });
            Qw.setWalletImage(t, URL.createObjectURL(n))
        },
        async _fetchNetworkImage(t) {
            const e = `${tf.baseUrl}/public/getAssetImage/${t}`,
                n = await tf.getBlob({
                    path: e,
                    headers: Vn._getApiHeaders()
                });
            Qw.setNetworkImage(t, URL.createObjectURL(n))
        },
        async _fetchConnectorImage(t) {
            const e = `${tf.baseUrl}/public/getAssetImage/${t}`,
                n = await tf.getBlob({
                    path: e,
                    headers: Vn._getApiHeaders()
                });
            Qw.setConnectorImage(t, URL.createObjectURL(n))
        },
        async fetchNetworkImages() {
            const {
                requestedCaipNetworks: t
            } = Gi.state, e = t == null ? void 0 : t.map(({
                imageId: n
            }) => n).filter(Boolean);
            e && await Promise.allSettled(e.map(n => Vn._fetchNetworkImage(n)))
        },
        async fetchConnectorImages() {
            const {
                connectors: t
            } = Wr.state, e = t.map(({
                imageId: n
            }) => n).filter(Boolean);
            await Promise.allSettled(e.map(n => Vn._fetchConnectorImage(n)))
        },
        async fetchFeaturedWallets() {
            const {
                featuredWalletIds: t
            } = _r.state;
            if (t != null && t.length) {
                const {
                    data: e
                } = await tf.get({
                    path: "/getWallets",
                    headers: Vn._getApiHeaders(),
                    params: {
                        page: "1",
                        entries: t != null && t.length ? String(t.length) : Cz,
                        include: t == null ? void 0 : t.join(",")
                    }
                });
                e.sort((r, i) => t.indexOf(r.id) - t.indexOf(i.id));
                const n = e.map(r => r.image_id).filter(Boolean);
                await Promise.allSettled(n.map(r => Vn._fetchWalletImage(r))), Go.featured = e
            }
        },
        async fetchRecommendedWallets() {
            const {
                includeWalletIds: t,
                excludeWalletIds: e,
                featuredWalletIds: n
            } = _r.state, r = [...e ? ? [], ...n ? ? []].filter(Boolean), {
                data: i,
                count: s
            } = await tf.get({
                path: "/getWallets",
                headers: Vn._getApiHeaders(),
                params: {
                    page: "1",
                    entries: Cz,
                    include: t == null ? void 0 : t.join(","),
                    exclude: r == null ? void 0 : r.join(",")
                }
            }), o = ia.getRecentWallets(), a = i.map(c => c.image_id).filter(Boolean), l = o.map(c => c.image_id).filter(Boolean);
            await Promise.allSettled([...a, ...l].map(c => Vn._fetchWalletImage(c))), Go.recommended = i, Go.count = s ? ? 0
        },
        async fetchWallets({
            page: t
        }) {
            const {
                includeWalletIds: e,
                excludeWalletIds: n,
                featuredWalletIds: r
            } = _r.state, i = [...Go.recommended.map(({
                id: l
            }) => l), ...n ? ? [], ...r ? ? []].filter(Boolean), {
                data: s,
                count: o
            } = await tf.get({
                path: "/getWallets",
                headers: Vn._getApiHeaders(),
                params: {
                    page: String(t),
                    entries: Pve,
                    include: e == null ? void 0 : e.join(","),
                    exclude: i.join(",")
                }
            }), a = s.map(l => l.image_id).filter(Boolean);
            await Promise.allSettled([...a.map(l => Vn._fetchWalletImage(l)), Yt.wait(300)]), Go.wallets = [...Go.wallets, ...s], Go.count = o > Go.count ? o : Go.count, Go.page = t
        },
        async searchWallet({
            search: t
        }) {
            const {
                includeWalletIds: e,
                excludeWalletIds: n
            } = _r.state;
            Go.search = [];
            const {
                data: r
            } = await tf.get({
                path: "/getWallets",
                headers: Vn._getApiHeaders(),
                params: {
                    page: "1",
                    entries: "100",
                    search: t,
                    include: e == null ? void 0 : e.join(","),
                    exclude: n == null ? void 0 : n.join(",")
                }
            }), i = r.map(s => s.image_id).filter(Boolean);
            await Promise.allSettled([...i.map(s => Vn._fetchWalletImage(s)), Yt.wait(300)]), Go.search = r
        },
        prefetch() {
            Go.prefetchPromise = Promise.race([Promise.allSettled([Vn.fetchFeaturedWallets(), Vn.fetchRecommendedWallets(), Vn.fetchNetworkImages(), Vn.fetchConnectorImages()]), Yt.wait(3e3)])
        }
    },
    kve = Yt.getAnalyticsUrl(),
    Mve = new E$({
        baseUrl: kve
    }),
    Dve = ["MODAL_CREATED"],
    Zy = Fo({
        timestamp: Date.now(),
        data: {
            type: "track",
            event: "MODAL_CREATED"
        }
    }),
    wn = {
        state: Zy,
        subscribe(t) {
            return Uu(Zy, () => t(Zy))
        },
        _getApiHeaders() {
            const {
                projectId: t,
                sdkType: e,
                sdkVersion: n
            } = _r.state;
            return {
                "x-project-id": t,
                "x-sdk-type": e,
                "x-sdk-version": n
            }
        },
        async _sendAnalyticsEvent(t) {
            try {
                if (Dve.includes(t.data.event) || typeof window > "u") return;
                await Mve.post({
                    path: "/e",
                    headers: wn._getApiHeaders(),
                    body: {
                        eventId: Yt.getUUID(),
                        url: window.location.href,
                        domain: window.location.hostname,
                        timestamp: t.timestamp,
                        props: t.data
                    }
                })
            } catch {}
        },
        sendEvent(t) {
            Zy.timestamp = Date.now(), Zy.data = t, _r.state.enableAnalytics && wn._sendAnalyticsEvent(Zy)
        }
    },
    Ei = Fo({
        view: "Connect",
        history: ["Connect"]
    }),
    Dt = {
        state: Ei,
        subscribeKey(t, e) {
            return Dc(Ei, t, e)
        },
        push(t, e) {
            t !== Ei.view && (Ei.view = t, Ei.history.push(t), Ei.data = e)
        },
        reset(t) {
            Ei.view = t, Ei.history = [t]
        },
        replace(t, e) {
            Ei.history.length > 1 && Ei.history.at(-1) !== t && (Ei.view = t, Ei.history[Ei.history.length - 1] = t, Ei.data = e)
        },
        goBack() {
            if (Ei.history.length > 1) {
                Ei.history.pop();
                const [t] = Ei.history.slice(-1);
                t && (Ei.view = t)
            }
        },
        goBackToIndex(t) {
            if (Ei.history.length > 1) {
                Ei.history = Ei.history.slice(0, t + 1);
                const [e] = Ei.history.slice(-1);
                e && (Ei.view = e)
            }
        }
    },
    Og = Fo({
        loading: !1,
        open: !1
    }),
    Vr = {
        state: Og,
        subscribe(t) {
            return Uu(Og, () => t(Og))
        },
        subscribeKey(t, e) {
            return Dc(Og, t, e)
        },
        async open(t) {
            await Vn.state.prefetchPromise, t != null && t.view ? Dt.reset(t.view) : hr.state.isConnected ? Dt.reset("Account") : Dt.reset("Connect"), Og.open = !0, Sb.set({
                open: !0
            }), wn.sendEvent({
                type: "track",
                event: "MODAL_OPEN"
            })
        },
        close() {
            Og.open = !1, Sb.set({
                open: !1
            }), wn.sendEvent({
                type: "track",
                event: "MODAL_CLOSE"
            })
        },
        setLoading(t) {
            Og.loading = t
        }
    },
    $ve = Yt.getBlockchainApiUrl(),
    Az = new E$({
        baseUrl: $ve
    }),
    XX = {
        fetchIdentity({
            caipChainId: t,
            address: e
        }) {
            return Az.get({
                path: `/v1/identity/${e}`,
                params: {
                    chainId: t,
                    projectId: _r.state.projectId
                }
            })
        },
        fetchTransactions({
            account: t,
            projectId: e,
            cursor: n
        }) {
            const r = n ? {
                cursor: n
            } : {};
            return Az.get({
                path: `/v1/account/${t}/history?projectId=${e}`,
                params: r
            })
        }
    },
    Ad = Fo({
        message: "",
        variant: "success",
        open: !1
    }),
    qi = {
        state: Ad,
        subscribeKey(t, e) {
            return Dc(Ad, t, e)
        },
        showSuccess(t) {
            Ad.message = t, Ad.variant = "success", Ad.open = !0
        },
        showError(t) {
            const e = Yt.parseError(t);
            Ad.message = e, Ad.variant = "error", Ad.open = !0
        },
        hide() {
            Ad.open = !1
        }
    },
    ms = Fo({
        transactions: [],
        transactionsByYear: {},
        loading: !1,
        empty: !1,
        next: void 0
    }),
    Qc = {
        state: ms,
        subscribe(t) {
            return Uu(ms, () => t(ms))
        },
        async fetchTransactions(t) {
            const {
                projectId: e
            } = _r.state;
            if (!e || !t) throw new Error("Transactions can't be fetched without a projectId and an accountAddress");
            ms.loading = !0;
            try {
                const n = await XX.fetchTransactions({
                        account: t,
                        projectId: e,
                        cursor: ms.next
                    }),
                    r = this.filterSpamTransactions(n.data),
                    i = [...ms.transactions, ...r];
                ms.loading = !1, ms.transactions = i, ms.transactionsByYear = this.groupTransactionsByYear(ms.transactionsByYear, r), ms.empty = i.length === 0, ms.next = n.next ? n.next : void 0
            } catch {
                wn.sendEvent({
                    type: "track",
                    event: "ERROR_FETCH_TRANSACTIONS",
                    properties: {
                        address: t,
                        projectId: e,
                        cursor: ms.next
                    }
                }), qi.showError("Failed to fetch transactions"), ms.loading = !1, ms.empty = !0
            }
        },
        groupTransactionsByYear(t = {}, e = []) {
            const n = t;
            return e.forEach(r => {
                var s;
                const i = new Date(r.metadata.minedAt).getFullYear();
                n[i] || (n[i] = []), (s = n[i]) == null || s.push(r)
            }), n
        },
        filterSpamTransactions(t) {
            return t.filter(e => !e.transfers.every(r => {
                var i;
                return ((i = r.nft_info) == null ? void 0 : i.flags.is_spam) === !0
            }))
        },
        resetTransactions() {
            ms.transactions = [], ms.transactionsByYear = {}, ms.loading = !1, ms.empty = !1, ms.next = void 0
        }
    },
    Ls = Fo({
        wcError: !1,
        buffering: !1
    }),
    ir = {
        state: Ls,
        subscribeKey(t, e) {
            return Dc(Ls, t, e)
        },
        _getClient() {
            if (!Ls._client) throw new Error("ConnectionController client not set");
            return Ls._client
        },
        setClient(t) {
            Ls._client = Eb(t)
        },
        connectWalletConnect() {
            Ls.wcPromise = this._getClient().connectWalletConnect(t => {
                Ls.wcUri = t, Ls.wcPairingExpiry = Yt.getPairingExpiry()
            })
        },
        async connectExternal(t) {
            var e, n;
            await ((n = (e = this._getClient()).connectExternal) == null ? void 0 : n.call(e, t)), ia.setConnectedConnector(t.type)
        },
        async signMessage(t) {
            return this._getClient().signMessage(t)
        },
        checkInstalled(t) {
            var e, n;
            return (n = (e = this._getClient()).checkInstalled) == null ? void 0 : n.call(e, t)
        },
        resetWcConnection() {
            Ls.wcUri = void 0, Ls.wcPairingExpiry = void 0, Ls.wcPromise = void 0, Ls.wcLinking = void 0, Ls.recentWallet = void 0, Qc.resetTransactions(), ia.deleteWalletConnectDeepLink()
        },
        setWcLinking(t) {
            Ls.wcLinking = t
        },
        setWcError(t) {
            Ls.wcError = t, Ls.buffering = !1
        },
        setRecentWallet(t) {
            Ls.recentWallet = t
        },
        setBuffering(t) {
            Ls.buffering = t
        },
        async disconnect() {
            await this._getClient().disconnect(), this.resetWcConnection()
        }
    },
    al = Fo({
        status: "uninitialized",
        isSiweEnabled: !1
    }),
    ss = {
        state: al,
        subscribeKey(t, e) {
            return Dc(al, t, e)
        },
        subscribe(t) {
            return Uu(al, () => t(al))
        },
        _getClient() {
            if (!al._client) throw new Error("SIWEController client not set");
            return al._client
        },
        async getNonce() {
            const e = await this._getClient().getNonce();
            return this.setNonce(e), e
        },
        async getSession() {
            const e = await this._getClient().getSession();
            return e && (this.setSession(e), this.setStatus("success")), e
        },
        createMessage(t) {
            const n = this._getClient().createMessage(t);
            return this.setMessage(n), n
        },
        async verifyMessage(t) {
            return await this._getClient().verifyMessage(t)
        },
        async signIn() {
            return await this._getClient().signIn()
        },
        async signOut() {
            var e;
            const t = this._getClient();
            await t.signOut(), this.setStatus("ready"), (e = t.onSignOut) == null || e.call(t)
        },
        onSignIn(t) {
            var n;
            const e = this._getClient();
            (n = e.onSignIn) == null || n.call(e, t)
        },
        onSignOut() {
            var e;
            const t = this._getClient();
            (e = t.onSignOut) == null || e.call(t)
        },
        setSIWEClient(t) {
            al._client = Eb(t), al.status = "ready", al.isSiweEnabled = t.options.enabled
        },
        setNonce(t) {
            al.nonce = t
        },
        setStatus(t) {
            al.status = t
        },
        setMessage(t) {
            al.message = t
        },
        setSession(t) {
            al.session = t
        }
    },
    Ng = Fo({
        themeMode: "dark",
        themeVariables: {}
    }),
    Na = {
        state: Ng,
        subscribe(t) {
            return Uu(Ng, () => t(Ng))
        },
        setThemeMode(t) {
            Ng.themeMode = t
        },
        setThemeVariables(t) {
            Ng.themeVariables = { ...Ng.themeVariables,
                ...t
            }
        },
        getSnapshot() {
            return q8(Ng)
        }
    },
    Wi = {
        getWalletImage(t) {
            if (t != null && t.image_url) return t == null ? void 0 : t.image_url;
            if (t != null && t.image_id) return Qw.state.walletImages[t.image_id]
        },
        getNetworkImage(t) {
            if (t != null && t.imageUrl) return t == null ? void 0 : t.imageUrl;
            if (t != null && t.imageId) return Qw.state.networkImages[t.imageId]
        },
        getConnectorImage(t) {
            if (t != null && t.imageUrl) return t.imageUrl;
            if (t != null && t.imageId) return Qw.state.connectorImages[t.imageId]
        }
    },
    eee = {
        goBackOrCloseModal() {
            Dt.state.history.length > 1 ? Dt.goBack() : Vr.close()
        },
        navigateAfterNetworkSwitch() {
            const {
                history: t
            } = Dt.state, e = t.findIndex(n => n === "Networks");
            e >= 1 ? Dt.goBackToIndex(e - 1) : Vr.close()
        }
    };
/**
 * @license
 * Copyright 2019 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const qS = globalThis,
    x$ = qS.ShadowRoot && (qS.ShadyCSS === void 0 || qS.ShadyCSS.nativeShadow) && "adoptedStyleSheets" in Document.prototype && "replace" in CSSStyleSheet.prototype,
    S$ = Symbol(),
    Tz = new WeakMap;
let tee = class {
    constructor(e, n, r) {
        if (this._$cssResult$ = !0, r !== S$) throw Error("CSSResult is not constructable. Use `unsafeCSS` or `css` instead.");
        this.cssText = e, this.t = n
    }
    get styleSheet() {
        let e = this.o;
        const n = this.t;
        if (x$ && e === void 0) {
            const r = n !== void 0 && n.length === 1;
            r && (e = Tz.get(n)), e === void 0 && ((this.o = e = new CSSStyleSheet).replaceSync(this.cssText), r && Tz.set(n, e))
        }
        return e
    }
    toString() {
        return this.cssText
    }
};
const ff = t => new tee(typeof t == "string" ? t : t + "", void 0, S$),
    Wt = (t, ...e) => {
        const n = t.length === 1 ? t[0] : e.reduce((r, i, s) => r + (o => {
            if (o._$cssResult$ === !0) return o.cssText;
            if (typeof o == "number") return o;
            throw Error("Value passed to 'css' function must be a 'css' function result: " + o + ". Use 'unsafeCSS' to pass non-literal values, but take care to ensure page security.")
        })(i) + t[s + 1], t[0]);
        return new tee(n, t, S$)
    },
    Lve = (t, e) => {
        if (x$) t.adoptedStyleSheets = e.map(n => n instanceof CSSStyleSheet ? n : n.styleSheet);
        else
            for (const n of e) {
                const r = document.createElement("style"),
                    i = qS.litNonce;
                i !== void 0 && r.setAttribute("nonce", i), r.textContent = n.cssText, t.appendChild(r)
            }
    },
    Iz = x$ ? t => t : t => t instanceof CSSStyleSheet ? (e => {
        let n = "";
        for (const r of e.cssRules) n += r.cssText;
        return ff(n)
    })(t) : t;
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const {
    is: Bve,
    defineProperty: Fve,
    getOwnPropertyDescriptor: Uve,
    getOwnPropertyNames: jve,
    getOwnPropertySymbols: Hve,
    getPrototypeOf: zve
} = Object, wp = globalThis, Rz = wp.trustedTypes, Wve = Rz ? Rz.emptyScript : "", IR = wp.reactiveElementPolyfillSupport, D3 = (t, e) => t, K8 = {
    toAttribute(t, e) {
        switch (e) {
            case Boolean:
                t = t ? Wve : null;
                break;
            case Object:
            case Array:
                t = t == null ? t : JSON.stringify(t)
        }
        return t
    },
    fromAttribute(t, e) {
        let n = t;
        switch (e) {
            case Boolean:
                n = t !== null;
                break;
            case Number:
                n = t === null ? null : Number(t);
                break;
            case Object:
            case Array:
                try {
                    n = JSON.parse(t)
                } catch {
                    n = null
                }
        }
        return n
    }
}, C$ = (t, e) => !Bve(t, e), Oz = {
    attribute: !0,
    type: String,
    converter: K8,
    reflect: !1,
    hasChanged: C$
};
Symbol.metadata ? ? (Symbol.metadata = Symbol("metadata")), wp.litPropertyMetadata ? ? (wp.litPropertyMetadata = new WeakMap);
let yw = class extends HTMLElement {
    static addInitializer(e) {
        this._$Ei(), (this.l ? ? (this.l = [])).push(e)
    }
    static get observedAttributes() {
        return this.finalize(), this._$Eh && [...this._$Eh.keys()]
    }
    static createProperty(e, n = Oz) {
        if (n.state && (n.attribute = !1), this._$Ei(), this.elementProperties.set(e, n), !n.noAccessor) {
            const r = Symbol(),
                i = this.getPropertyDescriptor(e, r, n);
            i !== void 0 && Fve(this.prototype, e, i)
        }
    }
    static getPropertyDescriptor(e, n, r) {
        const {
            get: i,
            set: s
        } = Uve(this.prototype, e) ? ? {
            get() {
                return this[n]
            },
            set(o) {
                this[n] = o
            }
        };
        return {
            get() {
                return i == null ? void 0 : i.call(this)
            },
            set(o) {
                const a = i == null ? void 0 : i.call(this);
                s.call(this, o), this.requestUpdate(e, a, r)
            },
            configurable: !0,
            enumerable: !0
        }
    }
    static getPropertyOptions(e) {
        return this.elementProperties.get(e) ? ? Oz
    }
    static _$Ei() {
        if (this.hasOwnProperty(D3("elementProperties"))) return;
        const e = zve(this);
        e.finalize(), e.l !== void 0 && (this.l = [...e.l]), this.elementProperties = new Map(e.elementProperties)
    }
    static finalize() {
        if (this.hasOwnProperty(D3("finalized"))) return;
        if (this.finalized = !0, this._$Ei(), this.hasOwnProperty(D3("properties"))) {
            const n = this.properties,
                r = [...jve(n), ...Hve(n)];
            for (const i of r) this.createProperty(i, n[i])
        }
        const e = this[Symbol.metadata];
        if (e !== null) {
            const n = litPropertyMetadata.get(e);
            if (n !== void 0)
                for (const [r, i] of n) this.elementProperties.set(r, i)
        }
        this._$Eh = new Map;
        for (const [n, r] of this.elementProperties) {
            const i = this._$Eu(n, r);
            i !== void 0 && this._$Eh.set(i, n)
        }
        this.elementStyles = this.finalizeStyles(this.styles)
    }
    static finalizeStyles(e) {
        const n = [];
        if (Array.isArray(e)) {
            const r = new Set(e.flat(1 / 0).reverse());
            for (const i of r) n.unshift(Iz(i))
        } else e !== void 0 && n.push(Iz(e));
        return n
    }
    static _$Eu(e, n) {
        const r = n.attribute;
        return r === !1 ? void 0 : typeof r == "string" ? r : typeof e == "string" ? e.toLowerCase() : void 0
    }
    constructor() {
        super(), this._$Ep = void 0, this.isUpdatePending = !1, this.hasUpdated = !1, this._$Em = null, this._$Ev()
    }
    _$Ev() {
        var e;
        this._$ES = new Promise(n => this.enableUpdating = n), this._$AL = new Map, this._$E_(), this.requestUpdate(), (e = this.constructor.l) == null || e.forEach(n => n(this))
    }
    addController(e) {
        var n;
        (this._$EO ? ? (this._$EO = new Set)).add(e), this.renderRoot !== void 0 && this.isConnected && ((n = e.hostConnected) == null || n.call(e))
    }
    removeController(e) {
        var n;
        (n = this._$EO) == null || n.delete(e)
    }
    _$E_() {
        const e = new Map,
            n = this.constructor.elementProperties;
        for (const r of n.keys()) this.hasOwnProperty(r) && (e.set(r, this[r]), delete this[r]);
        e.size > 0 && (this._$Ep = e)
    }
    createRenderRoot() {
        const e = this.shadowRoot ? ? this.attachShadow(this.constructor.shadowRootOptions);
        return Lve(e, this.constructor.elementStyles), e
    }
    connectedCallback() {
        var e;
        this.renderRoot ? ? (this.renderRoot = this.createRenderRoot()), this.enableUpdating(!0), (e = this._$EO) == null || e.forEach(n => {
            var r;
            return (r = n.hostConnected) == null ? void 0 : r.call(n)
        })
    }
    enableUpdating(e) {}
    disconnectedCallback() {
        var e;
        (e = this._$EO) == null || e.forEach(n => {
            var r;
            return (r = n.hostDisconnected) == null ? void 0 : r.call(n)
        })
    }
    attributeChangedCallback(e, n, r) {
        this._$AK(e, r)
    }
    _$EC(e, n) {
        var s;
        const r = this.constructor.elementProperties.get(e),
            i = this.constructor._$Eu(e, r);
        if (i !== void 0 && r.reflect === !0) {
            const o = (((s = r.converter) == null ? void 0 : s.toAttribute) !== void 0 ? r.converter : K8).toAttribute(n, r.type);
            this._$Em = e, o == null ? this.removeAttribute(i) : this.setAttribute(i, o), this._$Em = null
        }
    }
    _$AK(e, n) {
        var s;
        const r = this.constructor,
            i = r._$Eh.get(e);
        if (i !== void 0 && this._$Em !== i) {
            const o = r.getPropertyOptions(i),
                a = typeof o.converter == "function" ? {
                    fromAttribute: o.converter
                } : ((s = o.converter) == null ? void 0 : s.fromAttribute) !== void 0 ? o.converter : K8;
            this._$Em = i, this[i] = a.fromAttribute(n, o.type), this._$Em = null
        }
    }
    requestUpdate(e, n, r) {
        if (e !== void 0) {
            if (r ? ? (r = this.constructor.getPropertyOptions(e)), !(r.hasChanged ? ? C$)(this[e], n)) return;
            this.P(e, n, r)
        }
        this.isUpdatePending === !1 && (this._$ES = this._$ET())
    }
    P(e, n, r) {
        this._$AL.has(e) || this._$AL.set(e, n), r.reflect === !0 && this._$Em !== e && (this._$Ej ? ? (this._$Ej = new Set)).add(e)
    }
    async _$ET() {
        this.isUpdatePending = !0;
        try {
            await this._$ES
        } catch (n) {
            Promise.reject(n)
        }
        const e = this.scheduleUpdate();
        return e != null && await e, !this.isUpdatePending
    }
    scheduleUpdate() {
        return this.performUpdate()
    }
    performUpdate() {
        var r;
        if (!this.isUpdatePending) return;
        if (!this.hasUpdated) {
            if (this.renderRoot ? ? (this.renderRoot = this.createRenderRoot()), this._$Ep) {
                for (const [s, o] of this._$Ep) this[s] = o;
                this._$Ep = void 0
            }
            const i = this.constructor.elementProperties;
            if (i.size > 0)
                for (const [s, o] of i) o.wrapped !== !0 || this._$AL.has(s) || this[s] === void 0 || this.P(s, this[s], o)
        }
        let e = !1;
        const n = this._$AL;
        try {
            e = this.shouldUpdate(n), e ? (this.willUpdate(n), (r = this._$EO) == null || r.forEach(i => {
                var s;
                return (s = i.hostUpdate) == null ? void 0 : s.call(i)
            }), this.update(n)) : this._$EU()
        } catch (i) {
            throw e = !1, this._$EU(), i
        }
        e && this._$AE(n)
    }
    willUpdate(e) {}
    _$AE(e) {
        var n;
        (n = this._$EO) == null || n.forEach(r => {
            var i;
            return (i = r.hostUpdated) == null ? void 0 : i.call(r)
        }), this.hasUpdated || (this.hasUpdated = !0, this.firstUpdated(e)), this.updated(e)
    }
    _$EU() {
        this._$AL = new Map, this.isUpdatePending = !1
    }
    get updateComplete() {
        return this.getUpdateComplete()
    }
    getUpdateComplete() {
        return this._$ES
    }
    shouldUpdate(e) {
        return !0
    }
    update(e) {
        this._$Ej && (this._$Ej = this._$Ej.forEach(n => this._$EC(n, this[n]))), this._$EU()
    }
    updated(e) {}
    firstUpdated(e) {}
};
yw.elementStyles = [], yw.shadowRootOptions = {
    mode: "open"
}, yw[D3("elementProperties")] = new Map, yw[D3("finalized")] = new Map, IR == null || IR({
    ReactiveElement: yw
}), (wp.reactiveElementVersions ? ? (wp.reactiveElementVersions = [])).push("2.0.4");
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const $3 = globalThis,
    Y8 = $3.trustedTypes,
    Nz = Y8 ? Y8.createPolicy("lit-html", {
        createHTML: t => t
    }) : void 0,
    nee = "$lit$",
    O0 = `lit$${Math.random().toFixed(9).slice(2)}$`,
    ree = "?" + O0,
    Vve = `<${ree}>`,
    fm = document,
    p_ = () => fm.createComment(""),
    g_ = t => t === null || typeof t != "object" && typeof t != "function",
    A$ = Array.isArray,
    Gve = t => A$(t) || typeof(t == null ? void 0 : t[Symbol.iterator]) == "function",
    RR = `[ 	
\f\r]`,
    P5 = /<(?:(!--|\/[^a-zA-Z])|(\/?[a-zA-Z][^>\s]*)|(\/?$))/g,
    Pz = /-->/g,
    kz = />/g,
    Pg = RegExp(`>|${RR}(?:([^\\s"'>=/]+)(${RR}*=${RR}*(?:[^ 	
\f\r"'\`<>=]|("|')|))|$)`, "g"),
    Mz = /'/g,
    Dz = /"/g,
    iee = /^(?:script|style|textarea|title)$/i,
    see = t => (e, ...n) => ({
        _$litType$: t,
        strings: e,
        values: n
    }),
    We = see(1),
    pt = see(2),
    dm = Symbol.for("lit-noChange"),
    os = Symbol.for("lit-nothing"),
    $z = new WeakMap,
    s1 = fm.createTreeWalker(fm, 129);

function oee(t, e) {
    if (!A$(t) || !t.hasOwnProperty("raw")) throw Error("invalid template strings array");
    return Nz !== void 0 ? Nz.createHTML(e) : e
}
const qve = (t, e) => {
    const n = t.length - 1,
        r = [];
    let i, s = e === 2 ? "<svg>" : e === 3 ? "<math>" : "",
        o = P5;
    for (let a = 0; a < n; a++) {
        const l = t[a];
        let c, u, f = -1,
            h = 0;
        for (; h < l.length && (o.lastIndex = h, u = o.exec(l), u !== null);) h = o.lastIndex, o === P5 ? u[1] === "!--" ? o = Pz : u[1] !== void 0 ? o = kz : u[2] !== void 0 ? (iee.test(u[2]) && (i = RegExp("</" + u[2], "g")), o = Pg) : u[3] !== void 0 && (o = Pg) : o === Pg ? u[0] === ">" ? (o = i ? ? P5, f = -1) : u[1] === void 0 ? f = -2 : (f = o.lastIndex - u[2].length, c = u[1], o = u[3] === void 0 ? Pg : u[3] === '"' ? Dz : Mz) : o === Dz || o === Mz ? o = Pg : o === Pz || o === kz ? o = P5 : (o = Pg, i = void 0);
        const g = o === Pg && t[a + 1].startsWith("/>") ? " " : "";
        s += o === P5 ? l + Vve : f >= 0 ? (r.push(c), l.slice(0, f) + nee + l.slice(f) + O0 + g) : l + O0 + (f === -2 ? a : g)
    }
    return [oee(t, s + (t[n] || "<?>") + (e === 2 ? "</svg>" : e === 3 ? "</math>" : "")), r]
};
let MP = class aee {
    constructor({
        strings: e,
        _$litType$: n
    }, r) {
        let i;
        this.parts = [];
        let s = 0,
            o = 0;
        const a = e.length - 1,
            l = this.parts,
            [c, u] = qve(e, n);
        if (this.el = aee.createElement(c, r), s1.currentNode = this.el.content, n === 2 || n === 3) {
            const f = this.el.content.firstChild;
            f.replaceWith(...f.childNodes)
        }
        for (;
            (i = s1.nextNode()) !== null && l.length < a;) {
            if (i.nodeType === 1) {
                if (i.hasAttributes())
                    for (const f of i.getAttributeNames())
                        if (f.endsWith(nee)) {
                            const h = u[o++],
                                g = i.getAttribute(f).split(O0),
                                y = /([.?@])?(.*)/.exec(h);
                            l.push({
                                type: 1,
                                index: s,
                                name: y[2],
                                strings: g,
                                ctor: y[1] === "." ? Yve : y[1] === "?" ? Zve : y[1] === "@" ? Qve : fT
                            }), i.removeAttribute(f)
                        } else f.startsWith(O0) && (l.push({
                            type: 6,
                            index: s
                        }), i.removeAttribute(f));
                if (iee.test(i.tagName)) {
                    const f = i.textContent.split(O0),
                        h = f.length - 1;
                    if (h > 0) {
                        i.textContent = Y8 ? Y8.emptyScript : "";
                        for (let g = 0; g < h; g++) i.append(f[g], p_()), s1.nextNode(), l.push({
                            type: 2,
                            index: ++s
                        });
                        i.append(f[h], p_())
                    }
                }
            } else if (i.nodeType === 8)
                if (i.data === ree) l.push({
                    type: 2,
                    index: s
                });
                else {
                    let f = -1;
                    for (;
                        (f = i.data.indexOf(O0, f + 1)) !== -1;) l.push({
                        type: 7,
                        index: s
                    }), f += O0.length - 1
                }
            s++
        }
    }
    static createElement(e, n) {
        const r = fm.createElement("template");
        return r.innerHTML = e, r
    }
};

function Cb(t, e, n = t, r) {
    var o, a;
    if (e === dm) return e;
    let i = r !== void 0 ? (o = n.o) == null ? void 0 : o[r] : n.l;
    const s = g_(e) ? void 0 : e._$litDirective$;
    return (i == null ? void 0 : i.constructor) !== s && ((a = i == null ? void 0 : i._$AO) == null || a.call(i, !1), s === void 0 ? i = void 0 : (i = new s(t), i._$AT(t, n, r)), r !== void 0 ? (n.o ? ? (n.o = []))[r] = i : n.l = i), i !== void 0 && (e = Cb(t, i._$AS(t, e.values), i, r)), e
}
let Kve = class {
        constructor(e, n) {
            this._$AV = [], this._$AN = void 0, this._$AD = e, this._$AM = n
        }
        get parentNode() {
            return this._$AM.parentNode
        }
        get _$AU() {
            return this._$AM._$AU
        }
        u(e) {
            const {
                el: {
                    content: n
                },
                parts: r
            } = this._$AD, i = ((e == null ? void 0 : e.creationScope) ? ? fm).importNode(n, !0);
            s1.currentNode = i;
            let s = s1.nextNode(),
                o = 0,
                a = 0,
                l = r[0];
            for (; l !== void 0;) {
                if (o === l.index) {
                    let c;
                    l.type === 2 ? c = new T$(s, s.nextSibling, this, e) : l.type === 1 ? c = new l.ctor(s, l.name, l.strings, this, e) : l.type === 6 && (c = new Jve(s, this, e)), this._$AV.push(c), l = r[++a]
                }
                o !== (l == null ? void 0 : l.index) && (s = s1.nextNode(), o++)
            }
            return s1.currentNode = fm, i
        }
        p(e) {
            let n = 0;
            for (const r of this._$AV) r !== void 0 && (r.strings !== void 0 ? (r._$AI(e, r, n), n += r.strings.length - 2) : r._$AI(e[n])), n++
        }
    },
    T$ = class lee {
        get _$AU() {
            var e;
            return ((e = this._$AM) == null ? void 0 : e._$AU) ? ? this.v
        }
        constructor(e, n, r, i) {
            this.type = 2, this._$AH = os, this._$AN = void 0, this._$AA = e, this._$AB = n, this._$AM = r, this.options = i, this.v = (i == null ? void 0 : i.isConnected) ? ? !0
        }
        get parentNode() {
            let e = this._$AA.parentNode;
            const n = this._$AM;
            return n !== void 0 && (e == null ? void 0 : e.nodeType) === 11 && (e = n.parentNode), e
        }
        get startNode() {
            return this._$AA
        }
        get endNode() {
            return this._$AB
        }
        _$AI(e, n = this) {
            e = Cb(this, e, n), g_(e) ? e === os || e == null || e === "" ? (this._$AH !== os && this._$AR(), this._$AH = os) : e !== this._$AH && e !== dm && this._(e) : e._$litType$ !== void 0 ? this.$(e) : e.nodeType !== void 0 ? this.T(e) : Gve(e) ? this.k(e) : this._(e)
        }
        O(e) {
            return this._$AA.parentNode.insertBefore(e, this._$AB)
        }
        T(e) {
            this._$AH !== e && (this._$AR(), this._$AH = this.O(e))
        }
        _(e) {
            this._$AH !== os && g_(this._$AH) ? this._$AA.nextSibling.data = e : this.T(fm.createTextNode(e)), this._$AH = e
        }
        $(e) {
            var s;
            const {
                values: n,
                _$litType$: r
            } = e, i = typeof r == "number" ? this._$AC(e) : (r.el === void 0 && (r.el = MP.createElement(oee(r.h, r.h[0]), this.options)), r);
            if (((s = this._$AH) == null ? void 0 : s._$AD) === i) this._$AH.p(n);
            else {
                const o = new Kve(i, this),
                    a = o.u(this.options);
                o.p(n), this.T(a), this._$AH = o
            }
        }
        _$AC(e) {
            let n = $z.get(e.strings);
            return n === void 0 && $z.set(e.strings, n = new MP(e)), n
        }
        k(e) {
            A$(this._$AH) || (this._$AH = [], this._$AR());
            const n = this._$AH;
            let r, i = 0;
            for (const s of e) i === n.length ? n.push(r = new lee(this.O(p_()), this.O(p_()), this, this.options)) : r = n[i], r._$AI(s), i++;
            i < n.length && (this._$AR(r && r._$AB.nextSibling, i), n.length = i)
        }
        _$AR(e = this._$AA.nextSibling, n) {
            var r;
            for ((r = this._$AP) == null ? void 0 : r.call(this, !1, !0, n); e && e !== this._$AB;) {
                const i = e.nextSibling;
                e.remove(), e = i
            }
        }
        setConnected(e) {
            var n;
            this._$AM === void 0 && (this.v = e, (n = this._$AP) == null || n.call(this, e))
        }
    },
    fT = class {
        get tagName() {
            return this.element.tagName
        }
        get _$AU() {
            return this._$AM._$AU
        }
        constructor(e, n, r, i, s) {
            this.type = 1, this._$AH = os, this._$AN = void 0, this.element = e, this.name = n, this._$AM = i, this.options = s, r.length > 2 || r[0] !== "" || r[1] !== "" ? (this._$AH = Array(r.length - 1).fill(new String), this.strings = r) : this._$AH = os
        }
        _$AI(e, n = this, r, i) {
            const s = this.strings;
            let o = !1;
            if (s === void 0) e = Cb(this, e, n, 0), o = !g_(e) || e !== this._$AH && e !== dm, o && (this._$AH = e);
            else {
                const a = e;
                let l, c;
                for (e = s[0], l = 0; l < s.length - 1; l++) c = Cb(this, a[r + l], n, l), c === dm && (c = this._$AH[l]), o || (o = !g_(c) || c !== this._$AH[l]), c === os ? e = os : e !== os && (e += (c ? ? "") + s[l + 1]), this._$AH[l] = c
            }
            o && !i && this.j(e)
        }
        j(e) {
            e === os ? this.element.removeAttribute(this.name) : this.element.setAttribute(this.name, e ? ? "")
        }
    },
    Yve = class extends fT {
        constructor() {
            super(...arguments), this.type = 3
        }
        j(e) {
            this.element[this.name] = e === os ? void 0 : e
        }
    },
    Zve = class extends fT {
        constructor() {
            super(...arguments), this.type = 4
        }
        j(e) {
            this.element.toggleAttribute(this.name, !!e && e !== os)
        }
    },
    Qve = class extends fT {
        constructor(e, n, r, i, s) {
            super(e, n, r, i, s), this.type = 5
        }
        _$AI(e, n = this) {
            if ((e = Cb(this, e, n, 0) ? ? os) === dm) return;
            const r = this._$AH,
                i = e === os && r !== os || e.capture !== r.capture || e.once !== r.once || e.passive !== r.passive,
                s = e !== os && (r === os || i);
            i && this.element.removeEventListener(this.name, this, r), s && this.element.addEventListener(this.name, this, e), this._$AH = e
        }
        handleEvent(e) {
            var n;
            typeof this._$AH == "function" ? this._$AH.call(((n = this.options) == null ? void 0 : n.host) ? ? this.element, e) : this._$AH.handleEvent(e)
        }
    },
    Jve = class {
        constructor(e, n, r) {
            this.element = e, this.type = 6, this._$AN = void 0, this._$AM = n, this.options = r
        }
        get _$AU() {
            return this._$AM._$AU
        }
        _$AI(e) {
            Cb(this, e)
        }
    };
const OR = $3.litHtmlPolyfillSupport;
OR == null || OR(MP, T$), ($3.litHtmlVersions ? ? ($3.litHtmlVersions = [])).push("3.2.0");
const Xve = (t, e, n) => {
    const r = (n == null ? void 0 : n.renderBefore) ? ? e;
    let i = r._$litPart$;
    if (i === void 0) {
        const s = (n == null ? void 0 : n.renderBefore) ? ? null;
        r._$litPart$ = i = new T$(e.insertBefore(p_(), s), s, void 0, n ? ? {})
    }
    return i._$AI(t), i
};
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
let Zt = class extends yw {
    constructor() {
        super(...arguments), this.renderOptions = {
            host: this
        }, this.o = void 0
    }
    createRenderRoot() {
        var n;
        const e = super.createRenderRoot();
        return (n = this.renderOptions).renderBefore ? ? (n.renderBefore = e.firstChild), e
    }
    update(e) {
        const n = this.render();
        this.hasUpdated || (this.renderOptions.isConnected = this.isConnected), super.update(e), this.o = Xve(n, this.renderRoot, this.renderOptions)
    }
    connectedCallback() {
        var e;
        super.connectedCallback(), (e = this.o) == null || e.setConnected(!0)
    }
    disconnectedCallback() {
        var e;
        super.disconnectedCallback(), (e = this.o) == null || e.setConnected(!1)
    }
    render() {
        return dm
    }
};
var EX;
Zt._$litElement$ = !0, Zt.finalized = !0, (EX = globalThis.litElementHydrateSupport) == null || EX.call(globalThis, {
    LitElement: Zt
});
const NR = globalThis.litElementPolyfillSupport;
NR == null || NR({
    LitElement: Zt
});
(globalThis.litElementVersions ? ? (globalThis.litElementVersions = [])).push("4.1.0");
let L3, vp, bp;

function cee(t, e) {
    L3 = document.createElement("style"), vp = document.createElement("style"), bp = document.createElement("style"), L3.textContent = Jw(t).core.cssText, vp.textContent = Jw(t).dark.cssText, bp.textContent = Jw(t).light.cssText, document.head.appendChild(L3), document.head.appendChild(vp), document.head.appendChild(bp), I$(e)
}

function I$(t) {
    vp && bp && (t === "light" ? (vp.removeAttribute("media"), bp.media = "enabled") : (bp.removeAttribute("media"), vp.media = "enabled"))
}

function uee(t) {
    L3 && vp && bp && (L3.textContent = Jw(t).core.cssText, vp.textContent = Jw(t).dark.cssText, bp.textContent = Jw(t).light.cssText)
}

function Jw(t) {
    return {
        core: Wt `
      @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap');
      :root {
        --w3m-color-mix-strength: ${ff(t!=null&&t["--w3m-color-mix-strength"]?`${t["--w3m-color-mix-strength"]}%`:"0%")};
        --w3m-font-family: ${ff((t==null?void 0:t["--w3m-font-family"])||"Inter, Segoe UI, Roboto, Oxygen, Ubuntu, Cantarell, Fira Sans, Droid Sans, Helvetica Neue, sans-serif;")};
        --w3m-font-size-master: ${ff((t==null?void 0:t["--w3m-font-size-master"])||"10px")};
        --w3m-border-radius-master: ${ff((t==null?void 0:t["--w3m-border-radius-master"])||"4px")};
        --w3m-z-index: ${ff((t==null?void 0:t["--w3m-z-index"])||100)};

        --wui-font-family: var(--w3m-font-family);

        --wui-font-size-micro: var(--w3m-font-size-master);
        --wui-font-size-tiny: calc(var(--w3m-font-size-master) * 1.2);
        --wui-font-size-small: calc(var(--w3m-font-size-master) * 1.4);
        --wui-font-size-paragraph: calc(var(--w3m-font-size-master) * 1.6);
        --wui-font-size-large: calc(var(--w3m-font-size-master) * 2);

        --wui-border-radius-5xs: var(--w3m-border-radius-master);
        --wui-border-radius-4xs: calc(var(--w3m-border-radius-master) * 1.5);
        --wui-border-radius-3xs: calc(var(--w3m-border-radius-master) * 2);
        --wui-border-radius-xxs: calc(var(--w3m-border-radius-master) * 3);
        --wui-border-radius-xs: calc(var(--w3m-border-radius-master) * 4);
        --wui-border-radius-s: calc(var(--w3m-border-radius-master) * 5);
        --wui-border-radius-m: calc(var(--w3m-border-radius-master) * 7);
        --wui-border-radius-l: calc(var(--w3m-border-radius-master) * 9);
        --wui-border-radius-3xl: calc(var(--w3m-border-radius-master) * 20);

        --wui-font-weight-light: 400;
        --wui-font-weight-regular: 500;
        --wui-font-weight-medium: 600;
        --wui-font-weight-bold: 700;

        --wui-letter-spacing-large: -0.8px;
        --wui-letter-spacing-paragraph: -0.64px;
        --wui-letter-spacing-small: -0.56px;
        --wui-letter-spacing-tiny: -0.48px;
        --wui-letter-spacing-micro: -0.2px;

        --wui-spacing-0: 0px;
        --wui-spacing-4xs: 2px;
        --wui-spacing-3xs: 4px;
        --wui-spacing-xxs: 6px;
        --wui-spacing-2xs: 7px;
        --wui-spacing-xs: 8px;
        --wui-spacing-1xs: 10px;
        --wui-spacing-s: 12px;
        --wui-spacing-m: 14px;
        --wui-spacing-l: 16px;
        --wui-spacing-2l: 18px;
        --wui-spacing-xl: 20px;
        --wui-spacing-xxl: 24px;
        --wui-spacing-2xl: 32px;
        --wui-spacing-3xl: 40px;
        --wui-spacing-4xl: 90px;

        --wui-icon-box-size-xxs: 14px;
        --wui-icon-box-size-xs: 20px;
        --wui-icon-box-size-sm: 24px;
        --wui-icon-box-size-md: 32px;
        --wui-icon-box-size-lg: 40px;
        --wui-icon-box-size-xl: 64px;

        --wui-icon-size-inherit: inherit;
        --wui-icon-size-xxs: 10px;
        --wui-icon-size-xs: 12px;
        --wui-icon-size-sm: 14px;
        --wui-icon-size-md: 16px;
        --wui-icon-size-mdl: 18px;
        --wui-icon-size-lg: 20px;
        --wui-icon-size-xl: 24px;

        --wui-wallet-image-size-inherit: inherit;
        --wui-wallet-image-size-sm: 40px;
        --wui-wallet-image-size-md: 56px;
        --wui-wallet-image-size-lg: 80px;

        --wui-box-size-md: 100px;
        --wui-box-size-lg: 120px;

        --wui-ease-out-power-2: cubic-bezier(0, 0, 0.22, 1);
        --wui-ease-out-power-1: cubic-bezier(0, 0, 0.55, 1);

        --wui-ease-in-power-3: cubic-bezier(0.66, 0, 1, 1);
        --wui-ease-in-power-2: cubic-bezier(0.45, 0, 1, 1);
        --wui-ease-in-power-1: cubic-bezier(0.3, 0, 1, 1);

        --wui-ease-inout-power-1: cubic-bezier(0.45, 0, 0.55, 1);

        --wui-duration-lg: 200ms;
        --wui-duration-md: 125ms;
        --wui-duration-sm: 75ms;

        --wui-path-network: path(
          'M43.4605 10.7248L28.0485 1.61089C25.5438 0.129705 22.4562 0.129705 19.9515 1.61088L4.53951 10.7248C2.03626 12.2051 0.5 14.9365 0.5 17.886V36.1139C0.5 39.0635 2.03626 41.7949 4.53951 43.2752L19.9515 52.3891C22.4562 53.8703 25.5438 53.8703 28.0485 52.3891L43.4605 43.2752C45.9637 41.7949 47.5 39.0635 47.5 36.114V17.8861C47.5 14.9365 45.9637 12.2051 43.4605 10.7248Z'
        );

        --wui-path-network-lg: path(
          'M78.3244 18.926L50.1808 2.45078C45.7376 -0.150261 40.2624 -0.150262 35.8192 2.45078L7.6756 18.926C3.23322 21.5266 0.5 26.3301 0.5 31.5248V64.4752C0.5 69.6699 3.23322 74.4734 7.6756 77.074L35.8192 93.5492C40.2624 96.1503 45.7376 96.1503 50.1808 93.5492L78.3244 77.074C82.7668 74.4734 85.5 69.6699 85.5 64.4752V31.5248C85.5 26.3301 82.7668 21.5266 78.3244 18.926Z'
        );

        --wui-color-inherit: inherit;

        --wui-color-inverse-100: #fff;
        --wui-color-inverse-000: #000;

        --wui-cover: rgba(20, 20, 20, 0.8);

        --wui-color-modal-bg: var(--wui-color-modal-bg-base);

        --wui-color-blue-100: var(--wui-color-blue-base-100);

        --wui-color-accent-100: var(--wui-color-accent-base-100);
        --wui-color-accent-090: var(--wui-color-accent-base-090);
        --wui-color-accent-080: var(--wui-color-accent-base-080);

        --wui-accent-glass-090: var(--wui-accent-glass-base-090);
        --wui-accent-glass-080: var(--wui-accent-glass-base-080);
        --wui-accent-glass-020: var(--wui-accent-glass-base-020);
        --wui-accent-glass-015: var(--wui-accent-glass-base-015);
        --wui-accent-glass-010: var(--wui-accent-glass-base-010);
        --wui-accent-glass-005: var(--wui-accent-glass-base-005);
        --wui-accent-glass-002: var(--wui-accent-glass-base-002);

        --wui-color-fg-100: var(--wui-color-fg-base-100);
        --wui-color-fg-125: var(--wui-color-fg-base-125);
        --wui-color-fg-150: var(--wui-color-fg-base-150);
        --wui-color-fg-175: var(--wui-color-fg-base-175);
        --wui-color-fg-200: var(--wui-color-fg-base-200);
        --wui-color-fg-225: var(--wui-color-fg-base-225);
        --wui-color-fg-250: var(--wui-color-fg-base-250);
        --wui-color-fg-275: var(--wui-color-fg-base-275);
        --wui-color-fg-300: var(--wui-color-fg-base-300);

        --wui-color-bg-100: var(--wui-color-bg-base-100);
        --wui-color-bg-125: var(--wui-color-bg-base-125);
        --wui-color-bg-150: var(--wui-color-bg-base-150);
        --wui-color-bg-175: var(--wui-color-bg-base-175);
        --wui-color-bg-200: var(--wui-color-bg-base-200);
        --wui-color-bg-225: var(--wui-color-bg-base-225);
        --wui-color-bg-250: var(--wui-color-bg-base-250);
        --wui-color-bg-275: var(--wui-color-bg-base-275);
        --wui-color-bg-300: var(--wui-color-bg-base-300);

        --wui-color-success-100: var(--wui-color-success-base-100);
        --wui-color-error-100: var(--wui-color-error-base-100);

        --wui-icon-box-bg-error-100: var(--wui-icon-box-bg-error-base-100);
        --wui-icon-box-bg-blue-100: var(--wui-icon-box-bg-blue-base-100);
        --wui-icon-box-bg-success-100: var(--wui-icon-box-bg-success-base-100);
        --wui-icon-box-bg-inverse-100: var(--wui-icon-box-bg-inverse-base-100);

        --wui-all-wallets-bg-100: var(--wui-all-wallets-bg-base-100);

        --wui-avatar-border: var(--wui-avatar-border-base);

        --wui-thumbnail-border: var(--wui-thumbnail-border-base);

        --wui-box-shadow-blue: rgba(71, 161, 255, 0.16);
      }

      @supports (background: color-mix(in srgb, white 50%, black)) {
        :root {
          --wui-color-modal-bg: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-modal-bg-base)
          );

          --wui-box-shadow-blue: color-mix(in srgb, var(--wui-color-accent-100) 16%, transparent);

          --wui-color-accent-090: color-mix(
            in srgb,
            var(--wui-color-accent-base-100) 90%,
            var(--w3m-default)
          );
          --wui-color-accent-080: color-mix(
            in srgb,
            var(--wui-color-accent-base-100) 80%,
            var(--w3m-default)
          );

          --wui-color-accent-090: color-mix(
            in srgb,
            var(--wui-color-accent-base-100) 90%,
            transparent
          );
          --wui-color-accent-080: color-mix(
            in srgb,
            var(--wui-color-accent-base-100) 80%,
            transparent
          );

          --wui-accent-glass-090: color-mix(
            in srgb,
            var(--wui-color-accent-base-100) 90%,
            transparent
          );
          --wui-accent-glass-080: color-mix(
            in srgb,
            var(--wui-color-accent-base-100) 80%,
            transparent
          );
          --wui-accent-glass-020: color-mix(
            in srgb,
            var(--wui-color-accent-base-100) 20%,
            transparent
          );
          --wui-accent-glass-015: color-mix(
            in srgb,
            var(--wui-color-accent-base-100) 15%,
            transparent
          );
          --wui-accent-glass-010: color-mix(
            in srgb,
            var(--wui-color-accent-base-100) 10%,
            transparent
          );
          --wui-accent-glass-005: color-mix(
            in srgb,
            var(--wui-color-accent-base-100) 5%,
            transparent
          );
          --wui-color-accent-002: color-mix(
            in srgb,
            var(--wui-color-accent-base-100) 2%,
            transparent
          );

          --wui-color-fg-100: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-fg-base-100)
          );
          --wui-color-fg-125: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-fg-base-125)
          );
          --wui-color-fg-150: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-fg-base-150)
          );
          --wui-color-fg-175: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-fg-base-175)
          );
          --wui-color-fg-200: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-fg-base-200)
          );
          --wui-color-fg-225: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-fg-base-225)
          );
          --wui-color-fg-250: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-fg-base-250)
          );
          --wui-color-fg-275: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-fg-base-275)
          );
          --wui-color-fg-300: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-fg-base-300)
          );

          --wui-color-bg-100: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-bg-base-100)
          );
          --wui-color-bg-125: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-bg-base-125)
          );
          --wui-color-bg-150: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-bg-base-150)
          );
          --wui-color-bg-175: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-bg-base-175)
          );
          --wui-color-bg-200: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-bg-base-200)
          );
          --wui-color-bg-225: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-bg-base-225)
          );
          --wui-color-bg-250: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-bg-base-250)
          );
          --wui-color-bg-275: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-bg-base-275)
          );
          --wui-color-bg-300: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-bg-base-300)
          );

          --wui-color-success-100: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-success-base-100)
          );
          --wui-color-error-100: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-error-base-100)
          );

          --wui-icon-box-bg-error-100: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-icon-box-bg-error-base-100)
          );
          --wui-icon-box-bg-accent-100: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-icon-box-bg-blue-base-100)
          );
          --wui-icon-box-bg-success-100: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-icon-box-bg-success-base-100)
          );
          --wui-icon-box-bg-inverse-100: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-icon-box-bg-inverse-base-100)
          );

          --wui-all-wallets-bg-100: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-all-wallets-bg-base-100)
          );

          --wui-avatar-border: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-avatar-border-base)
          );

          --wui-thumbnail-border: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-thumbnail-border-base)
          );
        }
      }
    `,
        light: Wt `
      :root {
        --w3m-color-mix: ${ff((t==null?void 0:t["--w3m-color-mix"])||"#fff")};
        --w3m-accent: ${ff((t==null?void 0:t["--w3m-accent"])||"#47a1ff")};
        --w3m-default: #fff;

        --wui-color-modal-bg-base: #191a1a;

        --wui-color-blue-base-100: #47a1ff;

        --wui-color-accent-base-100: var(--w3m-accent);
        --wui-color-accent-base-090: #59aaff;
        --wui-color-accent-base-080: #6cb4ff;

        --wui-accent-glass-base-090: rgba(71, 161, 255, 0.9);
        --wui-accent-glass-base-080: rgba(71, 161, 255, 0.8);
        --wui-accent-glass-base-020: rgba(71, 161, 255, 0.2);
        --wui-accent-glass-base-015: rgba(71, 161, 255, 0.15);
        --wui-accent-glass-base-010: rgba(71, 161, 255, 0.1);
        --wui-accent-glass-base-005: rgba(71, 161, 255, 0.05);
        --wui-accent-glass-base-002: rgba(71, 161, 255, 0.02);

        --wui-color-fg-base-100: #e4e7e7;
        --wui-color-fg-base-125: #d0d5d5;
        --wui-color-fg-base-150: #a8b1b1;
        --wui-color-fg-base-175: #a8b0b0;
        --wui-color-fg-base-200: #949e9e;
        --wui-color-fg-base-225: #868f8f;
        --wui-color-fg-base-250: #788080;
        --wui-color-fg-base-275: #788181;
        --wui-color-fg-base-300: #6e7777;

        --wui-color-bg-base-100: #141414;
        --wui-color-bg-base-125: #191a1a;
        --wui-color-bg-base-150: #1e1f1f;
        --wui-color-bg-base-175: #222525;
        --wui-color-bg-base-200: #272a2a;
        --wui-color-bg-base-225: #2c3030;
        --wui-color-bg-base-250: #313535;
        --wui-color-bg-base-275: #363b3b;
        --wui-color-bg-base-300: #3b4040;

        --wui-color-success-base-100: #26d962;
        --wui-color-error-base-100: #f25a67;

        --wui-success-glass-001: rgba(38, 217, 98, 0.01);
        --wui-success-glass-002: rgba(38, 217, 98, 0.02);
        --wui-success-glass-005: rgba(38, 217, 98, 0.05);
        --wui-success-glass-010: rgba(38, 217, 98, 0.1);
        --wui-success-glass-015: rgba(38, 217, 98, 0.15);
        --wui-success-glass-020: rgba(38, 217, 98, 0.2);
        --wui-success-glass-025: rgba(38, 217, 98, 0.25);
        --wui-success-glass-030: rgba(38, 217, 98, 0.3);
        --wui-success-glass-060: rgba(38, 217, 98, 0.6);
        --wui-success-glass-080: rgba(38, 217, 98, 0.8);

        --wui-icon-box-bg-error-base-100: #3c2426;
        --wui-icon-box-bg-blue-base-100: #20303f;
        --wui-icon-box-bg-success-base-100: var(--wui-success-glass-015);
        --wui-icon-box-bg-inverse-base-100: #243240;

        --wui-all-wallets-bg-base-100: #222b35;

        --wui-avatar-border-base: #252525;

        --wui-thumbnail-border-base: #252525;

        --wui-gray-glass-001: rgba(255, 255, 255, 0.01);
        --wui-gray-glass-002: rgba(255, 255, 255, 0.02);
        --wui-gray-glass-005: rgba(255, 255, 255, 0.05);
        --wui-gray-glass-010: rgba(255, 255, 255, 0.1);
        --wui-gray-glass-015: rgba(255, 255, 255, 0.15);
        --wui-gray-glass-020: rgba(255, 255, 255, 0.2);
        --wui-gray-glass-025: rgba(255, 255, 255, 0.25);
        --wui-gray-glass-030: rgba(255, 255, 255, 0.3);
        --wui-gray-glass-060: rgba(255, 255, 255, 0.6);
        --wui-gray-glass-080: rgba(255, 255, 255, 0.8);
      }
    `,
        dark: Wt `
      :root {
        --w3m-color-mix: ${ff((t==null?void 0:t["--w3m-color-mix"])||"#000")};
        --w3m-accent: ${ff((t==null?void 0:t["--w3m-accent"])||"#3396ff")};
        --w3m-default: #000;

        --wui-color-modal-bg-base: #fff;

        --wui-color-blue-base-100: #3396ff;

        --wui-color-accent-base-100: var(--w3m-accent);
        --wui-color-accent-base-090: #2d7dd2;
        --wui-color-accent-base-080: #2978cc;

        --wui-accent-glass-base-090: rgba(51, 150, 255, 0.9);
        --wui-accent-glass-base-080: rgba(51, 150, 255, 0.8);
        --wui-accent-glass-base-020: rgba(51, 150, 255, 0.2);
        --wui-accent-glass-base-015: rgba(51, 150, 255, 0.15);
        --wui-accent-glass-base-010: rgba(51, 150, 255, 0.1);
        --wui-accent-glass-base-005: rgba(51, 150, 255, 0.05);
        --wui-accent-glass-base-002: rgba(51, 150, 255, 0.02);

        --wui-color-fg-base-100: #141414;
        --wui-color-fg-base-125: #2d3131;
        --wui-color-fg-base-150: #474d4d;
        --wui-color-fg-base-175: #636d6d;
        --wui-color-fg-base-200: #798686;
        --wui-color-fg-base-225: #828f8f;
        --wui-color-fg-base-250: #8b9797;
        --wui-color-fg-base-275: #95a0a0;
        --wui-color-fg-base-300: #9ea9a9;

        --wui-color-bg-base-100: #ffffff;
        --wui-color-bg-base-125: #f5fafa;
        --wui-color-bg-base-150: #f3f8f8;
        --wui-color-bg-base-175: #eef4f4;
        --wui-color-bg-base-200: #eaf1f1;
        --wui-color-bg-base-225: #e5eded;
        --wui-color-bg-base-250: #e1e9e9;
        --wui-color-bg-base-275: #dce7e7;
        --wui-color-bg-base-300: #d8e3e3;

        --wui-color-success-base-100: #26b562;
        --wui-color-error-base-100: #f05142;

        --wui-success-glass-001: rgba(38, 181, 98, 0.01);
        --wui-success-glass-002: rgba(38, 181, 98, 0.02);
        --wui-success-glass-005: rgba(38, 181, 98, 0.05);
        --wui-success-glass-010: rgba(38, 181, 98, 0.1);
        --wui-success-glass-015: rgba(38, 181, 98, 0.15);
        --wui-success-glass-020: rgba(38, 181, 98, 0.2);
        --wui-success-glass-025: rgba(38, 181, 98, 0.25);
        --wui-success-glass-030: rgba(38, 181, 98, 0.3);
        --wui-success-glass-060: rgba(38, 181, 98, 0.6);
        --wui-success-glass-080: rgba(38, 181, 98, 0.8);

        --wui-icon-box-bg-error-base-100: #f4dfdd;
        --wui-icon-box-bg-blue-base-100: #d9ecfb;
        --wui-icon-box-bg-success-base-100: #daf0e4;
        --wui-icon-box-bg-inverse-base-100: #dcecfc;

        --wui-all-wallets-bg-base-100: #e8f1fa;

        --wui-avatar-border-base: #f3f4f4;

        --wui-thumbnail-border-base: #eaefef;

        --wui-gray-glass-001: rgba(0, 0, 0, 0.01);
        --wui-gray-glass-002: rgba(0, 0, 0, 0.02);
        --wui-gray-glass-005: rgba(0, 0, 0, 0.05);
        --wui-gray-glass-010: rgba(0, 0, 0, 0.1);
        --wui-gray-glass-015: rgba(0, 0, 0, 0.15);
        --wui-gray-glass-020: rgba(0, 0, 0, 0.2);
        --wui-gray-glass-025: rgba(0, 0, 0, 0.25);
        --wui-gray-glass-030: rgba(0, 0, 0, 0.3);
        --wui-gray-glass-060: rgba(0, 0, 0, 0.6);
        --wui-gray-glass-080: rgba(0, 0, 0, 0.8);
      }
    `
    }
}
const dn = Wt `
  *,
  *::after,
  *::before,
  :host {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
    font-style: normal;
    text-rendering: optimizeSpeed;
    -webkit-font-smoothing: antialiased;
    -moz-osx-font-smoothing: grayscale;
    -webkit-tap-highlight-color: transparent;
    font-family: var(--wui-font-family);
    backface-visibility: hidden;
  }
`,
    Di = Wt `
  button,
  a {
    cursor: pointer;
    display: flex;
    justify-content: center;
    align-items: center;
    position: relative;
    transition: all var(--wui-ease-out-power-1) var(--wui-duration-lg);
    outline: none;
    border: 1px solid transparent;
    column-gap: var(--wui-spacing-3xs);
    background-color: transparent;
    text-decoration: none;
  }

  @media (hover: hover) and (pointer: fine) {
    button:hover:enabled {
      background-color: var(--wui-gray-glass-005);
    }

    button:active:enabled {
      transition: all var(--wui-ease-out-power-2) var(--wui-duration-sm);
      background-color: var(--wui-gray-glass-010);
    }

    button[data-variant='fill']:hover:enabled {
      background-color: var(--wui-color-accent-090);
    }

    button[data-variant='accentBg']:hover:enabled {
      background: var(--wui-accent-glass-015);
    }

    button[data-variant='accentBg']:active:enabled {
      background: var(--wui-accent-glass-020);
    }
  }

  button:disabled {
    cursor: not-allowed;
    background-color: var(--wui-gray-glass-005);
  }

  button[data-variant='shade']:disabled,
  button[data-variant='accent']:disabled,
  button[data-variant='accentBg']:disabled {
    background-color: var(--wui-gray-glass-010);
    color: var(--wui-gray-glass-015);
    filter: grayscale(1);
  }

  button:disabled > wui-wallet-image,
  button:disabled > wui-all-wallets-image,
  button:disabled > wui-network-image,
  button:disabled > wui-image,
  button:disabled > wui-icon-box,
  button:disabled > wui-transaction-visual,
  button:disabled > wui-logo {
    filter: grayscale(1);
  }

  button:focus-visible,
  a:focus-visible {
    border: 1px solid var(--wui-color-accent-100);
    background-color: var(--wui-gray-glass-005);
    -webkit-box-shadow: 0px 0px 0px 4px var(--wui-box-shadow-blue);
    -moz-box-shadow: 0px 0px 0px 4px var(--wui-box-shadow-blue);
    box-shadow: 0px 0px 0px 4px var(--wui-box-shadow-blue);
  }

  button[data-variant='fill']:focus-visible {
    background-color: var(--wui-color-accent-090);
  }

  button[data-variant='fill'] {
    color: var(--wui-color-inverse-100);
    background-color: var(--wui-color-accent-100);
  }

  button[data-variant='fill']:disabled {
    color: var(--wui-gray-glass-015);
    background-color: var(--wui-gray-glass-015);
  }

  button[data-variant='fill']:disabled > wui-icon {
    color: var(--wui-gray-glass-015);
  }

  button[data-variant='shade'] {
    color: var(--wui-color-fg-200);
  }

  button[data-variant='accent'],
  button[data-variant='accentBg'] {
    color: var(--wui-color-accent-100);
  }

  button[data-variant='accentBg'] {
    background: var(--wui-accent-glass-010);
    border: 1px solid var(--wui-accent-glass-010);
  }

  button[data-variant='fullWidth'] {
    width: 100%;
    border-radius: var(--wui-border-radius-xs);
    height: 56px;
    border: none;
    background-color: var(--wui-gray-glass-002);
    color: var(--wui-color-fg-200);
    gap: var(--wui-spacing-xs);
  }

  button:active:enabled {
    background-color: var(--wui-gray-glass-010);
  }

  button[data-variant='fill']:active:enabled {
    background-color: var(--wui-color-accent-080);
    border: 1px solid var(--wui-gray-glass-010);
  }

  input {
    border: none;
    outline: none;
    appearance: none;
  }
`,
    R$ = Wt `
  .wui-color-inherit {
    color: var(--wui-color-inherit);
  }

  .wui-color-accent-100 {
    color: var(--wui-color-accent-100);
  }

  .wui-color-error-100 {
    color: var(--wui-color-error-100);
  }

  .wui-color-success-100 {
    color: var(--wui-color-success-100);
  }

  .wui-color-inverse-100 {
    color: var(--wui-color-inverse-100);
  }

  .wui-color-inverse-000 {
    color: var(--wui-color-inverse-000);
  }

  .wui-color-fg-100 {
    color: var(--wui-color-fg-100);
  }

  .wui-color-fg-200 {
    color: var(--wui-color-fg-200);
  }

  .wui-color-fg-300 {
    color: var(--wui-color-fg-300);
  }

  .wui-bg-color-inherit {
    background-color: var(--wui-color-inherit);
  }

  .wui-bg-color-blue-100 {
    background-color: var(--wui-color-accent-100);
  }

  .wui-bg-color-error-100 {
    background-color: var(--wui-color-error-100);
  }

  .wui-bg-color-success-100 {
    background-color: var(--wui-color-success-100);
  }

  .wui-bg-color-inverse-100 {
    background-color: var(--wui-color-inverse-100);
  }

  .wui-bg-color-inverse-000 {
    background-color: var(--wui-color-inverse-000);
  }

  .wui-bg-color-fg-100 {
    background-color: var(--wui-color-fg-100);
  }

  .wui-bg-color-fg-200 {
    background-color: var(--wui-color-fg-200);
  }

  .wui-bg-color-fg-300 {
    background-color: var(--wui-color-fg-300);
  }
`;

function ebe(t, e) {
    const {
        kind: n,
        elements: r
    } = e;
    return {
        kind: n,
        elements: r,
        finisher(i) {
            customElements.get(t) || customElements.define(t, i)
        }
    }
}

function tbe(t, e) {
    return customElements.get(t) || customElements.define(t, e), e
}

function Qe(t) {
    return function(n) {
        return typeof n == "function" ? tbe(t, n) : ebe(t, n)
    }
}
const nbe = Wt `
  :host {
    display: block;
    border-radius: clamp(0px, var(--wui-border-radius-l), 44px);
    border: 1px solid var(--wui-gray-glass-005);
    background-color: var(--wui-color-modal-bg);
    overflow: hidden;
  }
`;
var rbe = function(t, e, n, r) {
    var i = arguments.length,
        s = i < 3 ? e : r === null ? r = Object.getOwnPropertyDescriptor(e, n) : r,
        o;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function") s = Reflect.decorate(t, e, n, r);
    else
        for (var a = t.length - 1; a >= 0; a--)(o = t[a]) && (s = (i < 3 ? o(s) : i > 3 ? o(e, n, s) : o(e, n)) || s);
    return i > 3 && s && Object.defineProperty(e, n, s), s
};
let Z8 = class extends Zt {
    render() {
        return We `<slot></slot>`
    }
};
Z8.styles = [dn, nbe];
Z8 = rbe([Qe("wui-card")], Z8);
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const ibe = {
        attribute: !0,
        type: String,
        converter: K8,
        reflect: !1,
        hasChanged: C$
    },
    sbe = (t = ibe, e, n) => {
        const {
            kind: r,
            metadata: i
        } = n;
        let s = globalThis.litPropertyMetadata.get(i);
        if (s === void 0 && globalThis.litPropertyMetadata.set(i, s = new Map), s.set(n.name, t), r === "accessor") {
            const {
                name: o
            } = n;
            return {
                set(a) {
                    const l = e.get.call(this);
                    e.set.call(this, a), this.requestUpdate(o, l, t)
                },
                init(a) {
                    return a !== void 0 && this.P(o, void 0, t), a
                }
            }
        }
        if (r === "setter") {
            const {
                name: o
            } = n;
            return function(a) {
                const l = this[o];
                e.call(this, a), this.requestUpdate(o, l, t)
            }
        }
        throw Error("Unsupported decorator location: " + r)
    };

function xe(t) {
    return (e, n) => typeof n == "object" ? sbe(t, e, n) : ((r, i, s) => {
        const o = i.hasOwnProperty(s);
        return i.constructor.createProperty(s, o ? { ...r,
            wrapped: !0
        } : r), o ? Object.getOwnPropertyDescriptor(i, s) : void 0
    })(t, e, n)
}
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
function dT(t) {
    return xe({ ...t,
        state: !0,
        attribute: !1
    })
}
const obe = Wt `
  :host {
    display: flex;
    aspect-ratio: 1 / 1;
    color: var(--local-color);
    width: var(--local-width);
  }

  svg {
    width: inherit;
    height: inherit;
    object-fit: contain;
    object-position: center;
  }
`,
    abe = pt `<svg fill="none" viewBox="0 0 24 24">
  <path
    style="fill: var(--wui-color-accent-100);"
    d="M10.2 6.6a3.6 3.6 0 1 1-7.2 0 3.6 3.6 0 0 1 7.2 0ZM21 6.6a3.6 3.6 0 1 1-7.2 0 3.6 3.6 0 0 1 7.2 0ZM10.2 17.4a3.6 3.6 0 1 1-7.2 0 3.6 3.6 0 0 1 7.2 0ZM21 17.4a3.6 3.6 0 1 1-7.2 0 3.6 3.6 0 0 1 7.2 0Z"
  />
</svg>`,
    lbe = pt `
<svg width="36" height="36">
  <path
    d="M28.724 0H7.271A7.269 7.269 0 0 0 0 7.272v21.46A7.268 7.268 0 0 0 7.271 36H28.73A7.272 7.272 0 0 0 36 28.728V7.272A7.275 7.275 0 0 0 28.724 0Z"
    fill="url(#a)"
  />
  <path
    d="m17.845 8.271.729-1.26a1.64 1.64 0 1 1 2.843 1.638l-7.023 12.159h5.08c1.646 0 2.569 1.935 1.853 3.276H6.434a1.632 1.632 0 0 1-1.638-1.638c0-.909.73-1.638 1.638-1.638h4.176l5.345-9.265-1.67-2.898a1.642 1.642 0 0 1 2.844-1.638l.716 1.264Zm-6.317 17.5-1.575 2.732a1.64 1.64 0 1 1-2.844-1.638l1.17-2.025c1.323-.41 2.398-.095 3.249.931Zm13.56-4.954h4.262c.909 0 1.638.729 1.638 1.638 0 .909-.73 1.638-1.638 1.638h-2.367l1.597 2.772c.45.788.185 1.782-.602 2.241a1.642 1.642 0 0 1-2.241-.603c-2.69-4.666-4.711-8.159-6.052-10.485-1.372-2.367-.391-4.743.576-5.549 1.075 1.846 2.682 4.631 4.828 8.348Z"
    fill="#fff"
  />
  <defs>
    <linearGradient id="a" x1="18" y1="0" x2="18" y2="36" gradientUnits="userSpaceOnUse">
      <stop stop-color="#18BFFB" />
      <stop offset="1" stop-color="#2072F3" />
    </linearGradient>
  </defs>
</svg>`,
    cbe = pt `<svg fill="none" viewBox="0 0 40 40">
  <g clip-path="url(#a)">
    <g clip-path="url(#b)">
      <circle cx="20" cy="19.89" r="20" fill="#000" />
      <g clip-path="url(#c)">
        <path
          fill="#fff"
          d="M28.77 23.3c-.69 1.99-2.75 5.52-4.87 5.56-1.4.03-1.86-.84-3.46-.84-1.61 0-2.12.81-3.45.86-2.25.1-5.72-5.1-5.72-9.62 0-4.15 2.9-6.2 5.42-6.25 1.36-.02 2.64.92 3.47.92.83 0 2.38-1.13 4.02-.97.68.03 2.6.28 3.84 2.08-3.27 2.14-2.76 6.61.75 8.25ZM24.2 7.88c-2.47.1-4.49 2.69-4.2 4.84 2.28.17 4.47-2.39 4.2-4.84Z"
        />
      </g>
    </g>
  </g>
  <defs>
    <clipPath id="a"><rect width="40" height="40" fill="#fff" rx="20" /></clipPath>
    <clipPath id="b"><path fill="#fff" d="M0 0h40v40H0z" /></clipPath>
    <clipPath id="c"><path fill="#fff" d="M8 7.89h24v24H8z" /></clipPath>
  </defs>
</svg>`,
    ube = pt `<svg fill="none" viewBox="0 0 14 15">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M7 1.99a1 1 0 0 1 1 1v7.58l2.46-2.46a1 1 0 0 1 1.41 1.42L7.7 13.69a1 1 0 0 1-1.41 0L2.12 9.53A1 1 0 0 1 3.54 8.1L6 10.57V3a1 1 0 0 1 1-1Z"
    clip-rule="evenodd"
  />
</svg>`,
    fbe = pt `<svg fill="none" viewBox="0 0 14 15">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M13 7.99a1 1 0 0 1-1 1H4.4l2.46 2.46a1 1 0 1 1-1.41 1.41L1.29 8.7a1 1 0 0 1 0-1.41L5.46 3.1a1 1 0 0 1 1.41 1.42L4.41 6.99H12a1 1 0 0 1 1 1Z"
    clip-rule="evenodd"
  />
</svg>`,
    dbe = pt `<svg fill="none" viewBox="0 0 14 15">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M1 7.99a1 1 0 0 1 1-1h7.58L7.12 4.53A1 1 0 1 1 8.54 3.1l4.16 4.17a1 1 0 0 1 0 1.41l-4.16 4.17a1 1 0 1 1-1.42-1.41l2.46-2.46H2a1 1 0 0 1-1-1Z"
    clip-rule="evenodd"
  />
</svg>`,
    hbe = pt `<svg fill="none" viewBox="0 0 14 15">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M7 13.99a1 1 0 0 1-1-1V5.4L3.54 7.86a1 1 0 0 1-1.42-1.41L6.3 2.28a1 1 0 0 1 1.41 0l4.17 4.17a1 1 0 1 1-1.41 1.41L8 5.4v7.59a1 1 0 0 1-1 1Z"
    clip-rule="evenodd"
  />
</svg>`,
    pbe = pt `<svg fill="none" viewBox="0 0 20 20">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M4 6.4a1 1 0 0 1-.46.89 6.98 6.98 0 0 0 .38 6.18A7 7 0 0 0 16.46 7.3a1 1 0 0 1-.47-.92 7 7 0 0 0-12 .03Zm-2.02-.5a9 9 0 1 1 16.03 8.2A9 9 0 0 1 1.98 5.9Z"
    clip-rule="evenodd"
  />
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M6.03 8.63c-1.46-.3-2.72-.75-3.6-1.35l-.02-.01-.14-.11a1 1 0 0 1 1.2-1.6l.1.08c.6.4 1.52.74 2.69 1 .16-.99.39-1.88.67-2.65.3-.79.68-1.5 1.15-2.02A2.58 2.58 0 0 1 9.99 1c.8 0 1.45.44 1.92.97.47.52.84 1.23 1.14 2.02.29.77.52 1.66.68 2.64a8 8 0 0 0 2.7-1l.26-.18h.48a1 1 0 0 1 .12 2c-.86.51-2.01.91-3.34 1.18a22.24 22.24 0 0 1-.03 3.19c1.45.29 2.7.73 3.58 1.31a1 1 0 0 1-1.1 1.68c-.6-.4-1.56-.76-2.75-1-.15.8-.36 1.55-.6 2.2-.3.79-.67 1.5-1.14 2.02-.47.53-1.12.97-1.92.97-.8 0-1.45-.44-1.91-.97a6.51 6.51 0 0 1-1.15-2.02c-.24-.65-.44-1.4-.6-2.2-1.18.24-2.13.6-2.73.99a1 1 0 1 1-1.1-1.67c.88-.58 2.12-1.03 3.57-1.31a22.03 22.03 0 0 1-.04-3.2Zm2.2-1.7c.15-.86.34-1.61.58-2.24.24-.65.51-1.12.76-1.4.25-.28.4-.29.42-.29.03 0 .17.01.42.3.25.27.52.74.77 1.4.23.62.43 1.37.57 2.22a19.96 19.96 0 0 1-3.52 0Zm-.18 4.6a20.1 20.1 0 0 1-.03-2.62 21.95 21.95 0 0 0 3.94 0 20.4 20.4 0 0 1-.03 2.63 21.97 21.97 0 0 0-3.88 0Zm.27 2c.13.66.3 1.26.49 1.78.24.65.51 1.12.76 1.4.25.28.4.29.42.29.03 0 .17-.01.42-.3.25-.27.52-.74.77-1.4.19-.5.36-1.1.49-1.78a20.03 20.03 0 0 0-3.35 0Z"
    clip-rule="evenodd"
  />
</svg>`,
    gbe = pt `<svg fill="none" viewBox="0 0 14 15">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M12.04 2.65c.47.3.6.91.3 1.38l-5.78 9a1 1 0 0 1-1.61.1L1.73 9.27A1 1 0 1 1 3.27 8L5.6 10.8l5.05-7.85a1 1 0 0 1 1.38-.3Z"
    clip-rule="evenodd"
  />
</svg>`,
    mbe = pt `<svg fill="none" viewBox="0 0 16 16">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M1.46 4.96a1 1 0 0 1 1.41 0L8 10.09l5.13-5.13a1 1 0 1 1 1.41 1.41l-5.83 5.84a1 1 0 0 1-1.42 0L1.46 6.37a1 1 0 0 1 0-1.41Z"
    clip-rule="evenodd"
  />
</svg>`,
    ybe = pt `<svg fill="none" viewBox="0 0 16 16">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M11.04 1.46a1 1 0 0 1 0 1.41L5.91 8l5.13 5.13a1 1 0 1 1-1.41 1.41L3.79 8.71a1 1 0 0 1 0-1.42l5.84-5.83a1 1 0 0 1 1.41 0Z"
    clip-rule="evenodd"
  />
</svg>`,
    wbe = pt `<svg fill="none" viewBox="0 0 16 16">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M4.96 14.54a1 1 0 0 1 0-1.41L10.09 8 4.96 2.87a1 1 0 0 1 1.41-1.41l5.84 5.83a1 1 0 0 1 0 1.42l-5.84 5.83a1 1 0 0 1-1.41 0Z"
    clip-rule="evenodd"
  />
</svg>`,
    vbe = pt `<svg fill="none" viewBox="0 0 16 16">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M14.54 11.04a1 1 0 0 1-1.41 0L8 5.92l-5.13 5.12a1 1 0 1 1-1.41-1.41l5.83-5.84a1 1 0 0 1 1.42 0l5.83 5.84a1 1 0 0 1 0 1.41Z"
    clip-rule="evenodd"
  />
</svg>`,
    bbe = pt `<svg width="36" height="36" fill="none">
  <path
    fill="#fff"
    fill-opacity=".05"
    d="M0 14.94c0-5.55 0-8.326 1.182-10.4a9 9 0 0 1 3.359-3.358C6.614 0 9.389 0 14.94 0h6.12c5.55 0 8.326 0 10.4 1.182a9 9 0 0 1 3.358 3.359C36 6.614 36 9.389 36 14.94v6.12c0 5.55 0 8.326-1.182 10.4a9 9 0 0 1-3.359 3.358C29.386 36 26.611 36 21.06 36h-6.12c-5.55 0-8.326 0-10.4-1.182a9 9 0 0 1-3.358-3.359C0 29.386 0 26.611 0 21.06v-6.12Z"
  />
  <path
    stroke="#fff"
    stroke-opacity=".05"
    d="M14.94.5h6.12c2.785 0 4.84 0 6.46.146 1.612.144 2.743.43 3.691.97a8.5 8.5 0 0 1 3.172 3.173c.541.948.826 2.08.971 3.692.145 1.62.146 3.675.146 6.459v6.12c0 2.785 0 4.84-.146 6.46-.145 1.612-.43 2.743-.97 3.691a8.5 8.5 0 0 1-3.173 3.172c-.948.541-2.08.826-3.692.971-1.62.145-3.674.146-6.459.146h-6.12c-2.784 0-4.84 0-6.46-.146-1.612-.145-2.743-.43-3.691-.97a8.5 8.5 0 0 1-3.172-3.173c-.541-.948-.827-2.08-.971-3.692C.5 25.9.5 23.845.5 21.06v-6.12c0-2.784 0-4.84.146-6.46.144-1.612.43-2.743.97-3.691A8.5 8.5 0 0 1 4.79 1.617C5.737 1.076 6.869.79 8.48.646 10.1.5 12.156.5 14.94.5Z"
  />
  <path
    fill="url(#a)"
    d="M17.998 10.8h12.469a14.397 14.397 0 0 0-24.938.001l6.234 10.798.006-.001a7.19 7.19 0 0 1 6.23-10.799Z"
  />
  <path
    fill="url(#b)"
    d="m24.237 21.598-6.234 10.798A14.397 14.397 0 0 0 30.47 10.798H18.002l-.002.006a7.191 7.191 0 0 1 6.237 10.794Z"
  />
  <path
    fill="url(#c)"
    d="M11.765 21.601 5.531 10.803A14.396 14.396 0 0 0 18.001 32.4l6.235-10.798-.004-.004a7.19 7.19 0 0 1-12.466.004Z"
  />
  <path fill="#fff" d="M18 25.2a7.2 7.2 0 1 0 0-14.4 7.2 7.2 0 0 0 0 14.4Z" />
  <path fill="#1A73E8" d="M18 23.7a5.7 5.7 0 1 0 0-11.4 5.7 5.7 0 0 0 0 11.4Z" />
  <defs>
    <linearGradient
      id="a"
      x1="6.294"
      x2="41.1"
      y1="5.995"
      y2="5.995"
      gradientUnits="userSpaceOnUse"
    >
      <stop stop-color="#D93025" />
      <stop offset="1" stop-color="#EA4335" />
    </linearGradient>
    <linearGradient
      id="b"
      x1="20.953"
      x2="37.194"
      y1="32.143"
      y2="2.701"
      gradientUnits="userSpaceOnUse"
    >
      <stop stop-color="#FCC934" />
      <stop offset="1" stop-color="#FBBC04" />
    </linearGradient>
    <linearGradient
      id="c"
      x1="25.873"
      x2="9.632"
      y1="31.2"
      y2="1.759"
      gradientUnits="userSpaceOnUse"
    >
      <stop stop-color="#1E8E3E" />
      <stop offset="1" stop-color="#34A853" />
    </linearGradient>
  </defs>
</svg>`,
    _be = pt `<svg fill="none" viewBox="0 0 16 16">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M7 2.99a5 5 0 1 0 0 10 5 5 0 0 0 0-10Zm-7 5a7 7 0 1 1 14 0 7 7 0 0 1-14 0Zm7-4a1 1 0 0 1 1 1v2.58l1.85 1.85a1 1 0 0 1-1.41 1.42L6.29 8.69A1 1 0 0 1 6 8v-3a1 1 0 0 1 1-1Z"
    clip-rule="evenodd"
  />
</svg>`,
    Ebe = pt `<svg fill="none" viewBox="0 0 16 16">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M2.54 2.54a1 1 0 0 1 1.42 0L8 6.6l4.04-4.05a1 1 0 1 1 1.42 1.42L9.4 8l4.05 4.04a1 1 0 0 1-1.42 1.42L8 9.4l-4.04 4.05a1 1 0 0 1-1.42-1.42L6.6 8 2.54 3.96a1 1 0 0 1 0-1.42Z"
    clip-rule="evenodd"
  />
</svg>`,
    xbe = pt `<svg fill="none" viewBox="0 0 20 20">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M10 3a7 7 0 0 0-6.85 8.44l8.29-8.3C10.97 3.06 10.49 3 10 3Zm3.49.93-9.56 9.56c.32.55.71 1.06 1.16 1.5L15 5.1a7.03 7.03 0 0 0-1.5-1.16Zm2.7 2.8-9.46 9.46a7 7 0 0 0 9.46-9.46ZM1.99 5.9A9 9 0 1 1 18 14.09 9 9 0 0 1 1.98 5.91Z"
    clip-rule="evenodd"
  />
</svg>`,
    Sbe = pt `<svg fill="none" viewBox="0 0 16 16">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M8 2a6 6 0 1 0 0 12A6 6 0 0 0 8 2ZM0 8a8 8 0 1 1 16 0A8 8 0 0 1 0 8Zm10.66-2.65a1 1 0 0 1 .23 1.06L9.83 9.24a1 1 0 0 1-.59.58l-2.83 1.06A1 1 0 0 1 5.13 9.6l1.06-2.82a1 1 0 0 1 .58-.59L9.6 5.12a1 1 0 0 1 1.06.23ZM7.9 7.89l-.13.35.35-.13.12-.35-.34.13Z"
    clip-rule="evenodd"
  />
</svg>`,
    Cbe = pt `<svg fill="none" viewBox="0 0 16 16">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M9.5 0h1.67c.68 0 1.26 0 1.73.04.5.05.97.14 1.42.4.52.3.95.72 1.24 1.24.26.45.35.92.4 1.42.04.47.04 1.05.04 1.73V6.5c0 .69 0 1.26-.04 1.74-.05.5-.14.97-.4 1.41-.3.52-.72.95-1.24 1.25-.45.25-.92.35-1.42.4-.43.03-.95.03-1.57.03 0 .62 0 1.14-.04 1.57-.04.5-.14.97-.4 1.42-.29.52-.72.95-1.24 1.24-.44.26-.92.35-1.41.4-.48.04-1.05.04-1.74.04H4.83c-.68 0-1.26 0-1.73-.04-.5-.05-.97-.14-1.42-.4-.52-.3-.95-.72-1.24-1.24a3.39 3.39 0 0 1-.4-1.42A20.9 20.9 0 0 1 0 11.17V9.5c0-.69 0-1.26.04-1.74.05-.5.14-.97.4-1.41.3-.52.72-.95 1.24-1.25.45-.25.92-.35 1.42-.4.43-.03.95-.03 1.57-.03 0-.62 0-1.14.04-1.57.04-.5.14-.97.4-1.42.29-.52.72-.95 1.24-1.24.44-.26.92-.35 1.41-.4A20.9 20.9 0 0 1 9.5 0ZM4.67 6.67c-.63 0-1.06 0-1.4.03-.35.03-.5.09-.6.14-.2.12-.38.3-.5.5-.05.1-.1.24-.14.6C2 8.32 2 8.8 2 9.54v1.59c0 .73 0 1.22.03 1.6.04.35.1.5.15.6.11.2.29.38.5.5.09.05.24.1.6.14.37.03.86.03 1.6.03h1.58c.74 0 1.22 0 1.6-.03.36-.04.5-.1.6-.15.2-.11.38-.29.5-.5.05-.09.1-.24.14-.6.03-.33.03-.76.03-1.39-.6 0-1.13 0-1.57-.04-.5-.04-.97-.14-1.41-.4-.52-.29-.95-.72-1.25-1.24a3.39 3.39 0 0 1-.4-1.41c-.03-.44-.03-.96-.03-1.57Zm3.27-4.64c-.36.04-.5.1-.6.15-.2.11-.38.29-.5.5-.05.09-.1.24-.14.6-.03.37-.03.86-.03 1.6v1.58c0 .74 0 1.22.03 1.6.03.36.09.5.14.6.12.2.3.38.5.5.1.05.24.1.6.14.38.03.86.03 1.6.03h1.59c.73 0 1.22 0 1.6-.03.35-.03.5-.09.6-.14.2-.12.38-.3.5-.5.05-.1.1-.24.14-.6.03-.38.03-.86.03-1.6V4.87c0-.73 0-1.22-.03-1.6a1.46 1.46 0 0 0-.15-.6c-.11-.2-.29-.38-.5-.5-.09-.05-.24-.1-.6-.14-.37-.03-.86-.03-1.6-.03H9.55c-.74 0-1.22 0-1.6.03Z"
    clip-rule="evenodd"
  />
</svg>`,
    Abe = pt ` <svg fill="none" viewBox="0 0 13 4">
  <path fill="currentColor" d="M.5 0h12L8.9 3.13a3.76 3.76 0 0 1-4.8 0L.5 0Z" />
</svg>`,
    Tbe = pt `<svg fill="none" viewBox="0 0 20 20">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M13.66 2H6.34c-1.07 0-1.96 0-2.68.08-.74.08-1.42.25-2.01.68a4 4 0 0 0-.89.89c-.43.6-.6 1.27-.68 2.01C0 6.38 0 7.26 0 8.34v.89c0 1.07 0 1.96.08 2.68.08.74.25 1.42.68 2.01a4 4 0 0 0 .89.89c.6.43 1.27.6 2.01.68a27 27 0 0 0 2.68.08h7.32a27 27 0 0 0 2.68-.08 4.03 4.03 0 0 0 2.01-.68 4 4 0 0 0 .89-.89c.43-.6.6-1.27.68-2.01.08-.72.08-1.6.08-2.68v-.89c0-1.07 0-1.96-.08-2.68a4.04 4.04 0 0 0-.68-2.01 4 4 0 0 0-.89-.89c-.6-.43-1.27-.6-2.01-.68C15.62 2 14.74 2 13.66 2ZM2.82 4.38c.2-.14.48-.25 1.06-.31C4.48 4 5.25 4 6.4 4h7.2c1.15 0 1.93 0 2.52.07.58.06.86.17 1.06.31a2 2 0 0 1 .44.44c.14.2.25.48.31 1.06.07.6.07 1.37.07 2.52v.77c0 1.15 0 1.93-.07 2.52-.06.58-.17.86-.31 1.06a2 2 0 0 1-.44.44c-.2.14-.48.25-1.06.32-.6.06-1.37.06-2.52.06H6.4c-1.15 0-1.93 0-2.52-.06-.58-.07-.86-.18-1.06-.32a2 2 0 0 1-.44-.44c-.14-.2-.25-.48-.31-1.06C2 11.1 2 10.32 2 9.17V8.4c0-1.15 0-1.93.07-2.52.06-.58.17-.86.31-1.06a2 2 0 0 1 .44-.44Z"
    clip-rule="evenodd"
  />
  <path fill="currentColor" d="M6.14 17.57a1 1 0 1 0 0 2h7.72a1 1 0 1 0 0-2H6.14Z" />
</svg>`,
    Ibe = pt `<svg fill="none" viewBox="0 0 16 16">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M6.07 1h.57a1 1 0 0 1 0 2h-.52c-.98 0-1.64 0-2.14.06-.48.05-.7.14-.84.24-.13.1-.25.22-.34.35-.1.14-.2.35-.25.83-.05.5-.05 1.16-.05 2.15v2.74c0 .99 0 1.65.05 2.15.05.48.14.7.25.83.1.14.2.25.34.35.14.1.36.2.84.25.5.05 1.16.05 2.14.05h.52a1 1 0 0 1 0 2h-.57c-.92 0-1.69 0-2.3-.07a3.6 3.6 0 0 1-1.8-.61c-.3-.22-.57-.49-.8-.8a3.6 3.6 0 0 1-.6-1.79C.5 11.11.5 10.35.5 9.43V6.58c0-.92 0-1.7.06-2.31a3.6 3.6 0 0 1 .62-1.8c.22-.3.48-.57.79-.79a3.6 3.6 0 0 1 1.8-.61C4.37 1 5.14 1 6.06 1ZM9.5 3a1 1 0 0 1 1.42 0l4.28 4.3a1 1 0 0 1 0 1.4L10.93 13a1 1 0 0 1-1.42-1.42L12.1 9H6.8a1 1 0 1 1 0-2h5.3L9.51 4.42a1 1 0 0 1 0-1.41Z"
    clip-rule="evenodd"
  />
</svg>`,
    Rbe = pt `<svg fill="none" viewBox="0 0 40 40">
  <g clip-path="url(#a)">
    <g clip-path="url(#b)">
      <circle cx="20" cy="19.89" r="20" fill="#5865F2" />
      <path
        fill="#fff"
        fill-rule="evenodd"
        d="M25.71 28.15C30.25 28 32 25.02 32 25.02c0-6.61-2.96-11.98-2.96-11.98-2.96-2.22-5.77-2.15-5.77-2.15l-.29.32c3.5 1.07 5.12 2.61 5.12 2.61a16.75 16.75 0 0 0-10.34-1.93l-.35.04a15.43 15.43 0 0 0-5.88 1.9s1.71-1.63 5.4-2.7l-.2-.24s-2.81-.07-5.77 2.15c0 0-2.96 5.37-2.96 11.98 0 0 1.73 2.98 6.27 3.13l1.37-1.7c-2.6-.79-3.6-2.43-3.6-2.43l.58.35.09.06.08.04.02.01.08.05a17.25 17.25 0 0 0 4.52 1.58 14.4 14.4 0 0 0 8.3-.86c.72-.27 1.52-.66 2.37-1.21 0 0-1.03 1.68-3.72 2.44.61.78 1.35 1.67 1.35 1.67Zm-9.55-9.6c-1.17 0-2.1 1.03-2.1 2.28 0 1.25.95 2.28 2.1 2.28 1.17 0 2.1-1.03 2.1-2.28.01-1.25-.93-2.28-2.1-2.28Zm7.5 0c-1.17 0-2.1 1.03-2.1 2.28 0 1.25.95 2.28 2.1 2.28 1.17 0 2.1-1.03 2.1-2.28 0-1.25-.93-2.28-2.1-2.28Z"
        clip-rule="evenodd"
      />
    </g>
  </g>
  <defs>
    <clipPath id="a"><rect width="40" height="40" fill="#fff" rx="20" /></clipPath>
    <clipPath id="b"><path fill="#fff" d="M0 0h40v40H0z" /></clipPath>
  </defs>
</svg>`,
    Obe = pt `<svg fill="none" viewBox="0 0 16 16">
  <path
    fill="currentColor"
    d="M4.25 7a.63.63 0 0 0-.63.63v3.97c0 .28-.2.51-.47.54l-.75.07a.93.93 0 0 1-.9-.47A7.51 7.51 0 0 1 5.54.92a7.5 7.5 0 0 1 9.54 4.62c.12.35.06.72-.16 1-.74.97-1.68 1.78-2.6 2.44V4.44a.64.64 0 0 0-.63-.64h-1.06c-.35 0-.63.3-.63.64v5.5c0 .23-.12.42-.32.5l-.52.23V6.05c0-.36-.3-.64-.64-.64H7.45c-.35 0-.64.3-.64.64v4.97c0 .25-.17.46-.4.52a5.8 5.8 0 0 0-.45.11v-4c0-.36-.3-.65-.64-.65H4.25ZM14.07 12.4A7.49 7.49 0 0 1 3.6 14.08c4.09-.58 9.14-2.5 11.87-6.6v.03a7.56 7.56 0 0 1-1.41 4.91Z"
  />
</svg>`,
    Nbe = pt `<svg fill="none" viewBox="0 0 14 15">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M6.71 2.99a.57.57 0 0 0-.57.57 1 1 0 0 1-1 1c-.58 0-.96 0-1.24.03-.27.03-.37.07-.42.1a.97.97 0 0 0-.36.35c-.04.08-.09.21-.11.67a2.57 2.57 0 0 1 0 5.13c.02.45.07.6.11.66.09.15.21.28.36.36.07.04.21.1.67.12a2.57 2.57 0 0 1 5.12 0c.46-.03.6-.08.67-.12a.97.97 0 0 0 .36-.36c.03-.04.07-.14.1-.41.02-.29.03-.66.03-1.24a1 1 0 0 1 1-1 .57.57 0 0 0 0-1.15 1 1 0 0 1-1-1c0-.58 0-.95-.03-1.24a1.04 1.04 0 0 0-.1-.42.97.97 0 0 0-.36-.36 1.04 1.04 0 0 0-.42-.1c-.28-.02-.65-.02-1.24-.02a1 1 0 0 1-1-1 .57.57 0 0 0-.57-.57ZM5.15 13.98a1 1 0 0 0 .99-1v-.78a.57.57 0 0 1 1.14 0v.78a1 1 0 0 0 .99 1H8.36a66.26 66.26 0 0 0 .73 0 3.78 3.78 0 0 0 1.84-.38c.46-.26.85-.64 1.1-1.1.23-.4.32-.8.36-1.22.02-.2.03-.4.03-.63a2.57 2.57 0 0 0 0-4.75c0-.23-.01-.44-.03-.63a2.96 2.96 0 0 0-.35-1.22 2.97 2.97 0 0 0-1.1-1.1c-.4-.22-.8-.31-1.22-.35a8.7 8.7 0 0 0-.64-.04 2.57 2.57 0 0 0-4.74 0c-.23 0-.44.02-.63.04-.42.04-.83.13-1.22.35-.46.26-.84.64-1.1 1.1-.33.57-.37 1.2-.39 1.84a21.39 21.39 0 0 0 0 .72v.1a1 1 0 0 0 1 .99h.78a.57.57 0 0 1 0 1.15h-.77a1 1 0 0 0-1 .98v.1a63.87 63.87 0 0 0 0 .73c0 .64.05 1.27.38 1.83.26.47.64.85 1.1 1.11.56.32 1.2.37 1.84.38a20.93 20.93 0 0 0 .72 0h.1Z"
    clip-rule="evenodd"
  />
</svg>`,
    Pbe = pt `<svg fill="none" viewBox="0 0 14 15">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M3.74 3.99a1 1 0 0 1 1-1H11a1 1 0 0 1 1 1v6.26a1 1 0 0 1-2 0V6.4l-6.3 6.3a1 1 0 0 1-1.4-1.42l6.29-6.3H4.74a1 1 0 0 1-1-1Z"
    clip-rule="evenodd"
  />
</svg>`,
    kbe = pt `<svg fill="none" viewBox="0 0 40 40">
  <g clip-path="url(#a)">
    <g clip-path="url(#b)">
      <circle cx="20" cy="19.89" r="20" fill="#1877F2" />
      <g clip-path="url(#c)">
        <path
          fill="#fff"
          d="M26 12.38h-2.89c-.92 0-1.61.38-1.61 1.34v1.66H26l-.36 4.5H21.5v12H17v-12h-3v-4.5h3V12.5c0-3.03 1.6-4.62 5.2-4.62H26v4.5Z"
        />
      </g>
    </g>
    <path
      fill="#1877F2"
      d="M40 20a20 20 0 1 0-23.13 19.76V25.78H11.8V20h5.07v-4.4c0-5.02 3-7.79 7.56-7.79 2.19 0 4.48.4 4.48.4v4.91h-2.53c-2.48 0-3.25 1.55-3.25 3.13V20h5.54l-.88 5.78h-4.66v13.98A20 20 0 0 0 40 20Z"
    />
    <path
      fill="#fff"
      d="m27.79 25.78.88-5.78h-5.55v-3.75c0-1.58.78-3.13 3.26-3.13h2.53V8.2s-2.3-.39-4.48-.39c-4.57 0-7.55 2.77-7.55 7.78V20H11.8v5.78h5.07v13.98a20.15 20.15 0 0 0 6.25 0V25.78h4.67Z"
    />
  </g>
  <defs>
    <clipPath id="a"><rect width="40" height="40" fill="#fff" rx="20" /></clipPath>
    <clipPath id="b"><path fill="#fff" d="M0 0h40v40H0z" /></clipPath>
    <clipPath id="c"><path fill="#fff" d="M8 7.89h24v24H8z" /></clipPath>
  </defs>
</svg>`,
    Mbe = pt `<svg fill="none" viewBox="0 0 16 16">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M0 3a1 1 0 0 1 1-1h14a1 1 0 1 1 0 2H1a1 1 0 0 1-1-1Zm2.63 5.25a1 1 0 0 1 1-1h8.75a1 1 0 1 1 0 2H3.63a1 1 0 0 1-1-1Zm2.62 5.25a1 1 0 0 1 1-1h3.5a1 1 0 0 1 0 2h-3.5a1 1 0 0 1-1-1Z"
    clip-rule="evenodd"
  />
</svg>`,
    Dbe = pt `<svg fill="none" viewBox="0 0 40 40">
  <g clip-path="url(#a)">
    <g clip-path="url(#b)">
      <circle cx="20" cy="19.89" r="20" fill="#1B1F23" />
      <g clip-path="url(#c)">
        <path
          fill="#fff"
          d="M8 19.89a12 12 0 1 1 15.8 11.38c-.6.12-.8-.26-.8-.57v-3.3c0-1.12-.4-1.85-.82-2.22 2.67-.3 5.48-1.31 5.48-5.92 0-1.31-.47-2.38-1.24-3.22.13-.3.54-1.52-.12-3.18 0 0-1-.32-3.3 1.23a11.54 11.54 0 0 0-6 0c-2.3-1.55-3.3-1.23-3.3-1.23a4.32 4.32 0 0 0-.12 3.18 4.64 4.64 0 0 0-1.24 3.22c0 4.6 2.8 5.63 5.47 5.93-.34.3-.65.83-.76 1.6-.69.31-2.42.84-3.5-1 0 0-.63-1.15-1.83-1.23 0 0-1.18-.02-.09.73 0 0 .8.37 1.34 1.76 0 0 .7 2.14 4.03 1.41v2.24c0 .31-.2.68-.8.57A12 12 0 0 1 8 19.9Z"
        />
      </g>
    </g>
  </g>
  <defs>
    <clipPath id="a"><rect width="40" height="40" fill="#fff" rx="20" /></clipPath>
    <clipPath id="b"><path fill="#fff" d="M0 0h40v40H0z" /></clipPath>
    <clipPath id="c"><path fill="#fff" d="M8 7.89h24v24H8z" /></clipPath>
  </defs>
</svg>`,
    $be = pt `<svg fill="none" viewBox="0 0 40 40">
  <g clip-path="url(#a)">
    <g clip-path="url(#b)">
      <circle cx="20" cy="19.89" r="20" fill="#fff" fill-opacity=".05" />
      <g clip-path="url(#c)">
        <path
          fill="#4285F4"
          d="M20 17.7v4.65h6.46a5.53 5.53 0 0 1-2.41 3.61l3.9 3.02c2.26-2.09 3.57-5.17 3.57-8.82 0-.85-.08-1.67-.22-2.46H20Z"
        />
        <path
          fill="#34A853"
          d="m13.27 22.17-.87.67-3.11 2.42A12 12 0 0 0 20 31.9c3.24 0 5.96-1.07 7.94-2.9l-3.9-3.03A7.15 7.15 0 0 1 20 27.12a7.16 7.16 0 0 1-6.72-4.94v-.01Z"
        />
        <path
          fill="#FBBC05"
          d="M9.29 14.5a11.85 11.85 0 0 0 0 10.76l3.99-3.1a7.19 7.19 0 0 1 0-4.55l-4-3.1Z"
        />
        <path
          fill="#EA4335"
          d="M20 12.66c1.77 0 3.34.61 4.6 1.8l3.43-3.44A11.51 11.51 0 0 0 20 7.89c-4.7 0-8.74 2.69-10.71 6.62l3.99 3.1A7.16 7.16 0 0 1 20 12.66Z"
        />
      </g>
    </g>
  </g>
  <defs>
    <clipPath id="a"><rect width="40" height="40" fill="#fff" rx="20" /></clipPath>
    <clipPath id="b"><path fill="#fff" d="M0 0h40v40H0z" /></clipPath>
    <clipPath id="c"><path fill="#fff" d="M8 7.89h24v24H8z" /></clipPath>
  </defs>
</svg>`,
    Lbe = pt `<svg fill="none" viewBox="0 0 16 16">
  <path
    fill="currentColor"
    d="M8.51 5.66a.83.83 0 0 0-.57-.2.83.83 0 0 0-.52.28.8.8 0 0 0-.25.52 1 1 0 0 1-2 0c0-.75.34-1.43.81-1.91a2.75 2.75 0 0 1 4.78 1.92c0 1.24-.8 1.86-1.25 2.2l-.04.03c-.47.36-.5.43-.5.65a1 1 0 1 1-2 0c0-1.25.8-1.86 1.24-2.2l.04-.04c.47-.36.5-.43.5-.65 0-.3-.1-.49-.24-.6ZM9.12 11.87a1.13 1.13 0 1 1-2.25 0 1.13 1.13 0 0 1 2.25 0Z"
  />
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M0 8a8 8 0 1 1 16 0A8 8 0 0 1 0 8Zm8-6a6 6 0 1 0 0 12A6 6 0 0 0 8 2Z"
    clip-rule="evenodd"
  />
</svg>`,
    Bbe = pt `<svg fill="none" viewBox="0 0 14 15">
  <path
    fill="currentColor"
    d="M6 10.49a1 1 0 1 0 2 0v-2a1 1 0 0 0-2 0v2ZM7 4.49a1 1 0 1 0 0 2 1 1 0 0 0 0-2Z"
  />
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M7 14.99a7 7 0 1 0 0-14 7 7 0 0 0 0 14Zm5-7a5 5 0 1 1-10 0 5 5 0 0 1 10 0Z"
    clip-rule="evenodd"
  />
</svg>`,
    Fbe = pt `<svg fill="none" viewBox="0 0 16 16">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M4.83 1.34h6.34c.68 0 1.26 0 1.73.04.5.05.97.15 1.42.4.52.3.95.72 1.24 1.24.26.45.35.92.4 1.42.04.47.04 1.05.04 1.73v3.71c0 .69 0 1.26-.04 1.74-.05.5-.14.97-.4 1.41-.3.52-.72.95-1.24 1.25-.45.25-.92.35-1.42.4-.47.03-1.05.03-1.73.03H4.83c-.68 0-1.26 0-1.73-.04-.5-.04-.97-.14-1.42-.4-.52-.29-.95-.72-1.24-1.24a3.39 3.39 0 0 1-.4-1.41A20.9 20.9 0 0 1 0 9.88v-3.7c0-.7 0-1.27.04-1.74.05-.5.14-.97.4-1.42.3-.52.72-.95 1.24-1.24.45-.25.92-.35 1.42-.4.47-.04 1.05-.04 1.73-.04ZM3.28 3.38c-.36.03-.51.08-.6.14-.21.11-.39.29-.5.5a.8.8 0 0 0-.08.19l5.16 3.44c.45.3 1.03.3 1.48 0L13.9 4.2a.79.79 0 0 0-.08-.2c-.11-.2-.29-.38-.5-.5-.09-.05-.24-.1-.6-.13-.37-.04-.86-.04-1.6-.04H4.88c-.73 0-1.22 0-1.6.04ZM14 6.54 9.85 9.31a3.33 3.33 0 0 1-3.7 0L2 6.54v3.3c0 .74 0 1.22.03 1.6.04.36.1.5.15.6.11.2.29.38.5.5.09.05.24.1.6.14.37.03.86.03 1.6.03h6.25c.73 0 1.22 0 1.6-.03.35-.03.5-.09.6-.14.2-.12.38-.3.5-.5.05-.1.1-.24.14-.6.03-.38.03-.86.03-1.6v-3.3Z"
    clip-rule="evenodd"
  />
</svg>`,
    Ube = pt `<svg fill="none" viewBox="0 0 20 20">
  <path fill="currentColor" d="M10.81 5.81a2 2 0 1 1-4 0 2 2 0 0 1 4 0Z" />
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M3 4.75A4.75 4.75 0 0 1 7.75 0h4.5A4.75 4.75 0 0 1 17 4.75v10.5A4.75 4.75 0 0 1 12.25 20h-4.5A4.75 4.75 0 0 1 3 15.25V4.75ZM7.75 2A2.75 2.75 0 0 0 5 4.75v10.5A2.75 2.75 0 0 0 7.75 18h4.5A2.75 2.75 0 0 0 15 15.25V4.75A2.75 2.75 0 0 0 12.25 2h-4.5Z"
    clip-rule="evenodd"
  />
</svg>`,
    jbe = pt `<svg fill="none" viewBox="0 0 22 20">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M16.32 13.62a3.14 3.14 0 1 1-.99 1.72l-1.6-.93a3.83 3.83 0 0 1-3.71 1 3.66 3.66 0 0 1-1.74-1l-1.6.94a3.14 3.14 0 1 1-1-1.73l1.6-.94a3.7 3.7 0 0 1 0-2 3.81 3.81 0 0 1 1.8-2.33c.29-.17.6-.3.92-.38V6.1a3.14 3.14 0 1 1 2 0l-.01.02v1.85H12a3.82 3.82 0 0 1 2.33 1.8 3.7 3.7 0 0 1 .39 2.91l1.6.93ZM2.6 16.54a1.14 1.14 0 0 0 1.98-1.14 1.14 1.14 0 0 0-1.98 1.14ZM11 2.01a1.14 1.14 0 1 0 0 2.28 1.14 1.14 0 0 0 0-2.28Zm1.68 10.45c.08-.19.14-.38.16-.58v-.05l.02-.13v-.13a1.92 1.92 0 0 0-.24-.8l-.11-.15a1.89 1.89 0 0 0-.74-.6 1.86 1.86 0 0 0-.77-.17h-.19a1.97 1.97 0 0 0-.89.34 1.98 1.98 0 0 0-.61.74 1.99 1.99 0 0 0-.16.9v.05a1.87 1.87 0 0 0 .24.74l.1.15c.12.16.26.3.42.42l.16.1.13.07.04.02a1.84 1.84 0 0 0 .76.17h.17a2 2 0 0 0 .91-.35 1.78 1.78 0 0 0 .52-.58l.03-.05a.84.84 0 0 0 .05-.11Zm5.15 4.5a1.14 1.14 0 0 0 1.14-1.97 1.13 1.13 0 0 0-1.55.41c-.32.55-.13 1.25.41 1.56Z"
    clip-rule="evenodd"
  />
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M4.63 9.43a1.5 1.5 0 1 0 1.5-2.6 1.5 1.5 0 0 0-1.5 2.6Zm.32-1.55a.5.5 0 0 1 .68-.19.5.5 0 0 1 .18.68.5.5 0 0 1-.68.19.5.5 0 0 1-.18-.68ZM17.94 8.88a1.5 1.5 0 1 1-2.6-1.5 1.5 1.5 0 1 1 2.6 1.5ZM16.9 7.69a.5.5 0 0 0-.68.19.5.5 0 0 0 .18.68.5.5 0 0 0 .68-.19.5.5 0 0 0-.18-.68ZM9.75 17.75a1.5 1.5 0 1 1 2.6 1.5 1.5 1.5 0 1 1-2.6-1.5Zm1.05 1.18a.5.5 0 0 0 .68-.18.5.5 0 0 0-.18-.68.5.5 0 0 0-.68.18.5.5 0 0 0 .18.68Z"
    clip-rule="evenodd"
  />
</svg>`,
    Hbe = pt `<svg fill="none" viewBox="0 0 20 20">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M9.13 1h1.71c1.46 0 2.63 0 3.56.1.97.1 1.8.33 2.53.85a5 5 0 0 1 1.1 1.11c.53.73.75 1.56.86 2.53.1.93.1 2.1.1 3.55v1.72c0 1.45 0 2.62-.1 3.55-.1.97-.33 1.8-.86 2.53a5 5 0 0 1-1.1 1.1c-.73.53-1.56.75-2.53.86-.93.1-2.1.1-3.55.1H9.13c-1.45 0-2.62 0-3.56-.1-.96-.1-1.8-.33-2.52-.85a5 5 0 0 1-1.1-1.11 5.05 5.05 0 0 1-.86-2.53c-.1-.93-.1-2.1-.1-3.55V9.14c0-1.45 0-2.62.1-3.55.1-.97.33-1.8.85-2.53a5 5 0 0 1 1.1-1.1 5.05 5.05 0 0 1 2.53-.86C6.51 1 7.67 1 9.13 1ZM5.79 3.09a3.1 3.1 0 0 0-1.57.48 3 3 0 0 0-.66.67c-.24.32-.4.77-.48 1.56-.1.82-.1 1.88-.1 3.4v1.6c0 1.15 0 2.04.05 2.76l.41-.42c.5-.5.93-.92 1.32-1.24.41-.33.86-.6 1.43-.7a3 3 0 0 1 .94 0c.35.06.66.2.95.37a17.11 17.11 0 0 0 .8.45c.1-.08.2-.2.41-.4l.04-.03a27 27 0 0 1 1.95-1.84 4.03 4.03 0 0 1 1.91-.94 4 4 0 0 1 1.25 0c.73.11 1.33.46 1.91.94l.64.55V9.2c0-1.52 0-2.58-.1-3.4a3.1 3.1 0 0 0-.48-1.56 3 3 0 0 0-.66-.67 3.1 3.1 0 0 0-1.56-.48C13.37 3 12.3 3 10.79 3h-1.6c-1.52 0-2.59 0-3.4.09Zm11.18 10-.04-.05a26.24 26.24 0 0 0-1.83-1.74c-.45-.36-.73-.48-.97-.52a2 2 0 0 0-.63 0c-.24.04-.51.16-.97.52-.46.38-1.01.93-1.83 1.74l-.02.02c-.17.18-.34.34-.49.47a2.04 2.04 0 0 1-1.08.5 1.97 1.97 0 0 1-1.25-.27l-.79-.46-.02-.02a.65.65 0 0 0-.24-.1 1 1 0 0 0-.31 0c-.08.02-.21.06-.49.28-.3.24-.65.59-1.2 1.14l-.56.56-.65.66a3 3 0 0 0 .62.6c.33.24.77.4 1.57.49.81.09 1.88.09 3.4.09h1.6c1.52 0 2.58 0 3.4-.09a3.1 3.1 0 0 0 1.56-.48 3 3 0 0 0 .66-.67c.24-.32.4-.77.49-1.56l.07-1.12Zm-8.02-1.03ZM4.99 7a2 2 0 1 1 4 0 2 2 0 0 1-4 0Z"
    clip-rule="evenodd"
  />
</svg>`,
    zbe = pt `<svg fill="none" viewBox="0 0 16 16">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M8 0a1 1 0 0 1 1 1v5.38a1 1 0 0 1-2 0V1a1 1 0 0 1 1-1ZM5.26 2.6a1 1 0 0 1-.28 1.39 5.46 5.46 0 1 0 6.04 0 1 1 0 1 1 1.1-1.67 7.46 7.46 0 1 1-8.25 0 1 1 0 0 1 1.4.28Z"
    clip-rule="evenodd"
  />
</svg>`,
    Wbe = pt ` <svg
  width="36"
  height="36"
  fill="none"
>
  <path
    d="M0 8a8 8 0 0 1 8-8h20a8 8 0 0 1 8 8v20a8 8 0 0 1-8 8H8a8 8 0 0 1-8-8V8Z"
    fill="#fff"
    fill-opacity=".05"
  />
  <path
    d="m18.262 17.513-8.944 9.49v.01a2.417 2.417 0 0 0 3.56 1.452l.026-.017 10.061-5.803-4.703-5.132Z"
    fill="#EA4335"
  />
  <path
    d="m27.307 15.9-.008-.008-4.342-2.52-4.896 4.36 4.913 4.912 4.325-2.494a2.42 2.42 0 0 0 .008-4.25Z"
    fill="#FBBC04"
  />
  <path
    d="M9.318 8.997c-.05.202-.084.403-.084.622V26.39c0 .218.025.42.084.621l9.246-9.247-9.246-8.768Z"
    fill="#4285F4"
  />
  <path
    d="m18.33 18 4.627-4.628-10.053-5.828a2.427 2.427 0 0 0-3.586 1.444L18.329 18Z"
    fill="#34A853"
  />
  <path
    d="M8 .5h20A7.5 7.5 0 0 1 35.5 8v20a7.5 7.5 0 0 1-7.5 7.5H8A7.5 7.5 0 0 1 .5 28V8A7.5 7.5 0 0 1 8 .5Z"
    stroke="#fff"
    stroke-opacity=".05"
  />
</svg>`,
    Vbe = pt `<svg fill="none" viewBox="0 0 20 20">
  <path
    fill="currentColor"
    d="M3 6a3 3 0 0 1 3-3h1a1 1 0 1 0 0-2H6a5 5 0 0 0-5 5v1a1 1 0 0 0 2 0V6ZM13 1a1 1 0 1 0 0 2h1a3 3 0 0 1 3 3v1a1 1 0 1 0 2 0V6a5 5 0 0 0-5-5h-1ZM3 13a1 1 0 1 0-2 0v1a5 5 0 0 0 5 5h1a1 1 0 1 0 0-2H6a3 3 0 0 1-3-3v-1ZM19 13a1 1 0 1 0-2 0v1a3 3 0 0 1-3 3h-1a1 1 0 1 0 0 2h1.01a5 5 0 0 0 5-5v-1ZM5.3 6.36c-.04.2-.04.43-.04.89s0 .7.05.89c.14.52.54.92 1.06 1.06.19.05.42.05.89.05.46 0 .7 0 .88-.05A1.5 1.5 0 0 0 9.2 8.14c.06-.2.06-.43.06-.89s0-.7-.06-.89A1.5 1.5 0 0 0 8.14 5.3c-.19-.05-.42-.05-.88-.05-.47 0-.7 0-.9.05a1.5 1.5 0 0 0-1.05 1.06ZM10.8 6.36c-.04.2-.04.43-.04.89s0 .7.05.89c.14.52.54.92 1.06 1.06.19.05.42.05.89.05.46 0 .7 0 .88-.05a1.5 1.5 0 0 0 1.06-1.06c.06-.2.06-.43.06-.89s0-.7-.06-.89a1.5 1.5 0 0 0-1.06-1.06c-.19-.05-.42-.05-.88-.05-.47 0-.7 0-.9.05a1.5 1.5 0 0 0-1.05 1.06ZM5.26 12.75c0-.46 0-.7.05-.89a1.5 1.5 0 0 1 1.06-1.06c.19-.05.42-.05.89-.05.46 0 .7 0 .88.05.52.14.93.54 1.06 1.06.06.2.06.43.06.89s0 .7-.06.89a1.5 1.5 0 0 1-1.06 1.06c-.19.05-.42.05-.88.05-.47 0-.7 0-.9-.05a1.5 1.5 0 0 1-1.05-1.06c-.05-.2-.05-.43-.05-.89ZM10.8 11.86c-.04.2-.04.43-.04.89s0 .7.05.89c.14.52.54.92 1.06 1.06.19.05.42.05.89.05.46 0 .7 0 .88-.05a1.5 1.5 0 0 0 1.06-1.06c.06-.2.06-.43.06-.89s0-.7-.06-.89a1.5 1.5 0 0 0-1.06-1.06c-.19-.05-.42-.05-.88-.05-.47 0-.7 0-.9.05a1.5 1.5 0 0 0-1.05 1.06Z"
  />
</svg>`,
    Gbe = pt `<svg fill="none" viewBox="0 0 14 16">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M3.94 1.04a1 1 0 0 1 .7 1.23l-.48 1.68a5.85 5.85 0 0 1 8.53 4.32 5.86 5.86 0 0 1-11.4 2.56 1 1 0 0 1 1.9-.57 3.86 3.86 0 1 0 1.83-4.5l1.87.53a1 1 0 0 1-.55 1.92l-4.1-1.15a1 1 0 0 1-.69-1.23l1.16-4.1a1 1 0 0 1 1.23-.7Z"
    clip-rule="evenodd"
  />
</svg>`,
    qbe = pt `<svg fill="none" viewBox="0 0 20 20">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M9.36 4.21a5.14 5.14 0 1 0 0 10.29 5.14 5.14 0 0 0 0-10.29ZM1.64 9.36a7.71 7.71 0 1 1 14 4.47l2.52 2.5a1.29 1.29 0 1 1-1.82 1.83l-2.51-2.51A7.71 7.71 0 0 1 1.65 9.36Z"
    clip-rule="evenodd"
  />
</svg>`,
    Kbe = pt `<svg fill="none" viewBox="0 0 20 20">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M6.76.3a1 1 0 0 1 0 1.4L4.07 4.4h9a1 1 0 1 1 0 2h-9l2.69 2.68a1 1 0 1 1-1.42 1.42L.95 6.09a1 1 0 0 1 0-1.4l4.4-4.4a1 1 0 0 1 1.4 0Zm6.49 9.21a1 1 0 0 1 1.41 0l4.39 4.4a1 1 0 0 1 0 1.4l-4.39 4.4a1 1 0 0 1-1.41-1.42l2.68-2.68h-9a1 1 0 0 1 0-2h9l-2.68-2.68a1 1 0 0 1 0-1.42Z"
    clip-rule="evenodd"
  />
</svg>`,
    Ybe = pt `<svg width="10" height="10" viewBox="0 0 10 10">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M3.77986 0.566631C4.0589 0.845577 4.0589 1.29784 3.77986 1.57678L3.08261 2.2738H6.34184C6.73647 2.2738 7.05637 2.5936 7.05637 2.98808C7.05637 3.38257 6.73647 3.70237 6.34184 3.70237H3.08261L3.77986 4.39938C4.0589 4.67833 4.0589 5.13059 3.77986 5.40954C3.50082 5.68848 3.04841 5.68848 2.76937 5.40954L0.852346 3.49316C0.573306 3.21421 0.573306 2.76195 0.852346 2.48301L2.76937 0.566631C3.04841 0.287685 3.50082 0.287685 3.77986 0.566631ZM6.22 4.59102C6.49904 4.31208 6.95145 4.31208 7.23049 4.59102L9.14751 6.5074C9.42655 6.78634 9.42655 7.23861 9.14751 7.51755L7.23049 9.43393C6.95145 9.71287 6.49904 9.71287 6.22 9.43393C5.94096 9.15498 5.94096 8.70272 6.22 8.42377L6.91725 7.72676L3.65802 7.72676C3.26339 7.72676 2.94349 7.40696 2.94349 7.01247C2.94349 6.61798 3.26339 6.29819 3.65802 6.29819L6.91725 6.29819L6.22 5.60117C5.94096 5.32223 5.94096 4.86997 6.22 4.59102Z"
    clip-rule="evenodd"
  />
</svg>`,
    Zbe = pt `<svg fill="none" viewBox="0 0 14 14">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M3.48 2.18a1 1 0 0 1 1.41 0l2.68 2.68a1 1 0 1 1-1.41 1.42l-.98-.98v4.56a1 1 0 0 1-2 0V5.3l-.97.98A1 1 0 0 1 .79 4.86l2.69-2.68Zm6.34 2.93a1 1 0 0 1 1 1v4.56l.97-.98a1 1 0 1 1 1.42 1.42l-2.69 2.68a1 1 0 0 1-1.41 0l-2.68-2.68a1 1 0 0 1 1.41-1.42l.98.98V6.1a1 1 0 0 1 1-1Z"
    clip-rule="evenodd"
  />
</svg>`,
    Qbe = pt `<svg fill="none" viewBox="0 0 40 40">
  <g clip-path="url(#a)">
    <g clip-path="url(#b)">
      <circle cx="20" cy="19.89" r="20" fill="#5865F2" />
      <path
        fill="#fff"
        fill-rule="evenodd"
        d="M25.71 28.15C30.25 28 32 25.02 32 25.02c0-6.61-2.96-11.98-2.96-11.98-2.96-2.22-5.77-2.15-5.77-2.15l-.29.32c3.5 1.07 5.12 2.61 5.12 2.61a16.75 16.75 0 0 0-10.34-1.93l-.35.04a15.43 15.43 0 0 0-5.88 1.9s1.71-1.63 5.4-2.7l-.2-.24s-2.81-.07-5.77 2.15c0 0-2.96 5.37-2.96 11.98 0 0 1.73 2.98 6.27 3.13l1.37-1.7c-2.6-.79-3.6-2.43-3.6-2.43l.58.35.09.06.08.04.02.01.08.05a17.25 17.25 0 0 0 4.52 1.58 14.4 14.4 0 0 0 8.3-.86c.72-.27 1.52-.66 2.37-1.21 0 0-1.03 1.68-3.72 2.44.61.78 1.35 1.67 1.35 1.67Zm-9.55-9.6c-1.17 0-2.1 1.03-2.1 2.28 0 1.25.95 2.28 2.1 2.28 1.17 0 2.1-1.03 2.1-2.28.01-1.25-.93-2.28-2.1-2.28Zm7.5 0c-1.17 0-2.1 1.03-2.1 2.28 0 1.25.95 2.28 2.1 2.28 1.17 0 2.1-1.03 2.1-2.28 0-1.25-.93-2.28-2.1-2.28Z"
        clip-rule="evenodd"
      />
    </g>
  </g>
  <defs>
    <clipPath id="a"><rect width="40" height="40" fill="#fff" rx="20" /></clipPath>
    <clipPath id="b"><path fill="#fff" d="M0 0h40v40H0z" /></clipPath>
  </defs>
</svg> `,
    Jbe = pt `<svg fill="none" viewBox="0 0 40 40">
  <g clip-path="url(#a)">
    <g clip-path="url(#b)">
      <circle cx="20" cy="19.89" r="20" fill="#5A3E85" />
      <g clip-path="url(#c)">
        <path
          fill="#fff"
          d="M18.22 25.7 20 23.91h3.34l2.1-2.1v-6.68H15.4v8.78h2.82v1.77Zm3.87-8.16h1.25v3.66H22.1v-3.66Zm-3.34 0H20v3.66h-1.25v-3.66ZM20 7.9a12 12 0 1 0 0 24 12 12 0 0 0 0-24Zm6.69 14.56-3.66 3.66h-2.72l-1.77 1.78h-1.88V26.1H13.3v-9.82l.94-2.4H26.7v8.56Z"
        />
      </g>
    </g>
  </g>
  <defs>
    <clipPath id="a"><rect width="40" height="40" fill="#fff" rx="20" /></clipPath>
    <clipPath id="b"><path fill="#fff" d="M0 0h40v40H0z" /></clipPath>
    <clipPath id="c"><path fill="#fff" d="M8 7.89h24v24H8z" /></clipPath>
  </defs>
</svg>`,
    Xbe = pt `<svg fill="none" viewBox="0 0 40 40">
  <g clip-path="url(#a)">
    <g clip-path="url(#b)">
      <circle cx="20" cy="19.89" r="20" fill="#1D9BF0" />
      <path
        fill="#fff"
        d="M30 13.81c-.74.33-1.53.55-2.36.65.85-.51 1.5-1.32 1.8-2.27-.79.47-1.66.8-2.6 1a4.1 4.1 0 0 0-7 3.73c-3.4-.17-6.42-1.8-8.45-4.28a4.1 4.1 0 0 0 1.27 5.47c-.67-.02-1.3-.2-1.86-.5a4.1 4.1 0 0 0 3.3 4.07c-.58.15-1.21.19-1.86.07a4.1 4.1 0 0 0 3.83 2.85A8.25 8.25 0 0 1 10 26.3a11.62 11.62 0 0 0 6.29 1.84c7.62 0 11.92-6.44 11.66-12.2.8-.59 1.5-1.3 2.05-2.13Z"
      />
    </g>
  </g>
  <defs>
    <clipPath id="a"><rect width="40" height="40" fill="#fff" rx="20" /></clipPath>
    <clipPath id="b"><path fill="#fff" d="M0 0h40v40H0z" /></clipPath>
  </defs>
</svg>`,
    e2e = pt `<svg fill="none" viewBox="0 0 16 16">
  <path
    fill="currentColor"
    d="m14.36 4.74.01.42c0 4.34-3.3 9.34-9.34 9.34A9.3 9.3 0 0 1 0 13.03a6.6 6.6 0 0 0 4.86-1.36 3.29 3.29 0 0 1-3.07-2.28c.5.1 1 .07 1.48-.06A3.28 3.28 0 0 1 .64 6.11v-.04c.46.26.97.4 1.49.41A3.29 3.29 0 0 1 1.11 2.1a9.32 9.32 0 0 0 6.77 3.43 3.28 3.28 0 0 1 5.6-3 6.59 6.59 0 0 0 2.08-.8 3.3 3.3 0 0 1-1.45 1.82A6.53 6.53 0 0 0 16 3.04c-.44.66-1 1.23-1.64 1.7Z"
  />
</svg>`,
    t2e = pt `<svg fill="none" viewBox="0 0 28 28">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M18.1 4.76c-.42-.73-1.33-1.01-2.09-.66l-1.42.66c-.37.18-.8.18-1.18 0l-1.4-.65a1.63 1.63 0 0 0-2.1.66l-.84 1.45c-.2.34-.53.59-.92.67l-1.7.35c-.83.17-1.39.94-1.3 1.78l.19 1.56c.04.39-.08.78-.33 1.07l-1.12 1.3c-.52.6-.52 1.5 0 2.11L5 16.38c.25.3.37.68.33 1.06l-.18 1.57c-.1.83.46 1.6 1.28 1.78l1.7.35c.4.08.73.32.93.66l.84 1.43a1.63 1.63 0 0 0 2.09.66l1.41-.66c.37-.17.8-.17 1.18 0l1.43.67c.76.35 1.66.07 2.08-.65l.86-1.45c.2-.34.54-.58.92-.66l1.68-.35A1.63 1.63 0 0 0 22.84 19l-.18-1.57a1.4 1.4 0 0 1 .33-1.06l1.12-1.32c.52-.6.52-1.5 0-2.11l-1.12-1.3a1.4 1.4 0 0 1-.33-1.07l.18-1.57c.1-.83-.46-1.6-1.28-1.77l-1.68-.35a1.4 1.4 0 0 1-.92-.66l-.86-1.47Zm-3.27-3.2a4.43 4.43 0 0 1 5.69 1.78l.54.93 1.07.22a4.43 4.43 0 0 1 3.5 4.84l-.11.96.7.83a4.43 4.43 0 0 1 .02 5.76l-.72.85.1.96a4.43 4.43 0 0 1-3.5 4.84l-1.06.22-.54.92a4.43 4.43 0 0 1-5.68 1.77l-.84-.4-.82.39a4.43 4.43 0 0 1-5.7-1.79l-.51-.89-1.09-.22a4.43 4.43 0 0 1-3.5-4.84l.1-.96-.72-.85a4.43 4.43 0 0 1 .01-5.76l.71-.83-.1-.95a4.43 4.43 0 0 1 3.5-4.84l1.08-.23.53-.9a4.43 4.43 0 0 1 5.7-1.8l.81.38.83-.39ZM18.2 9.4c.65.42.84 1.28.42 1.93l-4.4 6.87a1.4 1.4 0 0 1-2.26.14L9.5 15.39a1.4 1.4 0 0 1 2.15-1.8l1.23 1.48 3.38-5.26a1.4 1.4 0 0 1 1.93-.42Z"
    clip-rule="evenodd"
  />
</svg>`,
    n2e = pt `<svg fill="none" viewBox="0 0 14 14">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="m4.1 12.43-.45-.78-.93-.2a1.65 1.65 0 0 1-1.31-1.8l.1-.86-.61-.71a1.65 1.65 0 0 1 0-2.16l.6-.7-.09-.85c-.1-.86.47-1.64 1.3-1.81l.94-.2.45-.78A1.65 1.65 0 0 1 6.23.9l.77.36.78-.36c.77-.36 1.69-.07 2.12.66l.47.8.91.2c.84.17 1.4.95 1.31 1.8l-.1.86.6.7c.54.62.54 1.54.01 2.16l-.6.71.09.86c.1.85-.47 1.63-1.3 1.8l-.92.2-.47.79a1.65 1.65 0 0 1-2.12.66L7 12.74l-.77.36c-.78.35-1.7.07-2.13-.67Zm5.74-6.9a1 1 0 1 0-1.68-1.07L6.32 7.3l-.55-.66a1 1 0 0 0-1.54 1.28l1.43 1.71a1 1 0 0 0 1.61-.1l2.57-4Z"
    clip-rule="evenodd"
  />
</svg>`,
    r2e = pt `
  <svg fill="none" viewBox="0 0 48 44">
    <path
      style="fill: var(--wui-color-bg-300);"
      d="M4.56 8.64c-1.23 1.68-1.23 4.08-1.23 8.88v8.96c0 4.8 0 7.2 1.23 8.88.39.55.87 1.02 1.41 1.42C7.65 38 10.05 38 14.85 38h14.3c4.8 0 7.2 0 8.88-1.22a6.4 6.4 0 0 0 1.41-1.42c.83-1.14 1.1-2.6 1.19-4.92a6.4 6.4 0 0 0 5.16-4.65c.21-.81.21-1.8.21-3.79 0-1.98 0-2.98-.22-3.79a6.4 6.4 0 0 0-5.15-4.65c-.1-2.32-.36-3.78-1.19-4.92a6.4 6.4 0 0 0-1.41-1.42C36.35 6 33.95 6 29.15 6h-14.3c-4.8 0-7.2 0-8.88 1.22a6.4 6.4 0 0 0-1.41 1.42Z"
    />
    <path
      style="fill: var(--wui-color-fg-200);"
      fill-rule="evenodd"
      d="M2.27 11.33a6.4 6.4 0 0 1 6.4-6.4h26.66a6.4 6.4 0 0 1 6.4 6.4v1.7a6.4 6.4 0 0 1 5.34 6.3v5.34a6.4 6.4 0 0 1-5.34 6.3v1.7a6.4 6.4 0 0 1-6.4 6.4H8.67a6.4 6.4 0 0 1-6.4-6.4V11.33ZM39.6 31.07h-6.93a9.07 9.07 0 1 1 0-18.14h6.93v-1.6a4.27 4.27 0 0 0-4.27-4.26H8.67a4.27 4.27 0 0 0-4.27 4.26v21.34a4.27 4.27 0 0 0 4.27 4.26h26.66a4.27 4.27 0 0 0 4.27-4.26v-1.6Zm-6.93-16a6.93 6.93 0 0 0 0 13.86h8a4.27 4.27 0 0 0 4.26-4.26v-5.34a4.27 4.27 0 0 0-4.26-4.26h-8Z"
      clip-rule="evenodd"
    />
  </svg>
`,
    i2e = pt `<svg fill="none" viewBox="0 0 20 20">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M0 5.5c0-1.8 1.46-3.25 3.25-3.25H14.5c1.8 0 3.25 1.46 3.25 3.25v.28A3.25 3.25 0 0 1 20 8.88v2.24c0 1.45-.94 2.68-2.25 3.1v.28c0 1.8-1.46 3.25-3.25 3.25H3.25A3.25 3.25 0 0 1 0 14.5v-9Zm15.75 8.88h-2.38a4.38 4.38 0 0 1 0-8.76h2.38V5.5c0-.69-.56-1.25-1.25-1.25H3.25C2.56 4.25 2 4.81 2 5.5v9c0 .69.56 1.25 1.25 1.25H14.5c.69 0 1.25-.56 1.25-1.25v-.13Zm-2.38-6.76a2.37 2.37 0 1 0 0 4.75h3.38c.69 0 1.25-.55 1.25-1.24V8.87c0-.69-.56-1.24-1.25-1.24h-3.38Z"
    clip-rule="evenodd"
  />
</svg>`,
    s2e = pt `<svg fill="none" viewBox="0 0 96 67">
  <path
    fill="currentColor"
    d="M25.32 18.8a32.56 32.56 0 0 1 45.36 0l1.5 1.47c.63.62.63 1.61 0 2.22l-5.15 5.05c-.31.3-.82.3-1.14 0l-2.07-2.03a22.71 22.71 0 0 0-31.64 0l-2.22 2.18c-.31.3-.82.3-1.14 0l-5.15-5.05a1.55 1.55 0 0 1 0-2.22l1.65-1.62Zm56.02 10.44 4.59 4.5c.63.6.63 1.6 0 2.21l-20.7 20.26c-.62.61-1.63.61-2.26 0L48.28 41.83a.4.4 0 0 0-.56 0L33.03 56.21c-.63.61-1.64.61-2.27 0L10.07 35.95a1.55 1.55 0 0 1 0-2.22l4.59-4.5a1.63 1.63 0 0 1 2.27 0L31.6 43.63a.4.4 0 0 0 .57 0l14.69-14.38a1.63 1.63 0 0 1 2.26 0l14.69 14.38a.4.4 0 0 0 .57 0l14.68-14.38a1.63 1.63 0 0 1 2.27 0Z"
  />
  <path
    stroke="#000"
    stroke-opacity=".1"
    d="M25.67 19.15a32.06 32.06 0 0 1 44.66 0l1.5 1.48c.43.42.43 1.09 0 1.5l-5.15 5.05a.31.31 0 0 1-.44 0l-2.07-2.03a23.21 23.21 0 0 0-32.34 0l-2.22 2.18a.31.31 0 0 1-.44 0l-5.15-5.05a1.05 1.05 0 0 1 0-1.5l1.65-1.63ZM81 29.6l4.6 4.5c.42.41.42 1.09 0 1.5l-20.7 20.26c-.43.43-1.14.43-1.57 0L48.63 41.47a.9.9 0 0 0-1.26 0L32.68 55.85c-.43.43-1.14.43-1.57 0L10.42 35.6a1.05 1.05 0 0 1 0-1.5l4.59-4.5a1.13 1.13 0 0 1 1.57 0l14.68 14.38a.9.9 0 0 0 1.27 0l-.35-.35.35.35L47.22 29.6a1.13 1.13 0 0 1 1.56 0l14.7 14.38a.9.9 0 0 0 1.26 0L79.42 29.6a1.13 1.13 0 0 1 1.57 0Z"
  />
</svg>`,
    o2e = pt `<svg fill="none" viewBox="0 0 20 20">
  <path
    fill="currentColor"
    d="M11 6.67a1 1 0 1 0-2 0v2.66a1 1 0 0 0 2 0V6.67ZM10 14.5a1.25 1.25 0 1 0 0-2.5 1.25 1.25 0 0 0 0 2.5Z"
  />
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M10 1a9 9 0 1 0 0 18 9 9 0 0 0 0-18Zm-7 9a7 7 0 1 1 14 0 7 7 0 0 1-14 0Z"
    clip-rule="evenodd"
  />
</svg>`,
    a2e = pt `<svg xmlns="http://www.w3.org/2000/svg" width="14" height="12" viewBox="0 0 14 12" fill="none">
  <path fill-rule="evenodd" clip-rule="evenodd" d="M10.687 0.557043C11.1462 0.671832 11.4254 1.13706 11.3106 1.59615C11.2044 2.02082 11.0975 2.51184 10.9822 3.04102C10.7176 4.25623 10.4091 5.6727 9.96482 6.94907C10.1435 7.58939 10.3065 8.16905 10.4935 8.68429C10.6447 9.10072 10.7858 9.39487 10.9179 9.58289C11.0055 9.70747 11.0597 9.74443 11.0748 9.75277C11.096 9.75724 11.1075 9.75764 11.1531 9.71916C11.2342 9.65067 11.3386 9.50891 11.4426 9.28357C11.5416 9.06892 11.614 8.8366 11.662 8.6497C11.6854 8.55831 11.7019 8.48242 11.7122 8.43111C11.7174 8.40555 11.7209 8.38638 11.723 8.37476L11.725 8.36363C11.8 7.89659 12.2395 7.57864 12.7068 7.65342C13.1742 7.72822 13.4925 8.16766 13.4177 8.63494C13.4153 8.64924 13.42 8.62063 13.4177 8.63494L13.4175 8.63596L13.4173 8.63721L13.4168 8.64037L13.4153 8.64924L13.4105 8.67692C13.4064 8.69961 13.4006 8.73069 13.3929 8.76891C13.3776 8.84516 13.3545 8.95091 13.3224 9.07586C13.2593 9.32166 13.1564 9.66085 12.9992 10.0015C12.8469 10.3315 12.6139 10.7288 12.2595 11.0282C11.8757 11.3523 11.35 11.5553 10.7293 11.4312C10.1645 11.3183 9.77597 10.939 9.51527 10.5681C9.2535 10.1957 9.05129 9.7349 8.88212 9.26898C8.87877 9.25975 8.87542 9.25049 8.87208 9.2412C8.03954 10.4941 6.83375 11.4479 5.03926 11.4479C3.48049 11.4479 2.31021 10.7159 1.56788 9.63945C0.846767 8.5938 0.544023 7.25403 0.573206 5.9702C0.60242 4.68505 0.966023 3.36073 1.69055 2.33272C2.42915 1.28475 3.5614 0.531453 5.03927 0.531453C6.44937 0.531453 7.4408 1.29593 8.1276 2.27567C8.48261 2.7821 8.77248 3.36668 9.0177 3.97383C9.1059 3.59106 9.18901 3.20908 9.27086 2.83294C9.39492 2.26277 9.51606 1.70605 9.64752 1.18046C9.76235 0.721369 10.2277 0.442254 10.687 0.557043ZM8.16354 6.87693C8.08689 6.60534 8.01003 6.33741 7.93241 6.08076C7.59522 4.96581 7.22132 3.969 6.72371 3.25914C6.24674 2.57873 5.72135 2.24516 5.03927 2.24516C4.21565 2.24516 3.56947 2.6422 3.09195 3.31975C2.60035 4.01725 2.31013 4.99361 2.28705 6.00913C2.26393 7.02599 2.51041 7.9869 2.97927 8.66676C3.42691 9.31586 4.08734 9.73417 5.03926 9.73417C6.48097 9.73417 7.4216 8.72164 8.14437 6.9249C8.15079 6.90893 8.15718 6.89294 8.16354 6.87693Z" fill="#47A1FF"/>
</svg>`;
var hT = function(t, e, n, r) {
    var i = arguments.length,
        s = i < 3 ? e : r === null ? r = Object.getOwnPropertyDescriptor(e, n) : r,
        o;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function") s = Reflect.decorate(t, e, n, r);
    else
        for (var a = t.length - 1; a >= 0; a--)(o = t[a]) && (s = (i < 3 ? o(s) : i > 3 ? o(e, n, s) : o(e, n)) || s);
    return i > 3 && s && Object.defineProperty(e, n, s), s
};
const l2e = {
    allWallets: abe,
    alpha: a2e,
    appStore: lbe,
    chromeStore: bbe,
    apple: cbe,
    arrowBottom: ube,
    arrowLeft: fbe,
    arrowRight: dbe,
    arrowTop: hbe,
    browser: pbe,
    checkmark: gbe,
    chevronBottom: mbe,
    chevronLeft: ybe,
    chevronRight: wbe,
    chevronTop: vbe,
    clock: _be,
    close: Ebe,
    compass: Sbe,
    coinPlaceholder: xbe,
    copy: Cbe,
    cursor: Abe,
    desktop: Tbe,
    disconnect: Ibe,
    discord: Rbe,
    etherscan: Obe,
    extension: Nbe,
    externalLink: Pbe,
    facebook: kbe,
    filters: Mbe,
    github: Dbe,
    google: $be,
    helpCircle: Lbe,
    infoCircle: Bbe,
    mail: Fbe,
    mobile: Ube,
    networkPlaceholder: jbe,
    nftPlaceholder: Hbe,
    off: zbe,
    playStore: Wbe,
    qrCode: Vbe,
    refresh: Gbe,
    search: qbe,
    swapHorizontal: Kbe,
    swapHorizontalBold: Ybe,
    swapVertical: Zbe,
    telegram: Qbe,
    twitch: Jbe,
    twitter: Xbe,
    twitterIcon: e2e,
    verify: t2e,
    verifyFilled: n2e,
    wallet: i2e,
    walletConnect: s2e,
    walletPlaceholder: r2e,
    warningCircle: o2e
};
let hm = class extends Zt {
    constructor() {
        super(...arguments), this.size = "md", this.name = "copy", this.color = "fg-300"
    }
    render() {
        return this.style.cssText = `
      --local-color: ${`var(--wui-color-${this.color});`}
      --local-width: ${`var(--wui-icon-size-${this.size});`}
    `, We `${l2e[this.name]}`
    }
};
hm.styles = [dn, R$, obe];
hT([xe()], hm.prototype, "size", void 0);
hT([xe()], hm.prototype, "name", void 0);
hT([xe()], hm.prototype, "color", void 0);
hm = hT([Qe("wui-icon")], hm);
const c2e = Wt `
  :host {
    display: block;
    width: 100%;
    height: 100%;
  }

  img {
    display: block;
    width: 100%;
    height: 100%;
    object-fit: cover;
    object-position: center center;
    border-radius: inherit;
  }
`;
var O$ = function(t, e, n, r) {
    var i = arguments.length,
        s = i < 3 ? e : r === null ? r = Object.getOwnPropertyDescriptor(e, n) : r,
        o;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function") s = Reflect.decorate(t, e, n, r);
    else
        for (var a = t.length - 1; a >= 0; a--)(o = t[a]) && (s = (i < 3 ? o(s) : i > 3 ? o(e, n, s) : o(e, n)) || s);
    return i > 3 && s && Object.defineProperty(e, n, s), s
};
let Ab = class extends Zt {
    constructor() {
        super(...arguments), this.src = "./path/to/image.jpg", this.alt = "Image"
    }
    render() {
        return We `<img src=${this.src} alt=${this.alt} />`
    }
};
Ab.styles = [dn, R$, c2e];
O$([xe()], Ab.prototype, "src", void 0);
O$([xe()], Ab.prototype, "alt", void 0);
Ab = O$([Qe("wui-image")], Ab);
const u2e = Wt `
  :host {
    display: block;
    width: var(--wui-box-size-lg);
    height: var(--wui-box-size-lg);
  }

  svg {
    width: var(--wui-box-size-lg);
    height: var(--wui-box-size-lg);
    fill: none;
    stroke: transparent;
    stroke-linecap: round;
    transition: all var(--wui-ease-in-power-3) var(--wui-duration-lg);
  }

  use {
    stroke: var(--wui-color-accent-100);
    stroke-width: 2px;
    stroke-dasharray: 54, 118;
    stroke-dashoffset: 172;
    animation: dash 1s linear infinite;
  }

  @keyframes dash {
    to {
      stroke-dashoffset: 0px;
    }
  }
`;
var f2e = function(t, e, n, r) {
    var i = arguments.length,
        s = i < 3 ? e : r === null ? r = Object.getOwnPropertyDescriptor(e, n) : r,
        o;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function") s = Reflect.decorate(t, e, n, r);
    else
        for (var a = t.length - 1; a >= 0; a--)(o = t[a]) && (s = (i < 3 ? o(s) : i > 3 ? o(e, n, s) : o(e, n)) || s);
    return i > 3 && s && Object.defineProperty(e, n, s), s
};
let Q8 = class extends Zt {
    render() {
        return We `
      <svg viewBox="0 0 54 59">
        <path
          id="wui-loader-path"
          d="M17.22 5.295c3.877-2.277 5.737-3.363 7.72-3.726a11.44 11.44 0 0 1 4.12 0c1.983.363 3.844 1.45 7.72 3.726l6.065 3.562c3.876 2.276 5.731 3.372 7.032 4.938a11.896 11.896 0 0 1 2.06 3.63c.683 1.928.688 4.11.688 8.663v7.124c0 4.553-.005 6.735-.688 8.664a11.896 11.896 0 0 1-2.06 3.63c-1.3 1.565-3.156 2.66-7.032 4.937l-6.065 3.563c-3.877 2.276-5.737 3.362-7.72 3.725a11.46 11.46 0 0 1-4.12 0c-1.983-.363-3.844-1.449-7.72-3.726l-6.065-3.562c-3.876-2.276-5.731-3.372-7.032-4.938a11.885 11.885 0 0 1-2.06-3.63c-.682-1.928-.688-4.11-.688-8.663v-7.124c0-4.553.006-6.735.688-8.664a11.885 11.885 0 0 1 2.06-3.63c1.3-1.565 3.156-2.66 7.032-4.937l6.065-3.562Z"
        />
        <use xlink:href="#wui-loader-path"></use>
      </svg>
    `
    }
};
Q8.styles = [dn, u2e];
Q8 = f2e([Qe("wui-loading-hexagon")], Q8);
const d2e = Wt `
  :host {
    display: flex;
  }

  :host([data-size='sm']) > svg {
    width: 12px;
    height: 12px;
  }

  :host([data-size='md']) > svg {
    width: 16px;
    height: 16px;
  }

  :host([data-size='lg']) > svg {
    width: 24px;
    height: 24px;
  }

  :host([data-size='xl']) > svg {
    width: 32px;
    height: 32px;
  }

  svg {
    animation: rotate 2s linear infinite;
    transition: all var(--wui-ease-in-power-3) var(--wui-duration-lg);
  }

  circle {
    fill: none;
    stroke: var(--local-color);
    stroke-width: 4px;
    stroke-dasharray: 1, 124;
    stroke-dashoffset: 0;
    stroke-linecap: round;
    animation: dash 1.5s ease-in-out infinite;
  }

  :host([data-size='md']) > svg > circle {
    stroke-width: 6px;
  }

  :host([data-size='sm']) > svg > circle {
    stroke-width: 8px;
  }

  @keyframes rotate {
    100% {
      transform: rotate(360deg);
    }
  }

  @keyframes dash {
    0% {
      stroke-dasharray: 1, 124;
      stroke-dashoffset: 0;
    }

    50% {
      stroke-dasharray: 90, 124;
      stroke-dashoffset: -35;
    }

    100% {
      stroke-dashoffset: -125;
    }
  }
`;
var N$ = function(t, e, n, r) {
    var i = arguments.length,
        s = i < 3 ? e : r === null ? r = Object.getOwnPropertyDescriptor(e, n) : r,
        o;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function") s = Reflect.decorate(t, e, n, r);
    else
        for (var a = t.length - 1; a >= 0; a--)(o = t[a]) && (s = (i < 3 ? o(s) : i > 3 ? o(e, n, s) : o(e, n)) || s);
    return i > 3 && s && Object.defineProperty(e, n, s), s
};
let Tb = class extends Zt {
    constructor() {
        super(...arguments), this.color = "accent-100", this.size = "lg"
    }
    render() {
        return this.style.cssText = `--local-color: var(--wui-color-${this.color});`, this.dataset.size = this.size, We `<svg viewBox="25 25 50 50">
      <circle r="20" cy="50" cx="50"></circle>
    </svg>`
    }
};
Tb.styles = [dn, d2e];
N$([xe()], Tb.prototype, "color", void 0);
N$([xe()], Tb.prototype, "size", void 0);
Tb = N$([Qe("wui-loading-spinner")], Tb);
const h2e = Wt `
  :host {
    display: block;
    width: var(--wui-box-size-md);
    height: var(--wui-box-size-md);
  }

  svg {
    width: var(--wui-box-size-md);
    height: var(--wui-box-size-md);
    transition: all var(--wui-ease-in-power-3) var(--wui-duration-lg);
  }

  rect {
    fill: none;
    stroke: var(--wui-color-accent-100);
    stroke-width: 4px;
    stroke-linecap: round;
    animation: dash 1s linear infinite;
  }

  @keyframes dash {
    to {
      stroke-dashoffset: 0px;
    }
  }
`;
var fee = function(t, e, n, r) {
    var i = arguments.length,
        s = i < 3 ? e : r === null ? r = Object.getOwnPropertyDescriptor(e, n) : r,
        o;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function") s = Reflect.decorate(t, e, n, r);
    else
        for (var a = t.length - 1; a >= 0; a--)(o = t[a]) && (s = (i < 3 ? o(s) : i > 3 ? o(e, n, s) : o(e, n)) || s);
    return i > 3 && s && Object.defineProperty(e, n, s), s
};
let m_ = class extends Zt {
    constructor() {
        super(...arguments), this.radius = 36
    }
    render() {
        return this.svgLoaderTemplate()
    }
    svgLoaderTemplate() {
        const e = this.radius > 50 ? 50 : this.radius,
            r = 36 - e,
            i = 116 + r,
            s = 245 + r,
            o = 360 + r * 1.75;
        return We `
      <svg viewBox="0 0 110 110" width="110" height="110">
        <rect
          x="2"
          y="2"
          width="106"
          height="106"
          rx=${e}
          stroke-dasharray="${i} ${s}"
          stroke-dashoffset=${o}
        />
      </svg>
    `
    }
};
m_.styles = [dn, h2e];
fee([xe({
    type: Number
})], m_.prototype, "radius", void 0);
m_ = fee([Qe("wui-loading-thumbnail")], m_);
const p2e = Wt `
  :host {
    display: block;
    box-shadow: inset 0 0 0 1px var(--wui-gray-glass-005);
    background: linear-gradient(
      120deg,
      var(--wui-color-bg-200) 5%,
      var(--wui-color-bg-200) 48%,
      var(--wui-color-bg-300) 55%,
      var(--wui-color-bg-300) 60%,
      var(--wui-color-bg-300) calc(60% + 10px),
      var(--wui-color-bg-200) calc(60% + 12px),
      var(--wui-color-bg-200) 100%
    );
    background-size: 250%;
    animation: shimmer 3s linear infinite reverse;
  }

  @keyframes shimmer {
    from {
      background-position: -250% 0;
    }
    to {
      background-position: 250% 0;
    }
  }
`;
var pT = function(t, e, n, r) {
    var i = arguments.length,
        s = i < 3 ? e : r === null ? r = Object.getOwnPropertyDescriptor(e, n) : r,
        o;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function") s = Reflect.decorate(t, e, n, r);
    else
        for (var a = t.length - 1; a >= 0; a--)(o = t[a]) && (s = (i < 3 ? o(s) : i > 3 ? o(e, n, s) : o(e, n)) || s);
    return i > 3 && s && Object.defineProperty(e, n, s), s
};
let pm = class extends Zt {
    constructor() {
        super(...arguments), this.width = "", this.height = "", this.borderRadius = "m"
    }
    render() {
        return this.style.cssText = `
      width: ${this.width};
      height: ${this.height};
      border-radius: ${`clamp(0px,var(--wui-border-radius-${this.borderRadius}), 40px)`};
    `, We `<slot></slot>`
    }
};
pm.styles = [p2e];
pT([xe()], pm.prototype, "width", void 0);
pT([xe()], pm.prototype, "height", void 0);
pT([xe()], pm.prototype, "borderRadius", void 0);
pm = pT([Qe("wui-shimmer")], pm);
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const dee = {
        ATTRIBUTE: 1,
        CHILD: 2,
        PROPERTY: 3,
        BOOLEAN_ATTRIBUTE: 4,
        EVENT: 5,
        ELEMENT: 6
    },
    hee = t => (...e) => ({
        _$litDirective$: t,
        values: e
    });
let pee = class {
    constructor(e) {}
    get _$AU() {
        return this._$AM._$AU
    }
    _$AT(e, n, r) {
        this.t = e, this._$AM = n, this.i = r
    }
    _$AS(e, n) {
        return this.update(e, n)
    }
    update(e, n) {
        return this.render(...n)
    }
};
/**
 * @license
 * Copyright 2018 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const g2e = hee(class extends pee {
        constructor(t) {
            var e;
            if (super(t), t.type !== dee.ATTRIBUTE || t.name !== "class" || ((e = t.strings) == null ? void 0 : e.length) > 2) throw Error("`classMap()` can only be used in the `class` attribute and must be the only part in the attribute.")
        }
        render(t) {
            return " " + Object.keys(t).filter(e => t[e]).join(" ") + " "
        }
        update(t, [e]) {
            var r, i;
            if (this.st === void 0) {
                this.st = new Set, t.strings !== void 0 && (this.nt = new Set(t.strings.join(" ").split(/\s/).filter(s => s !== "")));
                for (const s in e) e[s] && !((r = this.nt) != null && r.has(s)) && this.st.add(s);
                return this.render(e)
            }
            const n = t.element.classList;
            for (const s of this.st) s in e || (n.remove(s), this.st.delete(s));
            for (const s in e) {
                const o = !!e[s];
                o === this.st.has(s) || (i = this.nt) != null && i.has(s) || (o ? (n.add(s), this.st.add(s)) : (n.remove(s), this.st.delete(s)))
            }
            return dm
        }
    }),
    m2e = Wt `
  :host {
    display: flex !important;
  }

  slot {
    display: inline-block;
    font-style: normal;
    font-family: var(--wui-font-family);
    font-feature-settings:
      'tnum' on,
      'lnum' on,
      'case' on;
    line-height: 130%;
    font-weight: var(--wui-font-weight-regular);
    overflow: inherit;
    text-overflow: inherit;
    text-align: var(--local-align);
    color: var(--local-color);
  }

  .wui-font-large-500,
  .wui-font-large-600,
  .wui-font-large-700 {
    font-size: var(--wui-font-size-large);
    letter-spacing: var(--wui-letter-spacing-large);
  }

  .wui-font-paragraph-500,
  .wui-font-paragraph-600,
  .wui-font-paragraph-700 {
    font-size: var(--wui-font-size-paragraph);
    letter-spacing: var(--wui-letter-spacing-paragraph);
  }

  .wui-font-small-400,
  .wui-font-small-500,
  .wui-font-small-600 {
    font-size: var(--wui-font-size-small);
    letter-spacing: var(--wui-letter-spacing-small);
  }

  .wui-font-tiny-500,
  .wui-font-tiny-600 {
    font-size: var(--wui-font-size-tiny);
    letter-spacing: var(--wui-letter-spacing-tiny);
  }

  .wui-font-micro-700,
  .wui-font-micro-600 {
    font-size: var(--wui-font-size-micro);
    letter-spacing: var(--wui-letter-spacing-micro);
    text-transform: uppercase;
  }

  .wui-font-small-400,
  .wui-font-paragraph-400 {
    font-weight: var(--wui-font-weight-light);
  }

  .wui-font-large-700,
  .wui-font-paragraph-700,
  .wui-font-micro-700 {
    font-weight: var(--wui-font-weight-bold);
  }

  .wui-font-large-600,
  .wui-font-paragraph-600,
  .wui-font-small-600,
  .wui-font-tiny-600,
  .wui-font-micro-600 {
    font-weight: var(--wui-font-weight-medium);
  }
`;
var gT = function(t, e, n, r) {
    var i = arguments.length,
        s = i < 3 ? e : r === null ? r = Object.getOwnPropertyDescriptor(e, n) : r,
        o;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function") s = Reflect.decorate(t, e, n, r);
    else
        for (var a = t.length - 1; a >= 0; a--)(o = t[a]) && (s = (i < 3 ? o(s) : i > 3 ? o(e, n, s) : o(e, n)) || s);
    return i > 3 && s && Object.defineProperty(e, n, s), s
};
let gm = class extends Zt {
    constructor() {
        super(...arguments), this.variant = "paragraph-500", this.color = "fg-300", this.align = "left"
    }
    render() {
        const e = {
            [`wui-font-${this.variant}`]: !0,
            [`wui-color-${this.color}`]: !0
        };
        return this.style.cssText = `
      --local-align: ${this.align};
      --local-color: var(--wui-color-${this.color});
    `, We `<slot class=${g2e(e)}></slot>`
    }
};
gm.styles = [dn, m2e];
gT([xe()], gm.prototype, "variant", void 0);
gT([xe()], gm.prototype, "color", void 0);
gT([xe()], gm.prototype, "align", void 0);
gm = gT([Qe("wui-text")], gm);
const y2e = pt `<svg fill="none" viewBox="0 0 60 60">
  <rect width="60" height="60" fill="#1DC956" rx="30" />
  <circle cx="30" cy="30" r="3" fill="#fff" />
  <path
    fill="#2BEE6C"
    stroke="#fff"
    stroke-width="2"
    d="m45.32 17.9-.88-.42.88.42.02-.05c.1-.2.21-.44.26-.7l-.82-.15.82.16a2 2 0 0 0-.24-1.4c-.13-.23-.32-.42-.47-.57a8.42 8.42 0 0 1-.04-.04l-.04-.04a2.9 2.9 0 0 0-.56-.47l-.51.86.5-.86a2 2 0 0 0-1.4-.24c-.26.05-.5.16-.69.26l-.05.02-15.05 7.25-.1.05c-1.14.55-1.85.89-2.46 1.37a7 7 0 0 0-1.13 1.14c-.5.6-.83 1.32-1.38 2.45l-.05.11-7.25 15.05-.02.05c-.1.2-.21.43-.26.69a2 2 0 0 0 .24 1.4l.85-.5-.85.5c.13.23.32.42.47.57l.04.04.04.04c.15.15.34.34.56.47a2 2 0 0 0 1.41.24l-.2-.98.2.98c.25-.05.5-.17.69-.26l.05-.02-.42-.87.42.87 15.05-7.25.1-.05c1.14-.55 1.85-.89 2.46-1.38a7 7 0 0 0 1.13-1.13 12.87 12.87 0 0 0 1.43-2.56l7.25-15.05Z"
  />
  <path
    fill="#1DC956"
    d="M33.38 32.72 30.7 29.3 15.86 44.14l.2.2a1 1 0 0 0 1.14.2l15.1-7.27a3 3 0 0 0 1.08-4.55Z"
  />
  <path
    fill="#86F999"
    d="m26.62 27.28 2.67 3.43 14.85-14.85-.2-.2a1 1 0 0 0-1.14-.2l-15.1 7.27a3 3 0 0 0-1.08 4.55Z"
  />
  <circle cx="30" cy="30" r="3" fill="#fff" transform="rotate(45 30 30)" />
  <rect width="59" height="59" x=".5" y=".5" stroke="#062B2B" stroke-opacity=".1" rx="29.5" />
</svg> `,
    w2e = pt `<svg viewBox="0 0 60 60" fill="none">
  <g clip-path="url(#clip0_7734_50402)">
    <path
      d="M0 24.9C0 15.6485 0 11.0228 1.97053 7.56812C3.3015 5.23468 5.23468 3.3015 7.56812 1.97053C11.0228 0 15.6485 0 24.9 0H35.1C44.3514 0 48.9772 0 52.4319 1.97053C54.7653 3.3015 56.6985 5.23468 58.0295 7.56812C60 11.0228 60 15.6485 60 24.9V35.1C60 44.3514 60 48.9772 58.0295 52.4319C56.6985 54.7653 54.7653 56.6985 52.4319 58.0295C48.9772 60 44.3514 60 35.1 60H24.9C15.6485 60 11.0228 60 7.56812 58.0295C5.23468 56.6985 3.3015 54.7653 1.97053 52.4319C0 48.9772 0 44.3514 0 35.1V24.9Z"
      fill="#EB8B47"
    />
    <path
      d="M0.5 24.9C0.5 20.2652 0.50047 16.8221 0.744315 14.105C0.987552 11.3946 1.46987 9.45504 2.40484 7.81585C3.69145 5.56019 5.56019 3.69145 7.81585 2.40484C9.45504 1.46987 11.3946 0.987552 14.105 0.744315C16.8221 0.50047 20.2652 0.5 24.9 0.5H35.1C39.7348 0.5 43.1779 0.50047 45.895 0.744315C48.6054 0.987552 50.545 1.46987 52.1841 2.40484C54.4398 3.69145 56.3086 5.56019 57.5952 7.81585C58.5301 9.45504 59.0124 11.3946 59.2557 14.105C59.4995 16.8221 59.5 20.2652 59.5 24.9V35.1C59.5 39.7348 59.4995 43.1779 59.2557 45.895C59.0124 48.6054 58.5301 50.545 57.5952 52.1841C56.3086 54.4398 54.4398 56.3086 52.1841 57.5952C50.545 58.5301 48.6054 59.0124 45.895 59.2557C43.1779 59.4995 39.7348 59.5 35.1 59.5H24.9C20.2652 59.5 16.8221 59.4995 14.105 59.2557C11.3946 59.0124 9.45504 58.5301 7.81585 57.5952C5.56019 56.3086 3.69145 54.4398 2.40484 52.1841C1.46987 50.545 0.987552 48.6054 0.744315 45.895C0.50047 43.1779 0.5 39.7348 0.5 35.1V24.9Z"
      stroke="#062B2B"
      stroke-opacity="0.1"
    />
    <path
      d="M19 52C24.5228 52 29 47.5228 29 42C29 36.4772 24.5228 32 19 32C13.4772 32 9 36.4772 9 42C9 47.5228 13.4772 52 19 52Z"
      fill="#FF974C"
      stroke="white"
      stroke-width="2"
    />
    <path
      fill-rule="evenodd"
      clip-rule="evenodd"
      d="M42.8437 8.3264C42.4507 7.70891 41.5493 7.70891 41.1564 8.32641L28.978 27.4638C28.5544 28.1295 29.0326 29.0007 29.8217 29.0007H54.1783C54.9674 29.0007 55.4456 28.1295 55.022 27.4638L42.8437 8.3264Z"
      fill="white"
    />
    <path
      fill-rule="evenodd"
      clip-rule="evenodd"
      d="M42.3348 11.6456C42.659 11.7608 42.9061 12.1492 43.4005 12.926L50.7332 24.4488C51.2952 25.332 51.5763 25.7737 51.5254 26.1382C51.4915 26.3808 51.3698 26.6026 51.1833 26.7614C50.9031 27 50.3796 27 49.3327 27H34.6673C33.6204 27 33.0969 27 32.8167 26.7614C32.6302 26.6026 32.5085 26.3808 32.4746 26.1382C32.4237 25.7737 32.7048 25.332 33.2669 24.4488L40.5995 12.926C41.0939 12.1492 41.341 11.7608 41.6652 11.6456C41.8818 11.5687 42.1182 11.5687 42.3348 11.6456ZM35.0001 26.999C38.8661 26.999 42.0001 23.865 42.0001 19.999C42.0001 23.865 45.1341 26.999 49.0001 26.999H35.0001Z"
      fill="#FF974C"
    />
    <path
      d="M10.1061 9.35712C9.9973 9.67775 9.99867 10.0388 9.99978 10.3323C9.99989 10.3611 10 10.3893 10 10.4167V25.5833C10 25.6107 9.99989 25.6389 9.99978 25.6677C9.99867 25.9612 9.9973 26.3222 10.1061 26.6429C10.306 27.2317 10.7683 27.694 11.3571 27.8939C11.6777 28.0027 12.0388 28.0013 12.3323 28.0002C12.3611 28.0001 12.3893 28 12.4167 28H19C24.5228 28 29 23.5228 29 18C29 12.4772 24.5228 8 19 8H12.4167C12.3893 8 12.3611 7.99989 12.3323 7.99978C12.0388 7.99867 11.6778 7.9973 11.3571 8.10614C10.7683 8.306 10.306 8.76834 10.1061 9.35712Z"
      fill="#FF974C"
      stroke="white"
      stroke-width="2"
    />
    <circle cx="19" cy="18" r="4" fill="#EB8B47" stroke="white" stroke-width="2" />
    <circle cx="19" cy="42" r="4" fill="#EB8B47" stroke="white" stroke-width="2" />
  </g>
  <defs>
    <clipPath id="clip0_7734_50402">
      <rect width="60" height="60" fill="white" />
    </clipPath>
  </defs>
</svg> `,
    v2e = pt `<svg fill="none" viewBox="0 0 60 60">
  <g clip-path="url(#a)">
    <path
      fill="#1DC956"
      d="M0 25.01c0-9.25 0-13.88 1.97-17.33a15 15 0 0 1 5.6-5.6C11.02.11 15.65.11 24.9.11h10.2c9.25 0 13.88 0 17.33 1.97a15 15 0 0 1 5.6 5.6C60 11.13 60 15.76 60 25v10.2c0 9.25 0 13.88-1.97 17.33a15 15 0 0 1-5.6 5.6c-3.45 1.97-8.08 1.97-17.33 1.97H24.9c-9.25 0-13.88 0-17.33-1.97a15 15 0 0 1-5.6-5.6C0 49.1 0 44.46 0 35.21v-10.2Z"
    />
    <path
      fill="#2BEE6C"
      d="M16.1 60c-3.82-.18-6.4-.64-8.53-1.86a15 15 0 0 1-5.6-5.6C.55 50.06.16 46.97.04 41.98L4.2 40.6a4 4 0 0 0 2.48-2.39l4.65-12.4a2 2 0 0 1 2.5-1.2l2.53.84a2 2 0 0 0 2.43-1l2.96-5.94a2 2 0 0 1 3.7.32l3.78 12.58a2 2 0 0 0 3.03 1.09l3.34-2.23a2 2 0 0 0 .65-.7l5.3-9.72a2 2 0 0 1 1.42-1.01l4.14-.69a2 2 0 0 1 1.6.44l3.9 3.24a2 2 0 0 0 2.7-.12l4.62-4.63c.08 2.2.08 4.8.08 7.93v10.2c0 9.25 0 13.88-1.97 17.33a15 15 0 0 1-5.6 5.6c-2.13 1.22-4.7 1.68-8.54 1.86H16.11Z"
    />
    <path
      fill="#fff"
      d="m.07 43.03-.05-2.1 3.85-1.28a3 3 0 0 0 1.86-1.79l4.66-12.4a3 3 0 0 1 3.75-1.8l2.53.84a1 1 0 0 0 1.21-.5l2.97-5.94a3 3 0 0 1 5.56.48l3.77 12.58a1 1 0 0 0 1.51.55l3.34-2.23a1 1 0 0 0 .33-.35l5.3-9.71a3 3 0 0 1 2.14-1.53l4.13-.69a3 3 0 0 1 2.41.66l3.9 3.24a1 1 0 0 0 1.34-.06l5.28-5.28c.05.85.08 1.75.1 2.73L56 22.41a3 3 0 0 1-4.04.19l-3.9-3.25a1 1 0 0 0-.8-.21l-4.13.69a1 1 0 0 0-.72.5l-5.3 9.72a3 3 0 0 1-.97 1.05l-3.34 2.23a3 3 0 0 1-4.53-1.63l-3.78-12.58a1 1 0 0 0-1.85-.16l-2.97 5.94a3 3 0 0 1-3.63 1.5l-2.53-.84a1 1 0 0 0-1.25.6l-4.65 12.4a5 5 0 0 1-3.1 3L.07 43.02Z"
    />
    <path
      fill="#fff"
      fill-rule="evenodd"
      d="M49.5 19a5.5 5.5 0 1 1-11 0 5.5 5.5 0 0 1 11 0Z"
      clip-rule="evenodd"
    />
    <path fill="#fff" d="M45 .28v59.66l-2 .1V.19c.7.02 1.37.05 2 .1Z" />
    <path fill="#2BEE6C" d="M47.5 19a3.5 3.5 0 1 1-7 0 3.5 3.5 0 0 1 7 0Z" />
    <path
      stroke="#fff"
      stroke-opacity=".1"
      d="M.5 25.01c0-4.63 0-8.08.24-10.8.25-2.7.73-4.64 1.66-6.28a14.5 14.5 0 0 1 5.42-5.41C9.46 1.58 11.39 1.1 14.1.85A133 133 0 0 1 24.9.61h10.2c4.63 0 8.08 0 10.8.24 2.7.25 4.65.73 6.28 1.67a14.5 14.5 0 0 1 5.42 5.4c.93 1.65 1.41 3.58 1.66 6.3.24 2.71.24 6.16.24 10.79v10.2c0 4.64 0 8.08-.24 10.8-.25 2.7-.73 4.65-1.66 6.28a14.5 14.5 0 0 1-5.42 5.42c-1.63.93-3.57 1.41-6.28 1.66-2.72.24-6.17.24-10.8.24H24.9c-4.63 0-8.08 0-10.8-.24-2.7-.25-4.64-.73-6.28-1.66a14.5 14.5 0 0 1-5.42-5.42C1.47 50.66 1 48.72.74 46.01A133 133 0 0 1 .5 35.2v-10.2Z"
    />
  </g>
  <defs>
    <clipPath id="a"><path fill="#fff" d="M0 0h60v60H0z" /></clipPath>
  </defs>
</svg>`,
    b2e = pt `<svg fill="none" viewBox="0 0 60 60">
  <g clip-path="url(#a)">
    <rect width="60" height="60" fill="#C653C6" rx="30" />
    <path
      fill="#E87DE8"
      d="M57.98.01v19.5a4.09 4.09 0 0 0-2.63 2.29L50.7 34.2a2 2 0 0 1-2.5 1.2l-2.53-.84a2 2 0 0 0-2.42 1l-2.97 5.94a2 2 0 0 1-3.7-.32L32.8 28.6a2 2 0 0 0-3.02-1.09l-3.35 2.23a2 2 0 0 0-.64.7l-5.3 9.72a2 2 0 0 1-1.43 1.01l-4.13.69a2 2 0 0 1-1.61-.44l-3.9-3.24a2 2 0 0 0-2.69.12L2.1 42.93.02 43V.01h57.96Z"
    />
    <path
      fill="#fff"
      d="m61.95 16.94.05 2.1-3.85 1.28a3 3 0 0 0-1.86 1.79l-4.65 12.4a3 3 0 0 1-3.76 1.8l-2.53-.84a1 1 0 0 0-1.2.5l-2.98 5.94a3 3 0 0 1-5.55-.48l-3.78-12.58a1 1 0 0 0-1.5-.55l-3.35 2.23a1 1 0 0 0-.32.35l-5.3 9.72a3 3 0 0 1-2.14 1.52l-4.14.69a3 3 0 0 1-2.41-.66l-3.9-3.24a1 1 0 0 0-1.34.06l-5.28 5.28c-.05-.84-.08-1.75-.1-2.73l3.97-3.96a3 3 0 0 1 4.04-.19l3.89 3.25a1 1 0 0 0 .8.21l4.14-.68a1 1 0 0 0 .71-.51l5.3-9.71a3 3 0 0 1 .97-1.06l3.34-2.23a3 3 0 0 1 4.54 1.63l3.77 12.58a1 1 0 0 0 1.86.16l2.96-5.93a3 3 0 0 1 3.64-1.5l2.52.83a1 1 0 0 0 1.25-.6l4.66-12.4a5 5 0 0 1 3.1-2.99l4.43-1.48Z"
    />
    <path
      fill="#fff"
      fill-rule="evenodd"
      d="M35.5 27a5.5 5.5 0 1 1-11 0 5.5 5.5 0 0 1 11 0Z"
      clip-rule="evenodd"
    />
    <path fill="#fff" d="M31 0v60h-2V0h2Z" />
    <path fill="#E87DE8" d="M33.5 27a3.5 3.5 0 1 1-7 0 3.5 3.5 0 0 1 7 0Z" />
  </g>
  <rect width="59" height="59" x=".5" y=".5" stroke="#fff" stroke-opacity=".1" rx="29.5" />
  <defs>
    <clipPath id="a"><rect width="60" height="60" fill="#fff" rx="30" /></clipPath>
  </defs>
</svg> `,
    _2e = pt `<svg fill="none" viewBox="0 0 60 60">
  <g clip-path="url(#a)">
    <rect width="60" height="60" fill="#987DE8" rx="30" />
    <path
      fill="#fff"
      fill-rule="evenodd"
      d="m15.48 28.37 11.97-19.3a3 3 0 0 1 5.1 0l11.97 19.3a6 6 0 0 1 .9 3.14v.03a6 6 0 0 1-1.16 3.56L33.23 50.2a4 4 0 0 1-6.46 0L15.73 35.1a6 6 0 0 1-1.15-3.54v-.03a6 6 0 0 1 .9-3.16Z"
      clip-rule="evenodd"
    />
    <path
      fill="#643CDD"
      d="M30.84 10.11a1 1 0 0 0-.84-.46V24.5l12.6 5.53a2 2 0 0 0-.28-1.4L30.84 10.11Z"
    />
    <path
      fill="#BDADEB"
      d="M30 9.65a1 1 0 0 0-.85.46L17.66 28.64a2 2 0 0 0-.26 1.39L30 24.5V9.65Z"
    />
    <path
      fill="#643CDD"
      d="M30 50.54a1 1 0 0 0 .8-.4l11.24-15.38c.3-.44-.2-1-.66-.73l-9.89 5.68a3 3 0 0 1-1.5.4v10.43Z"
    />
    <path
      fill="#BDADEB"
      d="m17.97 34.76 11.22 15.37c.2.28.5.41.8.41V40.11a3 3 0 0 1-1.49-.4l-9.88-5.68c-.47-.27-.97.3-.65.73Z"
    />
    <path
      fill="#401AB3"
      d="M42.6 30.03 30 24.5v13.14a3 3 0 0 0 1.5-.4l10.14-5.83a2 2 0 0 0 .95-1.38Z"
    />
    <path
      fill="#7C5AE2"
      d="M30 37.64V24.46l-12.6 5.57a2 2 0 0 0 .97 1.39l10.13 5.82a3 3 0 0 0 1.5.4Z"
    />
  </g>
  <rect width="59" height="59" x=".5" y=".5" stroke="#fff" stroke-opacity=".1" rx="29.5" />
  <defs>
    <clipPath id="a"><rect width="60" height="60" fill="#fff" rx="30" /></clipPath>
  </defs>
</svg> `,
    E2e = pt `<svg fill="none" viewBox="0 0 60 60">
  <rect width="60" height="60" fill="#1DC956" rx="3" />
  <path
    fill="#1FAD7E"
    stroke="#fff"
    stroke-width="2"
    d="m30.49 29.13-.49-.27-.49.27-12.77 7.1-.05.02c-.86.48-1.58.88-2.1 1.24-.54.37-1.04.81-1.28 1.45a3 3 0 0 0 0 2.12c.24.63.74 1.08 1.27 1.45.53.36 1.25.76 2.11 1.24l.05.03 6.33 3.51.17.1c2.33 1.3 3.72 2.06 5.22 2.32a9 9 0 0 0 3.08 0c1.5-.26 2.9-1.03 5.22-2.32l.18-.1 6.32-3.51.05-.03a26.9 26.9 0 0 0 2.1-1.24 3.21 3.21 0 0 0 1.28-1.45l-.94-.35.94.35a3 3 0 0 0 0-2.12l-.94.35.94-.35a3.21 3.21 0 0 0-1.27-1.45c-.53-.36-1.25-.76-2.11-1.24l-.05-.03-12.77-7.1Z"
  />
  <path
    fill="#2BEE6C"
    stroke="#fff"
    stroke-width="2"
    d="m30.49 19.13-.49-.27-.49.27-12.77 7.1-.05.02c-.86.48-1.58.88-2.1 1.24-.54.37-1.04.81-1.28 1.45a3 3 0 0 0 0 2.12c.24.63.74 1.08 1.27 1.45.53.36 1.25.76 2.11 1.24l.05.03 6.33 3.51.17.1c2.33 1.3 3.72 2.06 5.22 2.32a9 9 0 0 0 3.08 0c1.5-.26 2.9-1.03 5.22-2.32l.18-.1 6.32-3.51.05-.03a26.9 26.9 0 0 0 2.1-1.24 3.21 3.21 0 0 0 1.28-1.45l-.94-.35.94.35a3 3 0 0 0 0-2.12l-.94.35.94-.35a3.21 3.21 0 0 0-1.27-1.45c-.53-.36-1.25-.76-2.11-1.24l-.05-.03-12.77-7.1Z"
  />
  <path
    fill="#86F999"
    stroke="#fff"
    stroke-width="2"
    d="m46.69 21.06-.94-.35.94.35a3 3 0 0 0 0-2.12l-.94.35.94-.35a3.21 3.21 0 0 0-1.27-1.45c-.53-.36-1.25-.76-2.11-1.24l-.05-.03-6.32-3.51-.18-.1c-2.33-1.3-3.72-2.06-5.22-2.33a9 9 0 0 0-3.08 0c-1.5.27-2.9 1.04-5.22 2.33l-.17.1-6.33 3.51-.05.03c-.86.48-1.58.88-2.1 1.24-.54.37-1.04.81-1.28 1.45a3 3 0 0 0 0 2.12c.24.63.74 1.08 1.27 1.45.53.36 1.25.76 2.11 1.24l.05.03 6.33 3.51.17.1c2.33 1.3 3.72 2.06 5.22 2.32a9 9 0 0 0 3.08 0c1.5-.26 2.9-1.03 5.22-2.32l.18-.1 6.32-3.51.05-.03a26.9 26.9 0 0 0 2.1-1.24 3.21 3.21 0 0 0 1.28-1.45Z"
  />
  <rect width="59" height="59" x=".5" y=".5" stroke="#fff" stroke-opacity=".1" rx="2.5" />
</svg>`,
    x2e = pt `<svg fill="none" viewBox="0 0 60 60">
  <rect width="60" height="60" fill="#C653C6" rx="3" />
  <path
    fill="#fff"
    d="M20.03 15.22C20 15.6 20 16.07 20 17v2.8c0 1.14 0 1.7-.2 2.12-.15.31-.3.5-.58.71-.37.28-1.06.42-2.43.7-.59.12-1.11.29-1.6.51a9 9 0 0 0-4.35 4.36C10 30 10 32.34 10 37c0 4.66 0 7 .84 8.8a9 9 0 0 0 4.36 4.36C17 51 19.34 51 24 51h12c4.66 0 7 0 8.8-.84a9 9 0 0 0 4.36-4.36C50 44 50 41.66 50 37c0-4.66 0-7-.84-8.8a9 9 0 0 0-4.36-4.36c-.48-.22-1-.39-1.6-.5-1.36-.29-2.05-.43-2.42-.7-.27-.22-.43-.4-.58-.72-.2-.42-.2-.98-.2-2.11V17c0-.93 0-1.4-.03-1.78a9 9 0 0 0-8.19-8.19C31.4 7 30.93 7 30 7s-1.4 0-1.78.03a9 9 0 0 0-8.19 8.19Z"
  />
  <path
    fill="#E87DE8"
    d="M22 17c0-.93 0-1.4.04-1.78a7 7 0 0 1 6.18-6.18C28.6 9 29.07 9 30 9s1.4 0 1.78.04a7 7 0 0 1 6.18 6.18c.04.39.04.85.04 1.78v4.5a1.5 1.5 0 0 1-3 0V17c0-.93 0-1.4-.08-1.78a4 4 0 0 0-3.14-3.14C31.39 12 30.93 12 30 12s-1.4 0-1.78.08a4 4 0 0 0-3.14 3.14c-.08.39-.08.85-.08 1.78v4.5a1.5 1.5 0 0 1-3 0V17Z"
  />
  <path
    fill="#E87DE8"
    fill-rule="evenodd"
    d="M12 36.62c0-4.32 0-6.48.92-8.09a7 7 0 0 1 2.61-2.61C17.14 25 19.3 25 23.62 25h6.86c.46 0 .7 0 .9.02 2.73.22 4.37 2.43 4.62 4.98.27-2.7 2.11-5 5.02-5A6.98 6.98 0 0 1 48 31.98v5.4c0 4.32 0 6.48-.92 8.09a7 7 0 0 1-2.61 2.61c-1.61.92-3.77.92-8.09.92h-5.86c-.46 0-.7 0-.9-.02-2.73-.22-4.37-2.43-4.62-4.98-.26 2.58-1.94 4.82-4.71 4.99l-.7.01c-.55 0-.82 0-1.05-.02a7 7 0 0 1-6.52-6.52c-.02-.23-.02-.5-.02-1.05v-4.79Zm21.24-.27a4 4 0 1 0-6.48 0 31.28 31.28 0 0 1 1.57 2.23c.17.4.17.81.17 1.24V42.5a1.5 1.5 0 0 0 3 0V39.82c0-.43 0-.85.17-1.24.09-.2.58-.87 1.57-2.23Z"
    clip-rule="evenodd"
  />
  <rect width="59" height="59" x=".5" y=".5" stroke="#fff" stroke-opacity=".1" rx="2.5" />
</svg>`,
    S2e = pt `<svg fill="none" viewBox="0 0 60 60">
  <g clip-path="url(#a)">
    <path
      fill="#EB8B47"
      d="M0 24.9c0-9.25 0-13.88 1.97-17.33a15 15 0 0 1 5.6-5.6C11.02 0 15.65 0 24.9 0h10.2c9.25 0 13.88 0 17.33 1.97a15 15 0 0 1 5.6 5.6C60 11.02 60 15.65 60 24.9v10.2c0 9.25 0 13.88-1.97 17.33a15 15 0 0 1-5.6 5.6C48.98 60 44.35 60 35.1 60H24.9c-9.25 0-13.88 0-17.33-1.97a15 15 0 0 1-5.6-5.6C0 48.98 0 44.35 0 35.1V24.9Z"
    />
    <path
      stroke="#062B2B"
      stroke-opacity=".1"
      d="M.5 24.9c0-4.64 0-8.08.24-10.8.25-2.7.73-4.65 1.66-6.28A14.5 14.5 0 0 1 7.82 2.4C9.46 1.47 11.39 1 14.1.74A133 133 0 0 1 24.9.5h10.2c4.63 0 8.08 0 10.8.24 2.7.25 4.65.73 6.28 1.66a14.5 14.5 0 0 1 5.42 5.42c.93 1.63 1.41 3.57 1.66 6.28.24 2.72.24 6.16.24 10.8v10.2c0 4.63 0 8.08-.24 10.8-.25 2.7-.73 4.64-1.66 6.28a14.5 14.5 0 0 1-5.42 5.41c-1.63.94-3.57 1.42-6.28 1.67-2.72.24-6.17.24-10.8.24H24.9c-4.63 0-8.08 0-10.8-.24-2.7-.25-4.64-.73-6.28-1.67a14.5 14.5 0 0 1-5.42-5.4C1.47 50.53 1 48.6.74 45.88A133 133 0 0 1 .5 35.1V24.9Z"
    />
    <path
      fill="#FF974C"
      stroke="#fff"
      stroke-width="2"
      d="M39.2 29.2a13 13 0 1 0-18.4 0l1.3 1.28a12.82 12.82 0 0 1 2.1 2.39 6 6 0 0 1 .6 1.47c.2.76.2 1.56.2 3.17v11.24c0 1.08 0 1.61.13 2.12a4 4 0 0 0 .41.98c.26.45.64.83 1.4 1.6l.3.29c.65.65.98.98 1.36 1.09.26.07.54.07.8 0 .38-.11.7-.44 1.36-1.1l3.48-3.47c.65-.65.98-.98 1.09-1.36a1.5 1.5 0 0 0 0-.8c-.1-.38-.44-.7-1.1-1.36l-.47-.48c-.65-.65-.98-.98-1.09-1.36a1.5 1.5 0 0 1 0-.8c.1-.38.44-.7 1.1-1.36l.47-.48c.65-.65.98-.98 1.09-1.36a1.5 1.5 0 0 0 0-.8c-.1-.38-.44-.7-1.1-1.36l-.48-.5c-.65-.64-.98-.97-1.08-1.35a1.5 1.5 0 0 1 0-.79c.1-.38.42-.7 1.06-1.36l5.46-5.55Z"
    />
    <circle cx="30" cy="17" r="4" fill="#EB8B47" stroke="#fff" stroke-width="2" />
  </g>
  <defs>
    <clipPath id="a"><path fill="#fff" d="M0 0h60v60H0z" /></clipPath>
  </defs>
</svg> `,
    C2e = pt `<svg fill="none" viewBox="0 0 60 60">
  <g clip-path="url(#a)">
    <rect width="60" height="60" fill="#00ACE6" rx="30" />
    <circle cx="64" cy="39" r="50" fill="#1AC6FF" stroke="#fff" stroke-width="2" />
    <circle cx="78" cy="30" r="50" fill="#4DD2FF" stroke="#fff" stroke-width="2" />
    <circle cx="72" cy="15" r="35" fill="#80DFFF" stroke="#fff" stroke-width="2" />
    <circle cx="34" cy="-17" r="45" stroke="#fff" stroke-width="2" />
    <circle cx="34" cy="-5" r="50" stroke="#fff" stroke-width="2" />
    <circle cx="30" cy="45" r="4" fill="#4DD2FF" stroke="#fff" stroke-width="2" />
    <circle cx="39.5" cy="27.5" r="4" fill="#80DFFF" stroke="#fff" stroke-width="2" />
    <circle cx="16" cy="24" r="4" fill="#19C6FF" stroke="#fff" stroke-width="2" />
  </g>
  <rect width="59" height="59" x=".5" y=".5" stroke="#062B2B" stroke-opacity=".1" rx="29.5" />
  <defs>
    <clipPath id="a"><rect width="60" height="60" fill="#fff" rx="30" /></clipPath>
  </defs>
</svg>`,
    A2e = pt `<svg fill="none" viewBox="0 0 60 60">
  <g clip-path="url(#a)">
    <rect width="60" height="60" fill="#C653C6" rx="3" />
    <path
      fill="#E87DE8"
      stroke="#fff"
      stroke-width="2"
      d="M52.1 47.34c0-4.24-1.44-9.55-5.9-12.4a2.86 2.86 0 0 0-1.6-3.89v-.82c0-1.19-.52-2.26-1.35-3a4.74 4.74 0 0 0-2.4-6.26v-5.5a11.31 11.31 0 1 0-22.63 0v2.15a3.34 3.34 0 0 0-1.18 5.05 4.74 4.74 0 0 0-.68 6.44A5.22 5.22 0 0 0 14 35.92c-3.06 4.13-6.1 8.3-6.1 15.64 0 2.67.37 4.86.74 6.39a20.3 20.3 0 0 0 .73 2.39l.02.04v.01l.92-.39-.92.4.26.6h38.26l.3-.49-.87-.51.86.5.02-.01.03-.07a16.32 16.32 0 0 0 .57-1.05c.36-.72.85-1.74 1.33-2.96a25.51 25.51 0 0 0 1.94-9.07Z"
    />
    <path
      fill="#fff"
      fill-rule="evenodd"
      d="M26.5 29.5c-3-.5-5.5-3-5.5-7v-7c0-.47 0-.7.03-.9a3 3 0 0 1 2.58-2.57c.2-.03.42-.03.89-.03 2 0 2.5-2.5 2.5-2.5s0 2.5 2.5 2.5c1.4 0 2.1 0 2.65.23a3 3 0 0 1 1.62 1.62c.23.55.23 1.25.23 2.65v6c0 4-3 7-6.5 7 1.35.23 4 0 6.5-2v9.53C34 38.5 31.5 40 28 40s-6-1.5-6-2.97L24 34l2.5 1.5v-6ZM26 47h4.5c2.5 0 3 4 3 5.5h-3l-1-1.5H26v-4Zm-6.25 5.5H24V57h-8c0-1 1-4.5 3.75-4.5Z"
      clip-rule="evenodd"
    />
  </g>
  <rect width="59" height="59" x=".5" y=".5" stroke="#fff" stroke-opacity=".1" rx="2.5" />
  <defs>
    <clipPath id="a"><rect width="60" height="60" fill="#fff" rx="3" /></clipPath>
  </defs>
</svg> `,
    T2e = pt `<svg fill="none" viewBox="0 0 60 60">
  <rect width="60" height="60" fill="#794CFF" rx="3" />
  <path
    fill="#987DE8"
    stroke="#fff"
    stroke-width="2"
    d="M33 22.5v-1H16v5H8.5V36H13v-5h3v7.5h17V31h1v7.5h17v-17H34v5h-1v-4Z"
  />
  <path fill="#fff" d="M37.5 25h10v10h-10z" />
  <path fill="#4019B2" d="M42.5 25h5v10h-5z" />
  <path fill="#fff" d="M19.5 25h10v10h-10z" />
  <path fill="#4019B2" d="M24.5 25h5v10h-5z" />
  <path fill="#fff" d="M12 30.5h4V37h-4v-6.5Z" />
  <rect width="59" height="59" x=".5" y=".5" stroke="#fff" stroke-opacity=".1" rx="2.5" />
</svg>`,
    I2e = pt `<svg
  viewBox="0 0 60 60"
  fill="none"
>
  <g clip-path="url(#1)">
    <rect width="60" height="60" rx="30" fill="#00ACE6" />
    <path
      d="M59 73C59 89.0163 46.0163 102 30 102C13.9837 102 1 89.0163 1 73C1 56.9837 12 44 30 44C48 44 59 56.9837 59 73Z"
      fill="#1AC6FF"
      stroke="white"
      stroke-width="2"
    />
    <path
      d="M18.6904 19.9015C19.6264 15.3286 23.3466 11.8445 27.9708 11.2096C29.3231 11.024 30.6751 11.0238 32.0289 11.2096C36.6532 11.8445 40.3733 15.3286 41.3094 19.9015C41.4868 20.7681 41.6309 21.6509 41.7492 22.5271C41.8811 23.5041 41.8811 24.4944 41.7492 25.4715C41.6309 26.3476 41.4868 27.2304 41.3094 28.097C40.3733 32.6699 36.6532 36.154 32.0289 36.7889C30.6772 36.9744 29.3216 36.9743 27.9708 36.7889C23.3466 36.154 19.6264 32.6699 18.6904 28.097C18.513 27.2304 18.3689 26.3476 18.2506 25.4715C18.1186 24.4944 18.1186 23.5041 18.2506 22.5271C18.3689 21.6509 18.513 20.7681 18.6904 19.9015Z"
      fill="#1AC6FF"
      stroke="white"
      stroke-width="2"
    />
    <circle cx="24.5" cy="23.5" r="1.5" fill="white" />
    <circle cx="35.5" cy="23.5" r="1.5" fill="white" />
    <path
      d="M31 20L28 28H32"
      stroke="white"
      stroke-width="2"
      stroke-linecap="round"
      stroke-linejoin="round"
    />
  </g>
  <rect x="0.5" y="0.5" width="59" height="59" rx="29.5" stroke="white" stroke-opacity="0.1" />
  <defs>
    <clipPath id="1">
      <rect width="60" height="60" rx="30" fill="white" />
    </clipPath>
  </defs>
</svg> `,
    R2e = pt `<svg viewBox="0 0 60 60" fill="none">
  <g clip-path="url(#1)">
    <path
      d="M0 24.9C0 15.6485 0 11.0228 1.97053 7.56812C3.3015 5.23468 5.23468 3.3015 7.56812 1.97053C11.0228 0 15.6485 0 24.9 0H35.1C44.3514 0 48.9772 0 52.4319 1.97053C54.7653 3.3015 56.6985 5.23468 58.0295 7.56812C60 11.0228 60 15.6485 60 24.9V35.1C60 44.3514 60 48.9772 58.0295 52.4319C56.6985 54.7653 54.7653 56.6985 52.4319 58.0295C48.9772 60 44.3514 60 35.1 60H24.9C15.6485 60 11.0228 60 7.56812 58.0295C5.23468 56.6985 3.3015 54.7653 1.97053 52.4319C0 48.9772 0 44.3514 0 35.1V24.9Z"
      fill="#794CFF"
    />
    <path
      d="M0.5 24.9C0.5 20.2652 0.50047 16.8221 0.744315 14.105C0.987552 11.3946 1.46987 9.45504 2.40484 7.81585C3.69145 5.56019 5.56019 3.69145 7.81585 2.40484C9.45504 1.46987 11.3946 0.987552 14.105 0.744315C16.8221 0.50047 20.2652 0.5 24.9 0.5H35.1C39.7348 0.5 43.1779 0.50047 45.895 0.744315C48.6054 0.987552 50.545 1.46987 52.1841 2.40484C54.4398 3.69145 56.3086 5.56019 57.5952 7.81585C58.5301 9.45504 59.0124 11.3946 59.2557 14.105C59.4995 16.8221 59.5 20.2652 59.5 24.9V35.1C59.5 39.7348 59.4995 43.1779 59.2557 45.895C59.0124 48.6054 58.5301 50.545 57.5952 52.1841C56.3086 54.4398 54.4398 56.3086 52.1841 57.5952C50.545 58.5301 48.6054 59.0124 45.895 59.2557C43.1779 59.4995 39.7348 59.5 35.1 59.5H24.9C20.2652 59.5 16.8221 59.4995 14.105 59.2557C11.3946 59.0124 9.45504 58.5301 7.81585 57.5952C5.56019 56.3086 3.69145 54.4398 2.40484 52.1841C1.46987 50.545 0.987552 48.6054 0.744315 45.895C0.50047 43.1779 0.5 39.7348 0.5 35.1V24.9Z"
      stroke="#062B2B"
      stroke-opacity="0.1"
    />
    <path
      d="M35.1403 31.5016C35.1193 30.9637 35.388 30.4558 35.8446 30.1707C36.1207 29.9982 36.4761 29.8473 36.7921 29.7685C37.3143 29.6382 37.8664 29.7977 38.2386 30.1864C38.8507 30.8257 39.3004 31.6836 39.8033 32.408C40.2796 33.0942 41.4695 33.2512 41.9687 32.5047C42.4839 31.7341 42.9405 30.8229 43.572 30.1399C43.9375 29.7447 44.4866 29.5756 45.0111 29.6967C45.3283 29.7701 45.6863 29.9147 45.9655 30.0823C46.4269 30.3595 46.7045 30.8626 46.6928 31.4008C46.6731 32.3083 46.3764 33.2571 46.2158 34.1473C46.061 35.0048 46.9045 35.8337 47.7592 35.664C48.6464 35.4878 49.5899 35.1747 50.497 35.1391C51.0348 35.1181 51.5427 35.3868 51.8279 35.8433C52.0004 36.1195 52.1513 36.4749 52.2301 36.7908C52.3604 37.3131 52.2009 37.8651 51.8121 38.2374C51.1729 38.8495 50.3151 39.2991 49.5908 39.8019C48.9046 40.2782 48.7473 41.4683 49.4939 41.9675C50.2644 42.4827 51.1757 42.9393 51.8587 43.5708C52.2539 43.9362 52.423 44.4854 52.3018 45.0099C52.2285 45.3271 52.0839 45.6851 51.9162 45.9642C51.6391 46.4257 51.1359 46.7032 50.5978 46.6916C49.6903 46.6719 48.7417 46.3753 47.8516 46.2146C46.9939 46.0598 46.1648 46.9035 46.3346 47.7583C46.5108 48.6454 46.8239 49.5888 46.8594 50.4958C46.8805 51.0336 46.6117 51.5415 46.1552 51.8267C45.879 51.9992 45.5236 52.15 45.2077 52.2289C44.6854 52.3592 44.1334 52.1997 43.7611 51.8109C43.1491 51.1718 42.6996 50.314 42.1968 49.5897C41.7203 48.9034 40.5301 48.7463 40.0309 49.493C39.5157 50.2634 39.0592 51.1746 38.4278 51.8574C38.0623 52.2527 37.5132 52.4218 36.9887 52.3006C36.6715 52.2273 36.3135 52.0826 36.0343 51.915C35.5729 51.6379 35.2953 51.1347 35.307 50.5966C35.3267 49.6891 35.6233 48.7405 35.7839 47.8505C35.9388 46.9928 35.0951 46.1636 34.2402 46.3334C33.3531 46.5096 32.4098 46.8227 31.5028 46.8582C30.9649 46.8793 30.457 46.6105 30.1719 46.154C29.9994 45.8778 29.8485 45.5224 29.7697 45.2065C29.6394 44.6842 29.7989 44.1322 30.1877 43.7599C30.8269 43.1479 31.6847 42.6982 32.4091 42.1954C33.0954 41.7189 33.2522 40.5289 32.5056 40.0297C31.7351 39.5145 30.824 39.058 30.1411 38.4265C29.7459 38.0611 29.5768 37.5119 29.698 36.9875C29.7713 36.6702 29.9159 36.3122 30.0836 36.0331C30.3607 35.5717 30.8638 35.2941 31.402 35.3058C32.3095 35.3255 33.2583 35.6221 34.1485 35.7828C35.006 35.9376 35.8349 35.094 35.6652 34.2393C35.489 33.3521 35.1759 32.4087 35.1403 31.5016Z"
      fill="#906EF7"
      stroke="white"
      stroke-width="2"
    />
    <path
      d="M20.7706 8.22357C20.9036 7.51411 21.5231 7 22.2449 7H23.7551C24.4769 7 25.0964 7.51411 25.2294 8.22357C25.5051 9.69403 25.4829 11.6321 27.1202 12.2606C27.3092 12.3331 27.4958 12.4105 27.6798 12.4926C29.2818 13.2072 30.6374 11.8199 31.8721 10.9752C32.4678 10.5676 33.2694 10.6421 33.7798 11.1525L34.8477 12.2204C35.3581 12.7308 35.4326 13.5323 35.025 14.128C34.1802 15.3627 32.7931 16.7183 33.5077 18.3202C33.5898 18.5043 33.6672 18.6909 33.7398 18.88C34.3683 20.5171 36.3061 20.4949 37.7764 20.7706C38.4859 20.9036 39 21.5231 39 22.2449V23.7551C39 24.4769 38.4859 25.0964 37.7764 25.2294C36.3061 25.5051 34.3685 25.483 33.7401 27.1201C33.6675 27.3093 33.59 27.4961 33.5079 27.6803C32.7934 29.282 34.1803 30.6374 35.025 31.8719C35.4326 32.4677 35.3581 33.2692 34.8477 33.7796L33.7798 34.8475C33.2694 35.3579 32.4678 35.4324 31.8721 35.0248C30.6376 34.1801 29.2823 32.7934 27.6806 33.508C27.4962 33.5903 27.3093 33.6678 27.12 33.7405C25.483 34.3688 25.5051 36.3062 25.2294 37.7764C25.0964 38.4859 24.4769 39 23.7551 39H22.2449C21.5231 39 20.9036 38.4859 20.7706 37.7764C20.4949 36.3062 20.517 34.3688 18.88 33.7405C18.6908 33.6678 18.5039 33.5903 18.3196 33.5081C16.7179 32.7936 15.3625 34.1804 14.1279 35.0251C13.5322 35.4327 12.7307 35.3582 12.2203 34.8478L11.1524 33.7799C10.642 33.2695 10.5675 32.4679 10.9751 31.8722C11.8198 30.6376 13.2067 29.2822 12.4922 27.6804C12.41 27.4962 12.3325 27.3093 12.2599 27.1201C11.6315 25.483 9.69392 25.5051 8.22357 25.2294C7.51411 25.0964 7 24.4769 7 23.7551V22.2449C7 21.5231 7.51411 20.9036 8.22357 20.7706C9.69394 20.4949 11.6317 20.5171 12.2602 18.88C12.3328 18.6909 12.4103 18.5042 12.4924 18.3201C13.207 16.7181 11.8198 15.3625 10.975 14.1278C10.5674 13.5321 10.6419 12.7305 11.1523 12.2201L12.2202 11.1522C12.7306 10.6418 13.5322 10.5673 14.1279 10.9749C15.3626 11.8197 16.7184 13.2071 18.3204 12.4925C18.5044 12.4105 18.6909 12.3331 18.8799 12.2606C20.5171 11.6321 20.4949 9.69403 20.7706 8.22357Z"
      fill="#906EF7"
      stroke="white"
      stroke-width="2"
    />
    <circle cx="23" cy="23" r="6" fill="#794CFF" stroke="white" stroke-width="2" />
    <circle cx="41" cy="41" r="4" fill="#794CFF" stroke="white" stroke-width="2" />
  </g>
  <defs>
    <clipPath id="1">
      <rect width="60" height="60" fill="white" />
    </clipPath>
  </defs>
</svg> `,
    O2e = Wt `
  :host {
    display: block;
    width: 55px;
    height: 55px;
  }
`;
var gee = function(t, e, n, r) {
    var i = arguments.length,
        s = i < 3 ? e : r === null ? r = Object.getOwnPropertyDescriptor(e, n) : r,
        o;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function") s = Reflect.decorate(t, e, n, r);
    else
        for (var a = t.length - 1; a >= 0; a--)(o = t[a]) && (s = (i < 3 ? o(s) : i > 3 ? o(e, n, s) : o(e, n)) || s);
    return i > 3 && s && Object.defineProperty(e, n, s), s
};
const N2e = {
    browser: y2e,
    dao: w2e,
    defi: v2e,
    defiAlt: b2e,
    eth: _2e,
    layers: E2e,
    lock: x2e,
    login: S2e,
    network: C2e,
    nft: A2e,
    noun: T2e,
    profile: I2e,
    system: R2e
};
let y_ = class extends Zt {
    constructor() {
        super(...arguments), this.name = "browser"
    }
    render() {
        return We `${N2e[this.name]}`
    }
};
y_.styles = [dn, O2e];
gee([xe()], y_.prototype, "name", void 0);
y_ = gee([Qe("wui-visual")], y_);
/**
 * @license
 * Copyright 2018 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const Vf = t => t ? ? os,
    Mr = {
        getSpacingStyles(t, e) {
            if (Array.isArray(t)) return t[e] ? `var(--wui-spacing-${t[e]})` : void 0;
            if (typeof t == "string") return `var(--wui-spacing-${t})`
        },
        getFormattedDate(t) {
            return new Intl.DateTimeFormat("en-US", {
                month: "short",
                day: "numeric"
            }).format(t)
        },
        getHostName(t) {
            return new URL(t).hostname
        },
        getTruncateString({
            string: t,
            charsStart: e,
            charsEnd: n,
            truncate: r
        }) {
            return t.length <= e + n ? t : r === "end" ? `${t.substring(0,e)}...` : r === "start" ? `...${t.substring(t.length-n)}` : `${t.substring(0,Math.floor(e))}...${t.substring(t.length-Math.floor(n))}`
        },
        generateAvatarColors(t) {
            const n = t.toLowerCase().replace(/^0x/iu, "").substring(0, 6),
                r = this.hexToRgb(n),
                i = getComputedStyle(document.documentElement).getPropertyValue("--w3m-border-radius-master"),
                o = 100 - 3 * Number(i == null ? void 0 : i.replace("px", "")),
                a = `${o}% ${o}% at 65% 40%`,
                l = [];
            for (let c = 0; c < 5; c += 1) {
                const u = this.tintColor(r, .15 * c);
                l.push(`rgb(${u[0]}, ${u[1]}, ${u[2]})`)
            }
            return `
    --local-color-1: ${l[0]};
    --local-color-2: ${l[1]};
    --local-color-3: ${l[2]};
    --local-color-4: ${l[3]};
    --local-color-5: ${l[4]};
    --local-radial-circle: ${a}
   `
        },
        hexToRgb(t) {
            const e = parseInt(t, 16),
                n = e >> 16 & 255,
                r = e >> 8 & 255,
                i = e & 255;
            return [n, r, i]
        },
        tintColor(t, e) {
            const [n, r, i] = t, s = Math.round(n + (255 - n) * e), o = Math.round(r + (255 - r) * e), a = Math.round(i + (255 - i) * e);
            return [s, o, a]
        },
        isNumber(t) {
            return {
                number: /^[0-9]+$/u
            }.number.test(t)
        },
        getColorTheme(t) {
            return t || (typeof window < "u" && window.matchMedia ? window.matchMedia("(prefers-color-scheme: dark)").matches ? "dark" : "light" : "dark")
        }
    },
    P2e = Wt `
  :host {
    display: flex;
    width: inherit;
    height: inherit;
  }
`;
var Nl = function(t, e, n, r) {
    var i = arguments.length,
        s = i < 3 ? e : r === null ? r = Object.getOwnPropertyDescriptor(e, n) : r,
        o;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function") s = Reflect.decorate(t, e, n, r);
    else
        for (var a = t.length - 1; a >= 0; a--)(o = t[a]) && (s = (i < 3 ? o(s) : i > 3 ? o(e, n, s) : o(e, n)) || s);
    return i > 3 && s && Object.defineProperty(e, n, s), s
};
let Mo = class extends Zt {
    render() {
        return this.style.cssText = `
      flex-direction: ${this.flexDirection};
      flex-wrap: ${this.flexWrap};
      flex-basis: ${this.flexBasis};
      flex-grow: ${this.flexGrow};
      flex-shrink: ${this.flexShrink};
      align-items: ${this.alignItems};
      justify-content: ${this.justifyContent};
      column-gap: ${this.columnGap&&`var(--wui-spacing-${this.columnGap})`};
      row-gap: ${this.rowGap&&`var(--wui-spacing-${this.rowGap})`};
      gap: ${this.gap&&`var(--wui-spacing-${this.gap})`};
      padding-top: ${this.padding&&Mr.getSpacingStyles(this.padding,0)};
      padding-right: ${this.padding&&Mr.getSpacingStyles(this.padding,1)};
      padding-bottom: ${this.padding&&Mr.getSpacingStyles(this.padding,2)};
      padding-left: ${this.padding&&Mr.getSpacingStyles(this.padding,3)};
      margin-top: ${this.margin&&Mr.getSpacingStyles(this.margin,0)};
      margin-right: ${this.margin&&Mr.getSpacingStyles(this.margin,1)};
      margin-bottom: ${this.margin&&Mr.getSpacingStyles(this.margin,2)};
      margin-left: ${this.margin&&Mr.getSpacingStyles(this.margin,3)};
    `, We `<slot></slot>`
    }
};
Mo.styles = [dn, P2e];
Nl([xe()], Mo.prototype, "flexDirection", void 0);
Nl([xe()], Mo.prototype, "flexWrap", void 0);
Nl([xe()], Mo.prototype, "flexBasis", void 0);
Nl([xe()], Mo.prototype, "flexGrow", void 0);
Nl([xe()], Mo.prototype, "flexShrink", void 0);
Nl([xe()], Mo.prototype, "alignItems", void 0);
Nl([xe()], Mo.prototype, "justifyContent", void 0);
Nl([xe()], Mo.prototype, "columnGap", void 0);
Nl([xe()], Mo.prototype, "rowGap", void 0);
Nl([xe()], Mo.prototype, "gap", void 0);
Nl([xe()], Mo.prototype, "padding", void 0);
Nl([xe()], Mo.prototype, "margin", void 0);
Mo = Nl([Qe("wui-flex")], Mo);
const k2e = Wt `
  :host {
    display: block;
    width: var(--wui-icon-box-size-xl);
    height: var(--wui-icon-box-size-xl);
    border-radius: var(--wui-border-radius-3xl);
    box-shadow: 0 0 0 8px var(--wui-gray-glass-005);
    overflow: hidden;
    position: relative;
  }

  :host([data-variant='generated']) {
    --mixed-local-color-1: var(--local-color-1);
    --mixed-local-color-2: var(--local-color-2);
    --mixed-local-color-3: var(--local-color-3);
    --mixed-local-color-4: var(--local-color-4);
    --mixed-local-color-5: var(--local-color-5);
  }

  @supports (background: color-mix(in srgb, white 50%, black)) {
    :host([data-variant='generated']) {
      --mixed-local-color-1: color-mix(
        in srgb,
        var(--w3m-color-mix) var(--w3m-color-mix-strength),
        var(--local-color-1)
      );
      --mixed-local-color-2: color-mix(
        in srgb,
        var(--w3m-color-mix) var(--w3m-color-mix-strength),
        var(--local-color-2)
      );
      --mixed-local-color-3: color-mix(
        in srgb,
        var(--w3m-color-mix) var(--w3m-color-mix-strength),
        var(--local-color-3)
      );
      --mixed-local-color-4: color-mix(
        in srgb,
        var(--w3m-color-mix) var(--w3m-color-mix-strength),
        var(--local-color-4)
      );
      --mixed-local-color-5: color-mix(
        in srgb,
        var(--w3m-color-mix) var(--w3m-color-mix-strength),
        var(--local-color-5)
      );
    }
  }

  :host([data-variant='generated']) {
    box-shadow: 0 0 0 8px var(--wui-gray-glass-005);
    background: radial-gradient(
      var(--local-radial-circle),
      #fff 0.52%,
      var(--mixed-local-color-5) 31.25%,
      var(--mixed-local-color-3) 51.56%,
      var(--mixed-local-color-2) 65.63%,
      var(--mixed-local-color-1) 82.29%,
      var(--mixed-local-color-4) 100%
    );
  }

  :host([data-variant='default']) {
    box-shadow: 0 0 0 8px var(--wui-gray-glass-005);
    background: radial-gradient(
      75.29% 75.29% at 64.96% 24.36%,
      #fff 0.52%,
      #f5ccfc 31.25%,
      #dba4f5 51.56%,
      #9a8ee8 65.63%,
      #6493da 82.29%,
      #6ebdea 100%
    );
  }
`;
var mT = function(t, e, n, r) {
    var i = arguments.length,
        s = i < 3 ? e : r === null ? r = Object.getOwnPropertyDescriptor(e, n) : r,
        o;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function") s = Reflect.decorate(t, e, n, r);
    else
        for (var a = t.length - 1; a >= 0; a--)(o = t[a]) && (s = (i < 3 ? o(s) : i > 3 ? o(e, n, s) : o(e, n)) || s);
    return i > 3 && s && Object.defineProperty(e, n, s), s
};
let mm = class extends Zt {
    constructor() {
        super(...arguments), this.imageSrc = void 0, this.alt = void 0, this.address = void 0
    }
    render() {
        return We `${this.visualTemplate()}`
    }
    visualTemplate() {
        if (this.imageSrc) return this.dataset.variant = "image", We `<wui-image src=${this.imageSrc} alt=${this.alt??"avatar"}></wui-image>`;
        if (this.address) {
            this.dataset.variant = "generated";
            const e = Mr.generateAvatarColors(this.address);
            return this.style.cssText = e, null
        }
        return this.dataset.variant = "default", null
    }
};
mm.styles = [dn, k2e];
mT([xe()], mm.prototype, "imageSrc", void 0);
mT([xe()], mm.prototype, "alt", void 0);
mT([xe()], mm.prototype, "address", void 0);
mm = mT([Qe("wui-avatar")], mm);
const M2e = Wt `
  :host {
    display: inline-flex;
    justify-content: center;
    align-items: center;
    position: relative;
    overflow: hidden;
    background-color: var(--wui-gray-glass-020);
    border-radius: var(--local-border-radius);
    box-shadow: 0 0 0 1px var(--local-border);
    width: var(--local-size);
    height: var(--local-size);
    min-height: var(--local-size);
    min-width: var(--local-size);
  }

  @supports (background: color-mix(in srgb, white 50%, black)) {
    :host {
      background-color: color-mix(in srgb, var(--local-bg-value) var(--local-bg-mix), transparent);
    }
  }
`;
var Lh = function(t, e, n, r) {
    var i = arguments.length,
        s = i < 3 ? e : r === null ? r = Object.getOwnPropertyDescriptor(e, n) : r,
        o;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function") s = Reflect.decorate(t, e, n, r);
    else
        for (var a = t.length - 1; a >= 0; a--)(o = t[a]) && (s = (i < 3 ? o(s) : i > 3 ? o(e, n, s) : o(e, n)) || s);
    return i > 3 && s && Object.defineProperty(e, n, s), s
};
let Ic = class extends Zt {
    constructor() {
        super(...arguments), this.size = "md", this.backgroundColor = "accent-100", this.iconColor = "accent-100", this.background = "transparent", this.border = !1, this.borderColor = "wui-color-bg-125", this.icon = "copy"
    }
    render() {
        const e = this.iconSize || this.size,
            n = this.size === "lg",
            r = this.size === "xl",
            i = n ? "12%" : "16%",
            s = n ? "xxs" : r ? "s" : "3xl",
            o = this.background === "gray",
            a = this.background === "opaque",
            l = this.backgroundColor === "accent-100" && a || this.backgroundColor === "success-100" && a || this.backgroundColor === "error-100" && a || this.backgroundColor === "inverse-100" && a;
        let c = `var(--wui-color-${this.backgroundColor})`;
        return l ? c = `var(--wui-icon-box-bg-${this.backgroundColor})` : o && (c = `var(--wui-gray-${this.backgroundColor})`), this.style.cssText = `
       --local-bg-value: ${c};
       --local-bg-mix: ${l||o?"100%":i};
       --local-border-radius: var(--wui-border-radius-${s});
       --local-size: var(--wui-icon-box-size-${this.size});
       --local-border: ${this.borderColor==="wui-color-bg-125"?"2px":"1px"} solid ${this.border?`var(--${this.borderColor})`:"transparent"}
   `, We ` <wui-icon color=${this.iconColor} size=${e} name=${this.icon}></wui-icon> `
    }
};
Ic.styles = [dn, Di, M2e];
Lh([xe()], Ic.prototype, "size", void 0);
Lh([xe()], Ic.prototype, "backgroundColor", void 0);
Lh([xe()], Ic.prototype, "iconColor", void 0);
Lh([xe()], Ic.prototype, "iconSize", void 0);
Lh([xe()], Ic.prototype, "background", void 0);
Lh([xe({
    type: Boolean
})], Ic.prototype, "border", void 0);
Lh([xe()], Ic.prototype, "borderColor", void 0);
Lh([xe()], Ic.prototype, "icon", void 0);
Ic = Lh([Qe("wui-icon-box")], Ic);
const D2e = Wt `
  :host {
    display: block;
  }

  button {
    border-radius: var(--wui-border-radius-3xl);
    background: var(--wui-gray-glass-002);
    display: flex;
    gap: var(--wui-spacing-xs);
    padding: var(--wui-spacing-3xs) var(--wui-spacing-xs) var(--wui-spacing-3xs)
      var(--wui-spacing-xs);
    border: 1px solid var(--wui-gray-glass-005);
  }

  button:disabled {
    background: var(--wui-gray-glass-015);
  }

  button:disabled > wui-text {
    color: var(--wui-gray-glass-015);
  }

  button:disabled > wui-flex > wui-text {
    color: var(--wui-gray-glass-015);
  }

  button:disabled > wui-image,
  button:disabled > wui-icon-box,
  button:disabled > wui-flex > wui-avatar {
    filter: grayscale(1);
  }

  button:has(wui-image) {
    padding: var(--wui-spacing-3xs) var(--wui-spacing-3xs) var(--wui-spacing-3xs)
      var(--wui-spacing-xs);
  }

  wui-text {
    color: var(--wui-color-fg-100);
  }

  wui-flex > wui-text {
    color: var(--wui-color-fg-200);
    transition: all var(--wui-ease-out-power-1) var(--wui-duration-lg);
  }

  wui-image,
  wui-icon-box {
    border-radius: var(--wui-border-radius-3xl);
    width: 24px;
    height: 24px;
    box-shadow: 0 0 0 2px var(--wui-gray-glass-005);
  }

  wui-flex {
    border-radius: var(--wui-border-radius-3xl);
    border: 1px solid var(--wui-gray-glass-005);
    background: var(--wui-gray-glass-005);
    padding: 4px var(--wui-spacing-m) 4px var(--wui-spacing-xxs);
  }

  button.local-no-balance {
    border-radius: 0px;
    border: none;
    background: transparent;
  }

  wui-avatar {
    width: 20px;
    height: 20px;
    box-shadow: 0 0 0 2px var(--wui-accent-glass-010);
  }

  @media (max-width: 500px) {
    button {
      gap: 0px;
      padding: var(--wui-spacing-3xs) var(--wui-spacing-xs) !important;
      height: 32px;
    }
    wui-image,
    wui-icon-box,
    button > wui-text {
      visibility: hidden;
      width: 0px;
      height: 0px;
    }
    button {
      border-radius: 0px;
      border: none;
      background: transparent;
      padding: 0px;
    }
  }

  @media (hover: hover) and (pointer: fine) {
    button:hover:enabled > wui-flex > wui-text {
      color: var(--wui-color-fg-175);
    }

    button:active:enabled > wui-flex > wui-text {
      color: var(--wui-color-fg-175);
    }
  }
`;
var Bh = function(t, e, n, r) {
    var i = arguments.length,
        s = i < 3 ? e : r === null ? r = Object.getOwnPropertyDescriptor(e, n) : r,
        o;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function") s = Reflect.decorate(t, e, n, r);
    else
        for (var a = t.length - 1; a >= 0; a--)(o = t[a]) && (s = (i < 3 ? o(s) : i > 3 ? o(e, n, s) : o(e, n)) || s);
    return i > 3 && s && Object.defineProperty(e, n, s), s
};
let Rc = class extends Zt {
    constructor() {
        super(...arguments), this.networkSrc = void 0, this.avatarSrc = void 0, this.balance = void 0, this.disabled = !1, this.isProfileName = !1, this.address = "", this.charsStart = 4, this.charsEnd = 6
    }
    render() {
        return We `
      <button
        ?disabled=${this.disabled}
        class=${Vf(this.balance?void 0:"local-no-balance")}
      >
        ${this.balanceTemplate()}
        <wui-flex gap="xxs" alignItems="center">
          <wui-avatar
            .imageSrc=${this.avatarSrc}
            alt=${this.address}
            address=${this.address}
          ></wui-avatar>
          <wui-text variant="paragraph-600" color="inherit">
            ${Mr.getTruncateString({string:this.address,charsStart:this.isProfileName?18:this.charsStart,charsEnd:this.isProfileName?0:this.charsEnd,truncate:this.isProfileName?"end":"middle"})}
          </wui-text>
        </wui-flex>
      </button>
    `
    }
    balanceTemplate() {
        if (this.balance) {
            const e = this.networkSrc ? We `<wui-image src=${this.networkSrc}></wui-image>` : We `
            <wui-icon-box
              size="sm"
              iconColor="fg-200"
              backgroundColor="fg-300"
              icon="networkPlaceholder"
            ></wui-icon-box>
          `;
            return We `
        ${e}
        <wui-text variant="paragraph-600" color="inherit"> ${this.balance} </wui-text>
      `
        }
        return null
    }
};
Rc.styles = [dn, Di, D2e];
Bh([xe()], Rc.prototype, "networkSrc", void 0);
Bh([xe()], Rc.prototype, "avatarSrc", void 0);
Bh([xe()], Rc.prototype, "balance", void 0);
Bh([xe({
    type: Boolean
})], Rc.prototype, "disabled", void 0);
Bh([xe({
    type: Boolean
})], Rc.prototype, "isProfileName", void 0);
Bh([xe()], Rc.prototype, "address", void 0);
Bh([xe()], Rc.prototype, "charsStart", void 0);
Bh([xe()], Rc.prototype, "charsEnd", void 0);
Rc = Bh([Qe("wui-account-button")], Rc);
const $2e = Wt `
  :host {
    position: relative;
    background-color: var(--wui-gray-glass-002);
    display: flex;
    justify-content: center;
    align-items: center;
    width: var(--local-size);
    height: var(--local-size);
    border-radius: inherit;
    border-radius: var(--local-border-radius);
  }

  :host > wui-flex {
    overflow: hidden;
    border-radius: inherit;
    border-radius: var(--local-border-radius);
  }

  :host::after {
    content: '';
    position: absolute;
    top: 0;
    bottom: 0;
    left: 0;
    right: 0;
    border-radius: inherit;
    border: 1px solid var(--wui-gray-glass-010);
    pointer-events: none;
  }

  :host([name='Extension'])::after {
    border: 1px solid var(--wui-accent-glass-010);
  }

  :host([data-wallet-icon='allWallets']) {
    background-color: var(--wui-all-wallets-bg-100);
  }

  :host([data-wallet-icon='allWallets'])::after {
    border: 1px solid var(--wui-accent-glass-010);
  }

  wui-icon[data-parent-size='inherit'] {
    width: 75%;
    height: 75%;
    align-items: center;
  }

  wui-icon[data-parent-size='sm'] {
    width: 18px;
    height: 18px;
  }

  wui-icon[data-parent-size='md'] {
    width: 24px;
    height: 24px;
  }

  wui-icon[data-parent-size='lg'] {
    width: 42px;
    height: 42px;
  }

  wui-icon[data-parent-size='full'] {
    width: 100%;
    height: 100%;
  }

  :host > wui-icon-box {
    position: absolute;
    overflow: hidden;
    right: -1px;
    bottom: -2px;
    z-index: 1;
    border: 2px solid var(--wui-color-bg-base-150, #1e1f1f);
    padding: 1px;
  }
`;
var ay = function(t, e, n, r) {
    var i = arguments.length,
        s = i < 3 ? e : r === null ? r = Object.getOwnPropertyDescriptor(e, n) : r,
        o;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function") s = Reflect.decorate(t, e, n, r);
    else
        for (var a = t.length - 1; a >= 0; a--)(o = t[a]) && (s = (i < 3 ? o(s) : i > 3 ? o(e, n, s) : o(e, n)) || s);
    return i > 3 && s && Object.defineProperty(e, n, s), s
};
let Jf = class extends Zt {
    constructor() {
        super(...arguments), this.size = "md", this.name = "", this.installed = !1, this.badgeSize = "xs"
    }
    render() {
        let e = "xxs";
        return this.size === "lg" ? e = "m" : this.size === "md" ? e = "xs" : e = "xxs", this.style.cssText = `
       --local-border-radius: var(--wui-border-radius-${e});
       --local-size: var(--wui-wallet-image-size-${this.size});
   `, this.walletIcon && (this.dataset.walletIcon = this.walletIcon), We `
      <wui-flex justifyContent="center" alignItems="center"> ${this.templateVisual()} </wui-flex>
    `
    }
    templateVisual() {
        return this.imageSrc ? We `<wui-image src=${this.imageSrc} alt=${this.name}></wui-image>` : this.walletIcon ? We `<wui-icon
        data-parent-size="md"
        size="md"
        color="inherit"
        name=${this.walletIcon}
      ></wui-icon>` : We `<wui-icon
      data-parent-size=${this.size}
      size="inherit"
      color="inherit"
      name="walletPlaceholder"
    ></wui-icon>`
    }
};
Jf.styles = [dn, $2e];
ay([xe()], Jf.prototype, "size", void 0);
ay([xe()], Jf.prototype, "name", void 0);
ay([xe()], Jf.prototype, "imageSrc", void 0);
ay([xe()], Jf.prototype, "walletIcon", void 0);
ay([xe({
    type: Boolean
})], Jf.prototype, "installed", void 0);
ay([xe()], Jf.prototype, "badgeSize", void 0);
Jf = ay([Qe("wui-wallet-image")], Jf);
const L2e = Wt `
  :host {
    position: relative;
    border-radius: var(--wui-border-radius-xxs);
    width: 40px;
    height: 40px;
    overflow: hidden;
    background: var(--wui-gray-glass-002);
    display: flex;
    justify-content: center;
    align-items: center;
    flex-wrap: wrap;
    gap: var(--wui-spacing-4xs);
    padding: 3.75px !important;
  }

  :host::after {
    content: '';
    position: absolute;
    top: 0;
    bottom: 0;
    left: 0;
    right: 0;
    border-radius: inherit;
    border: 1px solid var(--wui-gray-glass-010);
    pointer-events: none;
  }

  :host > wui-wallet-image {
    width: 14px;
    height: 14px;
    border-radius: var(--wui-border-radius-5xs);
  }

  :host > wui-flex {
    padding: 2px;
    position: fixed;
    overflow: hidden;
    left: 34px;
    bottom: 8px;
    background: var(--dark-background-150, #1e1f1f);
    border-radius: 50%;
    z-index: 2;
    display: flex;
  }
`;
var mee = function(t, e, n, r) {
    var i = arguments.length,
        s = i < 3 ? e : r === null ? r = Object.getOwnPropertyDescriptor(e, n) : r,
        o;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function") s = Reflect.decorate(t, e, n, r);
    else
        for (var a = t.length - 1; a >= 0; a--)(o = t[a]) && (s = (i < 3 ? o(s) : i > 3 ? o(e, n, s) : o(e, n)) || s);
    return i > 3 && s && Object.defineProperty(e, n, s), s
};
const PR = 4;
let w_ = class extends Zt {
    constructor() {
        super(...arguments), this.walletImages = []
    }
    render() {
        const e = this.walletImages.length < PR;
        return We `${this.walletImages.slice(0,PR).map(({src:n,walletName:r})=>We` <
            wui - wallet - image
        size = "inherit"
        imageSrc = $ {
            n
        }
        name = $ {
                Vf(r)
            } >
            < /wui-wallet-image>
        `)}
      ${e?[...Array(PR-this.walletImages.length)].map(()=>We` <wui-wallet-image size="inherit" name=""></wui-wallet-image>`):null}
      <wui-flex>
        <wui-icon-box
          size="xxs"
          iconSize="xxs"
          iconcolor="success-100"
          backgroundcolor="success-100"
          icon="checkmark"
          background="opaque"
        ></wui-icon-box>
      </wui-flex>`
    }
};
w_.styles = [dn, L2e];
mee([xe({
    type: Array
})], w_.prototype, "walletImages", void 0);
w_ = mee([Qe("wui-all-wallets-image")], w_);
const B2e = Wt `
  :host {
    width: var(--local-width);
    position: relative;
  }

  button {
    border: 1px solid var(--wui-gray-glass-010);
    border-radius: var(--wui-border-radius-m);
    width: var(--local-width);
  }

  button:disabled {
    border: 1px solid var(--wui-gray-glass-010);
  }

  button[data-size='sm'] {
    padding: var(--wui-spacing-xxs) var(--wui-spacing-s);
  }

  button[data-size='sm'][data-icon-left='true'] {
    padding: var(--wui-spacing-xxs) var(--wui-spacing-s) var(--wui-spacing-xxs)
      var(--wui-spacing-xs);
  }

  button[data-size='sm'][data-icon-right='true'] {
    padding: var(--wui-spacing-xxs) var(--wui-spacing-xs) var(--wui-spacing-xxs)
      var(--wui-spacing-s);
  }

  ::slotted(*) {
    transition: opacity 200ms ease-in-out;
    opacity: var(--local-opacity-100);
  }

  button > wui-text {
    transition: opacity 200ms ease-in-out;
    opacity: var(--local-opacity-100);
  }

  button[data-size='md'] {
    padding: 8.2px var(--wui-spacing-l) 9px var(--wui-spacing-l);
  }

  button[data-size='md'][data-icon-left='true'] {
    padding: 8.2px var(--wui-spacing-l) 9px var(--wui-spacing-s);
  }

  button[data-size='md'][data-icon-right='true'] {
    padding: 8.2px var(--wui-spacing-s) 9px var(--wui-spacing-l);
  }

  wui-loading-spinner {
    position: absolute;
    left: 50%;
    top: 50%;
    transition: all 200ms ease-in-out;
    transform: translate(-50%, -50%);
    opacity: var(--local-opacity-000);
  }
`;
var Xp = function(t, e, n, r) {
    var i = arguments.length,
        s = i < 3 ? e : r === null ? r = Object.getOwnPropertyDescriptor(e, n) : r,
        o;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function") s = Reflect.decorate(t, e, n, r);
    else
        for (var a = t.length - 1; a >= 0; a--)(o = t[a]) && (s = (i < 3 ? o(s) : i > 3 ? o(e, n, s) : o(e, n)) || s);
    return i > 3 && s && Object.defineProperty(e, n, s), s
};
let Iu = class extends Zt {
    constructor() {
        super(...arguments), this.size = "md", this.disabled = !1, this.fullWidth = !1, this.loading = !1, this.variant = "fill", this.hasIconLeft = !1, this.hasIconRight = !1
    }
    render() {
        this.style.cssText = `
    --local-width: ${this.fullWidth?"100%":"auto"};
    --local-opacity-100: ${this.loading?0:1};
    --local-opacity-000: ${this.loading?1:0};`;
        const e = this.size === "md" ? "paragraph-600" : "small-600";
        return We `
      <button
        data-variant=${this.variant}
        data-icon-left=${this.hasIconLeft}
        data-icon-right=${this.hasIconRight}
        data-size=${this.size}
        ?disabled=${this.disabled||this.loading}
        ontouchstart
      >
        ${this.loadingTemplate()}
        <slot name="iconLeft" @slotchange=${()=>this.handleSlotLeftChange()}></slot>
        <wui-text variant=${e} color="inherit">
          <slot></slot>
        </wui-text>
        <slot name="iconRight" @slotchange=${()=>this.handleSlotRightChange()}></slot>
      </button>
    `
    }
    handleSlotLeftChange() {
        this.hasIconLeft = !0
    }
    handleSlotRightChange() {
        this.hasIconRight = !0
    }
    loadingTemplate() {
        return this.loading ? We `<wui-loading-spinner color="fg-300"></wui-loading-spinner>` : We ``
    }
};
Iu.styles = [dn, Di, B2e];
Xp([xe()], Iu.prototype, "size", void 0);
Xp([xe({
    type: Boolean
})], Iu.prototype, "disabled", void 0);
Xp([xe({
    type: Boolean
})], Iu.prototype, "fullWidth", void 0);
Xp([xe({
    type: Boolean
})], Iu.prototype, "loading", void 0);
Xp([xe()], Iu.prototype, "variant", void 0);
Xp([xe({
    type: Boolean
})], Iu.prototype, "hasIconLeft", void 0);
Xp([xe({
    type: Boolean
})], Iu.prototype, "hasIconRight", void 0);
Iu = Xp([Qe("wui-button")], Iu);
const yee = pt `<svg  viewBox="0 0 48 54" fill="none">
  <path
    d="M43.4605 10.7248L28.0485 1.61089C25.5438 0.129705 22.4562 0.129705 19.9515 1.61088L4.53951 10.7248C2.03626 12.2051 0.5 14.9365 0.5 17.886V36.1139C0.5 39.0635 2.03626 41.7949 4.53951 43.2752L19.9515 52.3891C22.4562 53.8703 25.5438 53.8703 28.0485 52.3891L43.4605 43.2752C45.9637 41.7949 47.5 39.0635 47.5 36.114V17.8861C47.5 14.9365 45.9637 12.2051 43.4605 10.7248Z"
  />
</svg>`,
    F2e = Wt `
  :host {
    display: flex;
    flex-direction: column;
    align-items: center;
    width: 76px;
    row-gap: var(--wui-spacing-xs);
    padding: var(--wui-spacing-xs) 10px;
    background-color: var(--wui-gray-glass-002);
    border-radius: clamp(0px, var(--wui-border-radius-xs), 20px);
    position: relative;
  }

  wui-shimmer[data-type='network'] {
    border: none;
    -webkit-clip-path: var(--wui-path-network);
    clip-path: var(--wui-path-network);
  }

  svg {
    position: absolute;
    width: 48px;
    height: 54px;
    z-index: 1;
  }

  svg > path {
    stroke: var(--wui-gray-glass-010);
    stroke-width: 1px;
  }
`;
var wee = function(t, e, n, r) {
    var i = arguments.length,
        s = i < 3 ? e : r === null ? r = Object.getOwnPropertyDescriptor(e, n) : r,
        o;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function") s = Reflect.decorate(t, e, n, r);
    else
        for (var a = t.length - 1; a >= 0; a--)(o = t[a]) && (s = (i < 3 ? o(s) : i > 3 ? o(e, n, s) : o(e, n)) || s);
    return i > 3 && s && Object.defineProperty(e, n, s), s
};
let v_ = class extends Zt {
    constructor() {
        super(...arguments), this.type = "wallet"
    }
    render() {
        return We `
      ${this.shimmerTemplate()}
      <wui-shimmer width="56px" height="20px" borderRadius="xs"></wui-shimmer>
    `
    }
    shimmerTemplate() {
        return this.type === "network" ? We ` <wui-shimmer
          data-type=${this.type}
          width="48px"
          height="54px"
          borderRadius="xs"
        ></wui-shimmer>
        ${yee}` : We `<wui-shimmer width="56px" height="56px" borderRadius="xs"></wui-shimmer>`
    }
};
v_.styles = [dn, Di, F2e];
wee([xe()], v_.prototype, "type", void 0);
v_ = wee([Qe("wui-card-select-loader")], v_);
const U2e = pt `<svg width="86" height="96" fill="none">
  <path
    d="M78.3244 18.926L50.1808 2.45078C45.7376 -0.150261 40.2624 -0.150262 35.8192 2.45078L7.6756 18.926C3.23322 21.5266 0.5 26.3301 0.5 31.5248V64.4752C0.5 69.6699 3.23322 74.4734 7.6756 77.074L35.8192 93.5492C40.2624 96.1503 45.7376 96.1503 50.1808 93.5492L78.3244 77.074C82.7668 74.4734 85.5 69.6699 85.5 64.4752V31.5248C85.5 26.3301 82.7668 21.5266 78.3244 18.926Z"
  />
</svg>`,
    j2e = Wt `
  :host {
    position: relative;
    border-radius: inherit;
    display: flex;
    justify-content: center;
    align-items: center;
    width: var(--local-width);
    height: var(--local-height);
  }

  svg {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    z-index: 1;
    fill: var(--wui-gray-glass-002);
  }

  svg > path {
    stroke: var(--local-stroke);
    transition: stroke var(--wui-ease-out-power-1) var(--wui-duration-lg);
  }

  wui-image {
    width: 100%;
    height: 100%;
    -webkit-clip-path: var(--local-path);
    clip-path: var(--local-path);
    background: var(--wui-gray-glass-002);
  }

  wui-icon {
    transform: translateY(-5%);
    width: var(--local-icon-size);
    height: var(--local-icon-size);
  }
`;
var lE = function(t, e, n, r) {
    var i = arguments.length,
        s = i < 3 ? e : r === null ? r = Object.getOwnPropertyDescriptor(e, n) : r,
        o;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function") s = Reflect.decorate(t, e, n, r);
    else
        for (var a = t.length - 1; a >= 0; a--)(o = t[a]) && (s = (i < 3 ? o(s) : i > 3 ? o(e, n, s) : o(e, n)) || s);
    return i > 3 && s && Object.defineProperty(e, n, s), s
};
let Mp = class extends Zt {
    constructor() {
        super(...arguments), this.size = "md", this.name = "uknown", this.selected = !1
    }
    render() {
        const e = this.size === "lg";
        return this.style.cssText = `
      --local-stroke: ${this.selected?"var(--wui-color-accent-100)":"var(--wui-gray-glass-010)"};
      --local-path: ${e?"var(--wui-path-network-lg)":"var(--wui-path-network)"};
      --local-width: ${e?"86px":"48px"};
      --local-height: ${e?"96px":"54px"};
      --local-icon-size: ${e?"42px":"24px"};
    `, We `${this.templateVisual()} ${e?U2e:yee}`
    }
    templateVisual() {
        return this.imageSrc ? We `<wui-image src=${this.imageSrc} alt=${this.name}></wui-image>` : We `<wui-icon size="inherit" color="fg-200" name="networkPlaceholder"></wui-icon>`
    }
};
Mp.styles = [dn, j2e];
lE([xe()], Mp.prototype, "size", void 0);
lE([xe()], Mp.prototype, "name", void 0);
lE([xe()], Mp.prototype, "imageSrc", void 0);
lE([xe({
    type: Boolean
})], Mp.prototype, "selected", void 0);
Mp = lE([Qe("wui-network-image")], Mp);
const H2e = Wt `
  button {
    flex-direction: column;
    width: 76px;
    row-gap: var(--wui-spacing-xs);
    padding: var(--wui-spacing-xs) var(--wui-spacing-0);
    background-color: var(--wui-gray-glass-002);
    border-radius: clamp(0px, var(--wui-border-radius-xs), 20px);
  }

  button > wui-text {
    color: var(--wui-color-fg-100);
    max-width: var(--wui-icon-box-size-xl);
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    justify-content: center;
  }

  button:disabled > wui-text {
    color: var(--wui-gray-glass-015);
  }

  [data-selected='true'] {
    background-color: var(--wui-accent-glass-020);
  }

  @media (hover: hover) and (pointer: fine) {
    [data-selected='true']:hover:enabled {
      background-color: var(--wui-accent-glass-015);
    }
  }

  [data-selected='true']:active:enabled {
    background-color: var(--wui-accent-glass-010);
  }
`;
var ly = function(t, e, n, r) {
    var i = arguments.length,
        s = i < 3 ? e : r === null ? r = Object.getOwnPropertyDescriptor(e, n) : r,
        o;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function") s = Reflect.decorate(t, e, n, r);
    else
        for (var a = t.length - 1; a >= 0; a--)(o = t[a]) && (s = (i < 3 ? o(s) : i > 3 ? o(e, n, s) : o(e, n)) || s);
    return i > 3 && s && Object.defineProperty(e, n, s), s
};
let Xf = class extends Zt {
    constructor() {
        super(...arguments), this.name = "Unknown", this.type = "wallet", this.imageSrc = void 0, this.disabled = !1, this.selected = !1, this.installed = !1
    }
    render() {
        return We `
      <button data-selected=${Vf(this.selected)} ?disabled=${this.disabled} ontouchstart>
        ${this.imageTemplate()}
        <wui-text variant="tiny-500" color=${this.selected?"accent-100":"inherit"}>
          ${this.name}
        </wui-text>
      </button>
    `
    }
    imageTemplate() {
        return this.type === "network" ? We `
        <wui-network-image
          .selected=${this.selected}
          imageSrc=${Vf(this.imageSrc)}
          name=${this.name}
        >
        </wui-network-image>
      ` : We `
      <wui-wallet-image
        size="md"
        imageSrc=${Vf(this.imageSrc)}
        name=${this.name}
        .installed=${this.installed}
        badgeSize="sm"
      >
      </wui-wallet-image>
    `
    }
};
Xf.styles = [dn, Di, H2e];
ly([xe()], Xf.prototype, "name", void 0);
ly([xe()], Xf.prototype, "type", void 0);
ly([xe()], Xf.prototype, "imageSrc", void 0);
ly([xe({
    type: Boolean
})], Xf.prototype, "disabled", void 0);
ly([xe({
    type: Boolean
})], Xf.prototype, "selected", void 0);
ly([xe({
    type: Boolean
})], Xf.prototype, "installed", void 0);
Xf = ly([Qe("wui-card-select")], Xf);
const z2e = Wt `
  a {
    border: 1px solid var(--wui-gray-glass-010);
    border-radius: var(--wui-border-radius-3xl);
  }

  wui-image {
    border-radius: var(--wui-border-radius-3xl);
    overflow: hidden;
  }

  a.disabled > wui-icon,
  a.disabled > wui-image {
    filter: grayscale(1);
  }

  a[data-variant='fill'] {
    color: var(--wui-color-inverse-100);
    background-color: var(--wui-color-accent-100);
  }

  a[data-variant='shade'],
  a[data-variant='shadeSmall'] {
    background-color: transparent;
    background-color: var(--wui-gray-glass-010);
    color: var(--wui-color-fg-200);
  }

  a[data-variant='success'] {
    column-gap: var(--wui-spacing-xxs);
    border: 1px solid var(--wui-success-glass-010);
    background-color: var(--wui-success-glass-010);
    color: var(--wui-color-success-100);
  }

  a[data-variant='transparent'] {
    column-gap: var(--wui-spacing-xxs);
    background-color: transparent;
    color: var(--wui-color-fg-150);
  }

  a[data-variant='transparent'],
  a[data-variant='success'],
  a[data-variant='shadeSmall'] {
    padding: 7px var(--wui-spacing-s) 7px 10px;
  }

  a[data-variant='transparent']:has(wui-text:first-child),
  a[data-variant='success']:has(wui-text:first-child),
  a[data-variant='shadeSmall']:has(wui-text:first-child) {
    padding: 7px var(--wui-spacing-s);
  }

  a[data-variant='fill'],
  a[data-variant='shade'] {
    column-gap: var(--wui-spacing-xs);
    padding: var(--wui-spacing-xxs) var(--wui-spacing-m) var(--wui-spacing-xxs)
      var(--wui-spacing-xs);
  }

  a[data-variant='fill']:has(wui-text:first-child),
  a[data-variant='shade']:has(wui-text:first-child) {
    padding: 9px var(--wui-spacing-m) 9px var(--wui-spacing-m);
  }

  a[data-variant='fill'] > wui-image,
  a[data-variant='shade'] > wui-image {
    width: 24px;
    height: 24px;
  }

  a[data-variant='fill'] > wui-image {
    box-shadow: inset 0 0 0 1px var(--wui-color-accent-090);
  }

  a[data-variant='shade'] > wui-image,
  a[data-variant='shadeSmall'] > wui-image {
    box-shadow: inset 0 0 0 1px var(--wui-gray-glass-010);
  }

  a[data-variant='fill'] > wui-icon,
  a[data-variant='shade'] > wui-icon {
    width: 14px;
    height: 14px;
  }

  a[data-variant='transparent'] > wui-image,
  a[data-variant='success'] > wui-image,
  a[data-variant='shadeSmall'] > wui-image {
    width: 14px;
    height: 14px;
  }

  a[data-variant='transparent'] > wui-icon,
  a[data-variant='success'] > wui-icon,
  a[data-variant='shadeSmall'] > wui-icon {
    width: 12px;
    height: 12px;
  }

  a[data-variant='fill']:focus-visible {
    background-color: var(--wui-color-accent-090);
  }

  a[data-variant='shade']:focus-visible,
  a[data-variant='shadeSmall']:focus-visible {
    background-color: var(--wui-gray-glass-015);
  }

  a[data-variant='transparent']:focus-visible {
    background-color: var(--wui-gray-glass-005);
  }

  a[data-variant='success']:focus-visible {
    background-color: var(--wui-success-glass-015);
  }

  a.disabled {
    color: var(--wui-gray-glass-015);
    background-color: var(--wui-gray-glass-015);
    pointer-events: none;
  }

  @media (hover: hover) and (pointer: fine) {
    a[data-variant='fill']:hover {
      background-color: var(--wui-color-accent-090);
    }

    a[data-variant='shade']:hover,
    a[data-variant='shadeSmall']:hover {
      background-color: var(--wui-gray-glass-015);
    }

    a[data-variant='transparent']:hover {
      background-color: var(--wui-gray-glass-005);
    }

    a[data-variant='success']:hover {
      background-color: var(--wui-success-glass-015);
    }
  }

  a[data-variant='fill']:active {
    background-color: var(--wui-color-accent-080);
  }

  a[data-variant='shade']:active,
  a[data-variant='shadeSmall']:active {
    background-color: var(--wui-gray-glass-020);
  }

  a[data-variant='transparent']:active {
    background-color: var(--wui-gray-glass-010);
  }

  a[data-variant='success']:active {
    background-color: var(--wui-success-glass-020);
  }
`;
var cy = function(t, e, n, r) {
    var i = arguments.length,
        s = i < 3 ? e : r === null ? r = Object.getOwnPropertyDescriptor(e, n) : r,
        o;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function") s = Reflect.decorate(t, e, n, r);
    else
        for (var a = t.length - 1; a >= 0; a--)(o = t[a]) && (s = (i < 3 ? o(s) : i > 3 ? o(e, n, s) : o(e, n)) || s);
    return i > 3 && s && Object.defineProperty(e, n, s), s
};
let ed = class extends Zt {
    constructor() {
        super(...arguments), this.variant = "fill", this.imageSrc = void 0, this.disabled = !1, this.icon = "externalLink", this.href = "", this.text = void 0
    }
    render() {
        const n = this.variant === "success" || this.variant === "transparent" || this.variant === "shadeSmall" ? "small-600" : "paragraph-600";
        return We `
      <a
        rel="noreferrer"
        target="_blank"
        href=${this.href}
        class=${this.disabled?"disabled":""}
        data-variant=${this.variant}
      >
        ${this.imageTemplate()}
        <wui-text variant=${n} color="inherit">
          ${this.title?this.title:Mr.getHostName(this.href)}
        </wui-text>
        <wui-icon name=${this.icon} color="inherit" size="inherit"></wui-icon>
      </a>
    `
    }
    imageTemplate() {
        return this.imageSrc ? We `<wui-image src=${this.imageSrc}></wui-image>` : null
    }
};
ed.styles = [dn, Di, z2e];
cy([xe()], ed.prototype, "variant", void 0);
cy([xe()], ed.prototype, "imageSrc", void 0);
cy([xe({
    type: Boolean
})], ed.prototype, "disabled", void 0);
cy([xe()], ed.prototype, "icon", void 0);
cy([xe()], ed.prototype, "href", void 0);
cy([xe()], ed.prototype, "text", void 0);
ed = cy([Qe("wui-chip")], ed);
const W2e = Wt `
  :host {
    position: relative;
    display: block;
  }

  button {
    background: var(--wui-color-accent-100);
    border: 1px solid var(--wui-gray-glass-010);
    border-radius: var(--wui-border-radius-m);
    gap: var(--wui-spacing-xs);
  }

  button.loading {
    background: var(--wui-gray-glass-010);
    border: 1px solid var(--wui-gray-glass-010);
    pointer-events: none;
  }

  button:disabled {
    background-color: var(--wui-gray-glass-015);
    border: 1px solid var(--wui-gray-glass-010);
  }

  button:disabled > wui-text {
    color: var(--wui-gray-glass-015);
  }

  @media (hover: hover) and (pointer: fine) {
    button:hover:enabled {
      background-color: var(--wui-color-accent-090);
    }

    button:active:enabled {
      background-color: var(--wui-color-accent-080);
    }
  }

  button:focus-visible {
    border: 1px solid var(--wui-gray-glass-010);
    background-color: var(--wui-color-accent-090);
    -webkit-box-shadow: 0px 0px 0px 4px var(--wui-box-shadow-blue);
    -moz-box-shadow: 0px 0px 0px 4px var(--wui-box-shadow-blue);
    box-shadow: 0px 0px 0px 4px var(--wui-box-shadow-blue);
  }

  button[data-size='sm'] {
    padding: 6.75px 10px 7.25px;
  }

  ::slotted(*) {
    transition: opacity 200ms ease-in-out;
    opacity: var(--local-opacity-100);
  }

  button > wui-text {
    transition: opacity 200ms ease-in-out;
    opacity: var(--local-opacity-100);
    color: var(--wui-color-inverse-100);
  }

  button[data-size='md'] {
    padding: 9px var(--wui-spacing-l) 9px var(--wui-spacing-l);
  }

  button[data-size='md'] + wui-text {
    padding-left: var(--wui-spacing-3xs);
  }

  @media (max-width: 500px) {
    button[data-size='md'] {
      height: 32px;
      padding: 5px 12px;
    }

    button[data-size='md'] > wui-text > slot {
      font-size: 14px !important;
    }
  }

  wui-loading-spinner {
    width: 14px;
    height: 14px;
  }

  wui-loading-spinner::slotted(svg) {
    width: 10px !important;
    height: 10px !important;
  }

  button[data-size='sm'] > wui-loading-spinner {
    width: 12px;
    height: 12px;
  }
`;
var P$ = function(t, e, n, r) {
    var i = arguments.length,
        s = i < 3 ? e : r === null ? r = Object.getOwnPropertyDescriptor(e, n) : r,
        o;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function") s = Reflect.decorate(t, e, n, r);
    else
        for (var a = t.length - 1; a >= 0; a--)(o = t[a]) && (s = (i < 3 ? o(s) : i > 3 ? o(e, n, s) : o(e, n)) || s);
    return i > 3 && s && Object.defineProperty(e, n, s), s
};
let Ib = class extends Zt {
    constructor() {
        super(...arguments), this.size = "md", this.loading = !1
    }
    render() {
        const e = this.size === "md" ? "paragraph-600" : "small-600";
        return We `
      <button data-size=${this.size} ?disabled=${this.loading} ontouchstart>
        ${this.loadingTemplate()}
        <wui-text variant=${e} color=${this.loading?"accent-100":"inherit"}>
          <slot></slot>
        </wui-text>
      </button>
    `
    }
    loadingTemplate() {
        return this.loading ? We `<wui-loading-spinner size=${this.size} color="accent-100"></wui-loading-spinner>` : null
    }
};
Ib.styles = [dn, Di, W2e];
P$([xe()], Ib.prototype, "size", void 0);
P$([xe({
    type: Boolean
})], Ib.prototype, "loading", void 0);
Ib = P$([Qe("wui-connect-button")], Ib);
const V2e = Wt `
  wui-flex {
    width: 100%;
    background-color: var(--wui-gray-glass-002);
    border-radius: var(--wui-border-radius-xs);
  }
`;
var yT = function(t, e, n, r) {
    var i = arguments.length,
        s = i < 3 ? e : r === null ? r = Object.getOwnPropertyDescriptor(e, n) : r,
        o;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function") s = Reflect.decorate(t, e, n, r);
    else
        for (var a = t.length - 1; a >= 0; a--)(o = t[a]) && (s = (i < 3 ? o(s) : i > 3 ? o(e, n, s) : o(e, n)) || s);
    return i > 3 && s && Object.defineProperty(e, n, s), s
};
let ym = class extends Zt {
    constructor() {
        super(...arguments), this.disabled = !1, this.label = "", this.buttonLabel = ""
    }
    render() {
        return We `
      <wui-flex
        justifyContent="space-between"
        alignItems="center"
        .padding=${["1xs","2l","1xs","2l"]}
      >
        <wui-text variant="paragraph-500" color="fg-200">${this.label}</wui-text>
        <wui-button size="sm" variant="accent">
          ${this.buttonLabel}
          <wui-icon size="xs" color="inherit" slot="iconRight" name="chevronRight"></wui-icon>
        </wui-button>
      </wui-flex>
    `
    }
};
ym.styles = [dn, Di, V2e];
yT([xe({
    type: Boolean
})], ym.prototype, "disabled", void 0);
yT([xe()], ym.prototype, "label", void 0);
yT([xe()], ym.prototype, "buttonLabel", void 0);
ym = yT([Qe("wui-cta-button")], ym);
/**
 * @license
 * Copyright 2020 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const G2e = t => t.strings === void 0;
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const B3 = (t, e) => {
        var r;
        const n = t._$AN;
        if (n === void 0) return !1;
        for (const i of n)(r = i._$AO) == null || r.call(i, e, !1), B3(i, e);
        return !0
    },
    J8 = t => {
        let e, n;
        do {
            if ((e = t._$AM) === void 0) break;
            n = e._$AN, n.delete(t), t = e
        } while ((n == null ? void 0 : n.size) === 0)
    },
    vee = t => {
        for (let e; e = t._$AM; t = e) {
            let n = e._$AN;
            if (n === void 0) e._$AN = n = new Set;
            else if (n.has(t)) break;
            n.add(t), Y2e(e)
        }
    };

function q2e(t) {
    this._$AN !== void 0 ? (J8(this), this._$AM = t, vee(this)) : this._$AM = t
}

function K2e(t, e = !1, n = 0) {
    const r = this._$AH,
        i = this._$AN;
    if (i !== void 0 && i.size !== 0)
        if (e)
            if (Array.isArray(r))
                for (let s = n; s < r.length; s++) B3(r[s], !1), J8(r[s]);
            else r != null && (B3(r, !1), J8(r));
    else B3(this, t)
}
const Y2e = t => {
    t.type == dee.CHILD && (t._$AP ? ? (t._$AP = K2e), t._$AQ ? ? (t._$AQ = q2e))
};
let Z2e = class extends pee {
    constructor() {
        super(...arguments), this._$AN = void 0
    }
    _$AT(e, n, r) {
        super._$AT(e, n, r), vee(this), this.isConnected = e._$AU
    }
    _$AO(e, n = !0) {
        var r, i;
        e !== this.isConnected && (this.isConnected = e, e ? (r = this.reconnected) == null || r.call(this) : (i = this.disconnected) == null || i.call(this)), n && (B3(this, e), J8(this))
    }
    setValue(e) {
        if (G2e(this.t)) this.t._$AI(e, this);
        else {
            const n = [...this.t._$AH];
            n[this.i] = e, this.t._$AI(n, this, 0)
        }
    }
    disconnected() {}
    reconnected() {}
};
/**
 * @license
 * Copyright 2020 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const bee = () => new Q2e;
let Q2e = class {};
const kR = new WeakMap,
    _ee = hee(class extends Z2e {
        render(t) {
            return os
        }
        update(t, [e]) {
            var r;
            const n = e !== this.Y;
            return n && this.Y !== void 0 && this.rt(void 0), (n || this.lt !== this.ct) && (this.Y = e, this.ht = (r = t.options) == null ? void 0 : r.host, this.rt(this.ct = t.element)), os
        }
        rt(t) {
            if (this.isConnected || (t = void 0), typeof this.Y == "function") {
                const e = this.ht ? ? globalThis;
                let n = kR.get(e);
                n === void 0 && (n = new WeakMap, kR.set(e, n)), n.get(this.Y) !== void 0 && this.Y.call(this.ht, void 0), n.set(this.Y, t), t !== void 0 && this.Y.call(this.ht, t)
            } else this.Y.value = t
        }
        get lt() {
            var t, e;
            return typeof this.Y == "function" ? (t = kR.get(this.ht ? ? globalThis)) == null ? void 0 : t.get(this.Y) : (e = this.Y) == null ? void 0 : e.value
        }
        disconnected() {
            this.lt === this.ct && this.rt(void 0)
        }
        reconnected() {
            this.rt(this.ct)
        }
    }),
    J2e = Wt `
  :host {
    position: relative;
    width: 100%;
    display: inline-block;
    color: var(--wui-color-fg-275);
  }

  input {
    width: 100%;
    border-radius: var(--wui-border-radius-xs);
    border: 1px solid var(--wui-gray-glass-005);
    background: var(--wui-gray-glass-005);
    font-size: var(--wui-font-size-paragraph);
    font-weight: var(--wui-font-weight-light);
    letter-spacing: var(--wui-letter-spacing-paragraph);
    color: var(--wui-color-fg-100);
    transition: all var(--wui-ease-inout-power-1) var(--wui-duration-lg);
    caret-color: var(--wui-color-accent-100);
  }

  input:disabled {
    cursor: not-allowed;
    border: 1px solid var(--wui-gray-glass-010);
  }

  input:disabled::placeholder,
  input:disabled + wui-icon {
    color: var(--wui-color-fg-300);
  }

  input::placeholder {
    color: var(--wui-color-fg-275);
  }

  input:focus:enabled {
    transition: all var(--wui-ease-out-power-2) var(--wui-duration-sm);
    background-color: var(--wui-gray-glass-010);
    border: 1px solid var(--wui-color-accent-100);
    -webkit-box-shadow: 0px 0px 0px 4px var(--wui-box-shadow-blue);
    -moz-box-shadow: 0px 0px 0px 4px var(--wui-box-shadow-blue);
    box-shadow: 0px 0px 0px 4px var(--wui-box-shadow-blue);
  }

  input:hover:enabled {
    background-color: var(--wui-gray-glass-010);
  }

  wui-icon {
    position: absolute;
    top: 50%;
    transform: translateY(-50%);
    pointer-events: none;
  }

  .wui-size-sm {
    padding: 9px var(--wui-spacing-m) 10px var(--wui-spacing-s);
  }

  wui-icon + .wui-size-sm {
    padding: 9px var(--wui-spacing-m) 10px 36px;
  }

  wui-icon[data-input='sm'] {
    left: var(--wui-spacing-s);
  }

  .wui-size-md {
    padding: 15px var(--wui-spacing-m) var(--wui-spacing-l) var(--wui-spacing-m);
  }

  wui-icon + .wui-size-md,
  wui-loading-spinner + .wui-size-md {
    padding: 10.5px var(--wui-spacing-3xl) 10.5px 40px;
  }

  wui-icon[data-input='md'] {
    left: var(--wui-spacing-l);
  }

  input:placeholder-shown ~ ::slotted(wui-input-element),
  input:placeholder-shown ~ ::slotted(wui-icon) {
    opacity: 0;
    pointer-events: none;
  }

  ::slotted(wui-input-element),
  ::slotted(wui-icon) {
    position: absolute;
    top: 50%;
    transform: translateY(-50%);
    transition: all var(--wui-ease-in-power-2) var(--wui-duration-md);
  }

  ::slotted(wui-input-element) {
    right: var(--wui-spacing-m);
  }

  ::slotted(wui-icon) {
    right: 0px;
  }
`;
var eg = function(t, e, n, r) {
    var i = arguments.length,
        s = i < 3 ? e : r === null ? r = Object.getOwnPropertyDescriptor(e, n) : r,
        o;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function") s = Reflect.decorate(t, e, n, r);
    else
        for (var a = t.length - 1; a >= 0; a--)(o = t[a]) && (s = (i < 3 ? o(s) : i > 3 ? o(e, n, s) : o(e, n)) || s);
    return i > 3 && s && Object.defineProperty(e, n, s), s
};
let Ru = class extends Zt {
    constructor() {
        super(...arguments), this.inputElementRef = bee(), this.size = "md", this.disabled = !1, this.placeholder = "", this.type = "text"
    }
    render() {
        const e = `wui-size-${this.size}`;
        return We ` ${this.templateIcon()}
      <input
        ${_ee(this.inputElementRef)}
        class=${e}
        type=${this.type}
        enterkeyhint=${Vf(this.enterKeyHint)}
        ?disabled=${this.disabled}
        placeholder=${this.placeholder}
        @input=${this.dispatchInputChangeEvent.bind(this)}
        value=${Vf(this.value)}
      />
      <slot></slot>`
    }
    templateIcon() {
        return this.icon ? We `<wui-icon
        data-input=${this.size}
        size="sm"
        color="inherit"
        name=${this.icon}
      ></wui-icon>` : null
    }
    dispatchInputChangeEvent() {
        var e;
        this.dispatchEvent(new CustomEvent("inputChange", {
            detail: (e = this.inputElementRef.value) == null ? void 0 : e.value,
            bubbles: !0,
            composed: !0
        }))
    }
};
Ru.styles = [dn, Di, J2e];
eg([xe()], Ru.prototype, "size", void 0);
eg([xe()], Ru.prototype, "icon", void 0);
eg([xe({
    type: Boolean
})], Ru.prototype, "disabled", void 0);
eg([xe()], Ru.prototype, "placeholder", void 0);
eg([xe()], Ru.prototype, "type", void 0);
eg([xe()], Ru.prototype, "keyHint", void 0);
eg([xe()], Ru.prototype, "value", void 0);
Ru = eg([Qe("wui-input-text")], Ru);
const X2e = Wt `
  :host {
    position: relative;
    display: inline-block;
  }

  wui-text {
    margin: var(--wui-spacing-xxs) var(--wui-spacing-m) var(--wui-spacing-0) var(--wui-spacing-m);
  }
`;
var wT = function(t, e, n, r) {
    var i = arguments.length,
        s = i < 3 ? e : r === null ? r = Object.getOwnPropertyDescriptor(e, n) : r,
        o;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function") s = Reflect.decorate(t, e, n, r);
    else
        for (var a = t.length - 1; a >= 0; a--)(o = t[a]) && (s = (i < 3 ? o(s) : i > 3 ? o(e, n, s) : o(e, n)) || s);
    return i > 3 && s && Object.defineProperty(e, n, s), s
};
let wm = class extends Zt {
    constructor() {
        super(...arguments), this.disabled = !1
    }
    render() {
        return We `
      <wui-input-text
        placeholder="Email"
        icon="mail"
        size="md"
        .disabled=${this.disabled}
        .value=${this.value}
        data-testid="wui-email-input"
      ></wui-input-text>
      ${this.templateError()}
    `
    }
    templateError() {
        return this.errorMessage ? We `<wui-text variant="tiny-500" color="error-100">${this.errorMessage}</wui-text>` : null
    }
};
wm.styles = [dn, X2e];
wT([xe()], wm.prototype, "errorMessage", void 0);
wT([xe({
    type: Boolean
})], wm.prototype, "disabled", void 0);
wT([xe()], wm.prototype, "value", void 0);
wm = wT([Qe("wui-email-input")], wm);
const e5e = Wt `
  button {
    border-radius: var(--wui-border-radius-xxs);
    color: var(--wui-color-fg-100);
    padding: var(--wui-spacing-2xs);
  }

  @media (max-width: 700px) {
    button {
      padding: var(--wui-spacing-s);
    }
  }

  button > wui-icon {
    pointer-events: none;
  }

  button:disabled > wui-icon {
    color: var(--wui-color-bg-300) !important;
  }

  button:disabled {
    background-color: transparent;
  }
`;
var cE = function(t, e, n, r) {
    var i = arguments.length,
        s = i < 3 ? e : r === null ? r = Object.getOwnPropertyDescriptor(e, n) : r,
        o;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function") s = Reflect.decorate(t, e, n, r);
    else
        for (var a = t.length - 1; a >= 0; a--)(o = t[a]) && (s = (i < 3 ? o(s) : i > 3 ? o(e, n, s) : o(e, n)) || s);
    return i > 3 && s && Object.defineProperty(e, n, s), s
};
let Dp = class extends Zt {
    constructor() {
        super(...arguments), this.size = "md", this.disabled = !1, this.icon = "copy", this.iconColor = "inherit"
    }
    render() {
        return We `
      <button ?disabled=${this.disabled} ontouchstart>
        <wui-icon color=${this.iconColor} size=${this.size} name=${this.icon}></wui-icon>
      </button>
    `
    }
};
Dp.styles = [dn, Di, R$, e5e];
cE([xe()], Dp.prototype, "size", void 0);
cE([xe({
    type: Boolean
})], Dp.prototype, "disabled", void 0);
cE([xe()], Dp.prototype, "icon", void 0);
cE([xe()], Dp.prototype, "iconColor", void 0);
Dp = cE([Qe("wui-icon-link")], Dp);
const t5e = Wt `
  button {
    background-color: var(--wui-color-fg-300);
    border-radius: var(--wui-border-radius-4xs);
    width: 16px;
    height: 16px;
  }

  button:disabled {
    background-color: var(--wui-color-bg-300);
  }

  wui-icon {
    color: var(--wui-color-bg-200) !important;
  }

  button:focus-visible {
    background-color: var(--wui-color-fg-250);
    border: 1px solid var(--wui-color-accent-100);
  }

  button:active:enabled {
    background-color: var(--wui-color-fg-225);
  }

  @media (hover: hover) and (pointer: fine) {
    button:hover:enabled {
      background-color: var(--wui-color-fg-250);
    }
  }
`;
var Eee = function(t, e, n, r) {
    var i = arguments.length,
        s = i < 3 ? e : r === null ? r = Object.getOwnPropertyDescriptor(e, n) : r,
        o;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function") s = Reflect.decorate(t, e, n, r);
    else
        for (var a = t.length - 1; a >= 0; a--)(o = t[a]) && (s = (i < 3 ? o(s) : i > 3 ? o(e, n, s) : o(e, n)) || s);
    return i > 3 && s && Object.defineProperty(e, n, s), s
};
let b_ = class extends Zt {
    constructor() {
        super(...arguments), this.icon = "copy"
    }
    render() {
        return We `
      <button>
        <wui-icon color="inherit" size="xxs" name=${this.icon}></wui-icon>
      </button>
    `
    }
};
b_.styles = [dn, Di, t5e];
Eee([xe()], b_.prototype, "icon", void 0);
b_ = Eee([Qe("wui-input-element")], b_);
const n5e = Wt `
  :host {
    position: relative;
    display: inline-block;
  }

  input {
    width: 50px;
    height: 50px;
    background: var(--wui-gray-glass-010);
    border-radius: var(--wui-border-radius-xs);
    border: 1px solid var(--wui-gray-glass-005);
    font-family: var(--wui-font-family);
    font-size: var(--wui-font-size-large);
    font-weight: var(--wui-font-weight-regular);
    letter-spacing: var(--wui-letter-spacing-large);
    text-align: center;
    color: var(--wui-color-fg-100);
    caret-color: var(--wui-color-accent-100);
    transition: all var(--wui-ease-inout-power-1) var(--wui-duration-lg);
    box-sizing: border-box;
    -webkit-appearance: none;
    -moz-appearance: textfield;
    padding: 0px;
  }

  input::-webkit-outer-spin-button,
  input::-webkit-inner-spin-button {
    -webkit-appearance: none;
    margin: 0;
  }

  input[type='number'] {
    -moz-appearance: textfield;
  }

  input:disabled {
    cursor: not-allowed;
    border: 1px solid var(--wui-gray-glass-010);
    background: var(--wui-gray-glass-005);
  }

  input:focus:enabled {
    transition: all var(--wui-ease-out-power-2) var(--wui-duration-sm);
    background-color: var(--wui-gray-glass-015);
    border: 1px solid var(--wui-color-accent-100);
    -webkit-box-shadow: 0px 0px 0px 4px var(--wui-box-shadow-blue);
    -moz-box-shadow: 0px 0px 0px 4px var(--wui-box-shadow-blue);
    box-shadow: 0px 0px 0px 4px var(--wui-box-shadow-blue);
  }
  @media (hover: hover) and (pointer: fine) {
    input:hover:enabled {
      background-color: var(--wui-gray-glass-015);
    }
  }
`;
var k$ = function(t, e, n, r) {
    var i = arguments.length,
        s = i < 3 ? e : r === null ? r = Object.getOwnPropertyDescriptor(e, n) : r,
        o;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function") s = Reflect.decorate(t, e, n, r);
    else
        for (var a = t.length - 1; a >= 0; a--)(o = t[a]) && (s = (i < 3 ? o(s) : i > 3 ? o(e, n, s) : o(e, n)) || s);
    return i > 3 && s && Object.defineProperty(e, n, s), s
};
let Rb = class extends Zt {
    constructor() {
        super(...arguments), this.disabled = !1, this.value = ""
    }
    render() {
        return We `<input
      type="number"
      maxlength="1"
      inputmode="numeric"
      autofocus
      ?disabled=${this.disabled}
      value=${this.value}
    /> `
    }
};
Rb.styles = [dn, Di, n5e];
k$([xe({
    type: Boolean
})], Rb.prototype, "disabled", void 0);
k$([xe({
    type: String
})], Rb.prototype, "value", void 0);
Rb = k$([Qe("wui-input-numeric")], Rb);
const r5e = Wt `
  button {
    padding: var(--wui-spacing-4xs) var(--wui-spacing-xxs);
    border-radius: var(--wui-border-radius-3xs);
    background-color: transparent;
    color: var(--wui-color-accent-100);
  }

  button:disabled {
    background-color: transparent;
    color: var(--wui-gray-glass-015);
  }
`;
var M$ = function(t, e, n, r) {
    var i = arguments.length,
        s = i < 3 ? e : r === null ? r = Object.getOwnPropertyDescriptor(e, n) : r,
        o;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function") s = Reflect.decorate(t, e, n, r);
    else
        for (var a = t.length - 1; a >= 0; a--)(o = t[a]) && (s = (i < 3 ? o(s) : i > 3 ? o(e, n, s) : o(e, n)) || s);
    return i > 3 && s && Object.defineProperty(e, n, s), s
};
let Ob = class extends Zt {
    constructor() {
        super(...arguments), this.disabled = !1, this.color = "inherit"
    }
    render() {
        return We `
      <button ?disabled=${this.disabled} ontouchstart>
        <slot name="iconLeft"></slot>
        <wui-text variant="small-600" color=${this.color}>
          <slot></slot>
        </wui-text>
        <slot name="iconRight"></slot>
      </button>
    `
    }
};
Ob.styles = [dn, Di, r5e];
M$([xe({
    type: Boolean
})], Ob.prototype, "disabled", void 0);
M$([xe()], Ob.prototype, "color", void 0);
Ob = M$([Qe("wui-link")], Ob);
const i5e = Wt `
  button {
    column-gap: var(--wui-spacing-s);
    padding: 11px 18px 11px var(--wui-spacing-s);
    width: 100%;
    background-color: var(--wui-gray-glass-002);
    border-radius: var(--wui-border-radius-xs);
    color: var(--wui-color-fg-250);
  }

  button[data-iconvariant='square'],
  button[data-iconvariant='square-blue'] {
    padding: 6px 18px 6px 9px;
  }

  button > wui-flex {
    flex: 1;
  }

  button > wui-image {
    width: 32px;
    height: 32px;
    box-shadow: 0 0 0 2px var(--wui-gray-glass-005);
    border-radius: var(--wui-border-radius-3xl);
  }

  button > wui-icon {
    width: 36px;
    height: 36px;
  }

  button > wui-icon-box[data-variant='blue'] {
    box-shadow: 0 0 0 2px var(--wui-accent-glass-005);
  }

  button > wui-icon-box[data-variant='overlay'] {
    box-shadow: 0 0 0 2px var(--wui-gray-glass-005);
  }

  button > wui-icon-box[data-variant='square-blue'] {
    border-radius: var(--wui-border-radius-3xs);
    position: relative;
    border: none;
    width: 36px;
    height: 36px;
  }

  button > wui-icon-box[data-variant='square-blue']::after {
    content: '';
    position: absolute;
    top: 0;
    bottom: 0;
    left: 0;
    right: 0;
    border-radius: inherit;
    border: 1px solid var(--wui-accent-glass-010);
    pointer-events: none;
  }

  button > wui-icon:last-child {
    width: 14px;
    height: 14px;
  }

  button:disabled {
    background-color: var(--wui-gray-glass-015);
    color: var(--wui-gray-glass-015);
  }

  button[data-loading='true'] > wui-icon {
    transition: opacity 200ms ease-in-out;
    opacity: 0;
  }

  wui-loading-spinner {
    position: absolute;
    right: 18px;
    top: 50%;
    transform: translateY(-50%);
  }
`;
var cd = function(t, e, n, r) {
    var i = arguments.length,
        s = i < 3 ? e : r === null ? r = Object.getOwnPropertyDescriptor(e, n) : r,
        o;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function") s = Reflect.decorate(t, e, n, r);
    else
        for (var a = t.length - 1; a >= 0; a--)(o = t[a]) && (s = (i < 3 ? o(s) : i > 3 ? o(e, n, s) : o(e, n)) || s);
    return i > 3 && s && Object.defineProperty(e, n, s), s
};
let Rl = class extends Zt {
    constructor() {
        super(...arguments), this.variant = "icon", this.disabled = !1, this.imageSrc = void 0, this.alt = void 0, this.chevron = !1, this.loading = !1
    }
    render() {
        return We `
      <button
        ?disabled=${this.loading?!0:!!this.disabled}
        data-loading=${this.loading}
        data-iconvariant=${Vf(this.iconVariant)}
        ontouchstart
      >
        ${this.loadingTemplate()} ${this.visualTemplate()}
        <wui-flex gap="3xs">
          <slot></slot>
        </wui-flex>
        ${this.chevronTemplate()}
      </button>
    `
    }
    visualTemplate() {
        if (this.variant === "image" && this.imageSrc) return We `<wui-image src=${this.imageSrc} alt=${this.alt??"list item"}></wui-image>`;
        if (this.iconVariant === "square" && this.icon && this.variant === "icon") return We `<wui-icon name=${this.icon}></wui-icon>`;
        if (this.variant === "icon" && this.icon && this.iconVariant) {
            const e = ["blue", "square-blue"].includes(this.iconVariant) ? "accent-100" : "fg-200",
                n = this.iconVariant === "square-blue" ? "mdl" : "md",
                r = this.iconSize ? this.iconSize : n;
            return We `
        <wui-icon-box
          data-variant=${this.iconVariant}
          icon=${this.icon}
          iconSize=${r}
          background="transparent"
          iconColor=${e}
          backgroundColor=${e}
          size=${n}
        ></wui-icon-box>
      `
        }
        return null
    }
    loadingTemplate() {
        return this.loading ? We `<wui-loading-spinner color="fg-300"></wui-loading-spinner>` : We ``
    }
    chevronTemplate() {
        return this.chevron ? We `<wui-icon size="inherit" color="fg-200" name="chevronRight"></wui-icon>` : null
    }
};
Rl.styles = [dn, Di, i5e];
cd([xe()], Rl.prototype, "icon", void 0);
cd([xe()], Rl.prototype, "iconSize", void 0);
cd([xe()], Rl.prototype, "variant", void 0);
cd([xe()], Rl.prototype, "iconVariant", void 0);
cd([xe({
    type: Boolean
})], Rl.prototype, "disabled", void 0);
cd([xe()], Rl.prototype, "imageSrc", void 0);
cd([xe()], Rl.prototype, "alt", void 0);
cd([xe({
    type: Boolean
})], Rl.prototype, "chevron", void 0);
cd([xe({
    type: Boolean
})], Rl.prototype, "loading", void 0);
Rl = cd([Qe("wui-list-item")], Rl);
var DP;
(function(t) {
    t.approve = "approved", t.bought = "bought", t.borrow = "borrowed", t.burn = "burnt", t.cancel = "canceled", t.claim = "claimed", t.deploy = "deployed", t.deposit = "deposited", t.execute = "executed", t.mint = "minted", t.receive = "received", t.repay = "repaid", t.send = "sent", t.sell = "sold", t.stake = "staked", t.trade = "swapped", t.unstake = "unstaked", t.withdraw = "withdrawn"
})(DP || (DP = {}));
const s5e = Wt `
  :host > wui-flex {
    display: flex;
    justify-content: center;
    align-items: center;
    position: relative;
    width: 40px;
    height: 40px;
    box-shadow: inset 0 0 0 1px var(--wui-gray-glass-005);
    background-color: var(--wui-gray-glass-005);
  }

  :host > wui-flex wui-image {
    display: block;
    z-index: -1;
  }

  :host > wui-flex,
  :host > wui-flex wui-image,
  .swap-images-container,
  .swap-images-container.nft,
  wui-image.nft {
    border-top-left-radius: var(--local-left-border-radius);
    border-top-right-radius: var(--local-right-border-radius);
    border-bottom-left-radius: var(--local-left-border-radius);
    border-bottom-right-radius: var(--local-right-border-radius);
  }

  wui-icon {
    width: 20px;
    height: 20px;
  }

  wui-icon-box {
    position: absolute;
    right: 0;
    bottom: 0;
    transform: translate(20%, 20%);
  }

  .swap-images-container {
    position: relative;
    width: 40px;
    height: 40px;
    overflow: hidden;
  }

  .swap-images-container wui-image:first-child {
    position: absolute;
    width: 40px;
    height: 40px;
    top: 0;
    left: 0%;
    clip-path: inset(0px calc(50% + 2px) 0px 0%);
  }

  .swap-images-container wui-image:last-child {
    clip-path: inset(0px 0px 0px calc(50% + 2px));
  }
`;
var uy = function(t, e, n, r) {
    var i = arguments.length,
        s = i < 3 ? e : r === null ? r = Object.getOwnPropertyDescriptor(e, n) : r,
        o;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function") s = Reflect.decorate(t, e, n, r);
    else
        for (var a = t.length - 1; a >= 0; a--)(o = t[a]) && (s = (i < 3 ? o(s) : i > 3 ? o(e, n, s) : o(e, n)) || s);
    return i > 3 && s && Object.defineProperty(e, n, s), s
};
let td = class extends Zt {
    constructor() {
        super(...arguments), this.images = [], this.secondImage = {
            type: void 0,
            url: ""
        }
    }
    render() {
        const [e, n] = this.images, r = (e == null ? void 0 : e.type) === "NFT", i = n != null && n.url ? n.type === "NFT" : r, s = r ? "var(--wui-border-radius-xxs)" : "var(--wui-border-radius-s)", o = i ? "var(--wui-border-radius-xxs)" : "var(--wui-border-radius-s)";
        return this.style.cssText = `
    --local-left-border-radius: ${s};
    --local-right-border-radius: ${o};
    `, We `<wui-flex> ${this.templateVisual()} ${this.templateIcon()} </wui-flex>`
    }
    templateVisual() {
        const [e, n] = this.images, r = e == null ? void 0 : e.type;
        return this.images.length === 2 && (e != null && e.url || n != null && n.url) ? We `<div class="swap-images-container">
        ${e!=null&&e.url?We`<wui-image src=${e.url} alt="Transaction image"></wui-image>`:null}
        ${n!=null&&n.url?We`<wui-image src=${n.url} alt="Transaction image"></wui-image>`:null}
      </div>` : e != null && e.url ? We `<wui-image src=${e.url} alt="Transaction image"></wui-image>` : r === "NFT" ? We `<wui-icon size="inherit" color="fg-200" name="nftPlaceholder"></wui-icon>` : We `<wui-icon size="inherit" color="fg-200" name="coinPlaceholder"></wui-icon>`
    }
    templateIcon() {
        let e = "accent-100",
            n;
        return n = this.getIcon(), this.status && (e = this.getStatusColor()), n ? We `
      <wui-icon-box
        size="xxs"
        iconColor=${e}
        backgroundColor=${e}
        background="opaque"
        icon=${n}
        ?border=${!0}
        borderColor="wui-color-bg-125"
      ></wui-icon-box>
    ` : null
    }
    getDirectionIcon() {
        switch (this.direction) {
            case "in":
                return "arrowBottom";
            case "out":
                return "arrowTop";
            default:
                return
        }
    }
    getIcon() {
        return this.onlyDirectionIcon ? this.getDirectionIcon() : this.type === "trade" ? "swapHorizontalBold" : this.type === "approve" ? "checkmark" : this.type === "cancel" ? "close" : this.getDirectionIcon()
    }
    getStatusColor() {
        switch (this.status) {
            case "confirmed":
                return "success-100";
            case "failed":
                return "error-100";
            case "pending":
                return "inverse-100";
            default:
                return "accent-100"
        }
    }
};
td.styles = [s5e];
uy([xe()], td.prototype, "type", void 0);
uy([xe()], td.prototype, "status", void 0);
uy([xe()], td.prototype, "direction", void 0);
uy([xe({
    type: Boolean
})], td.prototype, "onlyDirectionIcon", void 0);
uy([xe({
    type: Array
})], td.prototype, "images", void 0);
uy([xe({
    type: Object
})], td.prototype, "secondImage", void 0);
td = uy([Qe("wui-transaction-visual")], td);
const o5e = Wt `
  :host > wui-flex:first-child {
    align-items: center;
    column-gap: var(--wui-spacing-s);
    padding: 6.5px var(--wui-spacing-l) 6.5px var(--wui-spacing-xs);
    width: 100%;
  }

  :host > wui-flex:first-child wui-text:nth-child(1) {
    text-transform: capitalize;
  }

  wui-transaction-visual {
    width: 40px;
    height: 40px;
  }

  wui-flex {
    flex: 1;
  }

  :host wui-flex wui-flex {
    overflow: hidden;
  }

  :host .description-container wui-text span {
    word-break: break-all;
  }

  :host .description-container wui-text {
    overflow: hidden;
  }

  :host .description-separator-icon {
    margin: 0px 6px;
  }

  :host wui-text > span {
    overflow: hidden;
    display: -webkit-box;
    -webkit-box-orient: vertical;
    -webkit-line-clamp: 1;
  }
`;
var tg = function(t, e, n, r) {
    var i = arguments.length,
        s = i < 3 ? e : r === null ? r = Object.getOwnPropertyDescriptor(e, n) : r,
        o;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function") s = Reflect.decorate(t, e, n, r);
    else
        for (var a = t.length - 1; a >= 0; a--)(o = t[a]) && (s = (i < 3 ? o(s) : i > 3 ? o(e, n, s) : o(e, n)) || s);
    return i > 3 && s && Object.defineProperty(e, n, s), s
};
let Ou = class extends Zt {
    constructor() {
        super(...arguments), this.type = "approve", this.onlyDirectionIcon = !1, this.images = []
    }
    render() {
        return We `
      <wui-flex>
        <wui-transaction-visual
          .status=${this.status}
          direction=${Vf(this.direction)}
          type=${this.type}
          onlyDirectionIcon=${Vf(this.onlyDirectionIcon)}
          .images=${this.images}
        ></wui-transaction-visual>
        <wui-flex flexDirection="column" gap="3xs">
          <wui-text variant="paragraph-600" color="fg-100">
            ${DP[this.type]}
          </wui-text>
          <wui-flex class="description-container">
            ${this.templateDescription()} ${this.templateSecondDescription()}
          </wui-flex>
        </wui-flex>
        <wui-text variant="micro-700" color="fg-300"><span>${this.date}</span></wui-text>
      </wui-flex>
    `
    }
    templateDescription() {
        var n;
        const e = (n = this.descriptions) == null ? void 0 : n[0];
        return e ? We `
          <wui-text variant="small-500" color="fg-200">
            <span>${e}</span>
          </wui-text>
        ` : null
    }
    templateSecondDescription() {
        var n;
        const e = (n = this.descriptions) == null ? void 0 : n[1];
        return e ? We `
          <wui-icon class="description-separator-icon" size="xxs" name="arrowRight"></wui-icon>
          <wui-text variant="small-400" color="fg-200">
            <span>${e}</span>
          </wui-text>
        ` : null
    }
};
Ou.styles = [dn, o5e];
tg([xe()], Ou.prototype, "type", void 0);
tg([xe({
    type: Array
})], Ou.prototype, "descriptions", void 0);
tg([xe()], Ou.prototype, "date", void 0);
tg([xe({
    type: Boolean
})], Ou.prototype, "onlyDirectionIcon", void 0);
tg([xe()], Ou.prototype, "status", void 0);
tg([xe()], Ou.prototype, "direction", void 0);
tg([xe({
    type: Array
})], Ou.prototype, "images", void 0);
Ou = tg([Qe("wui-transaction-list-item")], Ou);
const a5e = Wt `
  :host > wui-flex:first-child {
    column-gap: var(--wui-spacing-s);
    padding: 7px var(--wui-spacing-l) 7px var(--wui-spacing-xs);
    width: 100%;
  }

  wui-flex {
    display: flex;
    flex: 1;
  }
`;
var l5e = function(t, e, n, r) {
    var i = arguments.length,
        s = i < 3 ? e : r === null ? r = Object.getOwnPropertyDescriptor(e, n) : r,
        o;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function") s = Reflect.decorate(t, e, n, r);
    else
        for (var a = t.length - 1; a >= 0; a--)(o = t[a]) && (s = (i < 3 ? o(s) : i > 3 ? o(e, n, s) : o(e, n)) || s);
    return i > 3 && s && Object.defineProperty(e, n, s), s
};
let X8 = class extends Zt {
    render() {
        return We `
      <wui-flex alignItems="center">
        <wui-shimmer width="40px" height="40px"></wui-shimmer>
        <wui-flex flexDirection="column" gap="2xs">
          <wui-shimmer width="72px" height="16px" borderRadius="4xs"></wui-shimmer>
          <wui-shimmer width="148px" height="14px" borderRadius="4xs"></wui-shimmer>
        </wui-flex>
        <wui-shimmer width="24px" height="12px" borderRadius="5xs"></wui-shimmer>
      </wui-flex>
    `
    }
};
X8.styles = [dn, a5e];
X8 = l5e([Qe("wui-transaction-list-item-loader")], X8);
const c5e = Wt `
  :host {
    display: block;
    padding: 3.5px 5px !important;
    border-radius: var(--wui-border-radius-5xs);
  }

  :host([data-variant='main']) {
    background-color: var(--wui-accent-glass-015);
    color: var(--wui-color-accent-100);
  }

  :host([data-variant='shade']) {
    background-color: var(--wui-gray-glass-010);
    color: var(--wui-color-fg-200);
  }

  :host([data-variant='success']) {
    background-color: var(--wui-icon-box-bg-success-100);
    color: var(--wui-color-success-100);
  }

  :host([data-variant='error']) {
    background-color: var(--wui-icon-box-bg-error-100);
    color: var(--wui-color-error-100);
  }
`;
var xee = function(t, e, n, r) {
    var i = arguments.length,
        s = i < 3 ? e : r === null ? r = Object.getOwnPropertyDescriptor(e, n) : r,
        o;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function") s = Reflect.decorate(t, e, n, r);
    else
        for (var a = t.length - 1; a >= 0; a--)(o = t[a]) && (s = (i < 3 ? o(s) : i > 3 ? o(e, n, s) : o(e, n)) || s);
    return i > 3 && s && Object.defineProperty(e, n, s), s
};
let __ = class extends Zt {
    constructor() {
        super(...arguments), this.variant = "main"
    }
    render() {
        return this.dataset.variant = this.variant, We `
      <wui-text data-variant=${this.variant} variant="micro-700" color="inherit">
        <slot></slot>
      </wui-text>
    `
    }
};
__.styles = [dn, c5e];
xee([xe()], __.prototype, "variant", void 0);
__ = xee([Qe("wui-tag")], __);
const u5e = Wt `
  button {
    column-gap: var(--wui-spacing-s);
    padding: 7px var(--wui-spacing-l) 7px var(--wui-spacing-xs);
    width: 100%;
    background-color: var(--wui-gray-glass-002);
    border-radius: var(--wui-border-radius-xs);
    color: var(--wui-color-fg-100);
  }

  button > wui-text:nth-child(2) {
    display: flex;
    flex: 1;
  }

  wui-icon {
    color: var(--wui-color-fg-200) !important;
  }

  button:disabled {
    background-color: var(--wui-gray-glass-015);
    color: var(--wui-gray-glass-015);
  }

  button:disabled > wui-tag {
    background-color: var(--wui-gray-glass-010);
    color: var(--wui-color-fg-300);
  }
`;
var ju = function(t, e, n, r) {
    var i = arguments.length,
        s = i < 3 ? e : r === null ? r = Object.getOwnPropertyDescriptor(e, n) : r,
        o;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function") s = Reflect.decorate(t, e, n, r);
    else
        for (var a = t.length - 1; a >= 0; a--)(o = t[a]) && (s = (i < 3 ? o(s) : i > 3 ? o(e, n, s) : o(e, n)) || s);
    return i > 3 && s && Object.defineProperty(e, n, s), s
};
let Ka = class extends Zt {
    constructor() {
        super(...arguments), this.walletImages = [], this.imageSrc = "", this.name = "", this.installed = !1, this.disabled = !1, this.showAllWallets = !1
    }
    render() {
        return We `
      <button ?disabled=${this.disabled} ontouchstart>
        ${this.templateAllWallets()} ${this.templateWalletImage()}
        <wui-text variant="paragraph-500" color="inherit">${this.name}</wui-text>
        ${this.templateStatus()}
      </button>
    `
    }
    templateAllWallets() {
        return this.showAllWallets && this.imageSrc ? We ` <wui-all-wallets-image .imageeSrc=${this.imageSrc}> </wui-all-wallets-image> ` : this.showAllWallets && this.walletIcon ? We ` <wui-wallet-image .walletIcon=${this.walletIcon} size="sm"> </wui-wallet-image> ` : null
    }
    templateWalletImage() {
        return !this.showAllWallets && this.imageSrc ? We `<wui-wallet-image
        size="sm"
        imageSrc=${this.imageSrc}
        name=${this.name}
        .installed=${this.installed}
      ></wui-wallet-image>` : !this.showAllWallets && !this.imageSrc ? We `<wui-wallet-image size="sm" name=${this.name}></wui-wallet-image>` : null
    }
    templateStatus() {
        return this.tagLabel && this.tagVariant ? We `<wui-tag variant=${this.tagVariant}>${this.tagLabel}</wui-tag>` : this.icon ? We `<wui-icon color="inherit" size="sm" name=${this.icon}></wui-icon>` : null
    }
};
Ka.styles = [dn, Di, u5e];
ju([xe({
    type: Array
})], Ka.prototype, "walletImages", void 0);
ju([xe()], Ka.prototype, "imageSrc", void 0);
ju([xe()], Ka.prototype, "name", void 0);
ju([xe()], Ka.prototype, "tagLabel", void 0);
ju([xe()], Ka.prototype, "tagVariant", void 0);
ju([xe()], Ka.prototype, "icon", void 0);
ju([xe()], Ka.prototype, "walletIcon", void 0);
ju([xe({
    type: Boolean
})], Ka.prototype, "installed", void 0);
ju([xe({
    type: Boolean
})], Ka.prototype, "disabled", void 0);
ju([xe({
    type: Boolean
})], Ka.prototype, "showAllWallets", void 0);
Ka = ju([Qe("wui-list-wallet")], Ka);
const f5e = Wt `
  :host {
    display: block;
    width: 40px;
    height: 40px;
    border-radius: var(--wui-border-radius-3xl);
    border: 1px solid var(--wui-gray-glass-010);
    overflow: hidden;
  }

  wui-icon {
    width: 100%;
    height: 100%;
  }
`;
var See = function(t, e, n, r) {
    var i = arguments.length,
        s = i < 3 ? e : r === null ? r = Object.getOwnPropertyDescriptor(e, n) : r,
        o;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function") s = Reflect.decorate(t, e, n, r);
    else
        for (var a = t.length - 1; a >= 0; a--)(o = t[a]) && (s = (i < 3 ? o(s) : i > 3 ? o(e, n, s) : o(e, n)) || s);
    return i > 3 && s && Object.defineProperty(e, n, s), s
};
let E_ = class extends Zt {
    constructor() {
        super(...arguments), this.logo = "google"
    }
    render() {
        return We `<wui-icon color="inherit" size="inherit" name=${this.logo}></wui-icon> `
    }
};
E_.styles = [dn, f5e];
See([xe()], E_.prototype, "logo", void 0);
E_ = See([Qe("wui-logo")], E_);
const d5e = Wt `
  :host {
    display: block;
  }

  button {
    width: 50px;
    height: 50px;
    background: var(--wui-gray-glass-002);
    border-radius: var(--wui-border-radius-xs);
  }
`;
var D$ = function(t, e, n, r) {
    var i = arguments.length,
        s = i < 3 ? e : r === null ? r = Object.getOwnPropertyDescriptor(e, n) : r,
        o;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function") s = Reflect.decorate(t, e, n, r);
    else
        for (var a = t.length - 1; a >= 0; a--)(o = t[a]) && (s = (i < 3 ? o(s) : i > 3 ? o(e, n, s) : o(e, n)) || s);
    return i > 3 && s && Object.defineProperty(e, n, s), s
};
let Nb = class extends Zt {
    constructor() {
        super(...arguments), this.logo = "google", this.disabled = !1
    }
    render() {
        return We `
      <button ?disabled=${this.disabled} ontouchstart>
        <wui-logo logo=${this.logo}></wui-logo>
      </button>
    `
    }
};
Nb.styles = [dn, Di, d5e];
D$([xe()], Nb.prototype, "logo", void 0);
D$([xe({
    type: Boolean
})], Nb.prototype, "disabled", void 0);
Nb = D$([Qe("wui-logo-select")], Nb);
const h5e = Wt `
  :host {
    display: block;
  }

  button {
    border-radius: var(--wui-border-radius-3xl);
    display: flex;
    gap: var(--wui-spacing-xs);
    padding: var(--wui-spacing-2xs) var(--wui-spacing-s) var(--wui-spacing-2xs)
      var(--wui-spacing-xs);
    border: 1px solid var(--wui-gray-glass-010);
    background-color: var(--wui-gray-glass-005);
    color: var(--wui-color-fg-100);
  }

  button:disabled {
    border: 1px solid var(--wui-gray-glass-005);
    background-color: var(--wui-gray-glass-015);
    color: var(--wui-gray-glass-015);
  }

  @media (hover: hover) and (pointer: fine) {
    button:hover:enabled {
      background-color: var(--wui-gray-glass-010);
    }

    button:active:enabled {
      background-color: var(--wui-gray-glass-015);
    }
  }

  wui-image,
  wui-icon-box {
    border-radius: var(--wui-border-radius-3xl);
    width: 24px;
    height: 24px;
    box-shadow: 0 0 0 2px var(--wui-gray-glass-005);
  }
`;
var $$ = function(t, e, n, r) {
    var i = arguments.length,
        s = i < 3 ? e : r === null ? r = Object.getOwnPropertyDescriptor(e, n) : r,
        o;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function") s = Reflect.decorate(t, e, n, r);
    else
        for (var a = t.length - 1; a >= 0; a--)(o = t[a]) && (s = (i < 3 ? o(s) : i > 3 ? o(e, n, s) : o(e, n)) || s);
    return i > 3 && s && Object.defineProperty(e, n, s), s
};
let Pb = class extends Zt {
    constructor() {
        super(...arguments), this.imageSrc = void 0, this.disabled = !1
    }
    render() {
        return We `
      <button ?disabled=${this.disabled}>
        ${this.visualTemplate()}
        <wui-text variant="paragraph-600" color="inherit">
          <slot></slot>
        </wui-text>
      </button>
    `
    }
    visualTemplate() {
        return this.imageSrc ? We `<wui-image src=${this.imageSrc}></wui-image>` : We `
      <wui-icon-box
        size="sm"
        iconColor="inverse-100"
        backgroundColor="fg-100"
        icon="networkPlaceholder"
      ></wui-icon-box>
    `
    }
};
Pb.styles = [dn, Di, h5e];
$$([xe()], Pb.prototype, "imageSrc", void 0);
$$([xe({
    type: Boolean
})], Pb.prototype, "disabled", void 0);
Pb = $$([Qe("wui-network-button")], Pb);
const p5e = Wt `
  :host {
    position: relative;
    display: block;
  }
`;
var vT = function(t, e, n, r) {
    var i = arguments.length,
        s = i < 3 ? e : r === null ? r = Object.getOwnPropertyDescriptor(e, n) : r,
        o;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function") s = Reflect.decorate(t, e, n, r);
    else
        for (var a = t.length - 1; a >= 0; a--)(o = t[a]) && (s = (i < 3 ? o(s) : i > 3 ? o(e, n, s) : o(e, n)) || s);
    return i > 3 && s && Object.defineProperty(e, n, s), s
};
let vm = class extends Zt {
    constructor() {
        super(...arguments), this.length = 6, this.otp = "", this.values = Array.from({
            length: this.length
        }).map(() => ""), this.numerics = [], this.shouldInputBeEnabled = e => this.values.slice(0, e).every(r => r !== ""), this.handleKeyDown = (e, n) => {
            const r = e.target,
                i = this.getInputElement(r),
                s = ["ArrowLeft", "ArrowRight", "Shift", "Delete"];
            if (!i) return;
            s.includes(e.key) && e.preventDefault();
            const o = i.selectionStart;
            switch (e.key) {
                case "ArrowLeft":
                    o && i.setSelectionRange(o + 1, o + 1), this.focusInputField("prev", n);
                    break;
                case "ArrowRight":
                    this.focusInputField("next", n);
                    break;
                case "Shift":
                    this.focusInputField("next", n);
                    break;
                case "Delete":
                    i.value === "" ? this.focusInputField("prev", n) : this.updateInput(i, n, "");
                    break;
                case "Backspace":
                    i.value === "" ? this.focusInputField("prev", n) : this.updateInput(i, n, "");
                    break
            }
        }, this.focusInputField = (e, n) => {
            if (e === "next") {
                const r = n + 1;
                if (!this.shouldInputBeEnabled(r)) return;
                const i = this.numerics[r < this.length ? r : n],
                    s = i ? this.getInputElement(i) : void 0;
                s && (s.disabled = !1, s.focus())
            }
            if (e === "prev") {
                const r = n - 1,
                    i = this.numerics[r > -1 ? r : n],
                    s = i ? this.getInputElement(i) : void 0;
                s && s.focus()
            }
        }
    }
    firstUpdated() {
        var n, r;
        this.otp && (this.values = this.otp.split(""));
        const e = (n = this.shadowRoot) == null ? void 0 : n.querySelectorAll("wui-input-numeric");
        e && (this.numerics = Array.from(e)), (r = this.numerics[0]) == null || r.focus()
    }
    render() {
        return We `
      <wui-flex gap="xxs" data-testid="wui-otp-input">
        ${Array.from({length:this.length}).map((e,n)=>We` <
            wui - input - numeric
        @input = $ {
            r => this.handleInput(r, n)
        }
        @keydown = $ {
                r => this.handleKeyDown(r, n)
            }
            .disabled = $ {
                !this.shouldInputBeEnabled(n)
            }
            .value = $ {
                this.values[n] || ""
            } >
            <
            /wui-input-numeric>
        `)}
      </wui-flex>
    `
    }
    updateInput(e, n, r) {
        const i = this.numerics[n],
            s = e || (i ? this.getInputElement(i) : void 0);
        s && (s.value = r, this.values = this.values.map((o, a) => a === n ? r : o))
    }
    handleInput(e, n) {
        const r = e.target,
            i = this.getInputElement(r);
        if (i) {
            const s = i.value;
            e.inputType === "insertFromPaste" ? this.handlePaste(i, s, n) : Mr.isNumber(s) && e.data ? (this.updateInput(i, n, e.data), this.focusInputField("next", n)) : this.updateInput(i, n, "")
        }
        this.dispatchInputChangeEvent()
    }
    handlePaste(e, n, r) {
        const i = n[0];
        if (i && Mr.isNumber(i)) {
            this.updateInput(e, r, i);
            const o = n.substring(1);
            if (r + 1 < this.length && o.length) {
                const a = this.numerics[r + 1],
                    l = a ? this.getInputElement(a) : void 0;
                l && this.handlePaste(l, o, r + 1)
            } else this.focusInputField("next", r)
        } else this.updateInput(e, r, "")
    }
    getInputElement(e) {
        var n;
        return (n = e.shadowRoot) != null && n.querySelector("input") ? e.shadowRoot.querySelector("input") : null
    }
    dispatchInputChangeEvent() {
        const e = this.values.join("");
        this.dispatchEvent(new CustomEvent("inputChange", {
            detail: e,
            bubbles: !0,
            composed: !0
        }))
    }
};
vm.styles = [dn, p5e];
vT([xe({
    type: Number
})], vm.prototype, "length", void 0);
vT([xe({
    type: String
})], vm.prototype, "otp", void 0);
vT([dT()], vm.prototype, "values", void 0);
vm = vT([Qe("wui-otp")], vm);
var uE = {},
    g5e = function() {
        return typeof Promise == "function" && Promise.prototype && Promise.prototype.then
    },
    Cee = {},
    Pl = {};
let L$;
const m5e = [0, 26, 44, 70, 100, 134, 172, 196, 242, 292, 346, 404, 466, 532, 581, 655, 733, 815, 901, 991, 1085, 1156, 1258, 1364, 1474, 1588, 1706, 1828, 1921, 2051, 2185, 2323, 2465, 2611, 2761, 2876, 3034, 3196, 3362, 3532, 3706];
Pl.getSymbolSize = function(e) {
    if (!e) throw new Error('"version" cannot be null or undefined');
    if (e < 1 || e > 40) throw new Error('"version" should be in range from 1 to 40');
    return e * 4 + 17
};
Pl.getSymbolTotalCodewords = function(e) {
    return m5e[e]
};
Pl.getBCHDigit = function(t) {
    let e = 0;
    for (; t !== 0;) e++, t >>>= 1;
    return e
};
Pl.setToSJISFunction = function(e) {
    if (typeof e != "function") throw new Error('"toSJISFunc" is not a valid function.');
    L$ = e
};
Pl.isKanjiModeEnabled = function() {
    return typeof L$ < "u"
};
Pl.toSJIS = function(e) {
    return L$(e)
};
var bT = {};
(function(t) {
    t.L = {
        bit: 1
    }, t.M = {
        bit: 0
    }, t.Q = {
        bit: 3
    }, t.H = {
        bit: 2
    };

    function e(n) {
        if (typeof n != "string") throw new Error("Param is not a string");
        switch (n.toLowerCase()) {
            case "l":
            case "low":
                return t.L;
            case "m":
            case "medium":
                return t.M;
            case "q":
            case "quartile":
                return t.Q;
            case "h":
            case "high":
                return t.H;
            default:
                throw new Error("Unknown EC Level: " + n)
        }
    }
    t.isValid = function(r) {
        return r && typeof r.bit < "u" && r.bit >= 0 && r.bit < 4
    }, t.from = function(r, i) {
        if (t.isValid(r)) return r;
        try {
            return e(r)
        } catch {
            return i
        }
    }
})(bT);

function Aee() {
    this.buffer = [], this.length = 0
}
Aee.prototype = {
    get: function(t) {
        const e = Math.floor(t / 8);
        return (this.buffer[e] >>> 7 - t % 8 & 1) === 1
    },
    put: function(t, e) {
        for (let n = 0; n < e; n++) this.putBit((t >>> e - n - 1 & 1) === 1)
    },
    getLengthInBits: function() {
        return this.length
    },
    putBit: function(t) {
        const e = Math.floor(this.length / 8);
        this.buffer.length <= e && this.buffer.push(0), t && (this.buffer[e] |= 128 >>> this.length % 8), this.length++
    }
};
var y5e = Aee;

function fE(t) {
    if (!t || t < 1) throw new Error("BitMatrix size must be defined and greater than 0");
    this.size = t, this.data = new Uint8Array(t * t), this.reservedBit = new Uint8Array(t * t)
}
fE.prototype.set = function(t, e, n, r) {
    const i = t * this.size + e;
    this.data[i] = n, r && (this.reservedBit[i] = !0)
};
fE.prototype.get = function(t, e) {
    return this.data[t * this.size + e]
};
fE.prototype.xor = function(t, e, n) {
    this.data[t * this.size + e] ^= n
};
fE.prototype.isReserved = function(t, e) {
    return this.reservedBit[t * this.size + e]
};
var w5e = fE,
    Tee = {};
(function(t) {
    const e = Pl.getSymbolSize;
    t.getRowColCoords = function(r) {
        if (r === 1) return [];
        const i = Math.floor(r / 7) + 2,
            s = e(r),
            o = s === 145 ? 26 : Math.ceil((s - 13) / (2 * i - 2)) * 2,
            a = [s - 7];
        for (let l = 1; l < i - 1; l++) a[l] = a[l - 1] - o;
        return a.push(6), a.reverse()
    }, t.getPositions = function(r) {
        const i = [],
            s = t.getRowColCoords(r),
            o = s.length;
        for (let a = 0; a < o; a++)
            for (let l = 0; l < o; l++) a === 0 && l === 0 || a === 0 && l === o - 1 || a === o - 1 && l === 0 || i.push([s[a], s[l]]);
        return i
    }
})(Tee);
var Iee = {};
const v5e = Pl.getSymbolSize,
    Lz = 7;
Iee.getPositions = function(e) {
    const n = v5e(e);
    return [
        [0, 0],
        [n - Lz, 0],
        [0, n - Lz]
    ]
};
var Ree = {};
(function(t) {
    t.Patterns = {
        PATTERN000: 0,
        PATTERN001: 1,
        PATTERN010: 2,
        PATTERN011: 3,
        PATTERN100: 4,
        PATTERN101: 5,
        PATTERN110: 6,
        PATTERN111: 7
    };
    const e = {
        N1: 3,
        N2: 3,
        N3: 40,
        N4: 10
    };
    t.isValid = function(i) {
        return i != null && i !== "" && !isNaN(i) && i >= 0 && i <= 7
    }, t.from = function(i) {
        return t.isValid(i) ? parseInt(i, 10) : void 0
    }, t.getPenaltyN1 = function(i) {
        const s = i.size;
        let o = 0,
            a = 0,
            l = 0,
            c = null,
            u = null;
        for (let f = 0; f < s; f++) {
            a = l = 0, c = u = null;
            for (let h = 0; h < s; h++) {
                let g = i.get(f, h);
                g === c ? a++ : (a >= 5 && (o += e.N1 + (a - 5)), c = g, a = 1), g = i.get(h, f), g === u ? l++ : (l >= 5 && (o += e.N1 + (l - 5)), u = g, l = 1)
            }
            a >= 5 && (o += e.N1 + (a - 5)), l >= 5 && (o += e.N1 + (l - 5))
        }
        return o
    }, t.getPenaltyN2 = function(i) {
        const s = i.size;
        let o = 0;
        for (let a = 0; a < s - 1; a++)
            for (let l = 0; l < s - 1; l++) {
                const c = i.get(a, l) + i.get(a, l + 1) + i.get(a + 1, l) + i.get(a + 1, l + 1);
                (c === 4 || c === 0) && o++
            }
        return o * e.N2
    }, t.getPenaltyN3 = function(i) {
        const s = i.size;
        let o = 0,
            a = 0,
            l = 0;
        for (let c = 0; c < s; c++) {
            a = l = 0;
            for (let u = 0; u < s; u++) a = a << 1 & 2047 | i.get(c, u), u >= 10 && (a === 1488 || a === 93) && o++, l = l << 1 & 2047 | i.get(u, c), u >= 10 && (l === 1488 || l === 93) && o++
        }
        return o * e.N3
    }, t.getPenaltyN4 = function(i) {
        let s = 0;
        const o = i.data.length;
        for (let l = 0; l < o; l++) s += i.data[l];
        return Math.abs(Math.ceil(s * 100 / o / 5) - 10) * e.N4
    };

    function n(r, i, s) {
        switch (r) {
            case t.Patterns.PATTERN000:
                return (i + s) % 2 === 0;
            case t.Patterns.PATTERN001:
                return i % 2 === 0;
            case t.Patterns.PATTERN010:
                return s % 3 === 0;
            case t.Patterns.PATTERN011:
                return (i + s) % 3 === 0;
            case t.Patterns.PATTERN100:
                return (Math.floor(i / 2) + Math.floor(s / 3)) % 2 === 0;
            case t.Patterns.PATTERN101:
                return i * s % 2 + i * s % 3 === 0;
            case t.Patterns.PATTERN110:
                return (i * s % 2 + i * s % 3) % 2 === 0;
            case t.Patterns.PATTERN111:
                return (i * s % 3 + (i + s) % 2) % 2 === 0;
            default:
                throw new Error("bad maskPattern:" + r)
        }
    }
    t.applyMask = function(i, s) {
        const o = s.size;
        for (let a = 0; a < o; a++)
            for (let l = 0; l < o; l++) s.isReserved(l, a) || s.xor(l, a, n(i, l, a))
    }, t.getBestMask = function(i, s) {
        const o = Object.keys(t.Patterns).length;
        let a = 0,
            l = 1 / 0;
        for (let c = 0; c < o; c++) {
            s(c), t.applyMask(c, i);
            const u = t.getPenaltyN1(i) + t.getPenaltyN2(i) + t.getPenaltyN3(i) + t.getPenaltyN4(i);
            t.applyMask(c, i), u < l && (l = u, a = c)
        }
        return a
    }
})(Ree);
var _T = {};
const up = bT,
    Nx = [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 1, 2, 2, 4, 1, 2, 4, 4, 2, 4, 4, 4, 2, 4, 6, 5, 2, 4, 6, 6, 2, 5, 8, 8, 4, 5, 8, 8, 4, 5, 8, 11, 4, 8, 10, 11, 4, 9, 12, 16, 4, 9, 16, 16, 6, 10, 12, 18, 6, 10, 17, 16, 6, 11, 16, 19, 6, 13, 18, 21, 7, 14, 21, 25, 8, 16, 20, 25, 8, 17, 23, 25, 9, 17, 23, 34, 9, 18, 25, 30, 10, 20, 27, 32, 12, 21, 29, 35, 12, 23, 34, 37, 12, 25, 34, 40, 13, 26, 35, 42, 14, 28, 38, 45, 15, 29, 40, 48, 16, 31, 43, 51, 17, 33, 45, 54, 18, 35, 48, 57, 19, 37, 51, 60, 19, 38, 53, 63, 20, 40, 56, 66, 21, 43, 59, 70, 22, 45, 62, 74, 24, 47, 65, 77, 25, 49, 68, 81],
    Px = [7, 10, 13, 17, 10, 16, 22, 28, 15, 26, 36, 44, 20, 36, 52, 64, 26, 48, 72, 88, 36, 64, 96, 112, 40, 72, 108, 130, 48, 88, 132, 156, 60, 110, 160, 192, 72, 130, 192, 224, 80, 150, 224, 264, 96, 176, 260, 308, 104, 198, 288, 352, 120, 216, 320, 384, 132, 240, 360, 432, 144, 280, 408, 480, 168, 308, 448, 532, 180, 338, 504, 588, 196, 364, 546, 650, 224, 416, 600, 700, 224, 442, 644, 750, 252, 476, 690, 816, 270, 504, 750, 900, 300, 560, 810, 960, 312, 588, 870, 1050, 336, 644, 952, 1110, 360, 700, 1020, 1200, 390, 728, 1050, 1260, 420, 784, 1140, 1350, 450, 812, 1200, 1440, 480, 868, 1290, 1530, 510, 924, 1350, 1620, 540, 980, 1440, 1710, 570, 1036, 1530, 1800, 570, 1064, 1590, 1890, 600, 1120, 1680, 1980, 630, 1204, 1770, 2100, 660, 1260, 1860, 2220, 720, 1316, 1950, 2310, 750, 1372, 2040, 2430];
_T.getBlocksCount = function(e, n) {
    switch (n) {
        case up.L:
            return Nx[(e - 1) * 4 + 0];
        case up.M:
            return Nx[(e - 1) * 4 + 1];
        case up.Q:
            return Nx[(e - 1) * 4 + 2];
        case up.H:
            return Nx[(e - 1) * 4 + 3];
        default:
            return
    }
};
_T.getTotalCodewordsCount = function(e, n) {
    switch (n) {
        case up.L:
            return Px[(e - 1) * 4 + 0];
        case up.M:
            return Px[(e - 1) * 4 + 1];
        case up.Q:
            return Px[(e - 1) * 4 + 2];
        case up.H:
            return Px[(e - 1) * 4 + 3];
        default:
            return
    }
};
var Oee = {},
    ET = {};
const F3 = new Uint8Array(512),
    eC = new Uint8Array(256);
(function() {
    let e = 1;
    for (let n = 0; n < 255; n++) F3[n] = e, eC[e] = n, e <<= 1, e & 256 && (e ^= 285);
    for (let n = 255; n < 512; n++) F3[n] = F3[n - 255]
})();
ET.log = function(e) {
    if (e < 1) throw new Error("log(" + e + ")");
    return eC[e]
};
ET.exp = function(e) {
    return F3[e]
};
ET.mul = function(e, n) {
    return e === 0 || n === 0 ? 0 : F3[eC[e] + eC[n]]
};
(function(t) {
    const e = ET;
    t.mul = function(r, i) {
        const s = new Uint8Array(r.length + i.length - 1);
        for (let o = 0; o < r.length; o++)
            for (let a = 0; a < i.length; a++) s[o + a] ^= e.mul(r[o], i[a]);
        return s
    }, t.mod = function(r, i) {
        let s = new Uint8Array(r);
        for (; s.length - i.length >= 0;) {
            const o = s[0];
            for (let l = 0; l < i.length; l++) s[l] ^= e.mul(i[l], o);
            let a = 0;
            for (; a < s.length && s[a] === 0;) a++;
            s = s.slice(a)
        }
        return s
    }, t.generateECPolynomial = function(r) {
        let i = new Uint8Array([1]);
        for (let s = 0; s < r; s++) i = t.mul(i, new Uint8Array([1, e.exp(s)]));
        return i
    }
})(Oee);
const Nee = Oee;

function B$(t) {
    this.genPoly = void 0, this.degree = t, this.degree && this.initialize(this.degree)
}
B$.prototype.initialize = function(e) {
    this.degree = e, this.genPoly = Nee.generateECPolynomial(this.degree)
};
B$.prototype.encode = function(e) {
    if (!this.genPoly) throw new Error("Encoder not initialized");
    const n = new Uint8Array(e.length + this.degree);
    n.set(e);
    const r = Nee.mod(n, this.genPoly),
        i = this.degree - r.length;
    if (i > 0) {
        const s = new Uint8Array(this.degree);
        return s.set(r, i), s
    }
    return r
};
var b5e = B$,
    Pee = {},
    ng = {},
    F$ = {};
F$.isValid = function(e) {
    return !isNaN(e) && e >= 1 && e <= 40
};
var ud = {};
const kee = "[0-9]+",
    _5e = "[A-Z $%*+\\-./:]+";
let x_ = "(?:[u3000-u303F]|[u3040-u309F]|[u30A0-u30FF]|[uFF00-uFFEF]|[u4E00-u9FAF]|[u2605-u2606]|[u2190-u2195]|u203B|[u2010u2015u2018u2019u2025u2026u201Cu201Du2225u2260]|[u0391-u0451]|[u00A7u00A8u00B1u00B4u00D7u00F7])+";
x_ = x_.replace(/u/g, "\\u");
const E5e = "(?:(?![A-Z0-9 $%*+\\-./:]|" + x_ + `)(?:.|[\r
]))+`;
ud.KANJI = new RegExp(x_, "g");
ud.BYTE_KANJI = new RegExp("[^A-Z0-9 $%*+\\-./:]+", "g");
ud.BYTE = new RegExp(E5e, "g");
ud.NUMERIC = new RegExp(kee, "g");
ud.ALPHANUMERIC = new RegExp(_5e, "g");
const x5e = new RegExp("^" + x_ + "$"),
    S5e = new RegExp("^" + kee + "$"),
    C5e = new RegExp("^[A-Z0-9 $%*+\\-./:]+$");
ud.testKanji = function(e) {
    return x5e.test(e)
};
ud.testNumeric = function(e) {
    return S5e.test(e)
};
ud.testAlphanumeric = function(e) {
    return C5e.test(e)
};
(function(t) {
    const e = F$,
        n = ud;
    t.NUMERIC = {
        id: "Numeric",
        bit: 1,
        ccBits: [10, 12, 14]
    }, t.ALPHANUMERIC = {
        id: "Alphanumeric",
        bit: 2,
        ccBits: [9, 11, 13]
    }, t.BYTE = {
        id: "Byte",
        bit: 4,
        ccBits: [8, 16, 16]
    }, t.KANJI = {
        id: "Kanji",
        bit: 8,
        ccBits: [8, 10, 12]
    }, t.MIXED = {
        bit: -1
    }, t.getCharCountIndicator = function(s, o) {
        if (!s.ccBits) throw new Error("Invalid mode: " + s);
        if (!e.isValid(o)) throw new Error("Invalid version: " + o);
        return o >= 1 && o < 10 ? s.ccBits[0] : o < 27 ? s.ccBits[1] : s.ccBits[2]
    }, t.getBestModeForData = function(s) {
        return n.testNumeric(s) ? t.NUMERIC : n.testAlphanumeric(s) ? t.ALPHANUMERIC : n.testKanji(s) ? t.KANJI : t.BYTE
    }, t.toString = function(s) {
        if (s && s.id) return s.id;
        throw new Error("Invalid mode")
    }, t.isValid = function(s) {
        return s && s.bit && s.ccBits
    };

    function r(i) {
        if (typeof i != "string") throw new Error("Param is not a string");
        switch (i.toLowerCase()) {
            case "numeric":
                return t.NUMERIC;
            case "alphanumeric":
                return t.ALPHANUMERIC;
            case "kanji":
                return t.KANJI;
            case "byte":
                return t.BYTE;
            default:
                throw new Error("Unknown mode: " + i)
        }
    }
    t.from = function(s, o) {
        if (t.isValid(s)) return s;
        try {
            return r(s)
        } catch {
            return o
        }
    }
})(ng);
(function(t) {
    const e = Pl,
        n = _T,
        r = bT,
        i = ng,
        s = F$,
        o = 7973,
        a = e.getBCHDigit(o);

    function l(h, g, y) {
        for (let _ = 1; _ <= 40; _++)
            if (g <= t.getCapacity(_, y, h)) return _
    }

    function c(h, g) {
        return i.getCharCountIndicator(h, g) + 4
    }

    function u(h, g) {
        let y = 0;
        return h.forEach(function(_) {
            const C = c(_.mode, g);
            y += C + _.getBitsLength()
        }), y
    }

    function f(h, g) {
        for (let y = 1; y <= 40; y++)
            if (u(h, y) <= t.getCapacity(y, g, i.MIXED)) return y
    }
    t.from = function(g, y) {
        return s.isValid(g) ? parseInt(g, 10) : y
    }, t.getCapacity = function(g, y, _) {
        if (!s.isValid(g)) throw new Error("Invalid QR Code version");
        typeof _ > "u" && (_ = i.BYTE);
        const C = e.getSymbolTotalCodewords(g),
            b = n.getTotalCodewordsCount(g, y),
            w = (C - b) * 8;
        if (_ === i.MIXED) return w;
        const S = w - c(_, g);
        switch (_) {
            case i.NUMERIC:
                return Math.floor(S / 10 * 3);
            case i.ALPHANUMERIC:
                return Math.floor(S / 11 * 2);
            case i.KANJI:
                return Math.floor(S / 13);
            case i.BYTE:
            default:
                return Math.floor(S / 8)
        }
    }, t.getBestVersionForData = function(g, y) {
        let _;
        const C = r.from(y, r.M);
        if (Array.isArray(g)) {
            if (g.length > 1) return f(g, C);
            if (g.length === 0) return 1;
            _ = g[0]
        } else _ = g;
        return l(_.mode, _.getLength(), C)
    }, t.getEncodedBits = function(g) {
        if (!s.isValid(g) || g < 7) throw new Error("Invalid QR Code version");
        let y = g << 12;
        for (; e.getBCHDigit(y) - a >= 0;) y ^= o << e.getBCHDigit(y) - a;
        return g << 12 | y
    }
})(Pee);
var Mee = {};
const $P = Pl,
    Dee = 1335,
    A5e = 21522,
    Bz = $P.getBCHDigit(Dee);
Mee.getEncodedBits = function(e, n) {
    const r = e.bit << 3 | n;
    let i = r << 10;
    for (; $P.getBCHDigit(i) - Bz >= 0;) i ^= Dee << $P.getBCHDigit(i) - Bz;
    return (r << 10 | i) ^ A5e
};
var $ee = {};
const T5e = ng;

function kb(t) {
    this.mode = T5e.NUMERIC, this.data = t.toString()
}
kb.getBitsLength = function(e) {
    return 10 * Math.floor(e / 3) + (e % 3 ? e % 3 * 3 + 1 : 0)
};
kb.prototype.getLength = function() {
    return this.data.length
};
kb.prototype.getBitsLength = function() {
    return kb.getBitsLength(this.data.length)
};
kb.prototype.write = function(e) {
    let n, r, i;
    for (n = 0; n + 3 <= this.data.length; n += 3) r = this.data.substr(n, 3), i = parseInt(r, 10), e.put(i, 10);
    const s = this.data.length - n;
    s > 0 && (r = this.data.substr(n), i = parseInt(r, 10), e.put(i, s * 3 + 1))
};
var I5e = kb;
const R5e = ng,
    MR = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", " ", "$", "%", "*", "+", "-", ".", "/", ":"];

function Mb(t) {
    this.mode = R5e.ALPHANUMERIC, this.data = t
}
Mb.getBitsLength = function(e) {
    return 11 * Math.floor(e / 2) + 6 * (e % 2)
};
Mb.prototype.getLength = function() {
    return this.data.length
};
Mb.prototype.getBitsLength = function() {
    return Mb.getBitsLength(this.data.length)
};
Mb.prototype.write = function(e) {
    let n;
    for (n = 0; n + 2 <= this.data.length; n += 2) {
        let r = MR.indexOf(this.data[n]) * 45;
        r += MR.indexOf(this.data[n + 1]), e.put(r, 11)
    }
    this.data.length % 2 && e.put(MR.indexOf(this.data[n]), 6)
};
var O5e = Mb,
    N5e = function(e) {
        for (var n = [], r = e.length, i = 0; i < r; i++) {
            var s = e.charCodeAt(i);
            if (s >= 55296 && s <= 56319 && r > i + 1) {
                var o = e.charCodeAt(i + 1);
                o >= 56320 && o <= 57343 && (s = (s - 55296) * 1024 + o - 56320 + 65536, i += 1)
            }
            if (s < 128) {
                n.push(s);
                continue
            }
            if (s < 2048) {
                n.push(s >> 6 | 192), n.push(s & 63 | 128);
                continue
            }
            if (s < 55296 || s >= 57344 && s < 65536) {
                n.push(s >> 12 | 224), n.push(s >> 6 & 63 | 128), n.push(s & 63 | 128);
                continue
            }
            if (s >= 65536 && s <= 1114111) {
                n.push(s >> 18 | 240), n.push(s >> 12 & 63 | 128), n.push(s >> 6 & 63 | 128), n.push(s & 63 | 128);
                continue
            }
            n.push(239, 191, 189)
        }
        return new Uint8Array(n).buffer
    };
const P5e = N5e,
    k5e = ng;

function Db(t) {
    this.mode = k5e.BYTE, typeof t == "string" && (t = P5e(t)), this.data = new Uint8Array(t)
}
Db.getBitsLength = function(e) {
    return e * 8
};
Db.prototype.getLength = function() {
    return this.data.length
};
Db.prototype.getBitsLength = function() {
    return Db.getBitsLength(this.data.length)
};
Db.prototype.write = function(t) {
    for (let e = 0, n = this.data.length; e < n; e++) t.put(this.data[e], 8)
};
var M5e = Db;
const D5e = ng,
    $5e = Pl;

function $b(t) {
    this.mode = D5e.KANJI, this.data = t
}
$b.getBitsLength = function(e) {
    return e * 13
};
$b.prototype.getLength = function() {
    return this.data.length
};
$b.prototype.getBitsLength = function() {
    return $b.getBitsLength(this.data.length)
};
$b.prototype.write = function(t) {
    let e;
    for (e = 0; e < this.data.length; e++) {
        let n = $5e.toSJIS(this.data[e]);
        if (n >= 33088 && n <= 40956) n -= 33088;
        else if (n >= 57408 && n <= 60351) n -= 49472;
        else throw new Error("Invalid SJIS character: " + this.data[e] + `
Make sure your charset is UTF-8`);
        n = (n >>> 8 & 255) * 192 + (n & 255), t.put(n, 13)
    }
};
var L5e = $b,
    Lee = {
        exports: {}
    };
(function(t) {
    var e = {
        single_source_shortest_paths: function(n, r, i) {
            var s = {},
                o = {};
            o[r] = 0;
            var a = e.PriorityQueue.make();
            a.push(r, 0);
            for (var l, c, u, f, h, g, y, _, C; !a.empty();) {
                l = a.pop(), c = l.value, f = l.cost, h = n[c] || {};
                for (u in h) h.hasOwnProperty(u) && (g = h[u], y = f + g, _ = o[u], C = typeof o[u] > "u", (C || _ > y) && (o[u] = y, a.push(u, y), s[u] = c))
            }
            if (typeof i < "u" && typeof o[i] > "u") {
                var b = ["Could not find a path from ", r, " to ", i, "."].join("");
                throw new Error(b)
            }
            return s
        },
        extract_shortest_path_from_predecessor_list: function(n, r) {
            for (var i = [], s = r; s;) i.push(s), n[s], s = n[s];
            return i.reverse(), i
        },
        find_path: function(n, r, i) {
            var s = e.single_source_shortest_paths(n, r, i);
            return e.extract_shortest_path_from_predecessor_list(s, i)
        },
        PriorityQueue: {
            make: function(n) {
                var r = e.PriorityQueue,
                    i = {},
                    s;
                n = n || {};
                for (s in r) r.hasOwnProperty(s) && (i[s] = r[s]);
                return i.queue = [], i.sorter = n.sorter || r.default_sorter, i
            },
            default_sorter: function(n, r) {
                return n.cost - r.cost
            },
            push: function(n, r) {
                var i = {
                    value: n,
                    cost: r
                };
                this.queue.push(i), this.queue.sort(this.sorter)
            },
            pop: function() {
                return this.queue.shift()
            },
            empty: function() {
                return this.queue.length === 0
            }
        }
    };
    t.exports = e
})(Lee);
var B5e = Lee.exports;
(function(t) {
    const e = ng,
        n = I5e,
        r = O5e,
        i = M5e,
        s = L5e,
        o = ud,
        a = Pl,
        l = B5e;

    function c(b) {
        return unescape(encodeURIComponent(b)).length
    }

    function u(b, w, S) {
        const I = [];
        let P;
        for (;
            (P = b.exec(S)) !== null;) I.push({
            data: P[0],
            index: P.index,
            mode: w,
            length: P[0].length
        });
        return I
    }

    function f(b) {
        const w = u(o.NUMERIC, e.NUMERIC, b),
            S = u(o.ALPHANUMERIC, e.ALPHANUMERIC, b);
        let I, P;
        return a.isKanjiModeEnabled() ? (I = u(o.BYTE, e.BYTE, b), P = u(o.KANJI, e.KANJI, b)) : (I = u(o.BYTE_KANJI, e.BYTE, b), P = []), w.concat(S, I, P).sort(function(A, E) {
            return A.index - E.index
        }).map(function(A) {
            return {
                data: A.data,
                mode: A.mode,
                length: A.length
            }
        })
    }

    function h(b, w) {
        switch (w) {
            case e.NUMERIC:
                return n.getBitsLength(b);
            case e.ALPHANUMERIC:
                return r.getBitsLength(b);
            case e.KANJI:
                return s.getBitsLength(b);
            case e.BYTE:
                return i.getBitsLength(b)
        }
    }

    function g(b) {
        return b.reduce(function(w, S) {
            const I = w.length - 1 >= 0 ? w[w.length - 1] : null;
            return I && I.mode === S.mode ? (w[w.length - 1].data += S.data, w) : (w.push(S), w)
        }, [])
    }

    function y(b) {
        const w = [];
        for (let S = 0; S < b.length; S++) {
            const I = b[S];
            switch (I.mode) {
                case e.NUMERIC:
                    w.push([I, {
                        data: I.data,
                        mode: e.ALPHANUMERIC,
                        length: I.length
                    }, {
                        data: I.data,
                        mode: e.BYTE,
                        length: I.length
                    }]);
                    break;
                case e.ALPHANUMERIC:
                    w.push([I, {
                        data: I.data,
                        mode: e.BYTE,
                        length: I.length
                    }]);
                    break;
                case e.KANJI:
                    w.push([I, {
                        data: I.data,
                        mode: e.BYTE,
                        length: c(I.data)
                    }]);
                    break;
                case e.BYTE:
                    w.push([{
                        data: I.data,
                        mode: e.BYTE,
                        length: c(I.data)
                    }])
            }
        }
        return w
    }

    function _(b, w) {
        const S = {},
            I = {
                start: {}
            };
        let P = ["start"];
        for (let M = 0; M < b.length; M++) {
            const A = b[M],
                E = [];
            for (let $ = 0; $ < A.length; $++) {
                const H = A[$],
                    K = "" + M + $;
                E.push(K), S[K] = {
                    node: H,
                    lastCount: 0
                }, I[K] = {};
                for (let te = 0; te < P.length; te++) {
                    const U = P[te];
                    S[U] && S[U].node.mode === H.mode ? (I[U][K] = h(S[U].lastCount + H.length, H.mode) - h(S[U].lastCount, H.mode), S[U].lastCount += H.length) : (S[U] && (S[U].lastCount = H.length), I[U][K] = h(H.length, H.mode) + 4 + e.getCharCountIndicator(H.mode, w))
                }
            }
            P = E
        }
        for (let M = 0; M < P.length; M++) I[P[M]].end = 0;
        return {
            map: I,
            table: S
        }
    }

    function C(b, w) {
        let S;
        const I = e.getBestModeForData(b);
        if (S = e.from(w, I), S !== e.BYTE && S.bit < I.bit) throw new Error('"' + b + '" cannot be encoded with mode ' + e.toString(S) + `.
 Suggested mode is: ` + e.toString(I));
        switch (S === e.KANJI && !a.isKanjiModeEnabled() && (S = e.BYTE), S) {
            case e.NUMERIC:
                return new n(b);
            case e.ALPHANUMERIC:
                return new r(b);
            case e.KANJI:
                return new s(b);
            case e.BYTE:
                return new i(b)
        }
    }
    t.fromArray = function(w) {
        return w.reduce(function(S, I) {
            return typeof I == "string" ? S.push(C(I, null)) : I.data && S.push(C(I.data, I.mode)), S
        }, [])
    }, t.fromString = function(w, S) {
        const I = f(w, a.isKanjiModeEnabled()),
            P = y(I),
            M = _(P, S),
            A = l.find_path(M.map, "start", "end"),
            E = [];
        for (let $ = 1; $ < A.length - 1; $++) E.push(M.table[A[$]].node);
        return t.fromArray(g(E))
    }, t.rawSplit = function(w) {
        return t.fromArray(f(w, a.isKanjiModeEnabled()))
    }
})($ee);
const xT = Pl,
    DR = bT,
    F5e = y5e,
    U5e = w5e,
    j5e = Tee,
    H5e = Iee,
    LP = Ree,
    BP = _T,
    z5e = b5e,
    tC = Pee,
    W5e = Mee,
    V5e = ng,
    $R = $ee;

function G5e(t, e) {
    const n = t.size,
        r = H5e.getPositions(e);
    for (let i = 0; i < r.length; i++) {
        const s = r[i][0],
            o = r[i][1];
        for (let a = -1; a <= 7; a++)
            if (!(s + a <= -1 || n <= s + a))
                for (let l = -1; l <= 7; l++) o + l <= -1 || n <= o + l || (a >= 0 && a <= 6 && (l === 0 || l === 6) || l >= 0 && l <= 6 && (a === 0 || a === 6) || a >= 2 && a <= 4 && l >= 2 && l <= 4 ? t.set(s + a, o + l, !0, !0) : t.set(s + a, o + l, !1, !0))
    }
}

function q5e(t) {
    const e = t.size;
    for (let n = 8; n < e - 8; n++) {
        const r = n % 2 === 0;
        t.set(n, 6, r, !0), t.set(6, n, r, !0)
    }
}

function K5e(t, e) {
    const n = j5e.getPositions(e);
    for (let r = 0; r < n.length; r++) {
        const i = n[r][0],
            s = n[r][1];
        for (let o = -2; o <= 2; o++)
            for (let a = -2; a <= 2; a++) o === -2 || o === 2 || a === -2 || a === 2 || o === 0 && a === 0 ? t.set(i + o, s + a, !0, !0) : t.set(i + o, s + a, !1, !0)
    }
}

function Y5e(t, e) {
    const n = t.size,
        r = tC.getEncodedBits(e);
    let i, s, o;
    for (let a = 0; a < 18; a++) i = Math.floor(a / 3), s = a % 3 + n - 8 - 3, o = (r >> a & 1) === 1, t.set(i, s, o, !0), t.set(s, i, o, !0)
}

function LR(t, e, n) {
    const r = t.size,
        i = W5e.getEncodedBits(e, n);
    let s, o;
    for (s = 0; s < 15; s++) o = (i >> s & 1) === 1, s < 6 ? t.set(s, 8, o, !0) : s < 8 ? t.set(s + 1, 8, o, !0) : t.set(r - 15 + s, 8, o, !0), s < 8 ? t.set(8, r - s - 1, o, !0) : s < 9 ? t.set(8, 15 - s - 1 + 1, o, !0) : t.set(8, 15 - s - 1, o, !0);
    t.set(r - 8, 8, 1, !0)
}

function Z5e(t, e) {
    const n = t.size;
    let r = -1,
        i = n - 1,
        s = 7,
        o = 0;
    for (let a = n - 1; a > 0; a -= 2)
        for (a === 6 && a--;;) {
            for (let l = 0; l < 2; l++)
                if (!t.isReserved(i, a - l)) {
                    let c = !1;
                    o < e.length && (c = (e[o] >>> s & 1) === 1), t.set(i, a - l, c), s--, s === -1 && (o++, s = 7)
                }
            if (i += r, i < 0 || n <= i) {
                i -= r, r = -r;
                break
            }
        }
}

function Q5e(t, e, n) {
    const r = new F5e;
    n.forEach(function(l) {
        r.put(l.mode.bit, 4), r.put(l.getLength(), V5e.getCharCountIndicator(l.mode, t)), l.write(r)
    });
    const i = xT.getSymbolTotalCodewords(t),
        s = BP.getTotalCodewordsCount(t, e),
        o = (i - s) * 8;
    for (r.getLengthInBits() + 4 <= o && r.put(0, 4); r.getLengthInBits() % 8 !== 0;) r.putBit(0);
    const a = (o - r.getLengthInBits()) / 8;
    for (let l = 0; l < a; l++) r.put(l % 2 ? 17 : 236, 8);
    return J5e(r, t, e)
}

function J5e(t, e, n) {
    const r = xT.getSymbolTotalCodewords(e),
        i = BP.getTotalCodewordsCount(e, n),
        s = r - i,
        o = BP.getBlocksCount(e, n),
        a = r % o,
        l = o - a,
        c = Math.floor(r / o),
        u = Math.floor(s / o),
        f = u + 1,
        h = c - u,
        g = new z5e(h);
    let y = 0;
    const _ = new Array(o),
        C = new Array(o);
    let b = 0;
    const w = new Uint8Array(t.buffer);
    for (let A = 0; A < o; A++) {
        const E = A < l ? u : f;
        _[A] = w.slice(y, y + E), C[A] = g.encode(_[A]), y += E, b = Math.max(b, E)
    }
    const S = new Uint8Array(r);
    let I = 0,
        P, M;
    for (P = 0; P < b; P++)
        for (M = 0; M < o; M++) P < _[M].length && (S[I++] = _[M][P]);
    for (P = 0; P < h; P++)
        for (M = 0; M < o; M++) S[I++] = C[M][P];
    return S
}

function X5e(t, e, n, r) {
    let i;
    if (Array.isArray(t)) i = $R.fromArray(t);
    else if (typeof t == "string") {
        let c = e;
        if (!c) {
            const u = $R.rawSplit(t);
            c = tC.getBestVersionForData(u, n)
        }
        i = $R.fromString(t, c || 40)
    } else throw new Error("Invalid data");
    const s = tC.getBestVersionForData(i, n);
    if (!s) throw new Error("The amount of data is too big to be stored in a QR Code");
    if (!e) e = s;
    else if (e < s) throw new Error(`
The chosen QR Code version cannot contain this amount of data.
Minimum version required to store current data is: ` + s + `.
`);
    const o = Q5e(e, n, i),
        a = xT.getSymbolSize(e),
        l = new U5e(a);
    return G5e(l, e), q5e(l), K5e(l, e), LR(l, n, 0), e >= 7 && Y5e(l, e), Z5e(l, o), isNaN(r) && (r = LP.getBestMask(l, LR.bind(null, l, n))), LP.applyMask(r, l), LR(l, n, r), {
        modules: l,
        version: e,
        errorCorrectionLevel: n,
        maskPattern: r,
        segments: i
    }
}
Cee.create = function(e, n) {
    if (typeof e > "u" || e === "") throw new Error("No input text");
    let r = DR.M,
        i, s;
    return typeof n < "u" && (r = DR.from(n.errorCorrectionLevel, DR.M), i = tC.from(n.version), s = LP.from(n.maskPattern), n.toSJISFunc && xT.setToSJISFunction(n.toSJISFunc)), X5e(e, i, r, s)
};
var Bee = {},
    U$ = {};
(function(t) {
    function e(n) {
        if (typeof n == "number" && (n = n.toString()), typeof n != "string") throw new Error("Color should be defined as hex string");
        let r = n.slice().replace("#", "").split("");
        if (r.length < 3 || r.length === 5 || r.length > 8) throw new Error("Invalid hex color: " + n);
        (r.length === 3 || r.length === 4) && (r = Array.prototype.concat.apply([], r.map(function(s) {
            return [s, s]
        }))), r.length === 6 && r.push("F", "F");
        const i = parseInt(r.join(""), 16);
        return {
            r: i >> 24 & 255,
            g: i >> 16 & 255,
            b: i >> 8 & 255,
            a: i & 255,
            hex: "#" + r.slice(0, 6).join("")
        }
    }
    t.getOptions = function(r) {
        r || (r = {}), r.color || (r.color = {});
        const i = typeof r.margin > "u" || r.margin === null || r.margin < 0 ? 4 : r.margin,
            s = r.width && r.width >= 21 ? r.width : void 0,
            o = r.scale || 4;
        return {
            width: s,
            scale: s ? 4 : o,
            margin: i,
            color: {
                dark: e(r.color.dark || "#000000ff"),
                light: e(r.color.light || "#ffffffff")
            },
            type: r.type,
            rendererOpts: r.rendererOpts || {}
        }
    }, t.getScale = function(r, i) {
        return i.width && i.width >= r + i.margin * 2 ? i.width / (r + i.margin * 2) : i.scale
    }, t.getImageWidth = function(r, i) {
        const s = t.getScale(r, i);
        return Math.floor((r + i.margin * 2) * s)
    }, t.qrToImageData = function(r, i, s) {
        const o = i.modules.size,
            a = i.modules.data,
            l = t.getScale(o, s),
            c = Math.floor((o + s.margin * 2) * l),
            u = s.margin * l,
            f = [s.color.light, s.color.dark];
        for (let h = 0; h < c; h++)
            for (let g = 0; g < c; g++) {
                let y = (h * c + g) * 4,
                    _ = s.color.light;
                if (h >= u && g >= u && h < c - u && g < c - u) {
                    const C = Math.floor((h - u) / l),
                        b = Math.floor((g - u) / l);
                    _ = f[a[C * o + b] ? 1 : 0]
                }
                r[y++] = _.r, r[y++] = _.g, r[y++] = _.b, r[y] = _.a
            }
    }
})(U$);
(function(t) {
    const e = U$;

    function n(i, s, o) {
        i.clearRect(0, 0, s.width, s.height), s.style || (s.style = {}), s.height = o, s.width = o, s.style.height = o + "px", s.style.width = o + "px"
    }

    function r() {
        try {
            return document.createElement("canvas")
        } catch {
            throw new Error("You need to specify a canvas element")
        }
    }
    t.render = function(s, o, a) {
        let l = a,
            c = o;
        typeof l > "u" && (!o || !o.getContext) && (l = o, o = void 0), o || (c = r()), l = e.getOptions(l);
        const u = e.getImageWidth(s.modules.size, l),
            f = c.getContext("2d"),
            h = f.createImageData(u, u);
        return e.qrToImageData(h.data, s, l), n(f, c, u), f.putImageData(h, 0, 0), c
    }, t.renderToDataURL = function(s, o, a) {
        let l = a;
        typeof l > "u" && (!o || !o.getContext) && (l = o, o = void 0), l || (l = {});
        const c = t.render(s, o, l),
            u = l.type || "image/png",
            f = l.rendererOpts || {};
        return c.toDataURL(u, f.quality)
    }
})(Bee);
var Fee = {};
const e3e = U$;

function Fz(t, e) {
    const n = t.a / 255,
        r = e + '="' + t.hex + '"';
    return n < 1 ? r + " " + e + '-opacity="' + n.toFixed(2).slice(1) + '"' : r
}

function BR(t, e, n) {
    let r = t + e;
    return typeof n < "u" && (r += " " + n), r
}

function t3e(t, e, n) {
    let r = "",
        i = 0,
        s = !1,
        o = 0;
    for (let a = 0; a < t.length; a++) {
        const l = Math.floor(a % e),
            c = Math.floor(a / e);
        !l && !s && (s = !0), t[a] ? (o++, a > 0 && l > 0 && t[a - 1] || (r += s ? BR("M", l + n, .5 + c + n) : BR("m", i, 0), i = 0, s = !1), l + 1 < e && t[a + 1] || (r += BR("h", o), o = 0)) : i++
    }
    return r
}
Fee.render = function(e, n, r) {
    const i = e3e.getOptions(n),
        s = e.modules.size,
        o = e.modules.data,
        a = s + i.margin * 2,
        l = i.color.light.a ? "<path " + Fz(i.color.light, "fill") + ' d="M0 0h' + a + "v" + a + 'H0z"/>' : "",
        c = "<path " + Fz(i.color.dark, "stroke") + ' d="' + t3e(o, s, i.margin) + '"/>',
        u = 'viewBox="0 0 ' + a + " " + a + '"',
        h = '<svg xmlns="http://www.w3.org/2000/svg" ' + (i.width ? 'width="' + i.width + '" height="' + i.width + '" ' : "") + u + ' shape-rendering="crispEdges">' + l + c + `</svg>
`;
    return typeof r == "function" && r(null, h), h
};
const n3e = g5e,
    FP = Cee,
    Uee = Bee,
    r3e = Fee;

function j$(t, e, n, r, i) {
    const s = [].slice.call(arguments, 1),
        o = s.length,
        a = typeof s[o - 1] == "function";
    if (!a && !n3e()) throw new Error("Callback required as last argument");
    if (a) {
        if (o < 2) throw new Error("Too few arguments provided");
        o === 2 ? (i = n, n = e, e = r = void 0) : o === 3 && (e.getContext && typeof i > "u" ? (i = r, r = void 0) : (i = r, r = n, n = e, e = void 0))
    } else {
        if (o < 1) throw new Error("Too few arguments provided");
        return o === 1 ? (n = e, e = r = void 0) : o === 2 && !e.getContext && (r = n, n = e, e = void 0), new Promise(function(l, c) {
            try {
                const u = FP.create(n, r);
                l(t(u, e, r))
            } catch (u) {
                c(u)
            }
        })
    }
    try {
        const l = FP.create(n, r);
        i(null, t(l, e, r))
    } catch (l) {
        i(l)
    }
}
uE.create = FP.create;
uE.toCanvas = j$.bind(null, Uee.render);
uE.toDataURL = j$.bind(null, Uee.renderToDataURL);
uE.toString = j$.bind(null, function(t, e, n) {
    return r3e.render(t, n)
});
const i3e = .1,
    Uz = 2.5,
    Td = 7;

function FR(t, e, n) {
    return t === e ? !1 : (t - e < 0 ? e - t : t - e) <= n + i3e
}

function s3e(t, e) {
    const n = Array.prototype.slice.call(uE.create(t, {
            errorCorrectionLevel: e
        }).modules.data, 0),
        r = Math.sqrt(n.length);
    return n.reduce((i, s, o) => (o % r === 0 ? i.push([s]) : i[i.length - 1].push(s)) && i, [])
}
const o3e = {
        generate(t, e, n) {
            const r = "#141414",
                i = "transparent",
                o = [],
                a = s3e(t, "Q"),
                l = e / a.length,
                c = [{
                    x: 0,
                    y: 0
                }, {
                    x: 1,
                    y: 0
                }, {
                    x: 0,
                    y: 1
                }];
            c.forEach(({
                x: _,
                y: C
            }) => {
                const b = (a.length - Td) * l * _,
                    w = (a.length - Td) * l * C,
                    S = .45;
                for (let I = 0; I < c.length; I += 1) {
                    const P = l * (Td - I * 2);
                    o.push(pt `
            <rect
              fill=${I===2?r:i}
              width=${I===0?P-5:P}
              rx= ${I===0?(P-5)*S:P*S}
              ry= ${I===0?(P-5)*S:P*S}
              stroke=${r}
              stroke-width=${I===0?5:0}
              height=${I===0?P-5:P}
              x= ${I===0?w+l*I+5/2:w+l*I}
              y= ${I===0?b+l*I+5/2:b+l*I}
            />
          `)
                }
            });
            const u = Math.floor((n + 25) / l),
                f = a.length / 2 - u / 2,
                h = a.length / 2 + u / 2 - 1,
                g = [];
            a.forEach((_, C) => {
                _.forEach((b, w) => {
                    if (a[C][w] && !(C < Td && w < Td || C > a.length - (Td + 1) && w < Td || C < Td && w > a.length - (Td + 1)) && !(C > f && C < h && w > f && w < h)) {
                        const S = C * l + l / 2,
                            I = w * l + l / 2;
                        g.push([S, I])
                    }
                })
            });
            const y = {};
            return g.forEach(([_, C]) => {
                var b;
                y[_] ? (b = y[_]) == null || b.push(C) : y[_] = [C]
            }), Object.entries(y).map(([_, C]) => {
                const b = C.filter(w => C.every(S => !FR(w, S, l)));
                return [Number(_), b]
            }).forEach(([_, C]) => {
                C.forEach(b => {
                    o.push(pt `<circle cx=${_} cy=${b} fill=${r} r=${l/Uz} />`)
                })
            }), Object.entries(y).filter(([_, C]) => C.length > 1).map(([_, C]) => {
                const b = C.filter(w => C.some(S => FR(w, S, l)));
                return [Number(_), b]
            }).map(([_, C]) => {
                C.sort((w, S) => w < S ? -1 : 1);
                const b = [];
                for (const w of C) {
                    const S = b.find(I => I.some(P => FR(w, P, l)));
                    S ? S.push(w) : b.push([w])
                }
                return [_, b.map(w => [w[0], w[w.length - 1]])]
            }).forEach(([_, C]) => {
                C.forEach(([b, w]) => {
                    o.push(pt `
              <line
                x1=${_}
                x2=${_}
                y1=${b}
                y2=${w}
                stroke=${r}
                stroke-width=${l/(Uz/2)}
                stroke-linecap="round"
              />
            `)
                })
            }), o
        }
    },
    a3e = Wt `
  :host {
    position: relative;
    user-select: none;
    display: block;
    overflow: hidden;
    aspect-ratio: 1 / 1;
    width: var(--local-size);
  }

  :host([data-theme='dark']) {
    border-radius: clamp(0px, var(--wui-border-radius-l), 40px);
    background-color: var(--wui-color-inverse-100);
    padding: var(--wui-spacing-l);
  }

  :host([data-theme='light']) {
    box-shadow: 0 0 0 1px var(--wui-color-bg-125);
    background-color: var(--wui-color-bg-125);
  }

  svg:first-child,
  wui-image,
  wui-icon {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translateY(-50%) translateX(-50%);
  }

  wui-image {
    width: 25%;
    height: 25%;
    border-radius: var(--wui-border-radius-xs);
  }

  wui-icon {
    width: 100%;
    height: 100%;
    color: #3396ff !important;
    transform: translateY(-50%) translateX(-50%) scale(0.25);
  }
`;
var C2 = function(t, e, n, r) {
    var i = arguments.length,
        s = i < 3 ? e : r === null ? r = Object.getOwnPropertyDescriptor(e, n) : r,
        o;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function") s = Reflect.decorate(t, e, n, r);
    else
        for (var a = t.length - 1; a >= 0; a--)(o = t[a]) && (s = (i < 3 ? o(s) : i > 3 ? o(e, n, s) : o(e, n)) || s);
    return i > 3 && s && Object.defineProperty(e, n, s), s
};
let xh = class extends Zt {
    constructor() {
        super(...arguments), this.uri = "", this.size = 0, this.theme = "dark", this.imageSrc = void 0, this.alt = void 0
    }
    render() {
        return this.dataset.theme = this.theme, this.style.cssText = `--local-size: ${this.size}px`, We `${this.templateVisual()} ${this.templateSvg()}`
    }
    templateSvg() {
        const e = this.theme === "light" ? this.size : this.size - 32;
        return pt `
      <svg height=${e} width=${e}>
        ${o3e.generate(this.uri,e,e/4)}
      </svg>
    `
    }
    templateVisual() {
        return this.imageSrc ? We `<wui-image src=${this.imageSrc} alt=${this.alt??"logo"}></wui-image>` : We `<wui-icon size="inherit" color="inherit" name="walletConnect"></wui-icon>`
    }
};
xh.styles = [dn, a3e];
C2([xe()], xh.prototype, "uri", void 0);
C2([xe({
    type: Number
})], xh.prototype, "size", void 0);
C2([xe()], xh.prototype, "theme", void 0);
C2([xe()], xh.prototype, "imageSrc", void 0);
C2([xe()], xh.prototype, "alt", void 0);
xh = C2([Qe("wui-qr-code")], xh);
const l3e = Wt `
  :host {
    position: relative;
    display: inline-block;
    width: 100%;
  }
`;
var c3e = function(t, e, n, r) {
    var i = arguments.length,
        s = i < 3 ? e : r === null ? r = Object.getOwnPropertyDescriptor(e, n) : r,
        o;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function") s = Reflect.decorate(t, e, n, r);
    else
        for (var a = t.length - 1; a >= 0; a--)(o = t[a]) && (s = (i < 3 ? o(s) : i > 3 ? o(e, n, s) : o(e, n)) || s);
    return i > 3 && s && Object.defineProperty(e, n, s), s
};
let nC = class extends Zt {
    constructor() {
        super(...arguments), this.inputComponentRef = bee()
    }
    render() {
        return We `
      <wui-input-text
        ${_ee(this.inputComponentRef)}
        placeholder="Search wallet"
        icon="search"
        type="search"
        enterKeyHint="search"
        size="sm"
      >
        <wui-input-element @click=${this.clearValue} icon="close"></wui-input-element>
      </wui-input-text>
    `
    }
    clearValue() {
        const e = this.inputComponentRef.value,
            n = e == null ? void 0 : e.inputElementRef.value;
        n && (n.value = "", n.focus(), n.dispatchEvent(new Event("input")))
    }
};
nC.styles = [dn, l3e];
nC = c3e([Qe("wui-search-bar")], nC);
const u3e = Wt `
  :host {
    display: flex;
    column-gap: var(--wui-spacing-xs);
    align-items: center;
    padding: var(--wui-spacing-xs) var(--wui-spacing-m) var(--wui-spacing-xs) var(--wui-spacing-xs);
    border-radius: var(--wui-border-radius-3xl);
    border: 1px solid var(--wui-gray-glass-005);
    background-color: var(--wui-color-bg-175);
    box-shadow:
      0px 14px 64px -4px rgba(0, 0, 0, 0.15),
      0px 8px 22px -6px rgba(0, 0, 0, 0.15);
  }
`;
var dE = function(t, e, n, r) {
    var i = arguments.length,
        s = i < 3 ? e : r === null ? r = Object.getOwnPropertyDescriptor(e, n) : r,
        o;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function") s = Reflect.decorate(t, e, n, r);
    else
        for (var a = t.length - 1; a >= 0; a--)(o = t[a]) && (s = (i < 3 ? o(s) : i > 3 ? o(e, n, s) : o(e, n)) || s);
    return i > 3 && s && Object.defineProperty(e, n, s), s
};
let $p = class extends Zt {
    constructor() {
        super(...arguments), this.backgroundColor = "accent-100", this.iconColor = "accent-100", this.icon = "checkmark", this.message = ""
    }
    render() {
        return We `
      <wui-icon-box
        size="sm"
        iconSize="xs"
        iconColor=${this.iconColor}
        backgroundColor=${this.backgroundColor}
        icon=${this.icon}
        background="opaque"
      ></wui-icon-box>
      <wui-text variant="paragraph-500" color="fg-100">${this.message}</wui-text>
    `
    }
};
$p.styles = [dn, u3e];
dE([xe()], $p.prototype, "backgroundColor", void 0);
dE([xe()], $p.prototype, "iconColor", void 0);
dE([xe()], $p.prototype, "icon", void 0);
dE([xe()], $p.prototype, "message", void 0);
$p = dE([Qe("wui-snackbar")], $p);
const f3e = Wt `
  :host {
    display: inline-flex;
    background-color: var(--wui-gray-glass-002);
    border-radius: var(--wui-border-radius-3xl);
    padding: var(--wui-spacing-3xs);
    position: relative;
    height: 36px;
    overflow: hidden;
  }

  :host::before {
    content: '';
    position: absolute;
    pointer-events: none;
    top: 4px;
    left: 4px;
    display: block;
    width: var(--local-tab-width);
    height: 28px;
    border-radius: var(--wui-border-radius-3xl);
    background-color: var(--wui-gray-glass-002);
    box-shadow: inset 0 0 0 1px var(--wui-gray-glass-002);
    transform: translateX(calc(var(--local-tab) * var(--local-tab-width)));
    transition: transform var(--wui-ease-out-power-2) var(--wui-duration-lg);
  }

  :host([data-type='flex'])::before {
    left: 3px;
    transform: translateX(calc((var(--local-tab) * 34px) + (var(--local-tab) * 4px)));
  }

  :host([data-type='flex']) {
    display: flex;
    padding: 0px 0px 0px 12px;
    gap: 4px;
  }

  :host([data-type='flex']) > button > wui-text {
    position: absolute;
    left: 18px;
    opacity: 0;
  }

  button[data-active='true'] > wui-icon,
  button[data-active='true'] > wui-text {
    color: var(--wui-color-fg-100);
  }

  button[data-active='false'] > wui-icon,
  button[data-active='false'] > wui-text {
    color: var(--wui-color-fg-200);
  }

  button[data-active='true']:disabled,
  button[data-active='false']:disabled {
    background-color: transparent;
    opacity: 0.5;
    cursor: not-allowed;
  }

  button[data-active='true']:disabled > wui-text {
    color: var(--wui-color-fg-200);
  }

  button[data-active='false']:disabled > wui-text {
    color: var(--wui-color-fg-300);
  }

  button > wui-icon,
  button > wui-text {
    pointer-events: none;
    transition: all var(--wui-ease-out-power-2) var(--wui-duration-lg);
  }

  button {
    width: var(--local-tab-width);
  }

  :host([data-type='flex']) > button {
    width: 34px;
    position: relative;
    display: flex;
    justify-content: flex-start;
  }

  button:hover:enabled,
  button:active:enabled {
    background-color: transparent !important;
  }

  button:hover:enabled > wui-icon,
  button:active:enabled > wui-icon {
    color: var(--wui-color-fg-125);
  }

  button:hover:enabled > wui-text,
  button:active:enabled > wui-text {
    color: var(--wui-color-fg-125);
  }

  button {
    border-radius: var(--wui-border-radius-3xl);
  }
`;
var rg = function(t, e, n, r) {
    var i = arguments.length,
        s = i < 3 ? e : r === null ? r = Object.getOwnPropertyDescriptor(e, n) : r,
        o;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function") s = Reflect.decorate(t, e, n, r);
    else
        for (var a = t.length - 1; a >= 0; a--)(o = t[a]) && (s = (i < 3 ? o(s) : i > 3 ? o(e, n, s) : o(e, n)) || s);
    return i > 3 && s && Object.defineProperty(e, n, s), s
};
let Nu = class extends Zt {
    constructor() {
        super(...arguments), this.tabs = [], this.onTabChange = () => null, this.buttons = [], this.disabled = !1, this.activeTab = 0, this.localTabWidth = "100px", this.isDense = !1
    }
    render() {
        return this.isDense = this.tabs.length > 3, this.style.cssText = `
      --local-tab: ${this.activeTab};
      --local-tab-width: ${this.localTabWidth};
    `, this.dataset.type = this.isDense ? "flex" : "block", this.tabs.map((e, n) => {
            const r = n === this.activeTab;
            return We `
        <button
          ?disabled=${this.disabled}
          @click=${()=>this.onTabClick(n)}
          data-active=${r}
        >
          <wui-icon size="xs" color="inherit" name=${e.icon}></wui-icon>
          <wui-text variant="small-600" color="inherit"> ${e.label} </wui-text>
        </button>
      `
        })
    }
    firstUpdated() {
        this.shadowRoot && this.isDense && (this.buttons = [...this.shadowRoot.querySelectorAll("button")], setTimeout(() => {
            this.animateTabs(0, !0)
        }, 0))
    }
    onTabClick(e) {
        this.buttons && this.animateTabs(e, !1), this.activeTab = e, this.onTabChange(e)
    }
    animateTabs(e, n) {
        const r = this.buttons[this.activeTab],
            i = this.buttons[e],
            s = r == null ? void 0 : r.querySelector("wui-text"),
            o = i == null ? void 0 : i.querySelector("wui-text"),
            a = i == null ? void 0 : i.getBoundingClientRect(),
            l = o == null ? void 0 : o.getBoundingClientRect();
        r && s && !n && e !== this.activeTab && (s.animate([{
            opacity: 0
        }], {
            duration: 50,
            easing: "ease",
            fill: "forwards"
        }), r.animate([{
            width: "34px"
        }], {
            duration: 500,
            easing: "ease",
            fill: "forwards"
        })), i && a && l && o && (e !== this.activeTab || n) && (this.localTabWidth = `${Math.round(a.width+l.width)+6}px`, i.animate([{
            width: `${a.width+l.width}px`
        }], {
            duration: n ? 0 : 500,
            fill: "forwards",
            easing: "ease"
        }), o.animate([{
            opacity: 1
        }], {
            duration: n ? 0 : 125,
            delay: n ? 0 : 200,
            fill: "forwards",
            easing: "ease"
        }))
    }
};
Nu.styles = [dn, Di, f3e];
rg([xe({
    type: Array
})], Nu.prototype, "tabs", void 0);
rg([xe()], Nu.prototype, "onTabChange", void 0);
rg([xe({
    type: Array
})], Nu.prototype, "buttons", void 0);
rg([xe({
    type: Boolean
})], Nu.prototype, "disabled", void 0);
rg([dT()], Nu.prototype, "activeTab", void 0);
rg([dT()], Nu.prototype, "localTabWidth", void 0);
rg([dT()], Nu.prototype, "isDense", void 0);
Nu = rg([Qe("wui-tabs")], Nu);
const d3e = Wt `
  :host {
    display: block;
    padding: 9px var(--wui-spacing-s) 10px var(--wui-spacing-s);
    border-radius: var(--wui-border-radius-xxs);
    background-color: var(--wui-color-fg-100);
    color: var(--wui-color-bg-100);
    position: relative;
  }

  wui-icon {
    position: absolute;
    width: 12px !important;
    height: 4px !important;
  }

  wui-icon[data-placement='top'] {
    bottom: 0;
    left: 50%;
    transform: translate(-50%, 95%);
  }

  wui-icon[data-placement='bottom'] {
    top: 0;
    left: 50%;
    transform: translate(-50%, -95%) rotate(180deg);
  }

  wui-icon[data-placement='right'] {
    top: 50%;
    left: 0;
    transform: translate(-65%, -50%) rotate(90deg);
  }

  wui-icon[data-placement='left'] {
    top: 50%;
    right: 0%;
    transform: translate(65%, -50%) rotate(270deg);
  }
`;
var H$ = function(t, e, n, r) {
    var i = arguments.length,
        s = i < 3 ? e : r === null ? r = Object.getOwnPropertyDescriptor(e, n) : r,
        o;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function") s = Reflect.decorate(t, e, n, r);
    else
        for (var a = t.length - 1; a >= 0; a--)(o = t[a]) && (s = (i < 3 ? o(s) : i > 3 ? o(e, n, s) : o(e, n)) || s);
    return i > 3 && s && Object.defineProperty(e, n, s), s
};
let Lb = class extends Zt {
    constructor() {
        super(...arguments), this.placement = "top", this.message = ""
    }
    render() {
        return We `<wui-icon
        data-placement=${this.placement}
        color="fg-100"
        size="inherit"
        name="cursor"
      ></wui-icon>
      <wui-text color="inherit" variant="small-500">${this.message}</wui-text>`
    }
};
Lb.styles = [dn, Di, d3e];
H$([xe()], Lb.prototype, "placement", void 0);
H$([xe()], Lb.prototype, "message", void 0);
Lb = H$([Qe("wui-tooltip")], Lb);
const h3e = Wt `
  :host {
    display: flex;
    justify-content: center;
    align-items: center;
    width: var(--wui-icon-box-size-xl);
    height: var(--wui-icon-box-size-xl);
    box-shadow: 0 0 0 8px var(--wui-thumbnail-border);
    border-radius: var(--local-border-radius);
    overflow: hidden;
  }

  wui-icon {
    width: 32px;
    height: 32px;
  }
`;
var ST = function(t, e, n, r) {
    var i = arguments.length,
        s = i < 3 ? e : r === null ? r = Object.getOwnPropertyDescriptor(e, n) : r,
        o;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function") s = Reflect.decorate(t, e, n, r);
    else
        for (var a = t.length - 1; a >= 0; a--)(o = t[a]) && (s = (i < 3 ? o(s) : i > 3 ? o(e, n, s) : o(e, n)) || s);
    return i > 3 && s && Object.defineProperty(e, n, s), s
};
let bm = class extends Zt {
    render() {
        return this.style.cssText = `--local-border-radius: ${this.borderRadiusFull?"1000px":"20px"};`, We `${this.templateVisual()}`
    }
    templateVisual() {
        return this.imageSrc ? We `<wui-image src=${this.imageSrc} alt=${this.alt??""}></wui-image>` : We `<wui-icon
      data-parent-size="md"
      size="inherit"
      color="inherit"
      name="walletPlaceholder"
    ></wui-icon>`
    }
};
bm.styles = [dn, h3e];
ST([xe()], bm.prototype, "imageSrc", void 0);
ST([xe()], bm.prototype, "alt", void 0);
ST([xe({
    type: Boolean
})], bm.prototype, "borderRadiusFull", void 0);
bm = ST([Qe("wui-visual-thumbnail")], bm);
const p3e = Wt `
  :host {
    display: block;
  }

  button {
    width: 100%;
    display: block;
    padding-top: var(--wui-spacing-l);
    padding-bottom: var(--wui-spacing-l);
    padding-left: var(--wui-spacing-s);
    padding-right: var(--wui-spacing-2l);
    border-radius: var(--wui-border-radius-s);
    background-color: var(--wui-accent-glass-015);
  }

  button:hover {
    background-color: var(--wui-accent-glass-010) !important;
  }

  button:active {
    background-color: var(--wui-accent-glass-020) !important;
  }
`;
var CT = function(t, e, n, r) {
    var i = arguments.length,
        s = i < 3 ? e : r === null ? r = Object.getOwnPropertyDescriptor(e, n) : r,
        o;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function") s = Reflect.decorate(t, e, n, r);
    else
        for (var a = t.length - 1; a >= 0; a--)(o = t[a]) && (s = (i < 3 ? o(s) : i > 3 ? o(e, n, s) : o(e, n)) || s);
    return i > 3 && s && Object.defineProperty(e, n, s), s
};
let _m = class extends Zt {
    constructor() {
        super(...arguments), this.label = "", this.description = "", this.icon = "wallet"
    }
    render() {
        return We `
      <button>
        <wui-flex gap="m" alignItems="center" justifyContent="space-between">
          <wui-icon-box
            size="lg"
            iconcolor="accent-100"
            backgroundcolor="accent-100"
            icon=${this.icon}
            background="transparent"
          ></wui-icon-box>

          <wui-flex flexDirection="column" gap="3xs">
            <wui-text variant="paragraph-500" color="fg-100">${this.label}</wui-text>
            <wui-text variant="small-400" color="fg-200">${this.description}</wui-text>
          </wui-flex>

          <wui-icon size="md" color="fg-200" name="chevronRight"></wui-icon>
        </wui-flex>
      </button>
    `
    }
};
_m.styles = [dn, Di, p3e];
CT([xe()], _m.prototype, "label", void 0);
CT([xe()], _m.prototype, "description", void 0);
CT([xe()], _m.prototype, "icon", void 0);
_m = CT([Qe("wui-notice-card")], _m);
const g3e = Wt `
  button {
    height: auto;
    position: relative;
    flex-direction: column;
    gap: var(--wui-spacing-s);
    padding: 17px 18px 17px var(--wui-spacing-m);
    width: 100%;
    background-color: var(--wui-gray-glass-002);
    border-radius: var(--wui-border-radius-xs);
    color: var(--wui-color-fg-250);
  }

  .overflowedContent {
    width: 100%;
    overflow: hidden;
  }

  .overflowedContent[data-active='false']:after {
    content: '';
    position: absolute;
    top: 50%;
    left: 0;
    right: 0;
    bottom: 0;
    background: linear-gradient(to top, var(--wui-color-bg-200), transparent);
    border-bottom-left-radius: var(--wui-border-radius-xs);
    border-bottom-right-radius: var(--wui-border-radius-xs);
  }

  .heightContent {
    max-height: 100px;
  }

  pre {
    text-align: left;
    white-space: pre-wrap;
    height: auto;
    overflow-x: auto;
    overflow-wrap: anywhere;
  }
`;
var z$ = function(t, e, n, r) {
    var i = arguments.length,
        s = i < 3 ? e : r === null ? r = Object.getOwnPropertyDescriptor(e, n) : r,
        o;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function") s = Reflect.decorate(t, e, n, r);
    else
        for (var a = t.length - 1; a >= 0; a--)(o = t[a]) && (s = (i < 3 ? o(s) : i > 3 ? o(e, n, s) : o(e, n)) || s);
    return i > 3 && s && Object.defineProperty(e, n, s), s
};
const UR = 100;
let Bb = class extends Zt {
    constructor() {
        super(...arguments), this.textTitle = "", this.overflowedContent = "", this.toggled = !1, this.enableAccordion = !1, this.scrollElement = void 0, this.scrollHeightElement = 0
    }
    firstUpdated() {
        setTimeout(() => {
            var n;
            const e = (n = this.shadowRoot) == null ? void 0 : n.querySelector(".heightContent");
            if (e) {
                this.scrollElement = e;
                const r = e == null ? void 0 : e.scrollHeight;
                r && r > UR && (this.enableAccordion = !0, this.scrollHeightElement = r, this.requestUpdate())
            }
        }, 0)
    }
    render() {
        return We `
      <button ontouchstart @click=${()=>this.onClick()}>
        <wui-flex justifyContent="space-between" alignItems="center">
          <wui-text variant="paragraph-500" color="fg-100">${this.textTitle}</wui-text>
          ${this.chevronTemplate()}
        </wui-flex>
        <div
          data-active=${this.enableAccordion?!!this.toggled:!0}
          class="overflowedContent"
        >
          <div class="heightContent">
            <wui-text variant="paragraph-400" color="fg-200">
              <pre>${this.overflowedContent}</pre>
            </wui-text>
          </div>
        </div>
      </button>
    `
    }
    onClick() {
        var n;
        const e = (n = this.shadowRoot) == null ? void 0 : n.querySelector("wui-icon");
        this.enableAccordion && (this.toggled = !this.toggled, this.requestUpdate(), this.scrollElement && this.scrollElement.animate([{
            maxHeight: this.toggled ? `${UR}px` : `${this.scrollHeightElement}px`
        }, {
            maxHeight: this.toggled ? `${this.scrollHeightElement}px` : `${UR}px`
        }], {
            duration: 300,
            fill: "forwards",
            easing: "ease"
        }), e && e.animate([{
            transform: this.toggled ? "rotate(0deg)" : "rotate(180deg)"
        }, {
            transform: this.toggled ? "rotate(180deg)" : "rotate(0deg)"
        }], {
            duration: 300,
            fill: "forwards",
            easing: "ease"
        }))
    }
    chevronTemplate() {
        return this.enableAccordion ? We ` <wui-icon color="fg-100" size="sm" name="chevronBottom"></wui-icon>` : null
    }
};
Bb.styles = [dn, Di, g3e];
z$([xe()], Bb.prototype, "textTitle", void 0);
z$([xe()], Bb.prototype, "overflowedContent", void 0);
Bb = z$([Qe("wui-list-accordion")], Bb);
const m3e = Wt `
  :host {
    display: flex;
    column-gap: var(--wui-spacing-s);
    padding: 17px 18px 17px var(--wui-spacing-m);
    width: 100%;
    background-color: var(--wui-gray-glass-002);
    border-radius: var(--wui-border-radius-xs);
    color: var(--wui-color-fg-250);
  }

  wui-image {
    width: var(--wui-icon-size-lg);
    height: var(--wui-icon-size-lg);
    border-radius: var(--wui-border-radius-3xl);
  }

  wui-icon {
    width: var(--wui-icon-size-lg);
    height: var(--wui-icon-size-lg);
  }
`;
var AT = function(t, e, n, r) {
    var i = arguments.length,
        s = i < 3 ? e : r === null ? r = Object.getOwnPropertyDescriptor(e, n) : r,
        o;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function") s = Reflect.decorate(t, e, n, r);
    else
        for (var a = t.length - 1; a >= 0; a--)(o = t[a]) && (s = (i < 3 ? o(s) : i > 3 ? o(e, n, s) : o(e, n)) || s);
    return i > 3 && s && Object.defineProperty(e, n, s), s
};
let Em = class extends Zt {
    constructor() {
        super(...arguments), this.imageSrc = void 0, this.textTitle = "", this.textValue = void 0
    }
    render() {
        return We `
      <wui-flex justifyContent="space-between" alignItems="center">
        <wui-text variant="paragraph-500" color=${this.textValue?"fg-200":"fg-100"}>
          ${this.textTitle}
        </wui-text>
        ${this.templateContent()}
      </wui-flex>
    `
    }
    templateContent() {
        return this.imageSrc ? We `<wui-image src=${this.imageSrc} alt=${this.textTitle}></wui-image>` : this.textValue ? We ` <wui-text variant="paragraph-400" color="fg-100"> ${this.textValue} </wui-text>` : We `<wui-icon size="inherit" color="fg-200" name="networkPlaceholder"></wui-icon>`
    }
};
Em.styles = [dn, Di, m3e];
AT([xe()], Em.prototype, "imageSrc", void 0);
AT([xe()], Em.prototype, "textTitle", void 0);
AT([xe()], Em.prototype, "textValue", void 0);
Em = AT([Qe("wui-list-content")], Em);
const y3e = Wt `
  :host {
    display: flex;
    flex-direction: column;
    gap: var(--wui-spacing-l);
    padding: 17px 18px 17px var(--wui-spacing-m);
    width: 100%;
    background-color: var(--wui-gray-glass-002);
    border-radius: var(--wui-border-radius-xs);
    color: var(--wui-color-fg-250);
  }

  wui-image {
    width: var(--wui-icon-size-lg);
    height: var(--wui-icon-size-lg);
    border-radius: var(--wui-border-radius-3xl);
  }

  wui-icon {
    width: var(--wui-icon-size-lg);
    height: var(--wui-icon-size-lg);
  }
`;
var hE = function(t, e, n, r) {
    var i = arguments.length,
        s = i < 3 ? e : r === null ? r = Object.getOwnPropertyDescriptor(e, n) : r,
        o;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function") s = Reflect.decorate(t, e, n, r);
    else
        for (var a = t.length - 1; a >= 0; a--)(o = t[a]) && (s = (i < 3 ? o(s) : i > 3 ? o(e, n, s) : o(e, n)) || s);
    return i > 3 && s && Object.defineProperty(e, n, s), s
};
let Lp = class extends Zt {
    constructor() {
        super(...arguments), this.amount = "", this.networkCurreny = "", this.networkImageUrl = "", this.receiverAddress = ""
    }
    render() {
        return We `
      <wui-flex justifyContent="space-between" alignItems="center">
        <wui-text variant="paragraph-500" color="fg-200">Sending</wui-text>
        <wui-flex gap="xs" alignItems="center">
          <wui-text variant="paragraph-400" color="fg-100">
            ${this.amount} ${this.networkCurreny}
          </wui-text>
          ${this.templateNetworkVisual()}
        </wui-flex>
      </wui-flex>
      <wui-flex justifyContent="space-between" alignItems="center">
        <wui-text variant="paragraph-500" color="fg-200">To</wui-text>
        <wui-chip
          icon="externalLink"
          variant="shadeSmall"
          href=${this.receiverAddress}
          title=${this.receiverAddress}
        ></wui-chip>
      </wui-flex>
    `
    }
    templateNetworkVisual() {
        return this.networkImageUrl ? We `<wui-image src=${this.networkImageUrl} alt="Network Image"></wui-image>` : We `<wui-icon size="inherit" color="fg-200" name="networkPlaceholder"></wui-icon>`
    }
};
Lp.styles = [dn, Di, y3e];
hE([xe()], Lp.prototype, "amount", void 0);
hE([xe()], Lp.prototype, "networkCurreny", void 0);
hE([xe()], Lp.prototype, "networkImageUrl", void 0);
hE([xe()], Lp.prototype, "receiverAddress", void 0);
Lp = hE([Qe("wui-list-wallet-transaction")], Lp);
const w3e = Wt `
  :host {
    display: grid;
    width: inherit;
    height: inherit;
  }
`;
var $c = function(t, e, n, r) {
    var i = arguments.length,
        s = i < 3 ? e : r === null ? r = Object.getOwnPropertyDescriptor(e, n) : r,
        o;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function") s = Reflect.decorate(t, e, n, r);
    else
        for (var a = t.length - 1; a >= 0; a--)(o = t[a]) && (s = (i < 3 ? o(s) : i > 3 ? o(e, n, s) : o(e, n)) || s);
    return i > 3 && s && Object.defineProperty(e, n, s), s
};
let fa = class extends Zt {
    render() {
        return this.style.cssText = `
      grid-template-rows: ${this.gridTemplateRows};
      grid-template-columns: ${this.gridTemplateColumns};
      justify-items: ${this.justifyItems};
      align-items: ${this.alignItems};
      justify-content: ${this.justifyContent};
      align-content: ${this.alignContent};
      column-gap: ${this.columnGap&&`var(--wui-spacing-${this.columnGap})`};
      row-gap: ${this.rowGap&&`var(--wui-spacing-${this.rowGap})`};
      gap: ${this.gap&&`var(--wui-spacing-${this.gap})`};
      padding-top: ${this.padding&&Mr.getSpacingStyles(this.padding,0)};
      padding-right: ${this.padding&&Mr.getSpacingStyles(this.padding,1)};
      padding-bottom: ${this.padding&&Mr.getSpacingStyles(this.padding,2)};
      padding-left: ${this.padding&&Mr.getSpacingStyles(this.padding,3)};
      margin-top: ${this.margin&&Mr.getSpacingStyles(this.margin,0)};
      margin-right: ${this.margin&&Mr.getSpacingStyles(this.margin,1)};
      margin-bottom: ${this.margin&&Mr.getSpacingStyles(this.margin,2)};
      margin-left: ${this.margin&&Mr.getSpacingStyles(this.margin,3)};
    `, We `<slot></slot>`
    }
};
fa.styles = [dn, w3e];
$c([xe()], fa.prototype, "gridTemplateRows", void 0);
$c([xe()], fa.prototype, "gridTemplateColumns", void 0);
$c([xe()], fa.prototype, "justifyItems", void 0);
$c([xe()], fa.prototype, "alignItems", void 0);
$c([xe()], fa.prototype, "justifyContent", void 0);
$c([xe()], fa.prototype, "alignContent", void 0);
$c([xe()], fa.prototype, "columnGap", void 0);
$c([xe()], fa.prototype, "rowGap", void 0);
$c([xe()], fa.prototype, "gap", void 0);
$c([xe()], fa.prototype, "padding", void 0);
$c([xe()], fa.prototype, "margin", void 0);
fa = $c([Qe("wui-grid")], fa);
const v3e = Wt `
  :host {
    position: relative;
    display: flex;
    width: 100%;
    height: 1px;
    background-color: var(--wui-gray-glass-005);
    justify-content: center;
    align-items: center;
  }

  :host > wui-text {
    position: absolute;
    padding: 0px 10px;
    background-color: var(--wui-color-modal-bg);
  }
`;
var jee = function(t, e, n, r) {
    var i = arguments.length,
        s = i < 3 ? e : r === null ? r = Object.getOwnPropertyDescriptor(e, n) : r,
        o;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function") s = Reflect.decorate(t, e, n, r);
    else
        for (var a = t.length - 1; a >= 0; a--)(o = t[a]) && (s = (i < 3 ? o(s) : i > 3 ? o(e, n, s) : o(e, n)) || s);
    return i > 3 && s && Object.defineProperty(e, n, s), s
};
let S_ = class extends Zt {
    constructor() {
        super(...arguments), this.text = ""
    }
    render() {
        return We `${this.template()}`
    }
    template() {
        return this.text ? We `<wui-text variant="small-500" color="fg-200">${this.text}</wui-text>` : null
    }
};
S_.styles = [dn, v3e];
jee([xe()], S_.prototype, "text", void 0);
S_ = jee([Qe("wui-separator")], S_);
var Hee = {
    exports: {}
};
(function(t, e) {
    (function(n, r) {
        t.exports = r()
    })(st, function() {
        var n = 1e3,
            r = 6e4,
            i = 36e5,
            s = "millisecond",
            o = "second",
            a = "minute",
            l = "hour",
            c = "day",
            u = "week",
            f = "month",
            h = "quarter",
            g = "year",
            y = "date",
            _ = "Invalid Date",
            C = /^(\d{4})[-/]?(\d{1,2})?[-/]?(\d{0,2})[Tt\s]*(\d{1,2})?:?(\d{1,2})?:?(\d{1,2})?[.:]?(\d+)?$/,
            b = /\[([^\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g,
            w = {
                name: "en",
                weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"),
                months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_"),
                ordinal: function(m) {
                    var v = ["th", "st", "nd", "rd"],
                        T = m % 100;
                    return "[" + m + (v[(T - 20) % 10] || v[T] || v[0]) + "]"
                }
            },
            S = function(m, v, T) {
                var N = String(m);
                return !N || N.length >= v ? m : "" + Array(v + 1 - N.length).join(T) + m
            },
            I = {
                s: S,
                z: function(m) {
                    var v = -m.utcOffset(),
                        T = Math.abs(v),
                        N = Math.floor(T / 60),
                        O = T % 60;
                    return (v <= 0 ? "+" : "-") + S(N, 2, "0") + ":" + S(O, 2, "0")
                },
                m: function m(v, T) {
                    if (v.date() < T.date()) return -m(T, v);
                    var N = 12 * (T.year() - v.year()) + (T.month() - v.month()),
                        O = v.clone().add(N, f),
                        L = T - O < 0,
                        G = v.clone().add(N + (L ? -1 : 1), f);
                    return +(-(N + (T - O) / (L ? O - G : G - O)) || 0)
                },
                a: function(m) {
                    return m < 0 ? Math.ceil(m) || 0 : Math.floor(m)
                },
                p: function(m) {
                    return {
                        M: f,
                        y: g,
                        w: u,
                        d: c,
                        D: y,
                        h: l,
                        m: a,
                        s: o,
                        ms: s,
                        Q: h
                    }[m] || String(m || "").toLowerCase().replace(/s$/, "")
                },
                u: function(m) {
                    return m === void 0
                }
            },
            P = "en",
            M = {};
        M[P] = w;
        var A = "$isDayjsObject",
            E = function(m) {
                return m instanceof te || !(!m || !m[A])
            },
            $ = function m(v, T, N) {
                var O;
                if (!v) return P;
                if (typeof v == "string") {
                    var L = v.toLowerCase();
                    M[L] && (O = L), T && (M[L] = T, O = L);
                    var G = v.split("-");
                    if (!O && G.length > 1) return m(G[0])
                } else {
                    var j = v.name;
                    M[j] = v, O = j
                }
                return !N && O && (P = O), O || !N && P
            },
            H = function(m, v) {
                if (E(m)) return m.clone();
                var T = typeof v == "object" ? v : {};
                return T.date = m, T.args = arguments, new te(T)
            },
            K = I;
        K.l = $, K.i = E, K.w = function(m, v) {
            return H(m, {
                locale: v.$L,
                utc: v.$u,
                x: v.$x,
                $offset: v.$offset
            })
        };
        var te = function() {
                function m(T) {
                    this.$L = $(T.locale, null, !0), this.parse(T), this.$x = this.$x || T.x || {}, this[A] = !0
                }
                var v = m.prototype;
                return v.parse = function(T) {
                    this.$d = function(N) {
                        var O = N.date,
                            L = N.utc;
                        if (O === null) return new Date(NaN);
                        if (K.u(O)) return new Date;
                        if (O instanceof Date) return new Date(O);
                        if (typeof O == "string" && !/Z$/i.test(O)) {
                            var G = O.match(C);
                            if (G) {
                                var j = G[2] - 1 || 0,
                                    R = (G[7] || "0").substring(0, 3);
                                return L ? new Date(Date.UTC(G[1], j, G[3] || 1, G[4] || 0, G[5] || 0, G[6] || 0, R)) : new Date(G[1], j, G[3] || 1, G[4] || 0, G[5] || 0, G[6] || 0, R)
                            }
                        }
                        return new Date(O)
                    }(T), this.init()
                }, v.init = function() {
                    var T = this.$d;
                    this.$y = T.getFullYear(), this.$M = T.getMonth(), this.$D = T.getDate(), this.$W = T.getDay(), this.$H = T.getHours(), this.$m = T.getMinutes(), this.$s = T.getSeconds(), this.$ms = T.getMilliseconds()
                }, v.$utils = function() {
                    return K
                }, v.isValid = function() {
                    return this.$d.toString() !== _
                }, v.isSame = function(T, N) {
                    var O = H(T);
                    return this.startOf(N) <= O && O <= this.endOf(N)
                }, v.isAfter = function(T, N) {
                    return H(T) < this.startOf(N)
                }, v.isBefore = function(T, N) {
                    return this.endOf(N) < H(T)
                }, v.$g = function(T, N, O) {
                    return K.u(T) ? this[N] : this.set(O, T)
                }, v.unix = function() {
                    return Math.floor(this.valueOf() / 1e3)
                }, v.valueOf = function() {
                    return this.$d.getTime()
                }, v.startOf = function(T, N) {
                    var O = this,
                        L = !!K.u(N) || N,
                        G = K.p(T),
                        j = function(ie, k) {
                            var z = K.w(O.$u ? Date.UTC(O.$y, k, ie) : new Date(O.$y, k, ie), O);
                            return L ? z : z.endOf(c)
                        },
                        R = function(ie, k) {
                            return K.w(O.toDate()[ie].apply(O.toDate("s"), (L ? [0, 0, 0, 0] : [23, 59, 59, 999]).slice(k)), O)
                        },
                        Y = this.$W,
                        ve = this.$M,
                        V = this.$D,
                        X = "set" + (this.$u ? "UTC" : "");
                    switch (G) {
                        case g:
                            return L ? j(1, 0) : j(31, 11);
                        case f:
                            return L ? j(1, ve) : j(0, ve + 1);
                        case u:
                            var q = this.$locale().weekStart || 0,
                                ne = (Y < q ? Y + 7 : Y) - q;
                            return j(L ? V - ne : V + (6 - ne), ve);
                        case c:
                        case y:
                            return R(X + "Hours", 0);
                        case l:
                            return R(X + "Minutes", 1);
                        case a:
                            return R(X + "Seconds", 2);
                        case o:
                            return R(X + "Milliseconds", 3);
                        default:
                            return this.clone()
                    }
                }, v.endOf = function(T) {
                    return this.startOf(T, !1)
                }, v.$set = function(T, N) {
                    var O, L = K.p(T),
                        G = "set" + (this.$u ? "UTC" : ""),
                        j = (O = {}, O[c] = G + "Date", O[y] = G + "Date", O[f] = G + "Month", O[g] = G + "FullYear", O[l] = G + "Hours", O[a] = G + "Minutes", O[o] = G + "Seconds", O[s] = G + "Milliseconds", O)[L],
                        R = L === c ? this.$D + (N - this.$W) : N;
                    if (L === f || L === g) {
                        var Y = this.clone().set(y, 1);
                        Y.$d[j](R), Y.init(), this.$d = Y.set(y, Math.min(this.$D, Y.daysInMonth())).$d
                    } else j && this.$d[j](R);
                    return this.init(), this
                }, v.set = function(T, N) {
                    return this.clone().$set(T, N)
                }, v.get = function(T) {
                    return this[K.p(T)]()
                }, v.add = function(T, N) {
                    var O, L = this;
                    T = Number(T);
                    var G = K.p(N),
                        j = function(ve) {
                            var V = H(L);
                            return K.w(V.date(V.date() + Math.round(ve * T)), L)
                        };
                    if (G === f) return this.set(f, this.$M + T);
                    if (G === g) return this.set(g, this.$y + T);
                    if (G === c) return j(1);
                    if (G === u) return j(7);
                    var R = (O = {}, O[a] = r, O[l] = i, O[o] = n, O)[G] || 1,
                        Y = this.$d.getTime() + T * R;
                    return K.w(Y, this)
                }, v.subtract = function(T, N) {
                    return this.add(-1 * T, N)
                }, v.format = function(T) {
                    var N = this,
                        O = this.$locale();
                    if (!this.isValid()) return O.invalidDate || _;
                    var L = T || "YYYY-MM-DDTHH:mm:ssZ",
                        G = K.z(this),
                        j = this.$H,
                        R = this.$m,
                        Y = this.$M,
                        ve = O.weekdays,
                        V = O.months,
                        X = O.meridiem,
                        q = function(k, z, Z, ge) {
                            return k && (k[z] || k(N, L)) || Z[z].slice(0, ge)
                        },
                        ne = function(k) {
                            return K.s(j % 12 || 12, k, "0")
                        },
                        ie = X || function(k, z, Z) {
                            var ge = k < 12 ? "AM" : "PM";
                            return Z ? ge.toLowerCase() : ge
                        };
                    return L.replace(b, function(k, z) {
                        return z || function(Z) {
                            switch (Z) {
                                case "YY":
                                    return String(N.$y).slice(-2);
                                case "YYYY":
                                    return K.s(N.$y, 4, "0");
                                case "M":
                                    return Y + 1;
                                case "MM":
                                    return K.s(Y + 1, 2, "0");
                                case "MMM":
                                    return q(O.monthsShort, Y, V, 3);
                                case "MMMM":
                                    return q(V, Y);
                                case "D":
                                    return N.$D;
                                case "DD":
                                    return K.s(N.$D, 2, "0");
                                case "d":
                                    return String(N.$W);
                                case "dd":
                                    return q(O.weekdaysMin, N.$W, ve, 2);
                                case "ddd":
                                    return q(O.weekdaysShort, N.$W, ve, 3);
                                case "dddd":
                                    return ve[N.$W];
                                case "H":
                                    return String(j);
                                case "HH":
                                    return K.s(j, 2, "0");
                                case "h":
                                    return ne(1);
                                case "hh":
                                    return ne(2);
                                case "a":
                                    return ie(j, R, !0);
                                case "A":
                                    return ie(j, R, !1);
                                case "m":
                                    return String(R);
                                case "mm":
                                    return K.s(R, 2, "0");
                                case "s":
                                    return String(N.$s);
                                case "ss":
                                    return K.s(N.$s, 2, "0");
                                case "SSS":
                                    return K.s(N.$ms, 3, "0");
                                case "Z":
                                    return G
                            }
                            return null
                        }(k) || G.replace(":", "")
                    })
                }, v.utcOffset = function() {
                    return 15 * -Math.round(this.$d.getTimezoneOffset() / 15)
                }, v.diff = function(T, N, O) {
                    var L, G = this,
                        j = K.p(N),
                        R = H(T),
                        Y = (R.utcOffset() - this.utcOffset()) * r,
                        ve = this - R,
                        V = function() {
                            return K.m(G, R)
                        };
                    switch (j) {
                        case g:
                            L = V() / 12;
                            break;
                        case f:
                            L = V();
                            break;
                        case h:
                            L = V() / 3;
                            break;
                        case u:
                            L = (ve - Y) / 6048e5;
                            break;
                        case c:
                            L = (ve - Y) / 864e5;
                            break;
                        case l:
                            L = ve / i;
                            break;
                        case a:
                            L = ve / r;
                            break;
                        case o:
                            L = ve / n;
                            break;
                        default:
                            L = ve
                    }
                    return O ? L : K.a(L)
                }, v.daysInMonth = function() {
                    return this.endOf(f).$D
                }, v.$locale = function() {
                    return M[this.$L]
                }, v.locale = function(T, N) {
                    if (!T) return this.$L;
                    var O = this.clone(),
                        L = $(T, N, !0);
                    return L && (O.$L = L), O
                }, v.clone = function() {
                    return K.w(this.$d, this)
                }, v.toDate = function() {
                    return new Date(this.valueOf())
                }, v.toJSON = function() {
                    return this.isValid() ? this.toISOString() : null
                }, v.toISOString = function() {
                    return this.$d.toISOString()
                }, v.toString = function() {
                    return this.$d.toUTCString()
                }, m
            }(),
            U = te.prototype;
        return H.prototype = U, [
            ["$ms", s],
            ["$s", o],
            ["$m", a],
            ["$H", l],
            ["$W", c],
            ["$M", f],
            ["$y", g],
            ["$D", y]
        ].forEach(function(m) {
            U[m[1]] = function(v) {
                return this.$g(v, m[0], m[1])
            }
        }), H.extend = function(m, v) {
            return m.$i || (m(v, te, H), m.$i = !0), H
        }, H.locale = $, H.isDayjs = E, H.unix = function(m) {
            return H(1e3 * m)
        }, H.en = M[P], H.Ls = M, H.p = {}, H
    })
})(Hee);
var b3e = Hee.exports;
const C_ = co(b3e);
var zee = {
    exports: {}
};
(function(t, e) {
    (function(n, r) {
        t.exports = r()
    })(st, function() {
        return function(n, r, i) {
            i.updateLocale = function(s, o) {
                var a = i.Ls[s];
                if (a) return (o ? Object.keys(o) : []).forEach(function(l) {
                    a[l] = o[l]
                }), a
            }
        }
    })
})(zee);
var _3e = zee.exports;
const E3e = co(_3e);
var Wee = {
    exports: {}
};
(function(t, e) {
    (function(n, r) {
        t.exports = r()
    })(st, function() {
        return function(n, r, i) {
            n = n || {};
            var s = r.prototype,
                o = {
                    future: "in %s",
                    past: "%s ago",
                    s: "a few seconds",
                    m: "a minute",
                    mm: "%d minutes",
                    h: "an hour",
                    hh: "%d hours",
                    d: "a day",
                    dd: "%d days",
                    M: "a month",
                    MM: "%d months",
                    y: "a year",
                    yy: "%d years"
                };

            function a(c, u, f, h) {
                return s.fromToBase(c, u, f, h)
            }
            i.en.relativeTime = o, s.fromToBase = function(c, u, f, h, g) {
                for (var y, _, C, b = f.$locale().relativeTime || o, w = n.thresholds || [{
                        l: "s",
                        r: 44,
                        d: "second"
                    }, {
                        l: "m",
                        r: 89
                    }, {
                        l: "mm",
                        r: 44,
                        d: "minute"
                    }, {
                        l: "h",
                        r: 89
                    }, {
                        l: "hh",
                        r: 21,
                        d: "hour"
                    }, {
                        l: "d",
                        r: 35
                    }, {
                        l: "dd",
                        r: 25,
                        d: "day"
                    }, {
                        l: "M",
                        r: 45
                    }, {
                        l: "MM",
                        r: 10,
                        d: "month"
                    }, {
                        l: "y",
                        r: 17
                    }, {
                        l: "yy",
                        d: "year"
                    }], S = w.length, I = 0; I < S; I += 1) {
                    var P = w[I];
                    P.d && (y = h ? i(c).diff(f, P.d, !0) : f.diff(c, P.d, !0));
                    var M = (n.rounding || Math.round)(Math.abs(y));
                    if (C = y > 0, M <= P.r || !P.r) {
                        M <= 1 && I > 0 && (P = w[I - 1]);
                        var A = b[P.l];
                        g && (M = g("" + M)), _ = typeof A == "string" ? A.replace("%d", M) : A(M, u, P.l, C);
                        break
                    }
                }
                if (u) return _;
                var E = C ? b.future : b.past;
                return typeof E == "function" ? E(_) : E.replace("%s", _)
            }, s.to = function(c, u) {
                return a(c, u, this, !0)
            }, s.from = function(c, u) {
                return a(c, u, this)
            };
            var l = function(c) {
                return c.$u ? i.utc() : i()
            };
            s.toNow = function(c) {
                return this.to(l(this), c)
            }, s.fromNow = function(c) {
                return this.from(l(this), c)
            }
        }
    })
})(Wee);
var x3e = Wee.exports;
const S3e = co(x3e);
C_.extend(S3e);
C_.extend(E3e);
C_.updateLocale("en", {
    relativeTime: {
        future: "in %s",
        past: "%s ago",
        s: "%s sec",
        m: "1 min",
        mm: "%d min",
        h: "1 hr",
        hh: "%d hrs",
        d: "1 d",
        dd: "%d d",
        M: "1 mo",
        MM: "%d mo",
        y: "1 yr",
        yy: "%d yr"
    }
});
const Vee = {
        getYear(t = new Date().toISOString()) {
            return C_(t).year()
        },
        getRelativeDateFromNow(t) {
            return C_(t).fromNow(!0)
        }
    },
    C3e = 3,
    A3e = ["receive", "deposit", "borrow", "claim"],
    T3e = ["withdraw", "repay", "burn"],
    o1 = {
        getTransactionGroupTitle(t) {
            const e = Vee.getYear();
            return t === e ? "This Year" : t
        },
        getTransactionImages(t) {
            const [e, n] = t, r = !!e && (t == null ? void 0 : t.every(o => !!o.nft_info)), i = (t == null ? void 0 : t.length) > 1;
            return (t == null ? void 0 : t.length) === 2 && !r ? [this.getTransactionImage(e), this.getTransactionImage(n)] : i ? t.map(o => this.getTransactionImage(o)) : [this.getTransactionImage(e)]
        },
        getTransactionImage(t) {
            return {
                type: o1.getTransactionTransferTokenType(t),
                url: o1.getTransactionImageURL(t)
            }
        },
        getTransactionImageURL(t) {
            var i, s, o, a, l;
            let e = null;
            const n = !!(t != null && t.nft_info),
                r = !!(t != null && t.fungible_info);
            return t && n ? e = (o = (s = (i = t == null ? void 0 : t.nft_info) == null ? void 0 : i.content) == null ? void 0 : s.preview) == null ? void 0 : o.url : t && r && (e = (l = (a = t == null ? void 0 : t.fungible_info) == null ? void 0 : a.icon) == null ? void 0 : l.url), e
        },
        getTransactionTransferTokenType(t) {
            return t != null && t.fungible_info ? "FUNGIBLE" : t != null && t.nft_info ? "NFT" : null
        },
        getTransactionDescriptions(t) {
            var f, h, g;
            const e = (f = t.metadata) == null ? void 0 : f.operationType,
                n = t.transfers,
                r = ((h = t.transfers) == null ? void 0 : h.length) > 0,
                i = ((g = t.transfers) == null ? void 0 : g.length) > 1,
                s = r && (n == null ? void 0 : n.every(y => !!y.fungible_info)),
                [o, a] = n;
            let l = this.getTransferDescription(o),
                c = this.getTransferDescription(a);
            if (!r) return (e === "send" || e === "receive") && s ? (l = Mr.getTruncateString({
                string: t.metadata.sentFrom,
                charsStart: 4,
                charsEnd: 6,
                truncate: "middle"
            }), c = Mr.getTruncateString({
                string: t.metadata.sentTo,
                charsStart: 4,
                charsEnd: 6,
                truncate: "middle"
            }), [l, c]) : [t.metadata.status];
            if (i) return n.map(y => this.getTransferDescription(y));
            let u = "";
            return A3e.includes(e) ? u = "+" : T3e.includes(e) && (u = "-"), l = u.concat(l), [l]
        },
        getTransferDescription(t) {
            var n;
            let e = "";
            return t && (t != null && t.nft_info ? e = ((n = t == null ? void 0 : t.nft_info) == null ? void 0 : n.name) || "-" : t != null && t.fungible_info && (e = this.getFungibleTransferDescription(t) || "-")), e
        },
        getFungibleTransferDescription(t) {
            var r;
            return t ? [this.getQuantityFixedValue(t == null ? void 0 : t.quantity.numeric), (r = t == null ? void 0 : t.fungible_info) == null ? void 0 : r.symbol].join(" ").trim() : null
        },
        getQuantityFixedValue(t) {
            return t ? parseFloat(t).toFixed(C3e) : null
        }
    },
    I3e = Object.freeze(Object.defineProperty({
        __proto__: null,
        TransactionUtil: o1,
        UiHelperUtil: Mr,
        get WuiAccountButton() {
            return Rc
        },
        get WuiAllWalletsImage() {
            return w_
        },
        get WuiAvatar() {
            return mm
        },
        get WuiButton() {
            return Iu
        },
        get WuiCard() {
            return Z8
        },
        get WuiCardSelect() {
            return Xf
        },
        get WuiCardSelectLoader() {
            return v_
        },
        get WuiChip() {
            return ed
        },
        get WuiConnectButton() {
            return Ib
        },
        get WuiCtaButton() {
            return ym
        },
        get WuiEmailInput() {
            return wm
        },
        get WuiFlex() {
            return Mo
        },
        get WuiGrid() {
            return fa
        },
        get WuiIcon() {
            return hm
        },
        get WuiIconBox() {
            return Ic
        },
        get WuiIconLink() {
            return Dp
        },
        get WuiImage() {
            return Ab
        },
        get WuiInputElement() {
            return b_
        },
        get WuiInputNumeric() {
            return Rb
        },
        get WuiInputText() {
            return Ru
        },
        get WuiLink() {
            return Ob
        },
        get WuiListAccordion() {
            return Bb
        },
        get WuiListContent() {
            return Em
        },
        get WuiListItem() {
            return Rl
        },
        get WuiListWallet() {
            return Ka
        },
        get WuiListWalletTransaction() {
            return Lp
        },
        get WuiLoadingHexagon() {
            return Q8
        },
        get WuiLoadingSpinner() {
            return Tb
        },
        get WuiLoadingThumbnail() {
            return m_
        },
        get WuiLogo() {
            return E_
        },
        get WuiLogoSelect() {
            return Nb
        },
        get WuiNetworkButton() {
            return Pb
        },
        get WuiNetworkImage() {
            return Mp
        },
        get WuiNoticeCard() {
            return _m
        },
        get WuiOtp() {
            return vm
        },
        get WuiQrCode() {
            return xh
        },
        get WuiSearchBar() {
            return nC
        },
        get WuiSeparator() {
            return S_
        },
        get WuiShimmer() {
            return pm
        },
        get WuiSnackbar() {
            return $p
        },
        get WuiTabs() {
            return Nu
        },
        get WuiTag() {
            return __
        },
        get WuiText() {
            return gm
        },
        get WuiTooltip() {
            return Lb
        },
        get WuiTransactionListItem() {
            return Ou
        },
        get WuiTransactionListItemLoader() {
            return X8
        },
        get WuiTransactionVisual() {
            return td
        },
        get WuiVisual() {
            return y_
        },
        get WuiVisualThumbnail() {
            return bm
        },
        get WuiWalletImage() {
            return Jf
        },
        customElement: Qe,
        initializeTheming: cee,
        setColorTheme: I$,
        setThemeVariables: uee
    }, Symbol.toStringTag, {
        value: "Module"
    }));
/**
 * @license
 * Copyright 2019 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const KS = globalThis,
    W$ = KS.ShadowRoot && (KS.ShadyCSS === void 0 || KS.ShadyCSS.nativeShadow) && "adoptedStyleSheets" in Document.prototype && "replace" in CSSStyleSheet.prototype,
    V$ = Symbol(),
    jz = new WeakMap;
let Gee = class {
    constructor(e, n, r) {
        if (this._$cssResult$ = !0, r !== V$) throw Error("CSSResult is not constructable. Use `unsafeCSS` or `css` instead.");
        this.cssText = e, this.t = n
    }
    get styleSheet() {
        let e = this.o;
        const n = this.t;
        if (W$ && e === void 0) {
            const r = n !== void 0 && n.length === 1;
            r && (e = jz.get(n)), e === void 0 && ((this.o = e = new CSSStyleSheet).replaceSync(this.cssText), r && jz.set(n, e))
        }
        return e
    }
    toString() {
        return this.cssText
    }
};
const R3e = t => new Gee(typeof t == "string" ? t : t + "", void 0, V$),
    bi = (t, ...e) => {
        const n = t.length === 1 ? t[0] : e.reduce((r, i, s) => r + (o => {
            if (o._$cssResult$ === !0) return o.cssText;
            if (typeof o == "number") return o;
            throw Error("Value passed to 'css' function must be a 'css' function result: " + o + ". Use 'unsafeCSS' to pass non-literal values, but take care to ensure page security.")
        })(i) + t[s + 1], t[0]);
        return new Gee(n, t, V$)
    },
    O3e = (t, e) => {
        if (W$) t.adoptedStyleSheets = e.map(n => n instanceof CSSStyleSheet ? n : n.styleSheet);
        else
            for (const n of e) {
                const r = document.createElement("style"),
                    i = KS.litNonce;
                i !== void 0 && r.setAttribute("nonce", i), r.textContent = n.cssText, t.appendChild(r)
            }
    },
    Hz = W$ ? t => t : t => t instanceof CSSStyleSheet ? (e => {
        let n = "";
        for (const r of e.cssRules) n += r.cssText;
        return R3e(n)
    })(t) : t;
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const {
    is: N3e,
    defineProperty: P3e,
    getOwnPropertyDescriptor: k3e,
    getOwnPropertyNames: M3e,
    getOwnPropertySymbols: D3e,
    getPrototypeOf: $3e
} = Object, _p = globalThis, zz = _p.trustedTypes, L3e = zz ? zz.emptyScript : "", jR = _p.reactiveElementPolyfillSupport, U3 = (t, e) => t, rC = {
    toAttribute(t, e) {
        switch (e) {
            case Boolean:
                t = t ? L3e : null;
                break;
            case Object:
            case Array:
                t = t == null ? t : JSON.stringify(t)
        }
        return t
    },
    fromAttribute(t, e) {
        let n = t;
        switch (e) {
            case Boolean:
                n = t !== null;
                break;
            case Number:
                n = t === null ? null : Number(t);
                break;
            case Object:
            case Array:
                try {
                    n = JSON.parse(t)
                } catch {
                    n = null
                }
        }
        return n
    }
}, G$ = (t, e) => !N3e(t, e), Wz = {
    attribute: !0,
    type: String,
    converter: rC,
    reflect: !1,
    hasChanged: G$
};
Symbol.metadata ? ? (Symbol.metadata = Symbol("metadata")), _p.litPropertyMetadata ? ? (_p.litPropertyMetadata = new WeakMap);
let ww = class extends HTMLElement {
    static addInitializer(e) {
        this._$Ei(), (this.l ? ? (this.l = [])).push(e)
    }
    static get observedAttributes() {
        return this.finalize(), this._$Eh && [...this._$Eh.keys()]
    }
    static createProperty(e, n = Wz) {
        if (n.state && (n.attribute = !1), this._$Ei(), this.elementProperties.set(e, n), !n.noAccessor) {
            const r = Symbol(),
                i = this.getPropertyDescriptor(e, r, n);
            i !== void 0 && P3e(this.prototype, e, i)
        }
    }
    static getPropertyDescriptor(e, n, r) {
        const {
            get: i,
            set: s
        } = k3e(this.prototype, e) ? ? {
            get() {
                return this[n]
            },
            set(o) {
                this[n] = o
            }
        };
        return {
            get() {
                return i == null ? void 0 : i.call(this)
            },
            set(o) {
                const a = i == null ? void 0 : i.call(this);
                s.call(this, o), this.requestUpdate(e, a, r)
            },
            configurable: !0,
            enumerable: !0
        }
    }
    static getPropertyOptions(e) {
        return this.elementProperties.get(e) ? ? Wz
    }
    static _$Ei() {
        if (this.hasOwnProperty(U3("elementProperties"))) return;
        const e = $3e(this);
        e.finalize(), e.l !== void 0 && (this.l = [...e.l]), this.elementProperties = new Map(e.elementProperties)
    }
    static finalize() {
        if (this.hasOwnProperty(U3("finalized"))) return;
        if (this.finalized = !0, this._$Ei(), this.hasOwnProperty(U3("properties"))) {
            const n = this.properties,
                r = [...M3e(n), ...D3e(n)];
            for (const i of r) this.createProperty(i, n[i])
        }
        const e = this[Symbol.metadata];
        if (e !== null) {
            const n = litPropertyMetadata.get(e);
            if (n !== void 0)
                for (const [r, i] of n) this.elementProperties.set(r, i)
        }
        this._$Eh = new Map;
        for (const [n, r] of this.elementProperties) {
            const i = this._$Eu(n, r);
            i !== void 0 && this._$Eh.set(i, n)
        }
        this.elementStyles = this.finalizeStyles(this.styles)
    }
    static finalizeStyles(e) {
        const n = [];
        if (Array.isArray(e)) {
            const r = new Set(e.flat(1 / 0).reverse());
            for (const i of r) n.unshift(Hz(i))
        } else e !== void 0 && n.push(Hz(e));
        return n
    }
    static _$Eu(e, n) {
        const r = n.attribute;
        return r === !1 ? void 0 : typeof r == "string" ? r : typeof e == "string" ? e.toLowerCase() : void 0
    }
    constructor() {
        super(), this._$Ep = void 0, this.isUpdatePending = !1, this.hasUpdated = !1, this._$Em = null, this._$Ev()
    }
    _$Ev() {
        var e;
        this._$ES = new Promise(n => this.enableUpdating = n), this._$AL = new Map, this._$E_(), this.requestUpdate(), (e = this.constructor.l) == null || e.forEach(n => n(this))
    }
    addController(e) {
        var n;
        (this._$EO ? ? (this._$EO = new Set)).add(e), this.renderRoot !== void 0 && this.isConnected && ((n = e.hostConnected) == null || n.call(e))
    }
    removeController(e) {
        var n;
        (n = this._$EO) == null || n.delete(e)
    }
    _$E_() {
        const e = new Map,
            n = this.constructor.elementProperties;
        for (const r of n.keys()) this.hasOwnProperty(r) && (e.set(r, this[r]), delete this[r]);
        e.size > 0 && (this._$Ep = e)
    }
    createRenderRoot() {
        const e = this.shadowRoot ? ? this.attachShadow(this.constructor.shadowRootOptions);
        return O3e(e, this.constructor.elementStyles), e
    }
    connectedCallback() {
        var e;
        this.renderRoot ? ? (this.renderRoot = this.createRenderRoot()), this.enableUpdating(!0), (e = this._$EO) == null || e.forEach(n => {
            var r;
            return (r = n.hostConnected) == null ? void 0 : r.call(n)
        })
    }
    enableUpdating(e) {}
    disconnectedCallback() {
        var e;
        (e = this._$EO) == null || e.forEach(n => {
            var r;
            return (r = n.hostDisconnected) == null ? void 0 : r.call(n)
        })
    }
    attributeChangedCallback(e, n, r) {
        this._$AK(e, r)
    }
    _$EC(e, n) {
        var s;
        const r = this.constructor.elementProperties.get(e),
            i = this.constructor._$Eu(e, r);
        if (i !== void 0 && r.reflect === !0) {
            const o = (((s = r.converter) == null ? void 0 : s.toAttribute) !== void 0 ? r.converter : rC).toAttribute(n, r.type);
            this._$Em = e, o == null ? this.removeAttribute(i) : this.setAttribute(i, o), this._$Em = null
        }
    }
    _$AK(e, n) {
        var s;
        const r = this.constructor,
            i = r._$Eh.get(e);
        if (i !== void 0 && this._$Em !== i) {
            const o = r.getPropertyOptions(i),
                a = typeof o.converter == "function" ? {
                    fromAttribute: o.converter
                } : ((s = o.converter) == null ? void 0 : s.fromAttribute) !== void 0 ? o.converter : rC;
            this._$Em = i, this[i] = a.fromAttribute(n, o.type), this._$Em = null
        }
    }
    requestUpdate(e, n, r) {
        if (e !== void 0) {
            if (r ? ? (r = this.constructor.getPropertyOptions(e)), !(r.hasChanged ? ? G$)(this[e], n)) return;
            this.P(e, n, r)
        }
        this.isUpdatePending === !1 && (this._$ES = this._$ET())
    }
    P(e, n, r) {
        this._$AL.has(e) || this._$AL.set(e, n), r.reflect === !0 && this._$Em !== e && (this._$Ej ? ? (this._$Ej = new Set)).add(e)
    }
    async _$ET() {
        this.isUpdatePending = !0;
        try {
            await this._$ES
        } catch (n) {
            Promise.reject(n)
        }
        const e = this.scheduleUpdate();
        return e != null && await e, !this.isUpdatePending
    }
    scheduleUpdate() {
        return this.performUpdate()
    }
    performUpdate() {
        var r;
        if (!this.isUpdatePending) return;
        if (!this.hasUpdated) {
            if (this.renderRoot ? ? (this.renderRoot = this.createRenderRoot()), this._$Ep) {
                for (const [s, o] of this._$Ep) this[s] = o;
                this._$Ep = void 0
            }
            const i = this.constructor.elementProperties;
            if (i.size > 0)
                for (const [s, o] of i) o.wrapped !== !0 || this._$AL.has(s) || this[s] === void 0 || this.P(s, this[s], o)
        }
        let e = !1;
        const n = this._$AL;
        try {
            e = this.shouldUpdate(n), e ? (this.willUpdate(n), (r = this._$EO) == null || r.forEach(i => {
                var s;
                return (s = i.hostUpdate) == null ? void 0 : s.call(i)
            }), this.update(n)) : this._$EU()
        } catch (i) {
            throw e = !1, this._$EU(), i
        }
        e && this._$AE(n)
    }
    willUpdate(e) {}
    _$AE(e) {
        var n;
        (n = this._$EO) == null || n.forEach(r => {
            var i;
            return (i = r.hostUpdated) == null ? void 0 : i.call(r)
        }), this.hasUpdated || (this.hasUpdated = !0, this.firstUpdated(e)), this.updated(e)
    }
    _$EU() {
        this._$AL = new Map, this.isUpdatePending = !1
    }
    get updateComplete() {
        return this.getUpdateComplete()
    }
    getUpdateComplete() {
        return this._$ES
    }
    shouldUpdate(e) {
        return !0
    }
    update(e) {
        this._$Ej && (this._$Ej = this._$Ej.forEach(n => this._$EC(n, this[n]))), this._$EU()
    }
    updated(e) {}
    firstUpdated(e) {}
};
ww.elementStyles = [], ww.shadowRootOptions = {
    mode: "open"
}, ww[U3("elementProperties")] = new Map, ww[U3("finalized")] = new Map, jR == null || jR({
    ReactiveElement: ww
}), (_p.reactiveElementVersions ? ? (_p.reactiveElementVersions = [])).push("2.0.4");
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const j3 = globalThis,
    iC = j3.trustedTypes,
    Vz = iC ? iC.createPolicy("lit-html", {
        createHTML: t => t
    }) : void 0,
    qee = "$lit$",
    N0 = `lit$${Math.random().toFixed(9).slice(2)}$`,
    Kee = "?" + N0,
    B3e = `<${Kee}>`,
    xm = document,
    A_ = () => xm.createComment(""),
    T_ = t => t === null || typeof t != "object" && typeof t != "function",
    q$ = Array.isArray,
    F3e = t => q$(t) || typeof(t == null ? void 0 : t[Symbol.iterator]) == "function",
    HR = `[ 	
\f\r]`,
    k5 = /<(?:(!--|\/[^a-zA-Z])|(\/?[a-zA-Z][^>\s]*)|(\/?$))/g,
    Gz = /-->/g,
    qz = />/g,
    kg = RegExp(`>|${HR}(?:([^\\s"'>=/]+)(${HR}*=${HR}*(?:[^ 	
\f\r"'\`<>=]|("|')|))|$)`, "g"),
    Kz = /'/g,
    Yz = /"/g,
    Yee = /^(?:script|style|textarea|title)$/i,
    U3e = t => (e, ...n) => ({
        _$litType$: t,
        strings: e,
        values: n
    }),
    $e = U3e(1),
    Fb = Symbol.for("lit-noChange"),
    as = Symbol.for("lit-nothing"),
    Zz = new WeakMap,
    a1 = xm.createTreeWalker(xm, 129);

function Zee(t, e) {
    if (!q$(t) || !t.hasOwnProperty("raw")) throw Error("invalid template strings array");
    return Vz !== void 0 ? Vz.createHTML(e) : e
}
const j3e = (t, e) => {
    const n = t.length - 1,
        r = [];
    let i, s = e === 2 ? "<svg>" : e === 3 ? "<math>" : "",
        o = k5;
    for (let a = 0; a < n; a++) {
        const l = t[a];
        let c, u, f = -1,
            h = 0;
        for (; h < l.length && (o.lastIndex = h, u = o.exec(l), u !== null);) h = o.lastIndex, o === k5 ? u[1] === "!--" ? o = Gz : u[1] !== void 0 ? o = qz : u[2] !== void 0 ? (Yee.test(u[2]) && (i = RegExp("</" + u[2], "g")), o = kg) : u[3] !== void 0 && (o = kg) : o === kg ? u[0] === ">" ? (o = i ? ? k5, f = -1) : u[1] === void 0 ? f = -2 : (f = o.lastIndex - u[2].length, c = u[1], o = u[3] === void 0 ? kg : u[3] === '"' ? Yz : Kz) : o === Yz || o === Kz ? o = kg : o === Gz || o === qz ? o = k5 : (o = kg, i = void 0);
        const g = o === kg && t[a + 1].startsWith("/>") ? " " : "";
        s += o === k5 ? l + B3e : f >= 0 ? (r.push(c), l.slice(0, f) + qee + l.slice(f) + N0 + g) : l + N0 + (f === -2 ? a : g)
    }
    return [Zee(t, s + (t[n] || "<?>") + (e === 2 ? "</svg>" : e === 3 ? "</math>" : "")), r]
};
let UP = class Qee {
    constructor({
        strings: e,
        _$litType$: n
    }, r) {
        let i;
        this.parts = [];
        let s = 0,
            o = 0;
        const a = e.length - 1,
            l = this.parts,
            [c, u] = j3e(e, n);
        if (this.el = Qee.createElement(c, r), a1.currentNode = this.el.content, n === 2 || n === 3) {
            const f = this.el.content.firstChild;
            f.replaceWith(...f.childNodes)
        }
        for (;
            (i = a1.nextNode()) !== null && l.length < a;) {
            if (i.nodeType === 1) {
                if (i.hasAttributes())
                    for (const f of i.getAttributeNames())
                        if (f.endsWith(qee)) {
                            const h = u[o++],
                                g = i.getAttribute(f).split(N0),
                                y = /([.?@])?(.*)/.exec(h);
                            l.push({
                                type: 1,
                                index: s,
                                name: y[2],
                                strings: g,
                                ctor: y[1] === "." ? z3e : y[1] === "?" ? W3e : y[1] === "@" ? V3e : TT
                            }), i.removeAttribute(f)
                        } else f.startsWith(N0) && (l.push({
                            type: 6,
                            index: s
                        }), i.removeAttribute(f));
                if (Yee.test(i.tagName)) {
                    const f = i.textContent.split(N0),
                        h = f.length - 1;
                    if (h > 0) {
                        i.textContent = iC ? iC.emptyScript : "";
                        for (let g = 0; g < h; g++) i.append(f[g], A_()), a1.nextNode(), l.push({
                            type: 2,
                            index: ++s
                        });
                        i.append(f[h], A_())
                    }
                }
            } else if (i.nodeType === 8)
                if (i.data === Kee) l.push({
                    type: 2,
                    index: s
                });
                else {
                    let f = -1;
                    for (;
                        (f = i.data.indexOf(N0, f + 1)) !== -1;) l.push({
                        type: 7,
                        index: s
                    }), f += N0.length - 1
                }
            s++
        }
    }
    static createElement(e, n) {
        const r = xm.createElement("template");
        return r.innerHTML = e, r
    }
};

function Ub(t, e, n = t, r) {
    var o, a;
    if (e === Fb) return e;
    let i = r !== void 0 ? (o = n.o) == null ? void 0 : o[r] : n.l;
    const s = T_(e) ? void 0 : e._$litDirective$;
    return (i == null ? void 0 : i.constructor) !== s && ((a = i == null ? void 0 : i._$AO) == null || a.call(i, !1), s === void 0 ? i = void 0 : (i = new s(t), i._$AT(t, n, r)), r !== void 0 ? (n.o ? ? (n.o = []))[r] = i : n.l = i), i !== void 0 && (e = Ub(t, i._$AS(t, e.values), i, r)), e
}
let H3e = class {
        constructor(e, n) {
            this._$AV = [], this._$AN = void 0, this._$AD = e, this._$AM = n
        }
        get parentNode() {
            return this._$AM.parentNode
        }
        get _$AU() {
            return this._$AM._$AU
        }
        u(e) {
            const {
                el: {
                    content: n
                },
                parts: r
            } = this._$AD, i = ((e == null ? void 0 : e.creationScope) ? ? xm).importNode(n, !0);
            a1.currentNode = i;
            let s = a1.nextNode(),
                o = 0,
                a = 0,
                l = r[0];
            for (; l !== void 0;) {
                if (o === l.index) {
                    let c;
                    l.type === 2 ? c = new K$(s, s.nextSibling, this, e) : l.type === 1 ? c = new l.ctor(s, l.name, l.strings, this, e) : l.type === 6 && (c = new G3e(s, this, e)), this._$AV.push(c), l = r[++a]
                }
                o !== (l == null ? void 0 : l.index) && (s = a1.nextNode(), o++)
            }
            return a1.currentNode = xm, i
        }
        p(e) {
            let n = 0;
            for (const r of this._$AV) r !== void 0 && (r.strings !== void 0 ? (r._$AI(e, r, n), n += r.strings.length - 2) : r._$AI(e[n])), n++
        }
    },
    K$ = class Jee {
        get _$AU() {
            var e;
            return ((e = this._$AM) == null ? void 0 : e._$AU) ? ? this.v
        }
        constructor(e, n, r, i) {
            this.type = 2, this._$AH = as, this._$AN = void 0, this._$AA = e, this._$AB = n, this._$AM = r, this.options = i, this.v = (i == null ? void 0 : i.isConnected) ? ? !0
        }
        get parentNode() {
            let e = this._$AA.parentNode;
            const n = this._$AM;
            return n !== void 0 && (e == null ? void 0 : e.nodeType) === 11 && (e = n.parentNode), e
        }
        get startNode() {
            return this._$AA
        }
        get endNode() {
            return this._$AB
        }
        _$AI(e, n = this) {
            e = Ub(this, e, n), T_(e) ? e === as || e == null || e === "" ? (this._$AH !== as && this._$AR(), this._$AH = as) : e !== this._$AH && e !== Fb && this._(e) : e._$litType$ !== void 0 ? this.$(e) : e.nodeType !== void 0 ? this.T(e) : F3e(e) ? this.k(e) : this._(e)
        }
        O(e) {
            return this._$AA.parentNode.insertBefore(e, this._$AB)
        }
        T(e) {
            this._$AH !== e && (this._$AR(), this._$AH = this.O(e))
        }
        _(e) {
            this._$AH !== as && T_(this._$AH) ? this._$AA.nextSibling.data = e : this.T(xm.createTextNode(e)), this._$AH = e
        }
        $(e) {
            var s;
            const {
                values: n,
                _$litType$: r
            } = e, i = typeof r == "number" ? this._$AC(e) : (r.el === void 0 && (r.el = UP.createElement(Zee(r.h, r.h[0]), this.options)), r);
            if (((s = this._$AH) == null ? void 0 : s._$AD) === i) this._$AH.p(n);
            else {
                const o = new H3e(i, this),
                    a = o.u(this.options);
                o.p(n), this.T(a), this._$AH = o
            }
        }
        _$AC(e) {
            let n = Zz.get(e.strings);
            return n === void 0 && Zz.set(e.strings, n = new UP(e)), n
        }
        k(e) {
            q$(this._$AH) || (this._$AH = [], this._$AR());
            const n = this._$AH;
            let r, i = 0;
            for (const s of e) i === n.length ? n.push(r = new Jee(this.O(A_()), this.O(A_()), this, this.options)) : r = n[i], r._$AI(s), i++;
            i < n.length && (this._$AR(r && r._$AB.nextSibling, i), n.length = i)
        }
        _$AR(e = this._$AA.nextSibling, n) {
            var r;
            for ((r = this._$AP) == null ? void 0 : r.call(this, !1, !0, n); e && e !== this._$AB;) {
                const i = e.nextSibling;
                e.remove(), e = i
            }
        }
        setConnected(e) {
            var n;
            this._$AM === void 0 && (this.v = e, (n = this._$AP) == null || n.call(this, e))
        }
    },
    TT = class {
        get tagName() {
            return this.element.tagName
        }
        get _$AU() {
            return this._$AM._$AU
        }
        constructor(e, n, r, i, s) {
            this.type = 1, this._$AH = as, this._$AN = void 0, this.element = e, this.name = n, this._$AM = i, this.options = s, r.length > 2 || r[0] !== "" || r[1] !== "" ? (this._$AH = Array(r.length - 1).fill(new String), this.strings = r) : this._$AH = as
        }
        _$AI(e, n = this, r, i) {
            const s = this.strings;
            let o = !1;
            if (s === void 0) e = Ub(this, e, n, 0), o = !T_(e) || e !== this._$AH && e !== Fb, o && (this._$AH = e);
            else {
                const a = e;
                let l, c;
                for (e = s[0], l = 0; l < s.length - 1; l++) c = Ub(this, a[r + l], n, l), c === Fb && (c = this._$AH[l]), o || (o = !T_(c) || c !== this._$AH[l]), c === as ? e = as : e !== as && (e += (c ? ? "") + s[l + 1]), this._$AH[l] = c
            }
            o && !i && this.j(e)
        }
        j(e) {
            e === as ? this.element.removeAttribute(this.name) : this.element.setAttribute(this.name, e ? ? "")
        }
    },
    z3e = class extends TT {
        constructor() {
            super(...arguments), this.type = 3
        }
        j(e) {
            this.element[this.name] = e === as ? void 0 : e
        }
    },
    W3e = class extends TT {
        constructor() {
            super(...arguments), this.type = 4
        }
        j(e) {
            this.element.toggleAttribute(this.name, !!e && e !== as)
        }
    },
    V3e = class extends TT {
        constructor(e, n, r, i, s) {
            super(e, n, r, i, s), this.type = 5
        }
        _$AI(e, n = this) {
            if ((e = Ub(this, e, n, 0) ? ? as) === Fb) return;
            const r = this._$AH,
                i = e === as && r !== as || e.capture !== r.capture || e.once !== r.once || e.passive !== r.passive,
                s = e !== as && (r === as || i);
            i && this.element.removeEventListener(this.name, this, r), s && this.element.addEventListener(this.name, this, e), this._$AH = e
        }
        handleEvent(e) {
            var n;
            typeof this._$AH == "function" ? this._$AH.call(((n = this.options) == null ? void 0 : n.host) ? ? this.element, e) : this._$AH.handleEvent(e)
        }
    },
    G3e = class {
        constructor(e, n, r) {
            this.element = e, this.type = 6, this._$AN = void 0, this._$AM = n, this.options = r
        }
        get _$AU() {
            return this._$AM._$AU
        }
        _$AI(e) {
            Ub(this, e)
        }
    };
const zR = j3.litHtmlPolyfillSupport;
zR == null || zR(UP, K$), (j3.litHtmlVersions ? ? (j3.litHtmlVersions = [])).push("3.2.0");
const q3e = (t, e, n) => {
    const r = (n == null ? void 0 : n.renderBefore) ? ? e;
    let i = r._$litPart$;
    if (i === void 0) {
        const s = (n == null ? void 0 : n.renderBefore) ? ? null;
        r._$litPart$ = i = new K$(e.insertBefore(A_(), s), s, void 0, n ? ? {})
    }
    return i._$AI(t), i
};
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
let Dn = class extends ww {
    constructor() {
        super(...arguments), this.renderOptions = {
            host: this
        }, this.o = void 0
    }
    createRenderRoot() {
        var n;
        const e = super.createRenderRoot();
        return (n = this.renderOptions).renderBefore ? ? (n.renderBefore = e.firstChild), e
    }
    update(e) {
        const n = this.render();
        this.hasUpdated || (this.renderOptions.isConnected = this.isConnected), super.update(e), this.o = q3e(n, this.renderRoot, this.renderOptions)
    }
    connectedCallback() {
        var e;
        super.connectedCallback(), (e = this.o) == null || e.setConnected(!0)
    }
    disconnectedCallback() {
        var e;
        super.disconnectedCallback(), (e = this.o) == null || e.setConnected(!1)
    }
    render() {
        return Fb
    }
};
var xX;
Dn._$litElement$ = !0, Dn.finalized = !0, (xX = globalThis.litElementHydrateSupport) == null || xX.call(globalThis, {
    LitElement: Dn
});
const WR = globalThis.litElementPolyfillSupport;
WR == null || WR({
    LitElement: Dn
});
(globalThis.litElementVersions ? ? (globalThis.litElementVersions = [])).push("4.1.0");
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const K3e = {
        attribute: !0,
        type: String,
        converter: rC,
        reflect: !1,
        hasChanged: G$
    },
    Y3e = (t = K3e, e, n) => {
        const {
            kind: r,
            metadata: i
        } = n;
        let s = globalThis.litPropertyMetadata.get(i);
        if (s === void 0 && globalThis.litPropertyMetadata.set(i, s = new Map), s.set(n.name, t), r === "accessor") {
            const {
                name: o
            } = n;
            return {
                set(a) {
                    const l = e.get.call(this);
                    e.set.call(this, a), this.requestUpdate(o, l, t)
                },
                init(a) {
                    return a !== void 0 && this.P(o, void 0, t), a
                }
            }
        }
        if (r === "setter") {
            const {
                name: o
            } = n;
            return function(a) {
                const l = this[o];
                e.call(this, a), this.requestUpdate(o, l, t)
            }
        }
        throw Error("Unsupported decorator location: " + r)
    };

function $i(t) {
    return (e, n) => typeof n == "object" ? Y3e(t, e, n) : ((r, i, s) => {
        const o = i.hasOwnProperty(s);
        return i.constructor.createProperty(s, o ? { ...r,
            wrapped: !0
        } : r), o ? Object.getOwnPropertyDescriptor(i, s) : void 0
    })(t, e, n)
}
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
function Nt(t) {
    return $i({ ...t,
        state: !0,
        attribute: !1
    })
}
/**
 * @license
 * Copyright 2018 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const pr = t => t ? ? as;
var Hu = function(t, e, n, r) {
    var i = arguments.length,
        s = i < 3 ? e : r === null ? r = Object.getOwnPropertyDescriptor(e, n) : r,
        o;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function") s = Reflect.decorate(t, e, n, r);
    else
        for (var a = t.length - 1; a >= 0; a--)(o = t[a]) && (s = (i < 3 ? o(s) : i > 3 ? o(e, n, s) : o(e, n)) || s);
    return i > 3 && s && Object.defineProperty(e, n, s), s
};
let Oc = class extends Dn {
    constructor() {
        super(), this.unsubscribe = [], this.disabled = !1, this.balance = "show", this.charsStart = 4, this.charsEnd = 6, this.address = hr.state.address, this.balanceVal = hr.state.balance, this.balanceSymbol = hr.state.balanceSymbol, this.profileName = hr.state.profileName, this.profileImage = hr.state.profileImage, this.network = Gi.state.caipNetwork, this.unsubscribe.push(hr.subscribe(e => {
            e.isConnected ? (this.address = e.address, this.balanceVal = e.balance, this.profileName = e.profileName, this.profileImage = e.profileImage, this.balanceSymbol = e.balanceSymbol) : (this.address = "", this.balanceVal = "", this.profileName = "", this.profileImage = "", this.balanceSymbol = "")
        }), Gi.subscribeKey("caipNetwork", e => this.network = e))
    }
    disconnectedCallback() {
        this.unsubscribe.forEach(e => e())
    }
    render() {
        const e = Wi.getNetworkImage(this.network),
            n = this.balance === "show";
        return $e `
      <wui-account-button
        .disabled=${!!this.disabled}
        address=${pr(this.profileName??this.address)}
        ?isProfileName=${!!this.profileName}
        networkSrc=${pr(e)}
        avatarSrc=${pr(this.profileImage)}
        balance=${n?Yt.formatBalance(this.balanceVal,this.balanceSymbol):""}
        @click=${this.onClick.bind(this)}
        data-testid="account-button"
        .charsStart=${this.charsStart}
        .charsEnd=${this.charsEnd}
      >
      </wui-account-button>
    `
    }
    onClick() {
        Vr.open()
    }
};
Hu([$i({
    type: Boolean
})], Oc.prototype, "disabled", void 0);
Hu([$i()], Oc.prototype, "balance", void 0);
Hu([$i()], Oc.prototype, "charsStart", void 0);
Hu([$i()], Oc.prototype, "charsEnd", void 0);
Hu([Nt()], Oc.prototype, "address", void 0);
Hu([Nt()], Oc.prototype, "balanceVal", void 0);
Hu([Nt()], Oc.prototype, "balanceSymbol", void 0);
Hu([Nt()], Oc.prototype, "profileName", void 0);
Hu([Nt()], Oc.prototype, "profileImage", void 0);
Hu([Nt()], Oc.prototype, "network", void 0);
Oc = Hu([Qe("w3m-account-button")], Oc);
const Z3e = bi `
  :host {
    display: block;
    width: max-content;
  }
`;
var Fh = function(t, e, n, r) {
    var i = arguments.length,
        s = i < 3 ? e : r === null ? r = Object.getOwnPropertyDescriptor(e, n) : r,
        o;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function") s = Reflect.decorate(t, e, n, r);
    else
        for (var a = t.length - 1; a >= 0; a--)(o = t[a]) && (s = (i < 3 ? o(s) : i > 3 ? o(e, n, s) : o(e, n)) || s);
    return i > 3 && s && Object.defineProperty(e, n, s), s
};
let Pu = class extends Dn {
    constructor() {
        super(), this.unsubscribe = [], this.disabled = !1, this.balance = void 0, this.size = void 0, this.label = void 0, this.loadingLabel = void 0, this.charsStart = 4, this.charsEnd = 6, this.isAccount = hr.state.isConnected, this.unsubscribe.push(hr.subscribeKey("isConnected", e => {
            this.isAccount = e
        }))
    }
    disconnectedCallback() {
        this.unsubscribe.forEach(e => e())
    }
    render() {
        return this.isAccount ? $e `
          <w3m-account-button
            .disabled=${!!this.disabled}
            balance=${pr(this.balance)}
            .charsStart=${pr(this.charsStart)}
            .charsEnd=${pr(this.charsEnd)}
          >
          </w3m-account-button>
        ` : $e `
          <w3m-connect-button
            size=${pr(this.size)}
            label=${pr(this.label)}
            loadingLabel=${pr(this.loadingLabel)}
          ></w3m-connect-button>
        `
    }
};
Pu.styles = Z3e;
Fh([$i({
    type: Boolean
})], Pu.prototype, "disabled", void 0);
Fh([$i()], Pu.prototype, "balance", void 0);
Fh([$i()], Pu.prototype, "size", void 0);
Fh([$i()], Pu.prototype, "label", void 0);
Fh([$i()], Pu.prototype, "loadingLabel", void 0);
Fh([$i()], Pu.prototype, "charsStart", void 0);
Fh([$i()], Pu.prototype, "charsEnd", void 0);
Fh([Nt()], Pu.prototype, "isAccount", void 0);
Pu = Fh([Qe("w3m-button")], Pu);
var A2 = function(t, e, n, r) {
    var i = arguments.length,
        s = i < 3 ? e : r === null ? r = Object.getOwnPropertyDescriptor(e, n) : r,
        o;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function") s = Reflect.decorate(t, e, n, r);
    else
        for (var a = t.length - 1; a >= 0; a--)(o = t[a]) && (s = (i < 3 ? o(s) : i > 3 ? o(e, n, s) : o(e, n)) || s);
    return i > 3 && s && Object.defineProperty(e, n, s), s
};
let Sm = class extends Dn {
    constructor() {
        super(), this.unsubscribe = [], this.size = "md", this.label = "Connect Wallet", this.loadingLabel = "Connecting...", this.open = Vr.state.open, this.loading = Vr.state.loading, this.unsubscribe.push(Vr.subscribe(e => {
            this.open = e.open, this.loading = e.loading
        }))
    }
    disconnectedCallback() {
        this.unsubscribe.forEach(e => e())
    }
    render() {
        const e = this.loading || this.open;
        return $e `
      <wui-connect-button
        size=${pr(this.size)}
        .loading=${e}
        @click=${this.onClick.bind(this)}
        data-testid="connect-button"
      >
        ${e?this.loadingLabel:this.label}
      </wui-connect-button>
    `
    }
    onClick() {
        this.open ? Vr.close() : this.loading || Vr.open()
    }
};
A2([$i()], Sm.prototype, "size", void 0);
A2([$i()], Sm.prototype, "label", void 0);
A2([$i()], Sm.prototype, "loadingLabel", void 0);
A2([Nt()], Sm.prototype, "open", void 0);
A2([Nt()], Sm.prototype, "loading", void 0);
Sm = A2([Qe("w3m-connect-button")], Sm);
const Q3e = bi `
  :host {
    z-index: var(--w3m-z-index);
    display: block;
    backface-visibility: hidden;
    will-change: opacity;
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    pointer-events: none;
    opacity: 0;
    background-color: var(--wui-cover);
  }

  @keyframes zoom-in {
    0% {
      transform: scale(0.95) translateY(0);
    }
    100% {
      transform: scale(1) translateY(0);
    }
  }

  @keyframes slide-in {
    0% {
      transform: scale(1) translateY(50px);
    }
    100% {
      transform: scale(1) translateY(0);
    }
  }

  wui-card {
    max-width: 360px;
    width: 100%;
    position: relative;
    animation-delay: 0.3s;
    animation-duration: 0.2s;
    animation-name: zoom-in;
    animation-fill-mode: backwards;
    animation-timing-function: var(--wui-ease-out-power-2);
    outline: none;
  }

  wui-flex {
    overflow-x: hidden;
    overflow-y: auto;
    display: flex;
    align-items: center;
    justify-content: center;
    width: 100%;
    height: 100%;
  }

  @media (max-height: 700px) and (min-width: 431px) {
    wui-flex {
      align-items: flex-start;
    }

    wui-card {
      margin: var(--wui-spacing-xxl) 0px;
    }
  }

  @media (max-width: 430px) {
    wui-flex {
      align-items: flex-end;
    }

    wui-card {
      max-width: 100%;
      border-bottom-left-radius: 0;
      border-bottom-right-radius: 0;
      border-bottom: none;
      animation-name: slide-in;
    }
  }
`;
var IT = function(t, e, n, r) {
    var i = arguments.length,
        s = i < 3 ? e : r === null ? r = Object.getOwnPropertyDescriptor(e, n) : r,
        o;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function") s = Reflect.decorate(t, e, n, r);
    else
        for (var a = t.length - 1; a >= 0; a--)(o = t[a]) && (s = (i < 3 ? o(s) : i > 3 ? o(e, n, s) : o(e, n)) || s);
    return i > 3 && s && Object.defineProperty(e, n, s), s
};
const Qz = "scroll-lock";
let Cm = class extends Dn {
    constructor() {
        super(), this.unsubscribe = [], this.abortController = void 0, this.open = Vr.state.open, this.caipAddress = hr.state.address, this.isSiweEnabled = ss.state.isSiweEnabled, this.initializeTheming(), Vn.prefetch(), this.unsubscribe.push(Vr.subscribeKey("open", e => e ? this.onOpen() : this.onClose()), ss.subscribeKey("isSiweEnabled", e => {
            this.isSiweEnabled = e
        }), hr.subscribe(e => this.onNewAccountState(e))), wn.sendEvent({
            type: "track",
            event: "MODAL_LOADED"
        })
    }
    disconnectedCallback() {
        this.unsubscribe.forEach(e => e()), this.onRemoveKeyboardListener()
    }
    render() {
        return this.open ? $e `
          <wui-flex @click=${this.onOverlayClick.bind(this)}>
            <wui-card role="alertdialog" aria-modal="true" tabindex="0">
              <w3m-header></w3m-header>
              <w3m-router></w3m-router>
              <w3m-snackbar></w3m-snackbar>
            </wui-card>
          </wui-flex>
        ` : null
    }
    async onOverlayClick(e) {
        e.target === e.currentTarget && await this.handleClose()
    }
    async handleClose() {
        this.isSiweEnabled && ss.state.status !== "success" && await ir.disconnect(), Vr.close()
    }
    initializeTheming() {
        const {
            themeVariables: e,
            themeMode: n
        } = Na.state, r = Mr.getColorTheme(n);
        cee(e, r)
    }
    async onClose() {
        this.onScrollUnlock(), await this.animate([{
            opacity: 1
        }, {
            opacity: 0
        }], {
            duration: 200,
            easing: "ease",
            fill: "forwards"
        }).finished, qi.hide(), this.open = !1, this.onRemoveKeyboardListener()
    }
    async onOpen() {
        this.onScrollLock(), this.open = !0, await this.animate([{
            opacity: 0
        }, {
            opacity: 1
        }], {
            duration: 200,
            easing: "ease",
            fill: "forwards",
            delay: 300
        }).finished, this.onAddKeyboardListener()
    }
    onScrollLock() {
        const e = document.createElement("style");
        e.dataset.w3m = Qz, e.textContent = `
      html, body {
        touch-action: none;
        overflow: hidden;
        overscroll-behavior: contain;
      }
      w3m-modal {
        pointer-events: auto;
      }
    `, document.head.appendChild(e)
    }
    onScrollUnlock() {
        const e = document.head.querySelector(`style[data-w3m="${Qz}"]`);
        e && e.remove()
    }
    onAddKeyboardListener() {
        var n;
        this.abortController = new AbortController;
        const e = (n = this.shadowRoot) == null ? void 0 : n.querySelector("wui-card");
        e == null || e.focus(), window.addEventListener("keydown", r => {
            if (r.key === "Escape") this.handleClose();
            else if (r.key === "Tab") {
                const {
                    tagName: i
                } = r.target;
                i && !i.includes("W3M-") && !i.includes("WUI-") && (e == null || e.focus())
            }
        }, this.abortController)
    }
    onRemoveKeyboardListener() {
        var e;
        (e = this.abortController) == null || e.abort(), this.abortController = void 0
    }
    async onNewAccountState(e) {
        const {
            isConnected: n,
            caipAddress: r
        } = e;
        if (this.isSiweEnabled) {
            n && !this.caipAddress && (this.caipAddress = r), n && r && this.caipAddress !== r && (await ss.signOut(), this.onSiweNavigation(), this.caipAddress = r);
            try {
                const i = await ss.getSession();
                i && !n ? await ss.signOut() : n && !i && this.onSiweNavigation()
            } catch {
                n && this.onSiweNavigation()
            }
        }
    }
    onSiweNavigation() {
        this.open ? Dt.push("ConnectingSiwe") : Vr.open({
            view: "ConnectingSiwe"
        })
    }
};
Cm.styles = Q3e;
IT([Nt()], Cm.prototype, "open", void 0);
IT([Nt()], Cm.prototype, "caipAddress", void 0);
IT([Nt()], Cm.prototype, "isSiweEnabled", void 0);
Cm = IT([Qe("w3m-modal")], Cm);
const J3e = Object.freeze(Object.defineProperty({
        __proto__: null,
        get W3mModal() {
            return Cm
        }
    }, Symbol.toStringTag, {
        value: "Module"
    })),
    X3e = bi `
  :host {
    display: block;
    width: max-content;
  }
`;
var pE = function(t, e, n, r) {
    var i = arguments.length,
        s = i < 3 ? e : r === null ? r = Object.getOwnPropertyDescriptor(e, n) : r,
        o;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function") s = Reflect.decorate(t, e, n, r);
    else
        for (var a = t.length - 1; a >= 0; a--)(o = t[a]) && (s = (i < 3 ? o(s) : i > 3 ? o(e, n, s) : o(e, n)) || s);
    return i > 3 && s && Object.defineProperty(e, n, s), s
};
let Am = class extends Dn {
    constructor() {
        super(), this.unsubscribe = [], this.disabled = !1, this.network = Gi.state.caipNetwork, this.connected = hr.state.isConnected, this.loading = Vr.state.loading, this.unsubscribe.push(Gi.subscribeKey("caipNetwork", e => this.network = e), hr.subscribeKey("isConnected", e => this.connected = e), Vr.subscribeKey("loading", e => this.loading = e))
    }
    disconnectedCallback() {
        this.unsubscribe.forEach(e => e())
    }
    render() {
        var e;
        return $e `
      <wui-network-button
        .disabled=${!!(this.disabled||this.loading)}
        imageSrc=${pr(Wi.getNetworkImage(this.network))}
        @click=${this.onClick.bind(this)}
      >
        ${((e=this.network)==null?void 0:e.name)??(this.connected?"Unknown Network":"Select Network")}
      </wui-network-button>
    `
    }
    onClick() {
        this.loading || Vr.open({
            view: "Networks"
        })
    }
};
Am.styles = X3e;
pE([$i({
    type: Boolean
})], Am.prototype, "disabled", void 0);
pE([Nt()], Am.prototype, "network", void 0);
pE([Nt()], Am.prototype, "connected", void 0);
pE([Nt()], Am.prototype, "loading", void 0);
Am = pE([Qe("w3m-network-button")], Am);
const e_e = bi `
  :host {
    display: block;
    will-change: transform, opacity;
  }
`;
var Xee = function(t, e, n, r) {
    var i = arguments.length,
        s = i < 3 ? e : r === null ? r = Object.getOwnPropertyDescriptor(e, n) : r,
        o;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function") s = Reflect.decorate(t, e, n, r);
    else
        for (var a = t.length - 1; a >= 0; a--)(o = t[a]) && (s = (i < 3 ? o(s) : i > 3 ? o(e, n, s) : o(e, n)) || s);
    return i > 3 && s && Object.defineProperty(e, n, s), s
};
let sC = class extends Dn {
    constructor() {
        super(), this.resizeObserver = void 0, this.prevHeight = "0px", this.prevHistoryLength = 1, this.unsubscribe = [], this.view = Dt.state.view, this.unsubscribe.push(Dt.subscribeKey("view", e => this.onViewChange(e)))
    }
    firstUpdated() {
        this.resizeObserver = new ResizeObserver(async ([e]) => {
            const n = `${e==null?void 0:e.contentRect.height}px`;
            this.prevHeight !== "0px" && (await this.animate([{
                height: this.prevHeight
            }, {
                height: n
            }], {
                duration: 150,
                easing: "ease",
                fill: "forwards"
            }).finished, this.style.height = "auto"), this.prevHeight = n
        }), this.resizeObserver.observe(this.getWrapper())
    }
    disconnectedCallback() {
        var e;
        (e = this.resizeObserver) == null || e.unobserve(this.getWrapper()), this.unsubscribe.forEach(n => n())
    }
    render() {
        return $e `<div>${this.viewTemplate()}</div>`
    }
    viewTemplate() {
        switch (this.view) {
            case "Connect":
                return $e `<w3m-connect-view></w3m-connect-view>`;
            case "ConnectingWalletConnect":
                return $e `<w3m-connecting-wc-view></w3m-connecting-wc-view>`;
            case "ConnectingExternal":
                return $e `<w3m-connecting-external-view></w3m-connecting-external-view>`;
            case "ConnectingSiwe":
                return $e `<w3m-connecting-siwe-view></w3m-connecting-siwe-view>`;
            case "AllWallets":
                return $e `<w3m-all-wallets-view></w3m-all-wallets-view>`;
            case "Networks":
                return $e `<w3m-networks-view></w3m-networks-view>`;
            case "SwitchNetwork":
                return $e `<w3m-network-switch-view></w3m-network-switch-view>`;
            case "Account":
                return $e `<w3m-account-view></w3m-account-view>`;
            case "WhatIsAWallet":
                return $e `<w3m-what-is-a-wallet-view></w3m-what-is-a-wallet-view>`;
            case "WhatIsANetwork":
                return $e `<w3m-what-is-a-network-view></w3m-what-is-a-network-view>`;
            case "GetWallet":
                return $e `<w3m-get-wallet-view></w3m-get-wallet-view>`;
            case "Downloads":
                return $e `<w3m-downloads-view></w3m-downloads-view>`;
            case "EmailVerifyOtp":
                return $e `<w3m-email-verify-otp-view></w3m-email-verify-otp-view>`;
            case "EmailVerifyDevice":
                return $e `<w3m-email-verify-device-view></w3m-email-verify-device-view>`;
            case "ApproveTransaction":
                return $e `<w3m-approve-transaction-view></w3m-approve-transaction-view>`;
            case "Transactions":
                return $e `<w3m-transactions-view></w3m-transactions-view>`;
            case "UpgradeEmailWallet":
                return $e `<w3m-upgrade-wallet-view></w3m-upgrade-wallet-view>`;
            case "UpdateEmailWallet":
                return $e `<w3m-update-email-wallet-view></w3m-update-email-wallet-view>`;
            case "UpdateEmailWalletWaiting":
                return $e `<w3m-update-email-wallet-waiting-view></w3m-update-email-wallet-waiting-view>`;
            default:
                return $e `<w3m-connect-view></w3m-connect-view>`
        }
    }
    async onViewChange(e) {
        const {
            history: n
        } = Dt.state;
        let r = -10,
            i = 10;
        n.length < this.prevHistoryLength && (r = 10, i = -10), this.prevHistoryLength = n.length, await this.animate([{
            opacity: 1,
            transform: "translateX(0px)"
        }, {
            opacity: 0,
            transform: `translateX(${r}px)`
        }], {
            duration: 150,
            easing: "ease",
            fill: "forwards"
        }).finished, this.view = e, await this.animate([{
            opacity: 0,
            transform: `translateX(${i}px)`
        }, {
            opacity: 1,
            transform: "translateX(0px)"
        }], {
            duration: 150,
            easing: "ease",
            fill: "forwards",
            delay: 50
        }).finished
    }
    getWrapper() {
        var e;
        return (e = this.shadowRoot) == null ? void 0 : e.querySelector("div")
    }
};
sC.styles = e_e;
Xee([Nt()], sC.prototype, "view", void 0);
sC = Xee([Qe("w3m-router")], sC);
const t_e = bi `
  wui-flex {
    width: 100%;
  }

  :host > wui-flex:first-child {
    transform: translateY(calc(var(--wui-spacing-xxs) * -1));
  }

  wui-icon-link {
    margin-right: calc(var(--wui-icon-box-size-md) * -1);
  }

  wui-notice-card {
    margin-bottom: var(--wui-spacing-3xs);
  }
`;
var ig = function(t, e, n, r) {
    var i = arguments.length,
        s = i < 3 ? e : r === null ? r = Object.getOwnPropertyDescriptor(e, n) : r,
        o;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function") s = Reflect.decorate(t, e, n, r);
    else
        for (var a = t.length - 1; a >= 0; a--)(o = t[a]) && (s = (i < 3 ? o(s) : i > 3 ? o(e, n, s) : o(e, n)) || s);
    return i > 3 && s && Object.defineProperty(e, n, s), s
};
let nd = class extends Dn {
    constructor() {
        super(), this.usubscribe = [], this.address = hr.state.address, this.profileImage = hr.state.profileImage, this.profileName = hr.state.profileName, this.balance = hr.state.balance, this.balanceSymbol = hr.state.balanceSymbol, this.network = Gi.state.caipNetwork, this.disconecting = !1, this.usubscribe.push(hr.subscribe(e => {
            e.address ? (this.address = e.address, this.profileImage = e.profileImage, this.profileName = e.profileName, this.balance = e.balance, this.balanceSymbol = e.balanceSymbol) : Vr.close()
        }), Gi.subscribeKey("caipNetwork", e => {
            e != null && e.id && (this.network = e)
        }))
    }
    disconnectedCallback() {
        this.usubscribe.forEach(e => e())
    }
    render() {
        var n;
        if (!this.address) throw new Error("w3m-account-view: No account provided");
        const e = Wi.getNetworkImage(this.network);
        return $e `
      <wui-flex
        flexDirection="column"
        .padding=${["0","s","m","s"]}
        alignItems="center"
        gap="l"
      >
        <wui-avatar
          alt=${this.address}
          address=${this.address}
          imageSrc=${pr(this.profileImage===null?void 0:this.profileImage)}
        ></wui-avatar>

        <wui-flex flexDirection="column" alignItems="center">
          <wui-flex gap="3xs" alignItems="center" justifyContent="center">
            <wui-text variant="large-600" color="fg-100">
              ${this.profileName?Mr.getTruncateString({string:this.profileName,charsStart:20,charsEnd:0,truncate:"end"}):Mr.getTruncateString({string:this.address,charsStart:4,charsEnd:6,truncate:"middle"})}
            </wui-text>
            <wui-icon-link
              size="md"
              icon="copy"
              iconColor="fg-200"
              @click=${this.onCopyAddress}
            ></wui-icon-link>
          </wui-flex>
          <wui-flex gap="s" flexDirection="column" alignItems="center">
            <wui-text variant="paragraph-500" color="fg-200">
              ${Yt.formatBalance(this.balance,this.balanceSymbol)}
            </wui-text>

            ${this.explorerBtnTemplate()}
          </wui-flex>
        </wui-flex>
      </wui-flex>

      <wui-flex flexDirection="column" gap="xs" .padding=${["0","s","s","s"]}>
        ${this.emailCardTemplate()} ${this.emailBtnTemplate()}

        <wui-list-item
          .variant=${e?"image":"icon"}
          iconVariant="overlay"
          icon="networkPlaceholder"
          imageSrc=${pr(e)}
          ?chevron=${this.isAllowedNetworkSwitch()}
          @click=${this.onNetworks.bind(this)}
          data-testid="w3m-account-select-network"
        >
          <wui-text variant="paragraph-500" color="fg-100">
            ${((n=this.network)==null?void 0:n.name)??"Unknown"}
          </wui-text>
        </wui-list-item>
        <wui-list-item
          iconVariant="blue"
          icon="swapHorizontalBold"
          iconSize="sm"
          ?chevron=${!0}
          @click=${this.onTransactions.bind(this)}
        >
          <wui-text variant="paragraph-500" color="fg-100">Activity</wui-text>
        </wui-list-item>
        <wui-list-item
          variant="icon"
          iconVariant="overlay"
          icon="disconnect"
          ?chevron=${!1}
          .loading=${this.disconecting}
          @click=${this.onDisconnect.bind(this)}
          data-testid="disconnect-button"
        >
          <wui-text variant="paragraph-500" color="fg-200">Disconnect</wui-text>
        </wui-list-item>
      </wui-flex>
    `
    }
    emailCardTemplate() {
        const e = ia.getConnectedConnector(),
            n = Wr.getEmailConnector(),
            {
                origin: r
            } = location;
        return !n || e !== "EMAIL" || r.includes(ah.SECURE_SITE) ? null : $e `
      <wui-notice-card
        @click=${this.onGoToUpgradeView.bind(this)}
        label="Upgrade your wallet"
        description="Transition to a non-custodial wallet"
        icon="wallet"
      ></wui-notice-card>
    `
    }
    emailBtnTemplate() {
        const e = ia.getConnectedConnector(),
            n = Wr.getEmailConnector();
        if (!n || e !== "EMAIL") return null;
        const r = n.provider.getEmail() ? ? "";
        return $e `
      <wui-list-item
        variant="icon"
        iconVariant="overlay"
        icon="mail"
        iconSize="sm"
        ?chevron=${!0}
        @click=${()=>this.onGoToUpdateEmail(r)}
      >
        <wui-text variant="paragraph-500" color="fg-100">${r}</wui-text>
      </wui-list-item>
    `
    }
    explorerBtnTemplate() {
        const {
            addressExplorerUrl: e
        } = hr.state;
        return e ? $e `
      <wui-button size="sm" variant="shade" @click=${this.onExplorer.bind(this)}>
        <wui-icon size="sm" color="inherit" slot="iconLeft" name="compass"></wui-icon>
        Block Explorer
        <wui-icon size="sm" color="inherit" slot="iconRight" name="externalLink"></wui-icon>
      </wui-button>
    ` : null
    }
    isAllowedNetworkSwitch() {
        const {
            requestedCaipNetworks: e
        } = Gi.state, n = e ? e.length > 1 : !1, r = e == null ? void 0 : e.find(({
            id: i
        }) => {
            var s;
            return i === ((s = this.network) == null ? void 0 : s.id)
        });
        return n || !r
    }
    onCopyAddress() {
        try {
            this.address && (Yt.copyToClopboard(this.address), qi.showSuccess("Address copied"))
        } catch {
            qi.showError("Failed to copy")
        }
    }
    onNetworks() {
        this.isAllowedNetworkSwitch() && Dt.push("Networks")
    }
    onTransactions() {
        wn.sendEvent({
            type: "track",
            event: "CLICK_TRANSACTIONS"
        }), Dt.push("Transactions")
    }
    async onDisconnect() {
        try {
            this.disconecting = !0, await ir.disconnect(), wn.sendEvent({
                type: "track",
                event: "DISCONNECT_SUCCESS"
            }), Vr.close()
        } catch {
            wn.sendEvent({
                type: "track",
                event: "DISCONNECT_ERROR"
            }), qi.showError("Failed to disconnect")
        } finally {
            this.disconecting = !1
        }
    }
    onExplorer() {
        const {
            addressExplorerUrl: e
        } = hr.state;
        e && Yt.openHref(e, "_blank")
    }
    onGoToUpgradeView() {
        wn.sendEvent({
            type: "track",
            event: "EMAIL_UPGRADE_FROM_MODAL"
        }), Dt.push("UpgradeEmailWallet")
    }
    onGoToUpdateEmail(e) {
        Dt.push("UpdateEmailWallet", {
            email: e
        })
    }
};
nd.styles = t_e;
ig([Nt()], nd.prototype, "address", void 0);
ig([Nt()], nd.prototype, "profileImage", void 0);
ig([Nt()], nd.prototype, "profileName", void 0);
ig([Nt()], nd.prototype, "balance", void 0);
ig([Nt()], nd.prototype, "balanceSymbol", void 0);
ig([Nt()], nd.prototype, "network", void 0);
ig([Nt()], nd.prototype, "disconecting", void 0);
nd = ig([Qe("w3m-account-view")], nd);
var ete = function(t, e, n, r) {
    var i = arguments.length,
        s = i < 3 ? e : r === null ? r = Object.getOwnPropertyDescriptor(e, n) : r,
        o;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function") s = Reflect.decorate(t, e, n, r);
    else
        for (var a = t.length - 1; a >= 0; a--)(o = t[a]) && (s = (i < 3 ? o(s) : i > 3 ? o(e, n, s) : o(e, n)) || s);
    return i > 3 && s && Object.defineProperty(e, n, s), s
};
let jP = class extends Dn {
    constructor() {
        super(...arguments), this.search = "", this.onDebouncedSearch = Yt.debounce(e => {
            this.search = e
        })
    }
    render() {
        const e = this.search.length >= 2;
        return $e `
      <wui-flex padding="s" gap="s">
        <wui-search-bar @inputChange=${this.onInputChange.bind(this)}></wui-search-bar>
        ${this.qrButtonTemplate()}
      </wui-flex>
      ${e?$e`<w3m-all-wallets-search query=${this.search}></w3m-all-wallets-search>`:$e`<w3m-all-wallets-list></w3m-all-wallets-list>`}
    `
    }
    onInputChange(e) {
        this.onDebouncedSearch(e.detail)
    }
    qrButtonTemplate() {
        return Yt.isMobile() ? $e `
        <wui-icon-box
          size="lg"
          iconSize="xl"
          iconColor="accent-100"
          backgroundColor="accent-100"
          icon="qrCode"
          background="transparent"
          border
          borderColor="wui-accent-glass-010"
          @click=${this.onWalletConnectQr.bind(this)}
        ></wui-icon-box>
      ` : null
    }
    onWalletConnectQr() {
        Dt.push("ConnectingWalletConnect")
    }
};
ete([Nt()], jP.prototype, "search", void 0);
jP = ete([Qe("w3m-all-wallets-view")], jP);
const n_e = bi `
  wui-flex {
    max-height: clamp(360px, 540px, 80vh);
    overflow: scroll;
    scrollbar-width: none;
  }

  wui-flex::-webkit-scrollbar {
    display: none;
  }
`;
var tte = function(t, e, n, r) {
    var i = arguments.length,
        s = i < 3 ? e : r === null ? r = Object.getOwnPropertyDescriptor(e, n) : r,
        o;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function") s = Reflect.decorate(t, e, n, r);
    else
        for (var a = t.length - 1; a >= 0; a--)(o = t[a]) && (s = (i < 3 ? o(s) : i > 3 ? o(e, n, s) : o(e, n)) || s);
    return i > 3 && s && Object.defineProperty(e, n, s), s
};
let oC = class extends Dn {
    constructor() {
        super(), this.unsubscribe = [], this.connectors = Wr.state.connectors, this.unsubscribe.push(Wr.subscribeKey("connectors", e => this.connectors = e))
    }
    disconnectedCallback() {
        this.unsubscribe.forEach(e => e())
    }
    render() {
        return $e `
      <wui-flex flexDirection="column" padding="s" gap="xs">
        <w3m-email-login-widget></w3m-email-login-widget>

        ${this.walletConnectConnectorTemplate()} ${this.recentTemplate()}
        ${this.announcedTemplate()} ${this.injectedTemplate()} ${this.featuredTemplate()}
        ${this.customTemplate()} ${this.recommendedTemplate()} ${this.connectorsTemplate()}
        ${this.allWalletsTemplate()}
      </wui-flex>
      <w3m-legal-footer></w3m-legal-footer>
    `
    }
    walletConnectConnectorTemplate() {
        if (Yt.isMobile()) return null;
        const e = this.connectors.find(n => n.type === "WALLET_CONNECT");
        return e ? $e `
      <wui-list-wallet
        imageSrc=${pr(Wi.getConnectorImage(e))}
        name=${e.name??"Unknown"}
        @click=${()=>this.onConnector(e)}
        tagLabel="qr code"
        tagVariant="main"
        data-testid="wallet-selector-walletconnect"
      >
      </wui-list-wallet>
    ` : null
    }
    customTemplate() {
        const {
            customWallets: e
        } = _r.state;
        return e != null && e.length ? this.filterOutDuplicateWallets(e).map(r => $e `
        <wui-list-wallet
          imageSrc=${pr(Wi.getWalletImage(r))}
          name=${r.name??"Unknown"}
          @click=${()=>this.onConnectWallet(r)}
        >
        </wui-list-wallet>
      `) : null
    }
    featuredTemplate() {
        if (!this.connectors.find(i => i.type === "WALLET_CONNECT")) return null;
        const {
            featured: n
        } = Vn.state;
        return n.length ? this.filterOutDuplicateWallets(n).map(i => $e `
        <wui-list-wallet
          imageSrc=${pr(Wi.getWalletImage(i))}
          name=${i.name??"Unknown"}
          @click=${()=>this.onConnectWallet(i)}
        >
        </wui-list-wallet>
      `) : null
    }
    recentTemplate() {
        return ia.getRecentWallets().map(n => $e `
        <wui-list-wallet
          imageSrc=${pr(Wi.getWalletImage(n))}
          name=${n.name??"Unknown"}
          @click=${()=>this.onConnectWallet(n)}
          tagLabel="recent"
          tagVariant="shade"
        >
        </wui-list-wallet>
      `)
    }
    announcedTemplate() {
        return this.connectors.map(e => e.type !== "ANNOUNCED" ? null : $e `
        <wui-list-wallet
          imageSrc=${pr(Wi.getConnectorImage(e))}
          name=${e.name??"Unknown"}
          @click=${()=>this.onConnector(e)}
          tagVariant="success"
          .installed=${!0}
        >
        </wui-list-wallet>
      `)
    }
    injectedTemplate() {
        const e = this.connectors.find(n => n.type === "ANNOUNCED");
        return this.connectors.map(n => n.type !== "INJECTED" || !ir.checkInstalled() ? null : $e `
        <wui-list-wallet
          imageSrc=${pr(Wi.getConnectorImage(n))}
          .installed=${!!e}
          name=${n.name??"Unknown"}
          @click=${()=>this.onConnector(n)}
        >
        </wui-list-wallet>
      `)
    }
    connectorsTemplate() {
        const e = Wr.getAnnouncedConnectorRdns();
        return this.connectors.map(n => ["WALLET_CONNECT", "INJECTED", "ANNOUNCED", "EMAIL"].includes(n.type) || e.includes(ah.CONNECTOR_RDNS_MAP[n.id]) ? null : $e `
        <wui-list-wallet
          imageSrc=${pr(Wi.getConnectorImage(n))}
          name=${n.name??"Unknown"}
          @click=${()=>this.onConnector(n)}
        >
        </wui-list-wallet>
      `)
    }
    allWalletsTemplate() {
        if (!this.connectors.find(a => a.type === "WALLET_CONNECT")) return null;
        const n = Vn.state.count,
            r = Vn.state.featured.length,
            i = n + r,
            s = i < 10 ? i : Math.floor(i / 10) * 10,
            o = s < i ? `${s}+` : `${s}`;
        return $e `
      <wui-list-wallet
        name="All Wallets"
        walletIcon="allWallets"
        showAllWallets
        @click=${this.onAllWallets.bind(this)}
        tagLabel=${o}
        tagVariant="shade"
        data-testid="all-wallets"
      ></wui-list-wallet>
    `
    }
    recommendedTemplate() {
        if (!this.connectors.find(f => f.type === "WALLET_CONNECT")) return null;
        const {
            recommended: n
        } = Vn.state, {
            customWallets: r,
            featuredWalletIds: i
        } = _r.state, {
            connectors: s
        } = Wr.state, o = ia.getRecentWallets(), a = s.filter(f => f.type === "ANNOUNCED");
        if (i || r || !n.length) return null;
        const l = a.length + o.length,
            c = Math.max(0, 2 - l);
        return this.filterOutDuplicateWallets(n).slice(0, c).map(f => $e `
        <wui-list-wallet
          imageSrc=${pr(Wi.getWalletImage(f))}
          name=${(f==null?void 0:f.name)??"Unknown"}
          @click=${()=>this.onConnectWallet(f)}
        >
        </wui-list-wallet>
      `)
    }
    onConnector(e) {
        e.type === "WALLET_CONNECT" ? Yt.isMobile() ? Dt.push("AllWallets") : Dt.push("ConnectingWalletConnect") : Dt.push("ConnectingExternal", {
            connector: e
        })
    }
    filterOutDuplicateWallets(e) {
        const {
            connectors: n
        } = Wr.state, i = ia.getRecentWallets().map(a => a.id), s = n.map(a => {
            var l;
            return (l = a.info) == null ? void 0 : l.rdns
        }).filter(Boolean);
        return e.filter(a => !i.includes(a.id) && !s.includes(a.rdns ? ? void 0))
    }
    onAllWallets() {
        wn.sendEvent({
            type: "track",
            event: "CLICK_ALL_WALLETS"
        }), Dt.push("AllWallets")
    }
    onConnectWallet(e) {
        Dt.push("ConnectingWalletConnect", {
            wallet: e
        })
    }
};
oC.styles = n_e;
tte([Nt()], oC.prototype, "connectors", void 0);
oC = tte([Qe("w3m-connect-view")], oC);
const r_e = bi `
  @keyframes shake {
    0% {
      transform: translateX(0);
    }
    25% {
      transform: translateX(3px);
    }
    50% {
      transform: translateX(-3px);
    }
    75% {
      transform: translateX(3px);
    }
    100% {
      transform: translateX(0);
    }
  }

  wui-flex:first-child:not(:only-child) {
    position: relative;
  }

  wui-loading-thumbnail {
    position: absolute;
  }

  wui-icon-box {
    position: absolute;
    right: calc(var(--wui-spacing-3xs) * -1);
    bottom: calc(var(--wui-spacing-3xs) * -1);
    opacity: 0;
    transform: scale(0.5);
    transition: all var(--wui-ease-out-power-2) var(--wui-duration-lg);
  }

  wui-text[align='center'] {
    width: 100%;
    padding: 0px var(--wui-spacing-l);
  }

  [data-error='true'] wui-icon-box {
    opacity: 1;
    transform: scale(1);
  }

  [data-error='true'] > wui-flex:first-child {
    animation: shake 250ms cubic-bezier(0.36, 0.07, 0.19, 0.97) both;
  }

  [data-retry='false'] wui-link {
    display: none;
  }

  [data-retry='true'] wui-link {
    display: block;
    opacity: 1;
  }
`;
var fy = function(t, e, n, r) {
    var i = arguments.length,
        s = i < 3 ? e : r === null ? r = Object.getOwnPropertyDescriptor(e, n) : r,
        o;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function") s = Reflect.decorate(t, e, n, r);
    else
        for (var a = t.length - 1; a >= 0; a--)(o = t[a]) && (s = (i < 3 ? o(s) : i > 3 ? o(e, n, s) : o(e, n)) || s);
    return i > 3 && s && Object.defineProperty(e, n, s), s
};
class Za extends Dn {
    constructor() {
        var e, n, r, i;
        super(), this.wallet = (e = Dt.state.data) == null ? void 0 : e.wallet, this.connector = (n = Dt.state.data) == null ? void 0 : n.connector, this.timeout = void 0, this.secondaryBtnLabel = "Try again", this.secondaryBtnIcon = "refresh", this.secondaryLabel = "Accept connection request in the wallet", this.onConnect = void 0, this.onRender = void 0, this.onAutoConnect = void 0, this.isWalletConnect = !0, this.unsubscribe = [], this.imageSrc = Wi.getWalletImage(this.wallet) ? ? Wi.getConnectorImage(this.connector), this.name = ((r = this.wallet) == null ? void 0 : r.name) ? ? ((i = this.connector) == null ? void 0 : i.name) ? ? "Wallet", this.isRetrying = !1, this.uri = ir.state.wcUri, this.error = ir.state.wcError, this.ready = !1, this.showRetry = !1, this.buffering = !1, this.isMobile = !1, this.onRetry = void 0, this.unsubscribe.push(ir.subscribeKey("wcUri", s => {
            var o;
            this.uri = s, this.isRetrying && this.onRetry && (this.isRetrying = !1, (o = this.onConnect) == null || o.call(this))
        }), ir.subscribeKey("wcError", s => this.error = s), ir.subscribeKey("buffering", s => this.buffering = s))
    }
    firstUpdated() {
        var e;
        (e = this.onAutoConnect) == null || e.call(this), this.showRetry = !this.onAutoConnect
    }
    disconnectedCallback() {
        this.unsubscribe.forEach(e => e()), clearTimeout(this.timeout)
    }
    render() {
        var r;
        (r = this.onRender) == null || r.call(this), this.onShowRetry();
        const e = this.error ? "Connection can be declined if a previous request is still active" : this.secondaryLabel;
        let n = `Continue in ${this.name}`;
        return this.buffering && (n = "Connecting..."), this.error && (n = "Connection declined"), $e `
      <wui-flex
        data-error=${pr(this.error)}
        data-retry=${this.showRetry}
        flexDirection="column"
        alignItems="center"
        .padding=${["3xl","xl","xl","xl"]}
        gap="xl"
      >
        <wui-flex justifyContent="center" alignItems="center">
          <wui-wallet-image size="lg" imageSrc=${pr(this.imageSrc)}></wui-wallet-image>

          ${this.error?null:this.loaderTemplate()}

          <wui-icon-box
            backgroundColor="error-100"
            background="opaque"
            iconColor="error-100"
            icon="close"
            size="sm"
            border
            borderColor="wui-color-bg-125"
          ></wui-icon-box>
        </wui-flex>

        <wui-flex flexDirection="column" alignItems="center" gap="xs">
          <wui-text variant="paragraph-500" color=${this.error?"error-100":"fg-100"}>
            ${n}
          </wui-text>
          <wui-text align="center" variant="small-500" color="fg-200">${e}</wui-text>
        </wui-flex>

        <wui-button
          variant="accent"
          ?disabled=${!this.error&&this.buffering}
          @click=${this.onTryAgain.bind(this)}
        >
          <wui-icon color="inherit" slot="iconLeft" name=${this.secondaryBtnIcon}></wui-icon>
          ${this.secondaryBtnLabel}
        </wui-button>
      </wui-flex>

      ${this.isWalletConnect?$e`
            <wui-flex .padding=${["0","xl","xl","xl"]} justifyContent="center">
              <wui-link @click=${this.onCopyUri} color="fg-200">
                <wui-icon size="xs" color="fg-200" slot="iconLeft" name="copy"></wui-icon>
                Copy link
              </wui-link>
            </wui-flex>
          `:null}

      <w3m-mobile-download-links .wallet=${this.wallet}></w3m-mobile-download-links>
    `
    }
    onShowRetry() {
        var e;
        if (this.error && !this.showRetry) {
            this.showRetry = !0;
            const n = (e = this.shadowRoot) == null ? void 0 : e.querySelector("wui-button");
            n == null || n.animate([{
                opacity: 0
            }, {
                opacity: 1
            }], {
                fill: "forwards",
                easing: "ease"
            })
        }
    }
    onTryAgain() {
        var e, n;
        this.buffering || (ir.setWcError(!1), this.onRetry ? (this.isRetrying = !0, (e = this.onRetry) == null || e.call(this)) : (n = this.onConnect) == null || n.call(this))
    }
    loaderTemplate() {
        const e = Na.state.themeVariables["--w3m-border-radius-master"],
            n = e ? parseInt(e.replace("px", ""), 10) : 4;
        return $e `<wui-loading-thumbnail radius=${n*9}></wui-loading-thumbnail>`
    }
    onCopyUri() {
        try {
            this.uri && (Yt.copyToClopboard(this.uri), qi.showSuccess("Link copied"))
        } catch {
            qi.showError("Failed to copy")
        }
    }
}
Za.styles = r_e;
fy([Nt()], Za.prototype, "uri", void 0);
fy([Nt()], Za.prototype, "error", void 0);
fy([Nt()], Za.prototype, "ready", void 0);
fy([Nt()], Za.prototype, "showRetry", void 0);
fy([Nt()], Za.prototype, "buffering", void 0);
fy([$i({
    type: Boolean
})], Za.prototype, "isMobile", void 0);
fy([$i()], Za.prototype, "onRetry", void 0);
var i_e = function(t, e, n, r) {
    var i = arguments.length,
        s = i < 3 ? e : r === null ? r = Object.getOwnPropertyDescriptor(e, n) : r,
        o;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function") s = Reflect.decorate(t, e, n, r);
    else
        for (var a = t.length - 1; a >= 0; a--)(o = t[a]) && (s = (i < 3 ? o(s) : i > 3 ? o(e, n, s) : o(e, n)) || s);
    return i > 3 && s && Object.defineProperty(e, n, s), s
};
const s_e = {
    INJECTED: "browser",
    ANNOUNCED: "browser"
};
let Jz = class extends Za {
    constructor() {
        if (super(), !this.connector) throw new Error("w3m-connecting-view: No connector provided");
        wn.sendEvent({
            type: "track",
            event: "SELECT_WALLET",
            properties: {
                name: this.connector.name ? ? "Unknown",
                platform: s_e[this.connector.type] ? ? "external"
            }
        }), this.onConnect = this.onConnectProxy.bind(this), this.onAutoConnect = this.onConnectProxy.bind(this), this.isWalletConnect = !1
    }
    async onConnectProxy() {
        try {
            this.error = !1, this.connector && (this.connector.imageUrl && ia.setConnectedWalletImageUrl(this.connector.imageUrl), await ir.connectExternal(this.connector), ss.state.isSiweEnabled ? Dt.push("ConnectingSiwe") : Vr.close(), wn.sendEvent({
                type: "track",
                event: "CONNECT_SUCCESS",
                properties: {
                    method: "external"
                }
            }))
        } catch (e) {
            wn.sendEvent({
                type: "track",
                event: "CONNECT_ERROR",
                properties: {
                    message: (e == null ? void 0 : e.message) ? ? "Unknown"
                }
            }), this.error = !0
        }
    }
};
Jz = i_e([Qe("w3m-connecting-external-view")], Jz);
var nte = function(t, e, n, r) {
    var i = arguments.length,
        s = i < 3 ? e : r === null ? r = Object.getOwnPropertyDescriptor(e, n) : r,
        o;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function") s = Reflect.decorate(t, e, n, r);
    else
        for (var a = t.length - 1; a >= 0; a--)(o = t[a]) && (s = (i < 3 ? o(s) : i > 3 ? o(e, n, s) : o(e, n)) || s);
    return i > 3 && s && Object.defineProperty(e, n, s), s
};
let HP = class extends Dn {
    constructor() {
        var e;
        super(...arguments), this.dappName = (e = _r.state.metadata) == null ? void 0 : e.name, this.isSigning = !1
    }
    render() {
        return $e `
      <wui-flex justifyContent="center" .padding=${["2xl","0","xxl","0"]}>
        <w3m-connecting-siwe></w3m-connecting-siwe>
      </wui-flex>
      <wui-flex
        .padding=${["0","4xl","l","4xl"]}
        gap="s"
        justifyContent="space-between"
      >
        <wui-text variant="paragraph-500" align="center" color="fg-100"
          >${this.dappName??"Dapp"} needs to connect to your wallet</wui-text
        >
      </wui-flex>
      <wui-flex
        .padding=${["0","3xl","l","3xl"]}
        gap="s"
        justifyContent="space-between"
      >
        <wui-text variant="small-400" align="center" color="fg-200"
          >Sign this message to prove you own this wallet and proceed. Canceling will disconnect
          you.</wui-text
        >
      </wui-flex>
      <wui-flex .padding=${["l","xl","xl","xl"]} gap="s" justifyContent="space-between">
        <wui-button
          size="md"
          ?fullwidth=${!0}
          variant="shade"
          @click=${this.onCancel.bind(this)}
          data-testid="w3m-connecting-siwe-cancel"
        >
          Cancel
        </wui-button>
        <wui-button
          size="md"
          ?fullwidth=${!0}
          variant="fill"
          @click=${this.onSign.bind(this)}
          ?loading=${this.isSigning}
          data-testid="w3m-connecting-siwe-sign"
        >
          ${this.isSigning?"Signing...":"Sign"}
        </wui-button>
      </wui-flex>
    `
    }
    async onSign() {
        this.isSigning = !0, wn.sendEvent({
            event: "CLICK_SIGN_SIWE_MESSAGE",
            type: "track"
        });
        try {
            ss.setStatus("loading");
            const e = await ss.signIn();
            return ss.setStatus("success"), wn.sendEvent({
                event: "SIWE_AUTH_SUCCESS",
                type: "track"
            }), e
        } catch {
            return qi.showError("Signature declined"), ss.setStatus("error"), wn.sendEvent({
                event: "SIWE_AUTH_ERROR",
                type: "track"
            })
        } finally {
            this.isSigning = !1
        }
    }
    async onCancel() {
        const {
            isConnected: e
        } = hr.state;
        e ? (await ir.disconnect(), Vr.close()) : Dt.push("Connect"), wn.sendEvent({
            event: "CLICK_CANCEL_SIWE",
            type: "track"
        })
    }
};
nte([Nt()], HP.prototype, "isSigning", void 0);
HP = nte([Qe("w3m-connecting-siwe-view")], HP);
var Y$ = function(t, e, n, r) {
    var i = arguments.length,
        s = i < 3 ? e : r === null ? r = Object.getOwnPropertyDescriptor(e, n) : r,
        o;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function") s = Reflect.decorate(t, e, n, r);
    else
        for (var a = t.length - 1; a >= 0; a--)(o = t[a]) && (s = (i < 3 ? o(s) : i > 3 ? o(e, n, s) : o(e, n)) || s);
    return i > 3 && s && Object.defineProperty(e, n, s), s
};
let aC = class extends Dn {
    constructor() {
        var e;
        super(), this.interval = void 0, this.lastRetry = Date.now(), this.wallet = (e = Dt.state.data) == null ? void 0 : e.wallet, this.platform = void 0, this.platforms = [], this.initializeConnection(), this.interval = setInterval(this.initializeConnection.bind(this), ah.TEN_SEC_MS)
    }
    disconnectedCallback() {
        clearTimeout(this.interval)
    }
    render() {
        return this.wallet ? (this.determinePlatforms(), $e `
      ${this.headerTemplate()}
      <div>${this.platformTemplate()}</div>
    `) : $e `<w3m-connecting-wc-qrcode></w3m-connecting-wc-qrcode>`
    }
    async initializeConnection(e = !1) {
        try {
            const {
                wcPairingExpiry: n
            } = ir.state;
            if (e || Yt.isPairingExpired(n)) {
                if (ir.connectWalletConnect(), this.wallet) {
                    const r = Wi.getWalletImage(this.wallet);
                    r && ia.setConnectedWalletImageUrl(r)
                } else {
                    const i = Wr.state.connectors.find(o => o.type === "WALLET_CONNECT"),
                        s = Wi.getConnectorImage(i);
                    s && ia.setConnectedWalletImageUrl(s)
                }
                await ir.state.wcPromise, this.finalizeConnection(), ss.state.isSiweEnabled ? Dt.push("ConnectingSiwe") : Vr.close()
            }
        } catch (n) {
            wn.sendEvent({
                type: "track",
                event: "CONNECT_ERROR",
                properties: {
                    message: (n == null ? void 0 : n.message) ? ? "Unknown"
                }
            }), ir.setWcError(!0), Yt.isAllowedRetry(this.lastRetry) && (qi.showError("Declined"), this.lastRetry = Date.now(), this.initializeConnection(!0))
        }
    }
    finalizeConnection() {
        const {
            wcLinking: e,
            recentWallet: n
        } = ir.state;
        e && ia.setWalletConnectDeepLink(e), n && ia.setWeb3ModalRecent(n), wn.sendEvent({
            type: "track",
            event: "CONNECT_SUCCESS",
            properties: {
                method: e ? "mobile" : "qrcode"
            }
        })
    }
    determinePlatforms() {
        if (!this.wallet) throw new Error("w3m-connecting-wc-view:determinePlatforms No wallet");
        if (this.platform) return;
        const {
            mobile_link: e,
            desktop_link: n,
            webapp_link: r,
            injected: i,
            rdns: s
        } = this.wallet, o = i == null ? void 0 : i.map(({
            injected_id: y
        }) => y).filter(Boolean), a = s ? [s] : o ? ? [], l = a.length, c = e, u = r, f = ir.checkInstalled(a), h = l && f, g = n && !Yt.isMobile();
        h && this.platforms.push("browser"), c && this.platforms.push(Yt.isMobile() ? "mobile" : "qrcode"), u && this.platforms.push("web"), g && this.platforms.push("desktop"), !h && l && this.platforms.push("unsupported"), this.platform = this.platforms[0]
    }
    platformTemplate() {
        switch (this.platform) {
            case "browser":
                return $e `<w3m-connecting-wc-browser></w3m-connecting-wc-browser>`;
            case "desktop":
                return $e `
          <w3m-connecting-wc-desktop .onRetry=${()=>this.initializeConnection(!0)}>
          </w3m-connecting-wc-desktop>
        `;
            case "web":
                return $e `
          <w3m-connecting-wc-web .onRetry=${()=>this.initializeConnection(!0)}>
          </w3m-connecting-wc-web>
        `;
            case "mobile":
                return $e `
          <w3m-connecting-wc-mobile isMobile .onRetry=${()=>this.initializeConnection(!0)}>
          </w3m-connecting-wc-mobile>
        `;
            case "qrcode":
                return $e `<w3m-connecting-wc-qrcode></w3m-connecting-wc-qrcode>`;
            default:
                return $e `<w3m-connecting-wc-unsupported></w3m-connecting-wc-unsupported>`
        }
    }
    headerTemplate() {
        return this.platforms.length > 1 ? $e `
      <w3m-connecting-header
        .platforms=${this.platforms}
        .onSelectPlatfrom=${this.onSelectPlatform.bind(this)}
      >
      </w3m-connecting-header>
    ` : null
    }
    async onSelectPlatform(e) {
        var r;
        const n = (r = this.shadowRoot) == null ? void 0 : r.querySelector("div");
        n && (await n.animate([{
            opacity: 1
        }, {
            opacity: 0
        }], {
            duration: 200,
            fill: "forwards",
            easing: "ease"
        }).finished, this.platform = e, n.animate([{
            opacity: 0
        }, {
            opacity: 1
        }], {
            duration: 200,
            fill: "forwards",
            easing: "ease"
        }))
    }
};
Y$([Nt()], aC.prototype, "platform", void 0);
Y$([Nt()], aC.prototype, "platforms", void 0);
aC = Y$([Qe("w3m-connecting-wc-view")], aC);
var o_e = function(t, e, n, r) {
    var i = arguments.length,
        s = i < 3 ? e : r === null ? r = Object.getOwnPropertyDescriptor(e, n) : r,
        o;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function") s = Reflect.decorate(t, e, n, r);
    else
        for (var a = t.length - 1; a >= 0; a--)(o = t[a]) && (s = (i < 3 ? o(s) : i > 3 ? o(e, n, s) : o(e, n)) || s);
    return i > 3 && s && Object.defineProperty(e, n, s), s
};
let Xz = class extends Dn {
    constructor() {
        var e;
        super(...arguments), this.wallet = (e = Dt.state.data) == null ? void 0 : e.wallet
    }
    render() {
        if (!this.wallet) throw new Error("w3m-downloads-view");
        return $e `
      <wui-flex gap="xs" flexDirection="column" .padding=${["s","s","l","s"]}>
        ${this.chromeTemplate()} ${this.iosTemplate()} ${this.androidTemplate()}
        ${this.homepageTemplate()}
      </wui-flex>
    `
    }
    chromeTemplate() {
        var e;
        return (e = this.wallet) != null && e.chrome_store ? $e `<wui-list-item
      variant="icon"
      icon="chromeStore"
      iconVariant="square"
      @click=${this.onChromeStore.bind(this)}
      chevron
    >
      <wui-text variant="paragraph-500" color="fg-100">Chrome Extension</wui-text>
    </wui-list-item>` : null
    }
    iosTemplate() {
        var e;
        return (e = this.wallet) != null && e.app_store ? $e `<wui-list-item
      variant="icon"
      icon="appStore"
      iconVariant="square"
      @click=${this.onAppStore.bind(this)}
      chevron
    >
      <wui-text variant="paragraph-500" color="fg-100">iOS App</wui-text>
    </wui-list-item>` : null
    }
    androidTemplate() {
        var e;
        return (e = this.wallet) != null && e.play_store ? $e `<wui-list-item
      variant="icon"
      icon="playStore"
      iconVariant="square"
      @click=${this.onPlayStore.bind(this)}
      chevron
    >
      <wui-text variant="paragraph-500" color="fg-100">Android App</wui-text>
    </wui-list-item>` : null
    }
    homepageTemplate() {
        var e;
        return (e = this.wallet) != null && e.homepage ? $e `
      <wui-list-item
        variant="icon"
        icon="browser"
        iconVariant="square-blue"
        @click=${this.onHomePage.bind(this)}
        chevron
      >
        <wui-text variant="paragraph-500" color="fg-100">Website</wui-text>
      </wui-list-item>
    ` : null
    }
    onChromeStore() {
        var e;
        (e = this.wallet) != null && e.chrome_store && Yt.openHref(this.wallet.chrome_store, "_blank")
    }
    onAppStore() {
        var e;
        (e = this.wallet) != null && e.app_store && Yt.openHref(this.wallet.app_store, "_blank")
    }
    onPlayStore() {
        var e;
        (e = this.wallet) != null && e.play_store && Yt.openHref(this.wallet.play_store, "_blank")
    }
    onHomePage() {
        var e;
        (e = this.wallet) != null && e.homepage && Yt.openHref(this.wallet.homepage, "_blank")
    }
};
Xz = o_e([Qe("w3m-downloads-view")], Xz);
var a_e = function(t, e, n, r) {
    var i = arguments.length,
        s = i < 3 ? e : r === null ? r = Object.getOwnPropertyDescriptor(e, n) : r,
        o;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function") s = Reflect.decorate(t, e, n, r);
    else
        for (var a = t.length - 1; a >= 0; a--)(o = t[a]) && (s = (i < 3 ? o(s) : i > 3 ? o(e, n, s) : o(e, n)) || s);
    return i > 3 && s && Object.defineProperty(e, n, s), s
};
const l_e = "https://walletconnect.com/explorer";
let eW = class extends Dn {
    render() {
        return $e `
      <wui-flex flexDirection="column" padding="s" gap="xs">
        ${this.recommendedWalletsTemplate()}
        <wui-list-wallet
          name="Explore all"
          showAllWallets
          walletIcon="allWallets"
          icon="externalLink"
          @click=${()=>{Yt.openHref("https://walletconnect.com/explorer?type=wallet","_blank")}}
        ></wui-list-wallet>
      </wui-flex>
    `
    }
    recommendedWalletsTemplate() {
        const {
            recommended: e,
            featured: n
        } = Vn.state, {
            customWallets: r
        } = _r.state;
        return [...n, ...r ? ? [], ...e].slice(0, 4).map(s => $e `
        <wui-list-wallet
          name=${s.name??"Unknown"}
          tagVariant="main"
          imageSrc=${pr(Wi.getWalletImage(s))}
          @click=${()=>{Yt.openHref(s.homepage??l_e,"_blank")}}
        ></wui-list-wallet>
      `)
    }
};
eW = a_e([Qe("w3m-get-wallet-view")], eW);
const c_e = bi `
  @keyframes shake {
    0% {
      transform: translateX(0);
    }
    25% {
      transform: translateX(3px);
    }
    50% {
      transform: translateX(-3px);
    }
    75% {
      transform: translateX(3px);
    }
    100% {
      transform: translateX(0);
    }
  }

  wui-flex:first-child:not(:only-child) {
    position: relative;
  }

  wui-loading-hexagon {
    position: absolute;
  }

  wui-icon-box {
    position: absolute;
    right: 4px;
    bottom: 0;
    opacity: 0;
    transform: scale(0.5);
    z-index: 1;
    transition: all var(--wui-ease-out-power-2) var(--wui-duration-lg);
  }

  wui-button {
    display: none;
  }

  [data-error='true'] wui-icon-box {
    opacity: 1;
    transform: scale(1);
  }

  [data-error='true'] > wui-flex:first-child {
    animation: shake 250ms cubic-bezier(0.36, 0.07, 0.19, 0.97) both;
  }

  wui-button[data-retry='true'] {
    display: block;
    opacity: 1;
  }
`;
var Z$ = function(t, e, n, r) {
    var i = arguments.length,
        s = i < 3 ? e : r === null ? r = Object.getOwnPropertyDescriptor(e, n) : r,
        o;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function") s = Reflect.decorate(t, e, n, r);
    else
        for (var a = t.length - 1; a >= 0; a--)(o = t[a]) && (s = (i < 3 ? o(s) : i > 3 ? o(e, n, s) : o(e, n)) || s);
    return i > 3 && s && Object.defineProperty(e, n, s), s
};
let I_ = class extends Dn {
    constructor() {
        var e;
        super(), this.network = (e = Dt.state.data) == null ? void 0 : e.network, this.unsubscribe = [], this.showRetry = !1, this.error = !1
    }
    disconnectedCallback() {
        this.unsubscribe.forEach(e => e())
    }
    firstUpdated() {
        this.onSwitchNetwork()
    }
    render() {
        if (!this.network) throw new Error("w3m-network-switch-view: No network provided");
        this.onShowRetry();
        const e = this.error ? "Switch declined" : "Approve in wallet",
            n = this.error ? "Switch can be declined if chain is not supported by a wallet or previous request is still active" : "Accept connection request in your wallet";
        return $e `
      <wui-flex
        data-error=${this.error}
        flexDirection="column"
        alignItems="center"
        .padding=${["3xl","xl","3xl","xl"]}
        gap="xl"
      >
        <wui-flex justifyContent="center" alignItems="center">
          <wui-network-image
            size="lg"
            imageSrc=${pr(Wi.getNetworkImage(this.network))}
          ></wui-network-image>

          ${this.error?null:$e`<wui-loading-hexagon></wui-loading-hexagon>`}

          <wui-icon-box
            backgroundColor="error-100"
            background="opaque"
            iconColor="error-100"
            icon="close"
            size="sm"
            ?border=${!0}
            borderColor="wui-color-bg-125"
          ></wui-icon-box>
        </wui-flex>

        <wui-flex flexDirection="column" alignItems="center" gap="xs">
          <wui-text align="center" variant="paragraph-500" color="fg-100">${e}</wui-text>
          <wui-text align="center" variant="small-500" color="fg-200">${n}</wui-text>
        </wui-flex>

        <wui-button
          data-retry=${this.showRetry}
          variant="fill"
          .disabled=${!this.error}
          @click=${this.onSwitchNetwork.bind(this)}
        >
          <wui-icon color="inherit" slot="iconLeft" name="refresh"></wui-icon>
          Try again
        </wui-button>
      </wui-flex>
    `
    }
    onShowRetry() {
        var e;
        if (this.error && !this.showRetry) {
            this.showRetry = !0;
            const n = (e = this.shadowRoot) == null ? void 0 : e.querySelector("wui-button");
            n == null || n.animate([{
                opacity: 0
            }, {
                opacity: 1
            }], {
                fill: "forwards",
                easing: "ease"
            })
        }
    }
    async onSwitchNetwork() {
        try {
            this.error = !1, this.network && (await Gi.switchActiveNetwork(this.network), ss.state.isSiweEnabled || eee.navigateAfterNetworkSwitch())
        } catch {
            this.error = !0
        }
    }
};
I_.styles = c_e;
Z$([Nt()], I_.prototype, "showRetry", void 0);
Z$([Nt()], I_.prototype, "error", void 0);
I_ = Z$([Qe("w3m-network-switch-view")], I_);
const u_e = bi `
  :host > wui-grid {
    max-height: 360px;
    overflow: auto;
  }

  wui-grid::-webkit-scrollbar {
    display: none;
  }
`;
var rte = function(t, e, n, r) {
    var i = arguments.length,
        s = i < 3 ? e : r === null ? r = Object.getOwnPropertyDescriptor(e, n) : r,
        o;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function") s = Reflect.decorate(t, e, n, r);
    else
        for (var a = t.length - 1; a >= 0; a--)(o = t[a]) && (s = (i < 3 ? o(s) : i > 3 ? o(e, n, s) : o(e, n)) || s);
    return i > 3 && s && Object.defineProperty(e, n, s), s
};
let lC = class extends Dn {
    constructor() {
        super(), this.unsubscribe = [], this.caipNetwork = Gi.state.caipNetwork, this.unsubscribe.push(Gi.subscribeKey("caipNetwork", e => this.caipNetwork = e))
    }
    disconnectedCallback() {
        this.unsubscribe.forEach(e => e())
    }
    render() {
        return $e `
      <wui-grid padding="s" gridTemplateColumns="repeat(4, 1fr)" rowGap="l" columnGap="xs">
        ${this.networksTemplate()}
      </wui-grid>

      <wui-separator></wui-separator>

      <wui-flex padding="s" flexDirection="column" gap="m" alignItems="center">
        <wui-text variant="small-400" color="fg-300" align="center">
          Your connected wallet may not support some of the networks available for this dApp
        </wui-text>
        <wui-link @click=${this.onNetworkHelp.bind(this)}>
          <wui-icon size="xs" color="accent-100" slot="iconLeft" name="helpCircle"></wui-icon>
          What is a network
        </wui-link>
      </wui-flex>
    `
    }
    onNetworkHelp() {
        wn.sendEvent({
            type: "track",
            event: "CLICK_NETWORK_HELP"
        }), Dt.push("WhatIsANetwork")
    }
    networksTemplate() {
        const {
            approvedCaipNetworkIds: e,
            requestedCaipNetworks: n,
            supportsAllNetworks: r
        } = Gi.state, i = e, s = n, o = {};
        return s && i && (i.forEach((a, l) => {
            o[a] = l
        }), s.sort((a, l) => {
            const c = o[a.id],
                u = o[l.id];
            return c !== void 0 && u !== void 0 ? c - u : c !== void 0 ? -1 : u !== void 0 ? 1 : 0
        })), s == null ? void 0 : s.map(a => {
            var l;
            return $e `
        <wui-card-select
          .selected=${((l=this.caipNetwork)==null?void 0:l.id)===a.id}
          imageSrc=${pr(Wi.getNetworkImage(a))}
          type="network"
          name=${a.name??a.id}
          @click=${()=>this.onSwitchNetwork(a)}
          .disabled=${!r&&!(i!=null&&i.includes(a.id))}
          data-testid=${`w3m-network-switch-${a.name??a.id}`}
        ></wui-card-select>
      `
        })
    }
    async onSwitchNetwork(e) {
        const {
            isConnected: n
        } = hr.state, {
            approvedCaipNetworkIds: r,
            supportsAllNetworks: i,
            caipNetwork: s
        } = Gi.state, {
            data: o
        } = Dt.state;
        n && (s == null ? void 0 : s.id) !== e.id ? r != null && r.includes(e.id) ? (await Gi.switchActiveNetwork(e), eee.navigateAfterNetworkSwitch()) : i && Dt.push("SwitchNetwork", { ...o,
            network: e
        }) : n || (Gi.setCaipNetwork(e), Dt.push("Connect"))
    }
};
lC.styles = u_e;
rte([Nt()], lC.prototype, "caipNetwork", void 0);
lC = rte([Qe("w3m-networks-view")], lC);
const f_e = bi `
  :host > wui-flex:first-child {
    height: 500px;
    overflow-y: auto;
    overflow-x: hidden;
    scrollbar-width: none;
  }
`;
var dy = function(t, e, n, r) {
    var i = arguments.length,
        s = i < 3 ? e : r === null ? r = Object.getOwnPropertyDescriptor(e, n) : r,
        o;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function") s = Reflect.decorate(t, e, n, r);
    else
        for (var a = t.length - 1; a >= 0; a--)(o = t[a]) && (s = (i < 3 ? o(s) : i > 3 ? o(e, n, s) : o(e, n)) || s);
    return i > 3 && s && Object.defineProperty(e, n, s), s
};
const kx = "last-transaction",
    d_e = 7;
let Sh = class extends Dn {
    constructor() {
        super(), this.unsubscribe = [], this.paginationObserver = void 0, this.address = hr.state.address, this.transactions = Qc.state.transactions, this.transactionsByYear = Qc.state.transactionsByYear, this.loading = Qc.state.loading, this.empty = Qc.state.empty, this.next = Qc.state.next, this.unsubscribe.push(hr.subscribe(e => {
            e.isConnected && this.address !== e.address && (this.address = e.address, Qc.resetTransactions(), Qc.fetchTransactions(e.address))
        }), Qc.subscribe(e => {
            this.transactions = e.transactions, this.transactionsByYear = e.transactionsByYear, this.loading = e.loading, this.empty = e.empty, this.next = e.next
        }))
    }
    firstUpdated() {
        this.transactions.length === 0 && Qc.fetchTransactions(this.address), this.createPaginationObserver()
    }
    updated() {
        this.setPaginationObserver()
    }
    disconnectedCallback() {
        this.unsubscribe.forEach(e => e())
    }
    render() {
        return $e `
      <wui-flex flexDirection="column" padding="s" gap="s">
        ${this.empty?null:this.templateTransactionsByYear()}
        ${this.loading?this.templateLoading():null}
        ${!this.loading&&this.empty?this.templateEmpty():null}
      </wui-flex>
    `
    }
    templateTransactionsByYear() {
        const e = Object.keys(this.transactionsByYear).sort().reverse();
        return e.map((n, r) => {
            const i = r === e.length - 1,
                s = parseInt(n, 10),
                o = o1.getTransactionGroupTitle(s),
                a = this.transactionsByYear[s];
            return a ? $e `
        <wui-flex flexDirection="column" gap="s">
          <wui-flex
            alignItems="center"
            flexDirection="row"
            .padding=${["xs","s","s","s"]}
          >
            <wui-text variant="paragraph-500" color="fg-200">${o}</wui-text>
          </wui-flex>
          <wui-flex flexDirection="column" gap="xs">
            ${this.templateTransactions(a,i)}
          </wui-flex>
        </wui-flex>
      ` : null
        })
    }
    templateRenderTransaction(e, n) {
        const {
            date: r,
            descriptions: i,
            direction: s,
            isAllNFT: o,
            images: a,
            status: l,
            transfers: c,
            type: u
        } = this.getTransactionListItemProps(e), f = (c == null ? void 0 : c.length) > 1;
        return (c == null ? void 0 : c.length) === 2 && !o ? $e `
        <wui-transaction-list-item
          date=${r}
          .direction=${s}
          id=${n&&this.next?kx:""}
          status=${l}
          type=${u}
          .images=${a}
          .descriptions=${i}
        ></wui-transaction-list-item>
      ` : f ? c.map((g, y) => {
            const _ = o1.getTransferDescription(g),
                C = n && y === c.length - 1;
            return $e ` <wui-transaction-list-item
          date=${r}
          direction=${g.direction}
          id=${C&&this.next?kx:""}
          status=${l}
          type=${u}
          .onlyDirectionIcon=${!0}
          .images=${[a==null?void 0:a[y]]}
          .descriptions=${[_]}
        ></wui-transaction-list-item>`
        }) : $e `
      <wui-transaction-list-item
        date=${r}
        .direction=${s}
        id=${n&&this.next?kx:""}
        status=${l}
        type=${u}
        .images=${a}
        .descriptions=${i}
      ></wui-transaction-list-item>
    `
    }
    templateTransactions(e, n) {
        return e.map((r, i) => {
            const s = n && i === e.length - 1;
            return $e `${this.templateRenderTransaction(r,s)}`
        })
    }
    templateEmpty() {
        return $e `
      <wui-flex
        flexGrow="1"
        flexDirection="column"
        justifyContent="center"
        alignItems="center"
        .padding=${["3xl","xl","3xl","xl"]}
        gap="xl"
      >
        <wui-icon-box
          backgroundColor="glass-005"
          background="gray"
          iconColor="fg-200"
          icon="wallet"
          size="lg"
          ?border=${!0}
          borderColor="wui-color-bg-125"
        ></wui-icon-box>
        <wui-flex flexDirection="column" alignItems="center" gap="xs">
          <wui-text align="center" variant="paragraph-500" color="fg-100"
            >No Transactions yet</wui-text
          >
          <wui-text align="center" variant="small-500" color="fg-200"
            >Start trading on dApps <br />
            to grow your wallet!</wui-text
          >
        </wui-flex>
      </wui-flex>
    `
    }
    templateLoading() {
        return Array(d_e).fill($e ` <wui-transaction-list-item-loader></wui-transaction-list-item-loader> `).map(e => e)
    }
    createPaginationObserver() {
        const {
            projectId: e
        } = _r.state;
        this.paginationObserver = new IntersectionObserver(([n]) => {
            n != null && n.isIntersecting && !this.loading && (Qc.fetchTransactions(this.address), wn.sendEvent({
                type: "track",
                event: "LOAD_MORE_TRANSACTIONS",
                properties: {
                    address: this.address,
                    projectId: e,
                    cursor: this.next
                }
            }))
        }, {}), this.setPaginationObserver()
    }
    setPaginationObserver() {
        var n, r, i;
        (n = this.paginationObserver) == null || n.disconnect();
        const e = (r = this.shadowRoot) == null ? void 0 : r.querySelector(`#${kx}`);
        e && ((i = this.paginationObserver) == null || i.observe(e))
    }
    getTransactionListItemProps(e) {
        var l, c, u, f, h;
        const n = Vee.getRelativeDateFromNow((l = e == null ? void 0 : e.metadata) == null ? void 0 : l.minedAt),
            r = o1.getTransactionDescriptions(e),
            i = e == null ? void 0 : e.transfers,
            s = (c = e == null ? void 0 : e.transfers) == null ? void 0 : c[0],
            o = !!s && ((u = e == null ? void 0 : e.transfers) == null ? void 0 : u.every(g => !!g.nft_info)),
            a = o1.getTransactionImages(i);
        return {
            date: n,
            direction: s == null ? void 0 : s.direction,
            descriptions: r,
            isAllNFT: o,
            images: a,
            status: (f = e.metadata) == null ? void 0 : f.status,
            transfers: i,
            type: (h = e.metadata) == null ? void 0 : h.operationType
        }
    }
};
Sh.styles = f_e;
dy([Nt()], Sh.prototype, "address", void 0);
dy([Nt()], Sh.prototype, "transactions", void 0);
dy([Nt()], Sh.prototype, "transactionsByYear", void 0);
dy([Nt()], Sh.prototype, "loading", void 0);
dy([Nt()], Sh.prototype, "empty", void 0);
dy([Nt()], Sh.prototype, "next", void 0);
Sh = dy([Qe("w3m-transactions-view")], Sh);
var h_e = function(t, e, n, r) {
    var i = arguments.length,
        s = i < 3 ? e : r === null ? r = Object.getOwnPropertyDescriptor(e, n) : r,
        o;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function") s = Reflect.decorate(t, e, n, r);
    else
        for (var a = t.length - 1; a >= 0; a--)(o = t[a]) && (s = (i < 3 ? o(s) : i > 3 ? o(e, n, s) : o(e, n)) || s);
    return i > 3 && s && Object.defineProperty(e, n, s), s
};
const p_e = [{
    images: ["network", "layers", "system"],
    title: "The systems nuts and bolts",
    text: "A network is what brings the blockchain to life, as this technical infrastructure allows apps to access the ledger and smart contract services."
}, {
    images: ["noun", "defiAlt", "dao"],
    title: "Designed for different uses",
    text: "Each network is designed differently, and may therefore suit certain apps and experiences."
}];
let tW = class extends Dn {
    render() {
        return $e `
      <wui-flex
        flexDirection="column"
        .padding=${["xxl","xl","xl","xl"]}
        alignItems="center"
        gap="xl"
      >
        <w3m-help-widget .data=${p_e}></w3m-help-widget>
        <wui-button
          variant="fill"
          size="sm"
          @click=${()=>{Yt.openHref("https://ethereum.org/en/developers/docs/networks/","_blank")}}
        >
          Learn more
          <wui-icon color="inherit" slot="iconRight" name="externalLink"></wui-icon>
        </wui-button>
      </wui-flex>
    `
    }
};
tW = h_e([Qe("w3m-what-is-a-network-view")], tW);
var g_e = function(t, e, n, r) {
    var i = arguments.length,
        s = i < 3 ? e : r === null ? r = Object.getOwnPropertyDescriptor(e, n) : r,
        o;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function") s = Reflect.decorate(t, e, n, r);
    else
        for (var a = t.length - 1; a >= 0; a--)(o = t[a]) && (s = (i < 3 ? o(s) : i > 3 ? o(e, n, s) : o(e, n)) || s);
    return i > 3 && s && Object.defineProperty(e, n, s), s
};
const m_e = [{
    images: ["login", "profile", "lock"],
    title: "One login for all of web3",
    text: "Log in to any app by connecting your wallet. Say goodbye to countless passwords!"
}, {
    images: ["defi", "nft", "eth"],
    title: "A home for your digital assets",
    text: "A wallet lets you store, send and receive digital assets like cryptocurrencies and NFTs."
}, {
    images: ["browser", "noun", "dao"],
    title: "Your gateway to a new web",
    text: "With your wallet, you can explore and interact with DeFi, NFTs, DAOs, and much more."
}];
let nW = class extends Dn {
    render() {
        return $e `
      <wui-flex
        flexDirection="column"
        .padding=${["xxl","xl","xl","xl"]}
        alignItems="center"
        gap="xl"
      >
        <w3m-help-widget .data=${m_e}></w3m-help-widget>
        <wui-button variant="fill" size="sm" @click=${this.onGetWallet.bind(this)}>
          <wui-icon color="inherit" slot="iconLeft" name="wallet"></wui-icon>
          Get a wallet
        </wui-button>
      </wui-flex>
    `
    }
    onGetWallet() {
        wn.sendEvent({
            type: "track",
            event: "CLICK_GET_WALLET"
        }), Dt.push("GetWallet")
    }
};
nW = g_e([Qe("w3m-what-is-a-wallet-view")], nW);
const y_e = bi `
  wui-loading-spinner {
    margin: 9px auto;
  }
`,
    Pt = {
        SECURE_SITE_SDK: "https://secure.web3modal.com/sdk",
        APP_EVENT_KEY: "@w3m-app/",
        FRAME_EVENT_KEY: "@w3m-frame/",
        RPC_METHOD_KEY: "RPC_",
        STORAGE_KEY: "@w3m-storage/",
        SESSION_TOKEN_KEY: "SESSION_TOKEN_KEY",
        EMAIL_LOGIN_USED_KEY: "EMAIL_LOGIN_USED_KEY",
        LAST_USED_CHAIN_KEY: "LAST_USED_CHAIN_KEY",
        LAST_EMAIL_LOGIN_TIME: "LAST_EMAIL_LOGIN_TIME",
        EMAIL: "EMAIL",
        APP_SWITCH_NETWORK: "@w3m-app/SWITCH_NETWORK",
        APP_CONNECT_EMAIL: "@w3m-app/CONNECT_EMAIL",
        APP_CONNECT_DEVICE: "@w3m-app/CONNECT_DEVICE",
        APP_CONNECT_OTP: "@w3m-app/CONNECT_OTP",
        APP_GET_USER: "@w3m-app/GET_USER",
        APP_SIGN_OUT: "@w3m-app/SIGN_OUT",
        APP_IS_CONNECTED: "@w3m-app/IS_CONNECTED",
        APP_GET_CHAIN_ID: "@w3m-app/GET_CHAIN_ID",
        APP_RPC_REQUEST: "@w3m-app/RPC_REQUEST",
        APP_UPDATE_EMAIL: "@w3m-app/UPDATE_EMAIL",
        APP_AWAIT_UPDATE_EMAIL: "@w3m-app/AWAIT_UPDATE_EMAIL",
        APP_SYNC_THEME: "@w3m-app/SYNC_THEME",
        APP_SYNC_DAPP_DATA: "@w3m-app/SYNC_DAPP_DATA",
        FRAME_SWITCH_NETWORK_ERROR: "@w3m-frame/SWITCH_NETWORK_ERROR",
        FRAME_SWITCH_NETWORK_SUCCESS: "@w3m-frame/SWITCH_NETWORK_SUCCESS",
        FRAME_CONNECT_EMAIL_ERROR: "@w3m-frame/CONNECT_EMAIL_ERROR",
        FRAME_CONNECT_EMAIL_SUCCESS: "@w3m-frame/CONNECT_EMAIL_SUCCESS",
        FRAME_CONNECT_DEVICE_ERROR: "@w3m-frame/CONNECT_DEVICE_ERROR",
        FRAME_CONNECT_DEVICE_SUCCESS: "@w3m-frame/CONNECT_DEVICE_SUCCESS",
        FRAME_CONNECT_OTP_SUCCESS: "@w3m-frame/CONNECT_OTP_SUCCESS",
        FRAME_CONNECT_OTP_ERROR: "@w3m-frame/CONNECT_OTP_ERROR",
        FRAME_GET_USER_SUCCESS: "@w3m-frame/GET_USER_SUCCESS",
        FRAME_GET_USER_ERROR: "@w3m-frame/GET_USER_ERROR",
        FRAME_SIGN_OUT_SUCCESS: "@w3m-frame/SIGN_OUT_SUCCESS",
        FRAME_SIGN_OUT_ERROR: "@w3m-frame/SIGN_OUT_ERROR",
        FRAME_IS_CONNECTED_SUCCESS: "@w3m-frame/IS_CONNECTED_SUCCESS",
        FRAME_IS_CONNECTED_ERROR: "@w3m-frame/IS_CONNECTED_ERROR",
        FRAME_GET_CHAIN_ID_SUCCESS: "@w3m-frame/GET_CHAIN_ID_SUCCESS",
        FRAME_GET_CHAIN_ID_ERROR: "@w3m-frame/GET_CHAIN_ID_ERROR",
        FRAME_RPC_REQUEST_SUCCESS: "@w3m-frame/RPC_REQUEST_SUCCESS",
        FRAME_RPC_REQUEST_ERROR: "@w3m-frame/RPC_REQUEST_ERROR",
        FRAME_SESSION_UPDATE: "@w3m-frame/SESSION_UPDATE",
        FRAME_UPDATE_EMAIL_SUCCESS: "@w3m-frame/UPDATE_EMAIL_SUCCESS",
        FRAME_UPDATE_EMAIL_ERROR: "@w3m-frame/UPDATE_EMAIL_ERROR",
        FRAME_AWAIT_UPDATE_EMAIL_SUCCESS: "@w3m-frame/AWAIT_UPDATE_EMAIL_SUCCESS",
        FRAME_AWAIT_UPDATE_EMAIL_ERROR: "@w3m-frame/AWAIT_UPDATE_EMAIL_ERROR",
        FRAME_SYNC_THEME_SUCCESS: "@w3m-frame/SYNC_THEME_SUCCESS",
        FRAME_SYNC_THEME_ERROR: "@w3m-frame/SYNC_THEME_ERROR",
        FRAME_SYNC_DAPP_DATA_SUCCESS: "@w3m-frame/SYNC_DAPP_DATA_SUCCESS",
        FRAME_SYNC_DAPP_DATA_ERROR: "@w3m-frame/SYNC_DAPP_DATA_ERROR"
    },
    ite = {
        SAFE_RPC_METHODS: ["eth_blockNumber", "eth_estimateGas", "eth_getTransactionByHash"],
        GET_CHAIN_ID: "eth_chainId"
    };
var gr;
(function(t) {
    t.assertEqual = i => i;

    function e(i) {}
    t.assertIs = e;

    function n(i) {
        throw new Error
    }
    t.assertNever = n, t.arrayToEnum = i => {
        const s = {};
        for (const o of i) s[o] = o;
        return s
    }, t.getValidEnumValues = i => {
        const s = t.objectKeys(i).filter(a => typeof i[i[a]] != "number"),
            o = {};
        for (const a of s) o[a] = i[a];
        return t.objectValues(o)
    }, t.objectValues = i => t.objectKeys(i).map(function(s) {
        return i[s]
    }), t.objectKeys = typeof Object.keys == "function" ? i => Object.keys(i) : i => {
        const s = [];
        for (const o in i) Object.prototype.hasOwnProperty.call(i, o) && s.push(o);
        return s
    }, t.find = (i, s) => {
        for (const o of i)
            if (s(o)) return o
    }, t.isInteger = typeof Number.isInteger == "function" ? i => Number.isInteger(i) : i => typeof i == "number" && isFinite(i) && Math.floor(i) === i;

    function r(i, s = " | ") {
        return i.map(o => typeof o == "string" ? `'${o}'` : o).join(s)
    }
    t.joinValues = r, t.jsonStringifyReplacer = (i, s) => typeof s == "bigint" ? s.toString() : s
})(gr || (gr = {}));
var zP;
(function(t) {
    t.mergeShapes = (e, n) => ({ ...e,
        ...n
    })
})(zP || (zP = {}));
const Et = gr.arrayToEnum(["string", "nan", "number", "integer", "float", "boolean", "date", "bigint", "symbol", "function", "undefined", "null", "array", "object", "unknown", "promise", "void", "never", "map", "set"]),
    P0 = t => {
        switch (typeof t) {
            case "undefined":
                return Et.undefined;
            case "string":
                return Et.string;
            case "number":
                return isNaN(t) ? Et.nan : Et.number;
            case "boolean":
                return Et.boolean;
            case "function":
                return Et.function;
            case "bigint":
                return Et.bigint;
            case "symbol":
                return Et.symbol;
            case "object":
                return Array.isArray(t) ? Et.array : t === null ? Et.null : t.then && typeof t.then == "function" && t.catch && typeof t.catch == "function" ? Et.promise : typeof Map < "u" && t instanceof Map ? Et.map : typeof Set < "u" && t instanceof Set ? Et.set : typeof Date < "u" && t instanceof Date ? Et.date : Et.object;
            default:
                return Et.unknown
        }
    },
    et = gr.arrayToEnum(["invalid_type", "invalid_literal", "custom", "invalid_union", "invalid_union_discriminator", "invalid_enum_value", "unrecognized_keys", "invalid_arguments", "invalid_return_type", "invalid_date", "invalid_string", "too_small", "too_big", "invalid_intersection_types", "not_multiple_of", "not_finite"]),
    w_e = t => JSON.stringify(t, null, 2).replace(/"([^"]+)":/g, "$1:");
class xu extends Error {
    constructor(e) {
        super(), this.issues = [], this.addIssue = r => {
            this.issues = [...this.issues, r]
        }, this.addIssues = (r = []) => {
            this.issues = [...this.issues, ...r]
        };
        const n = new.target.prototype;
        Object.setPrototypeOf ? Object.setPrototypeOf(this, n) : this.__proto__ = n, this.name = "ZodError", this.issues = e
    }
    get errors() {
        return this.issues
    }
    format(e) {
        const n = e || function(s) {
                return s.message
            },
            r = {
                _errors: []
            },
            i = s => {
                for (const o of s.issues)
                    if (o.code === "invalid_union") o.unionErrors.map(i);
                    else if (o.code === "invalid_return_type") i(o.returnTypeError);
                else if (o.code === "invalid_arguments") i(o.argumentsError);
                else if (o.path.length === 0) r._errors.push(n(o));
                else {
                    let a = r,
                        l = 0;
                    for (; l < o.path.length;) {
                        const c = o.path[l];
                        l === o.path.length - 1 ? (a[c] = a[c] || {
                            _errors: []
                        }, a[c]._errors.push(n(o))) : a[c] = a[c] || {
                            _errors: []
                        }, a = a[c], l++
                    }
                }
            };
        return i(this), r
    }
    toString() {
        return this.message
    }
    get message() {
        return JSON.stringify(this.issues, gr.jsonStringifyReplacer, 2)
    }
    get isEmpty() {
        return this.issues.length === 0
    }
    flatten(e = n => n.message) {
        const n = {},
            r = [];
        for (const i of this.issues) i.path.length > 0 ? (n[i.path[0]] = n[i.path[0]] || [], n[i.path[0]].push(e(i))) : r.push(e(i));
        return {
            formErrors: r,
            fieldErrors: n
        }
    }
    get formErrors() {
        return this.flatten()
    }
}
xu.create = t => new xu(t);
const R_ = (t, e) => {
    let n;
    switch (t.code) {
        case et.invalid_type:
            t.received === Et.undefined ? n = "Required" : n = `Expected ${t.expected}, received ${t.received}`;
            break;
        case et.invalid_literal:
            n = `Invalid literal value, expected ${JSON.stringify(t.expected,gr.jsonStringifyReplacer)}`;
            break;
        case et.unrecognized_keys:
            n = `Unrecognized key(s) in object: ${gr.joinValues(t.keys,", ")}`;
            break;
        case et.invalid_union:
            n = "Invalid input";
            break;
        case et.invalid_union_discriminator:
            n = `Invalid discriminator value. Expected ${gr.joinValues(t.options)}`;
            break;
        case et.invalid_enum_value:
            n = `Invalid enum value. Expected ${gr.joinValues(t.options)}, received '${t.received}'`;
            break;
        case et.invalid_arguments:
            n = "Invalid function arguments";
            break;
        case et.invalid_return_type:
            n = "Invalid function return type";
            break;
        case et.invalid_date:
            n = "Invalid date";
            break;
        case et.invalid_string:
            typeof t.validation == "object" ? "includes" in t.validation ? (n = `Invalid input: must include "${t.validation.includes}"`, typeof t.validation.position == "number" && (n = `${n} at one or more positions greater than or equal to ${t.validation.position}`)) : "startsWith" in t.validation ? n = `Invalid input: must start with "${t.validation.startsWith}"` : "endsWith" in t.validation ? n = `Invalid input: must end with "${t.validation.endsWith}"` : gr.assertNever(t.validation) : t.validation !== "regex" ? n = `Invalid ${t.validation}` : n = "Invalid";
            break;
        case et.too_small:
            t.type === "array" ? n = `Array must contain ${t.exact?"exactly":t.inclusive?"at least":"more than"} ${t.minimum} element(s)` : t.type === "string" ? n = `String must contain ${t.exact?"exactly":t.inclusive?"at least":"over"} ${t.minimum} character(s)` : t.type === "number" ? n = `Number must be ${t.exact?"exactly equal to ":t.inclusive?"greater than or equal to ":"greater than "}${t.minimum}` : t.type === "date" ? n = `Date must be ${t.exact?"exactly equal to ":t.inclusive?"greater than or equal to ":"greater than "}${new Date(Number(t.minimum))}` : n = "Invalid input";
            break;
        case et.too_big:
            t.type === "array" ? n = `Array must contain ${t.exact?"exactly":t.inclusive?"at most":"less than"} ${t.maximum} element(s)` : t.type === "string" ? n = `String must contain ${t.exact?"exactly":t.inclusive?"at most":"under"} ${t.maximum} character(s)` : t.type === "number" ? n = `Number must be ${t.exact?"exactly":t.inclusive?"less than or equal to":"less than"} ${t.maximum}` : t.type === "bigint" ? n = `BigInt must be ${t.exact?"exactly":t.inclusive?"less than or equal to":"less than"} ${t.maximum}` : t.type === "date" ? n = `Date must be ${t.exact?"exactly":t.inclusive?"smaller than or equal to":"smaller than"} ${new Date(Number(t.maximum))}` : n = "Invalid input";
            break;
        case et.custom:
            n = "Invalid input";
            break;
        case et.invalid_intersection_types:
            n = "Intersection results could not be merged";
            break;
        case et.not_multiple_of:
            n = `Number must be a multiple of ${t.multipleOf}`;
            break;
        case et.not_finite:
            n = "Number must be finite";
            break;
        default:
            n = e.defaultError, gr.assertNever(t)
    }
    return {
        message: n
    }
};
let ste = R_;

function v_e(t) {
    ste = t
}

function cC() {
    return ste
}
const uC = t => {
        const {
            data: e,
            path: n,
            errorMaps: r,
            issueData: i
        } = t, s = [...n, ...i.path || []], o = { ...i,
            path: s
        };
        let a = "";
        const l = r.filter(c => !!c).slice().reverse();
        for (const c of l) a = c(o, {
            data: e,
            defaultError: a
        }).message;
        return { ...i,
            path: s,
            message: i.message || a
        }
    },
    b_e = [];

function Ct(t, e) {
    const n = uC({
        issueData: e,
        data: t.data,
        path: t.path,
        errorMaps: [t.common.contextualErrorMap, t.schemaErrorMap, cC(), R_].filter(r => !!r)
    });
    t.common.issues.push(n)
}
class Do {
    constructor() {
        this.value = "valid"
    }
    dirty() {
        this.value === "valid" && (this.value = "dirty")
    }
    abort() {
        this.value !== "aborted" && (this.value = "aborted")
    }
    static mergeArray(e, n) {
        const r = [];
        for (const i of n) {
            if (i.status === "aborted") return vn;
            i.status === "dirty" && e.dirty(), r.push(i.value)
        }
        return {
            status: e.value,
            value: r
        }
    }
    static async mergeObjectAsync(e, n) {
        const r = [];
        for (const i of n) r.push({
            key: await i.key,
            value: await i.value
        });
        return Do.mergeObjectSync(e, r)
    }
    static mergeObjectSync(e, n) {
        const r = {};
        for (const i of n) {
            const {
                key: s,
                value: o
            } = i;
            if (s.status === "aborted" || o.status === "aborted") return vn;
            s.status === "dirty" && e.dirty(), o.status === "dirty" && e.dirty(), s.value !== "__proto__" && (typeof o.value < "u" || i.alwaysSet) && (r[s.value] = o.value)
        }
        return {
            status: e.value,
            value: r
        }
    }
}
const vn = Object.freeze({
        status: "aborted"
    }),
    ote = t => ({
        status: "dirty",
        value: t
    }),
    da = t => ({
        status: "valid",
        value: t
    }),
    WP = t => t.status === "aborted",
    VP = t => t.status === "dirty",
    O_ = t => t.status === "valid",
    fC = t => typeof Promise < "u" && t instanceof Promise;
var Jt;
(function(t) {
    t.errToObj = e => typeof e == "string" ? {
        message: e
    } : e || {}, t.toString = e => typeof e == "string" ? e : e == null ? void 0 : e.message
})(Jt || (Jt = {}));
class rd {
    constructor(e, n, r, i) {
        this._cachedPath = [], this.parent = e, this.data = n, this._path = r, this._key = i
    }
    get path() {
        return this._cachedPath.length || (this._key instanceof Array ? this._cachedPath.push(...this._path, ...this._key) : this._cachedPath.push(...this._path, this._key)), this._cachedPath
    }
}
const rW = (t, e) => {
    if (O_(e)) return {
        success: !0,
        data: e.value
    };
    if (!t.common.issues.length) throw new Error("Validation failed but no issues detected.");
    return {
        success: !1,
        get error() {
            if (this._error) return this._error;
            const n = new xu(t.common.issues);
            return this._error = n, this._error
        }
    }
};

function Cn(t) {
    if (!t) return {};
    const {
        errorMap: e,
        invalid_type_error: n,
        required_error: r,
        description: i
    } = t;
    if (e && (n || r)) throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
    return e ? {
        errorMap: e,
        description: i
    } : {
        errorMap: (o, a) => o.code !== "invalid_type" ? {
            message: a.defaultError
        } : typeof a.data > "u" ? {
            message: r ? ? a.defaultError
        } : {
            message: n ? ? a.defaultError
        },
        description: i
    }
}
class $n {
    constructor(e) {
        this.spa = this.safeParseAsync, this._def = e, this.parse = this.parse.bind(this), this.safeParse = this.safeParse.bind(this), this.parseAsync = this.parseAsync.bind(this), this.safeParseAsync = this.safeParseAsync.bind(this), this.spa = this.spa.bind(this), this.refine = this.refine.bind(this), this.refinement = this.refinement.bind(this), this.superRefine = this.superRefine.bind(this), this.optional = this.optional.bind(this), this.nullable = this.nullable.bind(this), this.nullish = this.nullish.bind(this), this.array = this.array.bind(this), this.promise = this.promise.bind(this), this.or = this.or.bind(this), this.and = this.and.bind(this), this.transform = this.transform.bind(this), this.brand = this.brand.bind(this), this.default = this.default.bind(this), this.catch = this.catch.bind(this), this.describe = this.describe.bind(this), this.pipe = this.pipe.bind(this), this.readonly = this.readonly.bind(this), this.isNullable = this.isNullable.bind(this), this.isOptional = this.isOptional.bind(this)
    }
    get description() {
        return this._def.description
    }
    _getType(e) {
        return P0(e.data)
    }
    _getOrReturnCtx(e, n) {
        return n || {
            common: e.parent.common,
            data: e.data,
            parsedType: P0(e.data),
            schemaErrorMap: this._def.errorMap,
            path: e.path,
            parent: e.parent
        }
    }
    _processInputParams(e) {
        return {
            status: new Do,
            ctx: {
                common: e.parent.common,
                data: e.data,
                parsedType: P0(e.data),
                schemaErrorMap: this._def.errorMap,
                path: e.path,
                parent: e.parent
            }
        }
    }
    _parseSync(e) {
        const n = this._parse(e);
        if (fC(n)) throw new Error("Synchronous parse encountered promise.");
        return n
    }
    _parseAsync(e) {
        const n = this._parse(e);
        return Promise.resolve(n)
    }
    parse(e, n) {
        const r = this.safeParse(e, n);
        if (r.success) return r.data;
        throw r.error
    }
    safeParse(e, n) {
        var r;
        const i = {
                common: {
                    issues: [],
                    async: (r = n == null ? void 0 : n.async) !== null && r !== void 0 ? r : !1,
                    contextualErrorMap: n == null ? void 0 : n.errorMap
                },
                path: (n == null ? void 0 : n.path) || [],
                schemaErrorMap: this._def.errorMap,
                parent: null,
                data: e,
                parsedType: P0(e)
            },
            s = this._parseSync({
                data: e,
                path: i.path,
                parent: i
            });
        return rW(i, s)
    }
    async parseAsync(e, n) {
        const r = await this.safeParseAsync(e, n);
        if (r.success) return r.data;
        throw r.error
    }
    async safeParseAsync(e, n) {
        const r = {
                common: {
                    issues: [],
                    contextualErrorMap: n == null ? void 0 : n.errorMap,
                    async: !0
                },
                path: (n == null ? void 0 : n.path) || [],
                schemaErrorMap: this._def.errorMap,
                parent: null,
                data: e,
                parsedType: P0(e)
            },
            i = this._parse({
                data: e,
                path: r.path,
                parent: r
            }),
            s = await (fC(i) ? i : Promise.resolve(i));
        return rW(r, s)
    }
    refine(e, n) {
        const r = i => typeof n == "string" || typeof n > "u" ? {
            message: n
        } : typeof n == "function" ? n(i) : n;
        return this._refinement((i, s) => {
            const o = e(i),
                a = () => s.addIssue({
                    code: et.custom,
                    ...r(i)
                });
            return typeof Promise < "u" && o instanceof Promise ? o.then(l => l ? !0 : (a(), !1)) : o ? !0 : (a(), !1)
        })
    }
    refinement(e, n) {
        return this._refinement((r, i) => e(r) ? !0 : (i.addIssue(typeof n == "function" ? n(r, i) : n), !1))
    }
    _refinement(e) {
        return new ku({
            schema: this,
            typeName: on.ZodEffects,
            effect: {
                type: "refinement",
                refinement: e
            }
        })
    }
    superRefine(e) {
        return this._refinement(e)
    }
    optional() {
        return ph.create(this, this._def)
    }
    nullable() {
        return Rm.create(this, this._def)
    }
    nullish() {
        return this.nullable().optional()
    }
    array() {
        return Su.create(this, this._def)
    }
    promise() {
        return Hb.create(this, this._def)
    }
    or(e) {
        return M_.create([this, e], this._def)
    }
    and(e) {
        return D_.create(this, e, this._def)
    }
    transform(e) {
        return new ku({ ...Cn(this._def),
            schema: this,
            typeName: on.ZodEffects,
            effect: {
                type: "transform",
                transform: e
            }
        })
    }
    default (e) {
        const n = typeof e == "function" ? e : () => e;
        return new U_({ ...Cn(this._def),
            innerType: this,
            defaultValue: n,
            typeName: on.ZodDefault
        })
    }
    brand() {
        return new lte({
            typeName: on.ZodBranded,
            type: this,
            ...Cn(this._def)
        })
    } catch (e) {
        const n = typeof e == "function" ? e : () => e;
        return new gC({ ...Cn(this._def),
            innerType: this,
            catchValue: n,
            typeName: on.ZodCatch
        })
    }
    describe(e) {
        const n = this.constructor;
        return new n({ ...this._def,
            description: e
        })
    }
    pipe(e) {
        return gE.create(this, e)
    }
    readonly() {
        return yC.create(this)
    }
    isOptional() {
        return this.safeParse(void 0).success
    }
    isNullable() {
        return this.safeParse(null).success
    }
}
const __e = /^c[^\s-]{8,}$/i,
    E_e = /^[a-z][a-z0-9]*$/,
    x_e = /^[0-9A-HJKMNP-TV-Z]{26}$/,
    S_e = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i,
    C_e = /^(?!\.)(?!.*\.\.)([A-Z0-9_+-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i,
    A_e = "^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$";
let VR;
const T_e = /^(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))$/,
    I_e = /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/,
    R_e = t => t.precision ? t.offset ? new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{${t.precision}}(([+-]\\d{2}(:?\\d{2})?)|Z)$`) : new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{${t.precision}}Z$`) : t.precision === 0 ? t.offset ? new RegExp("^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(([+-]\\d{2}(:?\\d{2})?)|Z)$") : new RegExp("^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}Z$") : t.offset ? new RegExp("^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?(([+-]\\d{2}(:?\\d{2})?)|Z)$") : new RegExp("^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?Z$");

function O_e(t, e) {
    return !!((e === "v4" || !e) && T_e.test(t) || (e === "v6" || !e) && I_e.test(t))
}
class vu extends $n {
    _parse(e) {
        if (this._def.coerce && (e.data = String(e.data)), this._getType(e) !== Et.string) {
            const s = this._getOrReturnCtx(e);
            return Ct(s, {
                code: et.invalid_type,
                expected: Et.string,
                received: s.parsedType
            }), vn
        }
        const r = new Do;
        let i;
        for (const s of this._def.checks)
            if (s.kind === "min") e.data.length < s.value && (i = this._getOrReturnCtx(e, i), Ct(i, {
                code: et.too_small,
                minimum: s.value,
                type: "string",
                inclusive: !0,
                exact: !1,
                message: s.message
            }), r.dirty());
            else if (s.kind === "max") e.data.length > s.value && (i = this._getOrReturnCtx(e, i), Ct(i, {
            code: et.too_big,
            maximum: s.value,
            type: "string",
            inclusive: !0,
            exact: !1,
            message: s.message
        }), r.dirty());
        else if (s.kind === "length") {
            const o = e.data.length > s.value,
                a = e.data.length < s.value;
            (o || a) && (i = this._getOrReturnCtx(e, i), o ? Ct(i, {
                code: et.too_big,
                maximum: s.value,
                type: "string",
                inclusive: !0,
                exact: !0,
                message: s.message
            }) : a && Ct(i, {
                code: et.too_small,
                minimum: s.value,
                type: "string",
                inclusive: !0,
                exact: !0,
                message: s.message
            }), r.dirty())
        } else if (s.kind === "email") C_e.test(e.data) || (i = this._getOrReturnCtx(e, i), Ct(i, {
            validation: "email",
            code: et.invalid_string,
            message: s.message
        }), r.dirty());
        else if (s.kind === "emoji") VR || (VR = new RegExp(A_e, "u")), VR.test(e.data) || (i = this._getOrReturnCtx(e, i), Ct(i, {
            validation: "emoji",
            code: et.invalid_string,
            message: s.message
        }), r.dirty());
        else if (s.kind === "uuid") S_e.test(e.data) || (i = this._getOrReturnCtx(e, i), Ct(i, {
            validation: "uuid",
            code: et.invalid_string,
            message: s.message
        }), r.dirty());
        else if (s.kind === "cuid") __e.test(e.data) || (i = this._getOrReturnCtx(e, i), Ct(i, {
            validation: "cuid",
            code: et.invalid_string,
            message: s.message
        }), r.dirty());
        else if (s.kind === "cuid2") E_e.test(e.data) || (i = this._getOrReturnCtx(e, i), Ct(i, {
            validation: "cuid2",
            code: et.invalid_string,
            message: s.message
        }), r.dirty());
        else if (s.kind === "ulid") x_e.test(e.data) || (i = this._getOrReturnCtx(e, i), Ct(i, {
            validation: "ulid",
            code: et.invalid_string,
            message: s.message
        }), r.dirty());
        else if (s.kind === "url") try {
            new URL(e.data)
        } catch {
            i = this._getOrReturnCtx(e, i), Ct(i, {
                validation: "url",
                code: et.invalid_string,
                message: s.message
            }), r.dirty()
        } else s.kind === "regex" ? (s.regex.lastIndex = 0, s.regex.test(e.data) || (i = this._getOrReturnCtx(e, i), Ct(i, {
            validation: "regex",
            code: et.invalid_string,
            message: s.message
        }), r.dirty())) : s.kind === "trim" ? e.data = e.data.trim() : s.kind === "includes" ? e.data.includes(s.value, s.position) || (i = this._getOrReturnCtx(e, i), Ct(i, {
            code: et.invalid_string,
            validation: {
                includes: s.value,
                position: s.position
            },
            message: s.message
        }), r.dirty()) : s.kind === "toLowerCase" ? e.data = e.data.toLowerCase() : s.kind === "toUpperCase" ? e.data = e.data.toUpperCase() : s.kind === "startsWith" ? e.data.startsWith(s.value) || (i = this._getOrReturnCtx(e, i), Ct(i, {
            code: et.invalid_string,
            validation: {
                startsWith: s.value
            },
            message: s.message
        }), r.dirty()) : s.kind === "endsWith" ? e.data.endsWith(s.value) || (i = this._getOrReturnCtx(e, i), Ct(i, {
            code: et.invalid_string,
            validation: {
                endsWith: s.value
            },
            message: s.message
        }), r.dirty()) : s.kind === "datetime" ? R_e(s).test(e.data) || (i = this._getOrReturnCtx(e, i), Ct(i, {
            code: et.invalid_string,
            validation: "datetime",
            message: s.message
        }), r.dirty()) : s.kind === "ip" ? O_e(e.data, s.version) || (i = this._getOrReturnCtx(e, i), Ct(i, {
            validation: "ip",
            code: et.invalid_string,
            message: s.message
        }), r.dirty()) : gr.assertNever(s);
        return {
            status: r.value,
            value: e.data
        }
    }
    _regex(e, n, r) {
        return this.refinement(i => e.test(i), {
            validation: n,
            code: et.invalid_string,
            ...Jt.errToObj(r)
        })
    }
    _addCheck(e) {
        return new vu({ ...this._def,
            checks: [...this._def.checks, e]
        })
    }
    email(e) {
        return this._addCheck({
            kind: "email",
            ...Jt.errToObj(e)
        })
    }
    url(e) {
        return this._addCheck({
            kind: "url",
            ...Jt.errToObj(e)
        })
    }
    emoji(e) {
        return this._addCheck({
            kind: "emoji",
            ...Jt.errToObj(e)
        })
    }
    uuid(e) {
        return this._addCheck({
            kind: "uuid",
            ...Jt.errToObj(e)
        })
    }
    cuid(e) {
        return this._addCheck({
            kind: "cuid",
            ...Jt.errToObj(e)
        })
    }
    cuid2(e) {
        return this._addCheck({
            kind: "cuid2",
            ...Jt.errToObj(e)
        })
    }
    ulid(e) {
        return this._addCheck({
            kind: "ulid",
            ...Jt.errToObj(e)
        })
    }
    ip(e) {
        return this._addCheck({
            kind: "ip",
            ...Jt.errToObj(e)
        })
    }
    datetime(e) {
        var n;
        return typeof e == "string" ? this._addCheck({
            kind: "datetime",
            precision: null,
            offset: !1,
            message: e
        }) : this._addCheck({
            kind: "datetime",
            precision: typeof(e == null ? void 0 : e.precision) > "u" ? null : e == null ? void 0 : e.precision,
            offset: (n = e == null ? void 0 : e.offset) !== null && n !== void 0 ? n : !1,
            ...Jt.errToObj(e == null ? void 0 : e.message)
        })
    }
    regex(e, n) {
        return this._addCheck({
            kind: "regex",
            regex: e,
            ...Jt.errToObj(n)
        })
    }
    includes(e, n) {
        return this._addCheck({
            kind: "includes",
            value: e,
            position: n == null ? void 0 : n.position,
            ...Jt.errToObj(n == null ? void 0 : n.message)
        })
    }
    startsWith(e, n) {
        return this._addCheck({
            kind: "startsWith",
            value: e,
            ...Jt.errToObj(n)
        })
    }
    endsWith(e, n) {
        return this._addCheck({
            kind: "endsWith",
            value: e,
            ...Jt.errToObj(n)
        })
    }
    min(e, n) {
        return this._addCheck({
            kind: "min",
            value: e,
            ...Jt.errToObj(n)
        })
    }
    max(e, n) {
        return this._addCheck({
            kind: "max",
            value: e,
            ...Jt.errToObj(n)
        })
    }
    length(e, n) {
        return this._addCheck({
            kind: "length",
            value: e,
            ...Jt.errToObj(n)
        })
    }
    nonempty(e) {
        return this.min(1, Jt.errToObj(e))
    }
    trim() {
        return new vu({ ...this._def,
            checks: [...this._def.checks, {
                kind: "trim"
            }]
        })
    }
    toLowerCase() {
        return new vu({ ...this._def,
            checks: [...this._def.checks, {
                kind: "toLowerCase"
            }]
        })
    }
    toUpperCase() {
        return new vu({ ...this._def,
            checks: [...this._def.checks, {
                kind: "toUpperCase"
            }]
        })
    }
    get isDatetime() {
        return !!this._def.checks.find(e => e.kind === "datetime")
    }
    get isEmail() {
        return !!this._def.checks.find(e => e.kind === "email")
    }
    get isURL() {
        return !!this._def.checks.find(e => e.kind === "url")
    }
    get isEmoji() {
        return !!this._def.checks.find(e => e.kind === "emoji")
    }
    get isUUID() {
        return !!this._def.checks.find(e => e.kind === "uuid")
    }
    get isCUID() {
        return !!this._def.checks.find(e => e.kind === "cuid")
    }
    get isCUID2() {
        return !!this._def.checks.find(e => e.kind === "cuid2")
    }
    get isULID() {
        return !!this._def.checks.find(e => e.kind === "ulid")
    }
    get isIP() {
        return !!this._def.checks.find(e => e.kind === "ip")
    }
    get minLength() {
        let e = null;
        for (const n of this._def.checks) n.kind === "min" && (e === null || n.value > e) && (e = n.value);
        return e
    }
    get maxLength() {
        let e = null;
        for (const n of this._def.checks) n.kind === "max" && (e === null || n.value < e) && (e = n.value);
        return e
    }
}
vu.create = t => {
    var e;
    return new vu({
        checks: [],
        typeName: on.ZodString,
        coerce: (e = t == null ? void 0 : t.coerce) !== null && e !== void 0 ? e : !1,
        ...Cn(t)
    })
};

function N_e(t, e) {
    const n = (t.toString().split(".")[1] || "").length,
        r = (e.toString().split(".")[1] || "").length,
        i = n > r ? n : r,
        s = parseInt(t.toFixed(i).replace(".", "")),
        o = parseInt(e.toFixed(i).replace(".", ""));
    return s % o / Math.pow(10, i)
}
class Bp extends $n {
    constructor() {
        super(...arguments), this.min = this.gte, this.max = this.lte, this.step = this.multipleOf
    }
    _parse(e) {
        if (this._def.coerce && (e.data = Number(e.data)), this._getType(e) !== Et.number) {
            const s = this._getOrReturnCtx(e);
            return Ct(s, {
                code: et.invalid_type,
                expected: Et.number,
                received: s.parsedType
            }), vn
        }
        let r;
        const i = new Do;
        for (const s of this._def.checks) s.kind === "int" ? gr.isInteger(e.data) || (r = this._getOrReturnCtx(e, r), Ct(r, {
            code: et.invalid_type,
            expected: "integer",
            received: "float",
            message: s.message
        }), i.dirty()) : s.kind === "min" ? (s.inclusive ? e.data < s.value : e.data <= s.value) && (r = this._getOrReturnCtx(e, r), Ct(r, {
            code: et.too_small,
            minimum: s.value,
            type: "number",
            inclusive: s.inclusive,
            exact: !1,
            message: s.message
        }), i.dirty()) : s.kind === "max" ? (s.inclusive ? e.data > s.value : e.data >= s.value) && (r = this._getOrReturnCtx(e, r), Ct(r, {
            code: et.too_big,
            maximum: s.value,
            type: "number",
            inclusive: s.inclusive,
            exact: !1,
            message: s.message
        }), i.dirty()) : s.kind === "multipleOf" ? N_e(e.data, s.value) !== 0 && (r = this._getOrReturnCtx(e, r), Ct(r, {
            code: et.not_multiple_of,
            multipleOf: s.value,
            message: s.message
        }), i.dirty()) : s.kind === "finite" ? Number.isFinite(e.data) || (r = this._getOrReturnCtx(e, r), Ct(r, {
            code: et.not_finite,
            message: s.message
        }), i.dirty()) : gr.assertNever(s);
        return {
            status: i.value,
            value: e.data
        }
    }
    gte(e, n) {
        return this.setLimit("min", e, !0, Jt.toString(n))
    }
    gt(e, n) {
        return this.setLimit("min", e, !1, Jt.toString(n))
    }
    lte(e, n) {
        return this.setLimit("max", e, !0, Jt.toString(n))
    }
    lt(e, n) {
        return this.setLimit("max", e, !1, Jt.toString(n))
    }
    setLimit(e, n, r, i) {
        return new Bp({ ...this._def,
            checks: [...this._def.checks, {
                kind: e,
                value: n,
                inclusive: r,
                message: Jt.toString(i)
            }]
        })
    }
    _addCheck(e) {
        return new Bp({ ...this._def,
            checks: [...this._def.checks, e]
        })
    }
    int(e) {
        return this._addCheck({
            kind: "int",
            message: Jt.toString(e)
        })
    }
    positive(e) {
        return this._addCheck({
            kind: "min",
            value: 0,
            inclusive: !1,
            message: Jt.toString(e)
        })
    }
    negative(e) {
        return this._addCheck({
            kind: "max",
            value: 0,
            inclusive: !1,
            message: Jt.toString(e)
        })
    }
    nonpositive(e) {
        return this._addCheck({
            kind: "max",
            value: 0,
            inclusive: !0,
            message: Jt.toString(e)
        })
    }
    nonnegative(e) {
        return this._addCheck({
            kind: "min",
            value: 0,
            inclusive: !0,
            message: Jt.toString(e)
        })
    }
    multipleOf(e, n) {
        return this._addCheck({
            kind: "multipleOf",
            value: e,
            message: Jt.toString(n)
        })
    }
    finite(e) {
        return this._addCheck({
            kind: "finite",
            message: Jt.toString(e)
        })
    }
    safe(e) {
        return this._addCheck({
            kind: "min",
            inclusive: !0,
            value: Number.MIN_SAFE_INTEGER,
            message: Jt.toString(e)
        })._addCheck({
            kind: "max",
            inclusive: !0,
            value: Number.MAX_SAFE_INTEGER,
            message: Jt.toString(e)
        })
    }
    get minValue() {
        let e = null;
        for (const n of this._def.checks) n.kind === "min" && (e === null || n.value > e) && (e = n.value);
        return e
    }
    get maxValue() {
        let e = null;
        for (const n of this._def.checks) n.kind === "max" && (e === null || n.value < e) && (e = n.value);
        return e
    }
    get isInt() {
        return !!this._def.checks.find(e => e.kind === "int" || e.kind === "multipleOf" && gr.isInteger(e.value))
    }
    get isFinite() {
        let e = null,
            n = null;
        for (const r of this._def.checks) {
            if (r.kind === "finite" || r.kind === "int" || r.kind === "multipleOf") return !0;
            r.kind === "min" ? (n === null || r.value > n) && (n = r.value) : r.kind === "max" && (e === null || r.value < e) && (e = r.value)
        }
        return Number.isFinite(n) && Number.isFinite(e)
    }
}
Bp.create = t => new Bp({
    checks: [],
    typeName: on.ZodNumber,
    coerce: (t == null ? void 0 : t.coerce) || !1,
    ...Cn(t)
});
class Fp extends $n {
    constructor() {
        super(...arguments), this.min = this.gte, this.max = this.lte
    }
    _parse(e) {
        if (this._def.coerce && (e.data = BigInt(e.data)), this._getType(e) !== Et.bigint) {
            const s = this._getOrReturnCtx(e);
            return Ct(s, {
                code: et.invalid_type,
                expected: Et.bigint,
                received: s.parsedType
            }), vn
        }
        let r;
        const i = new Do;
        for (const s of this._def.checks) s.kind === "min" ? (s.inclusive ? e.data < s.value : e.data <= s.value) && (r = this._getOrReturnCtx(e, r), Ct(r, {
            code: et.too_small,
            type: "bigint",
            minimum: s.value,
            inclusive: s.inclusive,
            message: s.message
        }), i.dirty()) : s.kind === "max" ? (s.inclusive ? e.data > s.value : e.data >= s.value) && (r = this._getOrReturnCtx(e, r), Ct(r, {
            code: et.too_big,
            type: "bigint",
            maximum: s.value,
            inclusive: s.inclusive,
            message: s.message
        }), i.dirty()) : s.kind === "multipleOf" ? e.data % s.value !== BigInt(0) && (r = this._getOrReturnCtx(e, r), Ct(r, {
            code: et.not_multiple_of,
            multipleOf: s.value,
            message: s.message
        }), i.dirty()) : gr.assertNever(s);
        return {
            status: i.value,
            value: e.data
        }
    }
    gte(e, n) {
        return this.setLimit("min", e, !0, Jt.toString(n))
    }
    gt(e, n) {
        return this.setLimit("min", e, !1, Jt.toString(n))
    }
    lte(e, n) {
        return this.setLimit("max", e, !0, Jt.toString(n))
    }
    lt(e, n) {
        return this.setLimit("max", e, !1, Jt.toString(n))
    }
    setLimit(e, n, r, i) {
        return new Fp({ ...this._def,
            checks: [...this._def.checks, {
                kind: e,
                value: n,
                inclusive: r,
                message: Jt.toString(i)
            }]
        })
    }
    _addCheck(e) {
        return new Fp({ ...this._def,
            checks: [...this._def.checks, e]
        })
    }
    positive(e) {
        return this._addCheck({
            kind: "min",
            value: BigInt(0),
            inclusive: !1,
            message: Jt.toString(e)
        })
    }
    negative(e) {
        return this._addCheck({
            kind: "max",
            value: BigInt(0),
            inclusive: !1,
            message: Jt.toString(e)
        })
    }
    nonpositive(e) {
        return this._addCheck({
            kind: "max",
            value: BigInt(0),
            inclusive: !0,
            message: Jt.toString(e)
        })
    }
    nonnegative(e) {
        return this._addCheck({
            kind: "min",
            value: BigInt(0),
            inclusive: !0,
            message: Jt.toString(e)
        })
    }
    multipleOf(e, n) {
        return this._addCheck({
            kind: "multipleOf",
            value: e,
            message: Jt.toString(n)
        })
    }
    get minValue() {
        let e = null;
        for (const n of this._def.checks) n.kind === "min" && (e === null || n.value > e) && (e = n.value);
        return e
    }
    get maxValue() {
        let e = null;
        for (const n of this._def.checks) n.kind === "max" && (e === null || n.value < e) && (e = n.value);
        return e
    }
}
Fp.create = t => {
    var e;
    return new Fp({
        checks: [],
        typeName: on.ZodBigInt,
        coerce: (e = t == null ? void 0 : t.coerce) !== null && e !== void 0 ? e : !1,
        ...Cn(t)
    })
};
class N_ extends $n {
    _parse(e) {
        if (this._def.coerce && (e.data = !!e.data), this._getType(e) !== Et.boolean) {
            const r = this._getOrReturnCtx(e);
            return Ct(r, {
                code: et.invalid_type,
                expected: Et.boolean,
                received: r.parsedType
            }), vn
        }
        return da(e.data)
    }
}
N_.create = t => new N_({
    typeName: on.ZodBoolean,
    coerce: (t == null ? void 0 : t.coerce) || !1,
    ...Cn(t)
});
class Tm extends $n {
    _parse(e) {
        if (this._def.coerce && (e.data = new Date(e.data)), this._getType(e) !== Et.date) {
            const s = this._getOrReturnCtx(e);
            return Ct(s, {
                code: et.invalid_type,
                expected: Et.date,
                received: s.parsedType
            }), vn
        }
        if (isNaN(e.data.getTime())) {
            const s = this._getOrReturnCtx(e);
            return Ct(s, {
                code: et.invalid_date
            }), vn
        }
        const r = new Do;
        let i;
        for (const s of this._def.checks) s.kind === "min" ? e.data.getTime() < s.value && (i = this._getOrReturnCtx(e, i), Ct(i, {
            code: et.too_small,
            message: s.message,
            inclusive: !0,
            exact: !1,
            minimum: s.value,
            type: "date"
        }), r.dirty()) : s.kind === "max" ? e.data.getTime() > s.value && (i = this._getOrReturnCtx(e, i), Ct(i, {
            code: et.too_big,
            message: s.message,
            inclusive: !0,
            exact: !1,
            maximum: s.value,
            type: "date"
        }), r.dirty()) : gr.assertNever(s);
        return {
            status: r.value,
            value: new Date(e.data.getTime())
        }
    }
    _addCheck(e) {
        return new Tm({ ...this._def,
            checks: [...this._def.checks, e]
        })
    }
    min(e, n) {
        return this._addCheck({
            kind: "min",
            value: e.getTime(),
            message: Jt.toString(n)
        })
    }
    max(e, n) {
        return this._addCheck({
            kind: "max",
            value: e.getTime(),
            message: Jt.toString(n)
        })
    }
    get minDate() {
        let e = null;
        for (const n of this._def.checks) n.kind === "min" && (e === null || n.value > e) && (e = n.value);
        return e != null ? new Date(e) : null
    }
    get maxDate() {
        let e = null;
        for (const n of this._def.checks) n.kind === "max" && (e === null || n.value < e) && (e = n.value);
        return e != null ? new Date(e) : null
    }
}
Tm.create = t => new Tm({
    checks: [],
    coerce: (t == null ? void 0 : t.coerce) || !1,
    typeName: on.ZodDate,
    ...Cn(t)
});
class dC extends $n {
    _parse(e) {
        if (this._getType(e) !== Et.symbol) {
            const r = this._getOrReturnCtx(e);
            return Ct(r, {
                code: et.invalid_type,
                expected: Et.symbol,
                received: r.parsedType
            }), vn
        }
        return da(e.data)
    }
}
dC.create = t => new dC({
    typeName: on.ZodSymbol,
    ...Cn(t)
});
class P_ extends $n {
    _parse(e) {
        if (this._getType(e) !== Et.undefined) {
            const r = this._getOrReturnCtx(e);
            return Ct(r, {
                code: et.invalid_type,
                expected: Et.undefined,
                received: r.parsedType
            }), vn
        }
        return da(e.data)
    }
}
P_.create = t => new P_({
    typeName: on.ZodUndefined,
    ...Cn(t)
});
class k_ extends $n {
    _parse(e) {
        if (this._getType(e) !== Et.null) {
            const r = this._getOrReturnCtx(e);
            return Ct(r, {
                code: et.invalid_type,
                expected: Et.null,
                received: r.parsedType
            }), vn
        }
        return da(e.data)
    }
}
k_.create = t => new k_({
    typeName: on.ZodNull,
    ...Cn(t)
});
class jb extends $n {
    constructor() {
        super(...arguments), this._any = !0
    }
    _parse(e) {
        return da(e.data)
    }
}
jb.create = t => new jb({
    typeName: on.ZodAny,
    ...Cn(t)
});
class X1 extends $n {
    constructor() {
        super(...arguments), this._unknown = !0
    }
    _parse(e) {
        return da(e.data)
    }
}
X1.create = t => new X1({
    typeName: on.ZodUnknown,
    ...Cn(t)
});
class Ch extends $n {
    _parse(e) {
        const n = this._getOrReturnCtx(e);
        return Ct(n, {
            code: et.invalid_type,
            expected: Et.never,
            received: n.parsedType
        }), vn
    }
}
Ch.create = t => new Ch({
    typeName: on.ZodNever,
    ...Cn(t)
});
class hC extends $n {
    _parse(e) {
        if (this._getType(e) !== Et.undefined) {
            const r = this._getOrReturnCtx(e);
            return Ct(r, {
                code: et.invalid_type,
                expected: Et.void,
                received: r.parsedType
            }), vn
        }
        return da(e.data)
    }
}
hC.create = t => new hC({
    typeName: on.ZodVoid,
    ...Cn(t)
});
class Su extends $n {
    _parse(e) {
        const {
            ctx: n,
            status: r
        } = this._processInputParams(e), i = this._def;
        if (n.parsedType !== Et.array) return Ct(n, {
            code: et.invalid_type,
            expected: Et.array,
            received: n.parsedType
        }), vn;
        if (i.exactLength !== null) {
            const o = n.data.length > i.exactLength.value,
                a = n.data.length < i.exactLength.value;
            (o || a) && (Ct(n, {
                code: o ? et.too_big : et.too_small,
                minimum: a ? i.exactLength.value : void 0,
                maximum: o ? i.exactLength.value : void 0,
                type: "array",
                inclusive: !0,
                exact: !0,
                message: i.exactLength.message
            }), r.dirty())
        }
        if (i.minLength !== null && n.data.length < i.minLength.value && (Ct(n, {
                code: et.too_small,
                minimum: i.minLength.value,
                type: "array",
                inclusive: !0,
                exact: !1,
                message: i.minLength.message
            }), r.dirty()), i.maxLength !== null && n.data.length > i.maxLength.value && (Ct(n, {
                code: et.too_big,
                maximum: i.maxLength.value,
                type: "array",
                inclusive: !0,
                exact: !1,
                message: i.maxLength.message
            }), r.dirty()), n.common.async) return Promise.all([...n.data].map((o, a) => i.type._parseAsync(new rd(n, o, n.path, a)))).then(o => Do.mergeArray(r, o));
        const s = [...n.data].map((o, a) => i.type._parseSync(new rd(n, o, n.path, a)));
        return Do.mergeArray(r, s)
    }
    get element() {
        return this._def.type
    }
    min(e, n) {
        return new Su({ ...this._def,
            minLength: {
                value: e,
                message: Jt.toString(n)
            }
        })
    }
    max(e, n) {
        return new Su({ ...this._def,
            maxLength: {
                value: e,
                message: Jt.toString(n)
            }
        })
    }
    length(e, n) {
        return new Su({ ...this._def,
            exactLength: {
                value: e,
                message: Jt.toString(n)
            }
        })
    }
    nonempty(e) {
        return this.min(1, e)
    }
}
Su.create = (t, e) => new Su({
    type: t,
    minLength: null,
    maxLength: null,
    exactLength: null,
    typeName: on.ZodArray,
    ...Cn(e)
});

function vw(t) {
    if (t instanceof Ci) {
        const e = {};
        for (const n in t.shape) {
            const r = t.shape[n];
            e[n] = ph.create(vw(r))
        }
        return new Ci({ ...t._def,
            shape: () => e
        })
    } else return t instanceof Su ? new Su({ ...t._def,
        type: vw(t.element)
    }) : t instanceof ph ? ph.create(vw(t.unwrap())) : t instanceof Rm ? Rm.create(vw(t.unwrap())) : t instanceof id ? id.create(t.items.map(e => vw(e))) : t
}
class Ci extends $n {
    constructor() {
        super(...arguments), this._cached = null, this.nonstrict = this.passthrough, this.augment = this.extend
    }
    _getCached() {
        if (this._cached !== null) return this._cached;
        const e = this._def.shape(),
            n = gr.objectKeys(e);
        return this._cached = {
            shape: e,
            keys: n
        }
    }
    _parse(e) {
        if (this._getType(e) !== Et.object) {
            const c = this._getOrReturnCtx(e);
            return Ct(c, {
                code: et.invalid_type,
                expected: Et.object,
                received: c.parsedType
            }), vn
        }
        const {
            status: r,
            ctx: i
        } = this._processInputParams(e), {
            shape: s,
            keys: o
        } = this._getCached(), a = [];
        if (!(this._def.catchall instanceof Ch && this._def.unknownKeys === "strip"))
            for (const c in i.data) o.includes(c) || a.push(c);
        const l = [];
        for (const c of o) {
            const u = s[c],
                f = i.data[c];
            l.push({
                key: {
                    status: "valid",
                    value: c
                },
                value: u._parse(new rd(i, f, i.path, c)),
                alwaysSet: c in i.data
            })
        }
        if (this._def.catchall instanceof Ch) {
            const c = this._def.unknownKeys;
            if (c === "passthrough")
                for (const u of a) l.push({
                    key: {
                        status: "valid",
                        value: u
                    },
                    value: {
                        status: "valid",
                        value: i.data[u]
                    }
                });
            else if (c === "strict") a.length > 0 && (Ct(i, {
                code: et.unrecognized_keys,
                keys: a
            }), r.dirty());
            else if (c !== "strip") throw new Error("Internal ZodObject error: invalid unknownKeys value.")
        } else {
            const c = this._def.catchall;
            for (const u of a) {
                const f = i.data[u];
                l.push({
                    key: {
                        status: "valid",
                        value: u
                    },
                    value: c._parse(new rd(i, f, i.path, u)),
                    alwaysSet: u in i.data
                })
            }
        }
        return i.common.async ? Promise.resolve().then(async () => {
            const c = [];
            for (const u of l) {
                const f = await u.key;
                c.push({
                    key: f,
                    value: await u.value,
                    alwaysSet: u.alwaysSet
                })
            }
            return c
        }).then(c => Do.mergeObjectSync(r, c)) : Do.mergeObjectSync(r, l)
    }
    get shape() {
        return this._def.shape()
    }
    strict(e) {
        return Jt.errToObj, new Ci({ ...this._def,
            unknownKeys: "strict",
            ...e !== void 0 ? {
                errorMap: (n, r) => {
                    var i, s, o, a;
                    const l = (o = (s = (i = this._def).errorMap) === null || s === void 0 ? void 0 : s.call(i, n, r).message) !== null && o !== void 0 ? o : r.defaultError;
                    return n.code === "unrecognized_keys" ? {
                        message: (a = Jt.errToObj(e).message) !== null && a !== void 0 ? a : l
                    } : {
                        message: l
                    }
                }
            } : {}
        })
    }
    strip() {
        return new Ci({ ...this._def,
            unknownKeys: "strip"
        })
    }
    passthrough() {
        return new Ci({ ...this._def,
            unknownKeys: "passthrough"
        })
    }
    extend(e) {
        return new Ci({ ...this._def,
            shape: () => ({ ...this._def.shape(),
                ...e
            })
        })
    }
    merge(e) {
        return new Ci({
            unknownKeys: e._def.unknownKeys,
            catchall: e._def.catchall,
            shape: () => ({ ...this._def.shape(),
                ...e._def.shape()
            }),
            typeName: on.ZodObject
        })
    }
    setKey(e, n) {
        return this.augment({
            [e]: n
        })
    }
    catchall(e) {
        return new Ci({ ...this._def,
            catchall: e
        })
    }
    pick(e) {
        const n = {};
        return gr.objectKeys(e).forEach(r => {
            e[r] && this.shape[r] && (n[r] = this.shape[r])
        }), new Ci({ ...this._def,
            shape: () => n
        })
    }
    omit(e) {
        const n = {};
        return gr.objectKeys(this.shape).forEach(r => {
            e[r] || (n[r] = this.shape[r])
        }), new Ci({ ...this._def,
            shape: () => n
        })
    }
    deepPartial() {
        return vw(this)
    }
    partial(e) {
        const n = {};
        return gr.objectKeys(this.shape).forEach(r => {
            const i = this.shape[r];
            e && !e[r] ? n[r] = i : n[r] = i.optional()
        }), new Ci({ ...this._def,
            shape: () => n
        })
    }
    required(e) {
        const n = {};
        return gr.objectKeys(this.shape).forEach(r => {
            if (e && !e[r]) n[r] = this.shape[r];
            else {
                let s = this.shape[r];
                for (; s instanceof ph;) s = s._def.innerType;
                n[r] = s
            }
        }), new Ci({ ...this._def,
            shape: () => n
        })
    }
    keyof() {
        return ate(gr.objectKeys(this.shape))
    }
}
Ci.create = (t, e) => new Ci({
    shape: () => t,
    unknownKeys: "strip",
    catchall: Ch.create(),
    typeName: on.ZodObject,
    ...Cn(e)
});
Ci.strictCreate = (t, e) => new Ci({
    shape: () => t,
    unknownKeys: "strict",
    catchall: Ch.create(),
    typeName: on.ZodObject,
    ...Cn(e)
});
Ci.lazycreate = (t, e) => new Ci({
    shape: t,
    unknownKeys: "strip",
    catchall: Ch.create(),
    typeName: on.ZodObject,
    ...Cn(e)
});
class M_ extends $n {
    _parse(e) {
        const {
            ctx: n
        } = this._processInputParams(e), r = this._def.options;

        function i(s) {
            for (const a of s)
                if (a.result.status === "valid") return a.result;
            for (const a of s)
                if (a.result.status === "dirty") return n.common.issues.push(...a.ctx.common.issues), a.result;
            const o = s.map(a => new xu(a.ctx.common.issues));
            return Ct(n, {
                code: et.invalid_union,
                unionErrors: o
            }), vn
        }
        if (n.common.async) return Promise.all(r.map(async s => {
            const o = { ...n,
                common: { ...n.common,
                    issues: []
                },
                parent: null
            };
            return {
                result: await s._parseAsync({
                    data: n.data,
                    path: n.path,
                    parent: o
                }),
                ctx: o
            }
        })).then(i); {
            let s;
            const o = [];
            for (const l of r) {
                const c = { ...n,
                        common: { ...n.common,
                            issues: []
                        },
                        parent: null
                    },
                    u = l._parseSync({
                        data: n.data,
                        path: n.path,
                        parent: c
                    });
                if (u.status === "valid") return u;
                u.status === "dirty" && !s && (s = {
                    result: u,
                    ctx: c
                }), c.common.issues.length && o.push(c.common.issues)
            }
            if (s) return n.common.issues.push(...s.ctx.common.issues), s.result;
            const a = o.map(l => new xu(l));
            return Ct(n, {
                code: et.invalid_union,
                unionErrors: a
            }), vn
        }
    }
    get options() {
        return this._def.options
    }
}
M_.create = (t, e) => new M_({
    options: t,
    typeName: on.ZodUnion,
    ...Cn(e)
});
const YS = t => t instanceof L_ ? YS(t.schema) : t instanceof ku ? YS(t.innerType()) : t instanceof B_ ? [t.value] : t instanceof Up ? t.options : t instanceof F_ ? Object.keys(t.enum) : t instanceof U_ ? YS(t._def.innerType) : t instanceof P_ ? [void 0] : t instanceof k_ ? [null] : null;
class RT extends $n {
    _parse(e) {
        const {
            ctx: n
        } = this._processInputParams(e);
        if (n.parsedType !== Et.object) return Ct(n, {
            code: et.invalid_type,
            expected: Et.object,
            received: n.parsedType
        }), vn;
        const r = this.discriminator,
            i = n.data[r],
            s = this.optionsMap.get(i);
        return s ? n.common.async ? s._parseAsync({
            data: n.data,
            path: n.path,
            parent: n
        }) : s._parseSync({
            data: n.data,
            path: n.path,
            parent: n
        }) : (Ct(n, {
            code: et.invalid_union_discriminator,
            options: Array.from(this.optionsMap.keys()),
            path: [r]
        }), vn)
    }
    get discriminator() {
        return this._def.discriminator
    }
    get options() {
        return this._def.options
    }
    get optionsMap() {
        return this._def.optionsMap
    }
    static create(e, n, r) {
        const i = new Map;
        for (const s of n) {
            const o = YS(s.shape[e]);
            if (!o) throw new Error(`A discriminator value for key \`${e}\` could not be extracted from all schema options`);
            for (const a of o) {
                if (i.has(a)) throw new Error(`Discriminator property ${String(e)} has duplicate value ${String(a)}`);
                i.set(a, s)
            }
        }
        return new RT({
            typeName: on.ZodDiscriminatedUnion,
            discriminator: e,
            options: n,
            optionsMap: i,
            ...Cn(r)
        })
    }
}

function GP(t, e) {
    const n = P0(t),
        r = P0(e);
    if (t === e) return {
        valid: !0,
        data: t
    };
    if (n === Et.object && r === Et.object) {
        const i = gr.objectKeys(e),
            s = gr.objectKeys(t).filter(a => i.indexOf(a) !== -1),
            o = { ...t,
                ...e
            };
        for (const a of s) {
            const l = GP(t[a], e[a]);
            if (!l.valid) return {
                valid: !1
            };
            o[a] = l.data
        }
        return {
            valid: !0,
            data: o
        }
    } else if (n === Et.array && r === Et.array) {
        if (t.length !== e.length) return {
            valid: !1
        };
        const i = [];
        for (let s = 0; s < t.length; s++) {
            const o = t[s],
                a = e[s],
                l = GP(o, a);
            if (!l.valid) return {
                valid: !1
            };
            i.push(l.data)
        }
        return {
            valid: !0,
            data: i
        }
    } else return n === Et.date && r === Et.date && +t == +e ? {
        valid: !0,
        data: t
    } : {
        valid: !1
    }
}
class D_ extends $n {
    _parse(e) {
        const {
            status: n,
            ctx: r
        } = this._processInputParams(e), i = (s, o) => {
            if (WP(s) || WP(o)) return vn;
            const a = GP(s.value, o.value);
            return a.valid ? ((VP(s) || VP(o)) && n.dirty(), {
                status: n.value,
                value: a.data
            }) : (Ct(r, {
                code: et.invalid_intersection_types
            }), vn)
        };
        return r.common.async ? Promise.all([this._def.left._parseAsync({
            data: r.data,
            path: r.path,
            parent: r
        }), this._def.right._parseAsync({
            data: r.data,
            path: r.path,
            parent: r
        })]).then(([s, o]) => i(s, o)) : i(this._def.left._parseSync({
            data: r.data,
            path: r.path,
            parent: r
        }), this._def.right._parseSync({
            data: r.data,
            path: r.path,
            parent: r
        }))
    }
}
D_.create = (t, e, n) => new D_({
    left: t,
    right: e,
    typeName: on.ZodIntersection,
    ...Cn(n)
});
class id extends $n {
    _parse(e) {
        const {
            status: n,
            ctx: r
        } = this._processInputParams(e);
        if (r.parsedType !== Et.array) return Ct(r, {
            code: et.invalid_type,
            expected: Et.array,
            received: r.parsedType
        }), vn;
        if (r.data.length < this._def.items.length) return Ct(r, {
            code: et.too_small,
            minimum: this._def.items.length,
            inclusive: !0,
            exact: !1,
            type: "array"
        }), vn;
        !this._def.rest && r.data.length > this._def.items.length && (Ct(r, {
            code: et.too_big,
            maximum: this._def.items.length,
            inclusive: !0,
            exact: !1,
            type: "array"
        }), n.dirty());
        const s = [...r.data].map((o, a) => {
            const l = this._def.items[a] || this._def.rest;
            return l ? l._parse(new rd(r, o, r.path, a)) : null
        }).filter(o => !!o);
        return r.common.async ? Promise.all(s).then(o => Do.mergeArray(n, o)) : Do.mergeArray(n, s)
    }
    get items() {
        return this._def.items
    }
    rest(e) {
        return new id({ ...this._def,
            rest: e
        })
    }
}
id.create = (t, e) => {
    if (!Array.isArray(t)) throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
    return new id({
        items: t,
        typeName: on.ZodTuple,
        rest: null,
        ...Cn(e)
    })
};
class $_ extends $n {
    get keySchema() {
        return this._def.keyType
    }
    get valueSchema() {
        return this._def.valueType
    }
    _parse(e) {
        const {
            status: n,
            ctx: r
        } = this._processInputParams(e);
        if (r.parsedType !== Et.object) return Ct(r, {
            code: et.invalid_type,
            expected: Et.object,
            received: r.parsedType
        }), vn;
        const i = [],
            s = this._def.keyType,
            o = this._def.valueType;
        for (const a in r.data) i.push({
            key: s._parse(new rd(r, a, r.path, a)),
            value: o._parse(new rd(r, r.data[a], r.path, a))
        });
        return r.common.async ? Do.mergeObjectAsync(n, i) : Do.mergeObjectSync(n, i)
    }
    get element() {
        return this._def.valueType
    }
    static create(e, n, r) {
        return n instanceof $n ? new $_({
            keyType: e,
            valueType: n,
            typeName: on.ZodRecord,
            ...Cn(r)
        }) : new $_({
            keyType: vu.create(),
            valueType: e,
            typeName: on.ZodRecord,
            ...Cn(n)
        })
    }
}
class pC extends $n {
    get keySchema() {
        return this._def.keyType
    }
    get valueSchema() {
        return this._def.valueType
    }
    _parse(e) {
        const {
            status: n,
            ctx: r
        } = this._processInputParams(e);
        if (r.parsedType !== Et.map) return Ct(r, {
            code: et.invalid_type,
            expected: Et.map,
            received: r.parsedType
        }), vn;
        const i = this._def.keyType,
            s = this._def.valueType,
            o = [...r.data.entries()].map(([a, l], c) => ({
                key: i._parse(new rd(r, a, r.path, [c, "key"])),
                value: s._parse(new rd(r, l, r.path, [c, "value"]))
            }));
        if (r.common.async) {
            const a = new Map;
            return Promise.resolve().then(async () => {
                for (const l of o) {
                    const c = await l.key,
                        u = await l.value;
                    if (c.status === "aborted" || u.status === "aborted") return vn;
                    (c.status === "dirty" || u.status === "dirty") && n.dirty(), a.set(c.value, u.value)
                }
                return {
                    status: n.value,
                    value: a
                }
            })
        } else {
            const a = new Map;
            for (const l of o) {
                const c = l.key,
                    u = l.value;
                if (c.status === "aborted" || u.status === "aborted") return vn;
                (c.status === "dirty" || u.status === "dirty") && n.dirty(), a.set(c.value, u.value)
            }
            return {
                status: n.value,
                value: a
            }
        }
    }
}
pC.create = (t, e, n) => new pC({
    valueType: e,
    keyType: t,
    typeName: on.ZodMap,
    ...Cn(n)
});
class Im extends $n {
    _parse(e) {
        const {
            status: n,
            ctx: r
        } = this._processInputParams(e);
        if (r.parsedType !== Et.set) return Ct(r, {
            code: et.invalid_type,
            expected: Et.set,
            received: r.parsedType
        }), vn;
        const i = this._def;
        i.minSize !== null && r.data.size < i.minSize.value && (Ct(r, {
            code: et.too_small,
            minimum: i.minSize.value,
            type: "set",
            inclusive: !0,
            exact: !1,
            message: i.minSize.message
        }), n.dirty()), i.maxSize !== null && r.data.size > i.maxSize.value && (Ct(r, {
            code: et.too_big,
            maximum: i.maxSize.value,
            type: "set",
            inclusive: !0,
            exact: !1,
            message: i.maxSize.message
        }), n.dirty());
        const s = this._def.valueType;

        function o(l) {
            const c = new Set;
            for (const u of l) {
                if (u.status === "aborted") return vn;
                u.status === "dirty" && n.dirty(), c.add(u.value)
            }
            return {
                status: n.value,
                value: c
            }
        }
        const a = [...r.data.values()].map((l, c) => s._parse(new rd(r, l, r.path, c)));
        return r.common.async ? Promise.all(a).then(l => o(l)) : o(a)
    }
    min(e, n) {
        return new Im({ ...this._def,
            minSize: {
                value: e,
                message: Jt.toString(n)
            }
        })
    }
    max(e, n) {
        return new Im({ ...this._def,
            maxSize: {
                value: e,
                message: Jt.toString(n)
            }
        })
    }
    size(e, n) {
        return this.min(e, n).max(e, n)
    }
    nonempty(e) {
        return this.min(1, e)
    }
}
Im.create = (t, e) => new Im({
    valueType: t,
    minSize: null,
    maxSize: null,
    typeName: on.ZodSet,
    ...Cn(e)
});
class Xw extends $n {
    constructor() {
        super(...arguments), this.validate = this.implement
    }
    _parse(e) {
        const {
            ctx: n
        } = this._processInputParams(e);
        if (n.parsedType !== Et.function) return Ct(n, {
            code: et.invalid_type,
            expected: Et.function,
            received: n.parsedType
        }), vn;

        function r(a, l) {
            return uC({
                data: a,
                path: n.path,
                errorMaps: [n.common.contextualErrorMap, n.schemaErrorMap, cC(), R_].filter(c => !!c),
                issueData: {
                    code: et.invalid_arguments,
                    argumentsError: l
                }
            })
        }

        function i(a, l) {
            return uC({
                data: a,
                path: n.path,
                errorMaps: [n.common.contextualErrorMap, n.schemaErrorMap, cC(), R_].filter(c => !!c),
                issueData: {
                    code: et.invalid_return_type,
                    returnTypeError: l
                }
            })
        }
        const s = {
                errorMap: n.common.contextualErrorMap
            },
            o = n.data;
        if (this._def.returns instanceof Hb) {
            const a = this;
            return da(async function(...l) {
                const c = new xu([]),
                    u = await a._def.args.parseAsync(l, s).catch(g => {
                        throw c.addIssue(r(l, g)), c
                    }),
                    f = await Reflect.apply(o, this, u);
                return await a._def.returns._def.type.parseAsync(f, s).catch(g => {
                    throw c.addIssue(i(f, g)), c
                })
            })
        } else {
            const a = this;
            return da(function(...l) {
                const c = a._def.args.safeParse(l, s);
                if (!c.success) throw new xu([r(l, c.error)]);
                const u = Reflect.apply(o, this, c.data),
                    f = a._def.returns.safeParse(u, s);
                if (!f.success) throw new xu([i(u, f.error)]);
                return f.data
            })
        }
    }
    parameters() {
        return this._def.args
    }
    returnType() {
        return this._def.returns
    }
    args(...e) {
        return new Xw({ ...this._def,
            args: id.create(e).rest(X1.create())
        })
    }
    returns(e) {
        return new Xw({ ...this._def,
            returns: e
        })
    }
    implement(e) {
        return this.parse(e)
    }
    strictImplement(e) {
        return this.parse(e)
    }
    static create(e, n, r) {
        return new Xw({
            args: e || id.create([]).rest(X1.create()),
            returns: n || X1.create(),
            typeName: on.ZodFunction,
            ...Cn(r)
        })
    }
}
class L_ extends $n {
    get schema() {
        return this._def.getter()
    }
    _parse(e) {
        const {
            ctx: n
        } = this._processInputParams(e);
        return this._def.getter()._parse({
            data: n.data,
            path: n.path,
            parent: n
        })
    }
}
L_.create = (t, e) => new L_({
    getter: t,
    typeName: on.ZodLazy,
    ...Cn(e)
});
class B_ extends $n {
    _parse(e) {
        if (e.data !== this._def.value) {
            const n = this._getOrReturnCtx(e);
            return Ct(n, {
                received: n.data,
                code: et.invalid_literal,
                expected: this._def.value
            }), vn
        }
        return {
            status: "valid",
            value: e.data
        }
    }
    get value() {
        return this._def.value
    }
}
B_.create = (t, e) => new B_({
    value: t,
    typeName: on.ZodLiteral,
    ...Cn(e)
});

function ate(t, e) {
    return new Up({
        values: t,
        typeName: on.ZodEnum,
        ...Cn(e)
    })
}
class Up extends $n {
    _parse(e) {
        if (typeof e.data != "string") {
            const n = this._getOrReturnCtx(e),
                r = this._def.values;
            return Ct(n, {
                expected: gr.joinValues(r),
                received: n.parsedType,
                code: et.invalid_type
            }), vn
        }
        if (this._def.values.indexOf(e.data) === -1) {
            const n = this._getOrReturnCtx(e),
                r = this._def.values;
            return Ct(n, {
                received: n.data,
                code: et.invalid_enum_value,
                options: r
            }), vn
        }
        return da(e.data)
    }
    get options() {
        return this._def.values
    }
    get enum() {
        const e = {};
        for (const n of this._def.values) e[n] = n;
        return e
    }
    get Values() {
        const e = {};
        for (const n of this._def.values) e[n] = n;
        return e
    }
    get Enum() {
        const e = {};
        for (const n of this._def.values) e[n] = n;
        return e
    }
    extract(e) {
        return Up.create(e)
    }
    exclude(e) {
        return Up.create(this.options.filter(n => !e.includes(n)))
    }
}
Up.create = ate;
class F_ extends $n {
    _parse(e) {
        const n = gr.getValidEnumValues(this._def.values),
            r = this._getOrReturnCtx(e);
        if (r.parsedType !== Et.string && r.parsedType !== Et.number) {
            const i = gr.objectValues(n);
            return Ct(r, {
                expected: gr.joinValues(i),
                received: r.parsedType,
                code: et.invalid_type
            }), vn
        }
        if (n.indexOf(e.data) === -1) {
            const i = gr.objectValues(n);
            return Ct(r, {
                received: r.data,
                code: et.invalid_enum_value,
                options: i
            }), vn
        }
        return da(e.data)
    }
    get enum() {
        return this._def.values
    }
}
F_.create = (t, e) => new F_({
    values: t,
    typeName: on.ZodNativeEnum,
    ...Cn(e)
});
class Hb extends $n {
    unwrap() {
        return this._def.type
    }
    _parse(e) {
        const {
            ctx: n
        } = this._processInputParams(e);
        if (n.parsedType !== Et.promise && n.common.async === !1) return Ct(n, {
            code: et.invalid_type,
            expected: Et.promise,
            received: n.parsedType
        }), vn;
        const r = n.parsedType === Et.promise ? n.data : Promise.resolve(n.data);
        return da(r.then(i => this._def.type.parseAsync(i, {
            path: n.path,
            errorMap: n.common.contextualErrorMap
        })))
    }
}
Hb.create = (t, e) => new Hb({
    type: t,
    typeName: on.ZodPromise,
    ...Cn(e)
});
class ku extends $n {
    innerType() {
        return this._def.schema
    }
    sourceType() {
        return this._def.schema._def.typeName === on.ZodEffects ? this._def.schema.sourceType() : this._def.schema
    }
    _parse(e) {
        const {
            status: n,
            ctx: r
        } = this._processInputParams(e), i = this._def.effect || null, s = {
            addIssue: o => {
                Ct(r, o), o.fatal ? n.abort() : n.dirty()
            },
            get path() {
                return r.path
            }
        };
        if (s.addIssue = s.addIssue.bind(s), i.type === "preprocess") {
            const o = i.transform(r.data, s);
            return r.common.issues.length ? {
                status: "dirty",
                value: r.data
            } : r.common.async ? Promise.resolve(o).then(a => this._def.schema._parseAsync({
                data: a,
                path: r.path,
                parent: r
            })) : this._def.schema._parseSync({
                data: o,
                path: r.path,
                parent: r
            })
        }
        if (i.type === "refinement") {
            const o = a => {
                const l = i.refinement(a, s);
                if (r.common.async) return Promise.resolve(l);
                if (l instanceof Promise) throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
                return a
            };
            if (r.common.async === !1) {
                const a = this._def.schema._parseSync({
                    data: r.data,
                    path: r.path,
                    parent: r
                });
                return a.status === "aborted" ? vn : (a.status === "dirty" && n.dirty(), o(a.value), {
                    status: n.value,
                    value: a.value
                })
            } else return this._def.schema._parseAsync({
                data: r.data,
                path: r.path,
                parent: r
            }).then(a => a.status === "aborted" ? vn : (a.status === "dirty" && n.dirty(), o(a.value).then(() => ({
                status: n.value,
                value: a.value
            }))))
        }
        if (i.type === "transform")
            if (r.common.async === !1) {
                const o = this._def.schema._parseSync({
                    data: r.data,
                    path: r.path,
                    parent: r
                });
                if (!O_(o)) return o;
                const a = i.transform(o.value, s);
                if (a instanceof Promise) throw new Error("Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.");
                return {
                    status: n.value,
                    value: a
                }
            } else return this._def.schema._parseAsync({
                data: r.data,
                path: r.path,
                parent: r
            }).then(o => O_(o) ? Promise.resolve(i.transform(o.value, s)).then(a => ({
                status: n.value,
                value: a
            })) : o);
        gr.assertNever(i)
    }
}
ku.create = (t, e, n) => new ku({
    schema: t,
    typeName: on.ZodEffects,
    effect: e,
    ...Cn(n)
});
ku.createWithPreprocess = (t, e, n) => new ku({
    schema: e,
    effect: {
        type: "preprocess",
        transform: t
    },
    typeName: on.ZodEffects,
    ...Cn(n)
});
class ph extends $n {
    _parse(e) {
        return this._getType(e) === Et.undefined ? da(void 0) : this._def.innerType._parse(e)
    }
    unwrap() {
        return this._def.innerType
    }
}
ph.create = (t, e) => new ph({
    innerType: t,
    typeName: on.ZodOptional,
    ...Cn(e)
});
class Rm extends $n {
    _parse(e) {
        return this._getType(e) === Et.null ? da(null) : this._def.innerType._parse(e)
    }
    unwrap() {
        return this._def.innerType
    }
}
Rm.create = (t, e) => new Rm({
    innerType: t,
    typeName: on.ZodNullable,
    ...Cn(e)
});
class U_ extends $n {
    _parse(e) {
        const {
            ctx: n
        } = this._processInputParams(e);
        let r = n.data;
        return n.parsedType === Et.undefined && (r = this._def.defaultValue()), this._def.innerType._parse({
            data: r,
            path: n.path,
            parent: n
        })
    }
    removeDefault() {
        return this._def.innerType
    }
}
U_.create = (t, e) => new U_({
    innerType: t,
    typeName: on.ZodDefault,
    defaultValue: typeof e.default == "function" ? e.default : () => e.default,
    ...Cn(e)
});
class gC extends $n {
    _parse(e) {
        const {
            ctx: n
        } = this._processInputParams(e), r = { ...n,
            common: { ...n.common,
                issues: []
            }
        }, i = this._def.innerType._parse({
            data: r.data,
            path: r.path,
            parent: { ...r
            }
        });
        return fC(i) ? i.then(s => ({
            status: "valid",
            value: s.status === "valid" ? s.value : this._def.catchValue({
                get error() {
                    return new xu(r.common.issues)
                },
                input: r.data
            })
        })) : {
            status: "valid",
            value: i.status === "valid" ? i.value : this._def.catchValue({
                get error() {
                    return new xu(r.common.issues)
                },
                input: r.data
            })
        }
    }
    removeCatch() {
        return this._def.innerType
    }
}
gC.create = (t, e) => new gC({
    innerType: t,
    typeName: on.ZodCatch,
    catchValue: typeof e.catch == "function" ? e.catch : () => e.catch,
    ...Cn(e)
});
class mC extends $n {
    _parse(e) {
        if (this._getType(e) !== Et.nan) {
            const r = this._getOrReturnCtx(e);
            return Ct(r, {
                code: et.invalid_type,
                expected: Et.nan,
                received: r.parsedType
            }), vn
        }
        return {
            status: "valid",
            value: e.data
        }
    }
}
mC.create = t => new mC({
    typeName: on.ZodNaN,
    ...Cn(t)
});
const P_e = Symbol("zod_brand");
class lte extends $n {
    _parse(e) {
        const {
            ctx: n
        } = this._processInputParams(e), r = n.data;
        return this._def.type._parse({
            data: r,
            path: n.path,
            parent: n
        })
    }
    unwrap() {
        return this._def.type
    }
}
class gE extends $n {
    _parse(e) {
        const {
            status: n,
            ctx: r
        } = this._processInputParams(e);
        if (r.common.async) return (async () => {
            const s = await this._def.in._parseAsync({
                data: r.data,
                path: r.path,
                parent: r
            });
            return s.status === "aborted" ? vn : s.status === "dirty" ? (n.dirty(), ote(s.value)) : this._def.out._parseAsync({
                data: s.value,
                path: r.path,
                parent: r
            })
        })(); {
            const i = this._def.in._parseSync({
                data: r.data,
                path: r.path,
                parent: r
            });
            return i.status === "aborted" ? vn : i.status === "dirty" ? (n.dirty(), {
                status: "dirty",
                value: i.value
            }) : this._def.out._parseSync({
                data: i.value,
                path: r.path,
                parent: r
            })
        }
    }
    static create(e, n) {
        return new gE({ in: e,
            out: n,
            typeName: on.ZodPipeline
        })
    }
}
class yC extends $n {
    _parse(e) {
        const n = this._def.innerType._parse(e);
        return O_(n) && (n.value = Object.freeze(n.value)), n
    }
}
yC.create = (t, e) => new yC({
    innerType: t,
    typeName: on.ZodReadonly,
    ...Cn(e)
});
const cte = (t, e = {}, n) => t ? jb.create().superRefine((r, i) => {
        var s, o;
        if (!t(r)) {
            const a = typeof e == "function" ? e(r) : typeof e == "string" ? {
                    message: e
                } : e,
                l = (o = (s = a.fatal) !== null && s !== void 0 ? s : n) !== null && o !== void 0 ? o : !0,
                c = typeof a == "string" ? {
                    message: a
                } : a;
            i.addIssue({
                code: "custom",
                ...c,
                fatal: l
            })
        }
    }) : jb.create(),
    k_e = {
        object: Ci.lazycreate
    };
var on;
(function(t) {
    t.ZodString = "ZodString", t.ZodNumber = "ZodNumber", t.ZodNaN = "ZodNaN", t.ZodBigInt = "ZodBigInt", t.ZodBoolean = "ZodBoolean", t.ZodDate = "ZodDate", t.ZodSymbol = "ZodSymbol", t.ZodUndefined = "ZodUndefined", t.ZodNull = "ZodNull", t.ZodAny = "ZodAny", t.ZodUnknown = "ZodUnknown", t.ZodNever = "ZodNever", t.ZodVoid = "ZodVoid", t.ZodArray = "ZodArray", t.ZodObject = "ZodObject", t.ZodUnion = "ZodUnion", t.ZodDiscriminatedUnion = "ZodDiscriminatedUnion", t.ZodIntersection = "ZodIntersection", t.ZodTuple = "ZodTuple", t.ZodRecord = "ZodRecord", t.ZodMap = "ZodMap", t.ZodSet = "ZodSet", t.ZodFunction = "ZodFunction", t.ZodLazy = "ZodLazy", t.ZodLiteral = "ZodLiteral", t.ZodEnum = "ZodEnum", t.ZodEffects = "ZodEffects", t.ZodNativeEnum = "ZodNativeEnum", t.ZodOptional = "ZodOptional", t.ZodNullable = "ZodNullable", t.ZodDefault = "ZodDefault", t.ZodCatch = "ZodCatch", t.ZodPromise = "ZodPromise", t.ZodBranded = "ZodBranded", t.ZodPipeline = "ZodPipeline", t.ZodReadonly = "ZodReadonly"
})(on || (on = {}));
const M_e = (t, e = {
        message: `Input not instance of ${t.name}`
    }) => cte(n => n instanceof t, e),
    ute = vu.create,
    fte = Bp.create,
    D_e = mC.create,
    $_e = Fp.create,
    dte = N_.create,
    L_e = Tm.create,
    B_e = dC.create,
    F_e = P_.create,
    U_e = k_.create,
    j_e = jb.create,
    H_e = X1.create,
    z_e = Ch.create,
    W_e = hC.create,
    V_e = Su.create,
    G_e = Ci.create,
    q_e = Ci.strictCreate,
    K_e = M_.create,
    Y_e = RT.create,
    Z_e = D_.create,
    Q_e = id.create,
    J_e = $_.create,
    X_e = pC.create,
    e6e = Im.create,
    t6e = Xw.create,
    n6e = L_.create,
    r6e = B_.create,
    i6e = Up.create,
    s6e = F_.create,
    o6e = Hb.create,
    iW = ku.create,
    a6e = ph.create,
    l6e = Rm.create,
    c6e = ku.createWithPreprocess,
    u6e = gE.create,
    f6e = () => ute().optional(),
    d6e = () => fte().optional(),
    h6e = () => dte().optional(),
    p6e = {
        string: t => vu.create({ ...t,
            coerce: !0
        }),
        number: t => Bp.create({ ...t,
            coerce: !0
        }),
        boolean: t => N_.create({ ...t,
            coerce: !0
        }),
        bigint: t => Fp.create({ ...t,
            coerce: !0
        }),
        date: t => Tm.create({ ...t,
            coerce: !0
        })
    },
    g6e = vn;
var Oe = Object.freeze({
    __proto__: null,
    defaultErrorMap: R_,
    setErrorMap: v_e,
    getErrorMap: cC,
    makeIssue: uC,
    EMPTY_PATH: b_e,
    addIssueToContext: Ct,
    ParseStatus: Do,
    INVALID: vn,
    DIRTY: ote,
    OK: da,
    isAborted: WP,
    isDirty: VP,
    isValid: O_,
    isAsync: fC,
    get util() {
        return gr
    },
    get objectUtil() {
        return zP
    },
    ZodParsedType: Et,
    getParsedType: P0,
    ZodType: $n,
    ZodString: vu,
    ZodNumber: Bp,
    ZodBigInt: Fp,
    ZodBoolean: N_,
    ZodDate: Tm,
    ZodSymbol: dC,
    ZodUndefined: P_,
    ZodNull: k_,
    ZodAny: jb,
    ZodUnknown: X1,
    ZodNever: Ch,
    ZodVoid: hC,
    ZodArray: Su,
    ZodObject: Ci,
    ZodUnion: M_,
    ZodDiscriminatedUnion: RT,
    ZodIntersection: D_,
    ZodTuple: id,
    ZodRecord: $_,
    ZodMap: pC,
    ZodSet: Im,
    ZodFunction: Xw,
    ZodLazy: L_,
    ZodLiteral: B_,
    ZodEnum: Up,
    ZodNativeEnum: F_,
    ZodPromise: Hb,
    ZodEffects: ku,
    ZodTransformer: ku,
    ZodOptional: ph,
    ZodNullable: Rm,
    ZodDefault: U_,
    ZodCatch: gC,
    ZodNaN: mC,
    BRAND: P_e,
    ZodBranded: lte,
    ZodPipeline: gE,
    ZodReadonly: yC,
    custom: cte,
    Schema: $n,
    ZodSchema: $n,
    late: k_e,
    get ZodFirstPartyTypeKind() {
        return on
    },
    coerce: p6e,
    any: j_e,
    array: V_e,
    bigint: $_e,
    boolean: dte,
    date: L_e,
    discriminatedUnion: Y_e,
    effect: iW,
    enum: i6e,
    function: t6e,
    instanceof: M_e,
    intersection: Z_e,
    lazy: n6e,
    literal: r6e,
    map: X_e,
    nan: D_e,
    nativeEnum: s6e,
    never: z_e,
    null: U_e,
    nullable: l6e,
    number: fte,
    object: G_e,
    oboolean: h6e,
    onumber: d6e,
    optional: a6e,
    ostring: f6e,
    pipeline: u6e,
    preprocess: c6e,
    promise: o6e,
    record: J_e,
    set: e6e,
    strictObject: q_e,
    string: ute,
    symbol: B_e,
    transformer: iW,
    tuple: Q_e,
    undefined: F_e,
    union: K_e,
    unknown: H_e,
    void: W_e,
    NEVER: g6e,
    ZodIssueCode: et,
    quotelessJson: w_e,
    ZodError: xu
});
const ll = Oe.object({
    message: Oe.string()
});

function Pn(t) {
    return Oe.literal(Pt[t])
}
Oe.object({
    accessList: Oe.array(Oe.string()),
    blockHash: Oe.string().nullable(),
    blockNumber: Oe.string().nullable(),
    chainId: Oe.string(),
    from: Oe.string(),
    gas: Oe.string(),
    hash: Oe.string(),
    input: Oe.string().nullable(),
    maxFeePerGas: Oe.string(),
    maxPriorityFeePerGas: Oe.string(),
    nonce: Oe.string(),
    r: Oe.string(),
    s: Oe.string(),
    to: Oe.string(),
    transactionIndex: Oe.string().nullable(),
    type: Oe.string(),
    v: Oe.string(),
    value: Oe.string()
});
const m6e = Oe.object({
        chainId: Oe.number()
    }),
    y6e = Oe.object({
        email: Oe.string().email()
    }),
    w6e = Oe.object({
        otp: Oe.string()
    }),
    v6e = Oe.object({
        chainId: Oe.optional(Oe.number())
    }),
    b6e = Oe.object({
        email: Oe.string().email()
    }),
    _6e = Oe.object({
        themeMode: Oe.optional(Oe.enum(["light", "dark"])),
        themeVariables: Oe.optional(Oe.record(Oe.string(), Oe.string().or(Oe.number())))
    }),
    E6e = Oe.object({
        metadata: Oe.object({
            name: Oe.string(),
            description: Oe.string(),
            url: Oe.string(),
            icons: Oe.array(Oe.string())
        }).optional(),
        sdkVersion: Oe.string(),
        projectId: Oe.string()
    }),
    x6e = Oe.object({
        action: Oe.enum(["VERIFY_DEVICE", "VERIFY_OTP"])
    }),
    S6e = Oe.object({
        email: Oe.string().email(),
        address: Oe.string(),
        chainId: Oe.number()
    }),
    C6e = Oe.object({
        isConnected: Oe.boolean()
    }),
    A6e = Oe.object({
        chainId: Oe.number()
    }),
    T6e = Oe.object({
        chainId: Oe.number()
    }),
    I6e = Oe.object({
        email: Oe.string().email()
    }),
    R6e = Oe.any(),
    O6e = Oe.object({
        method: Oe.literal("personal_sign"),
        params: Oe.array(Oe.any())
    }),
    N6e = Oe.object({
        method: Oe.literal("eth_sendTransaction"),
        params: Oe.array(Oe.any())
    }),
    P6e = Oe.object({
        method: Oe.literal("eth_accounts")
    }),
    k6e = Oe.object({
        method: Oe.literal("eth_getBalance"),
        params: Oe.array(Oe.any())
    }),
    M6e = Oe.object({
        method: Oe.literal("eth_estimateGas"),
        params: Oe.array(Oe.any())
    }),
    D6e = Oe.object({
        method: Oe.literal("eth_gasPrice")
    }),
    $6e = Oe.object({
        method: Oe.literal("eth_signTypedData_v4"),
        params: Oe.array(Oe.any())
    }),
    L6e = Oe.object({
        method: Oe.literal("eth_getTransactionByHash"),
        params: Oe.array(Oe.any())
    }),
    B6e = Oe.object({
        method: Oe.literal("eth_blockNumber")
    }),
    F6e = Oe.object({
        method: Oe.literal("eth_chainId")
    }),
    sW = Oe.object({
        token: Oe.string()
    }),
    Mx = {
        appEvent: Oe.object({
            type: Pn("APP_SWITCH_NETWORK"),
            payload: m6e
        }).or(Oe.object({
            type: Pn("APP_CONNECT_EMAIL"),
            payload: y6e
        })).or(Oe.object({
            type: Pn("APP_CONNECT_DEVICE")
        })).or(Oe.object({
            type: Pn("APP_CONNECT_OTP"),
            payload: w6e
        })).or(Oe.object({
            type: Pn("APP_GET_USER"),
            payload: Oe.optional(v6e)
        })).or(Oe.object({
            type: Pn("APP_SIGN_OUT")
        })).or(Oe.object({
            type: Pn("APP_IS_CONNECTED"),
            payload: Oe.optional(sW)
        })).or(Oe.object({
            type: Pn("APP_GET_CHAIN_ID")
        })).or(Oe.object({
            type: Pn("APP_RPC_REQUEST"),
            payload: O6e.or(N6e).or(P6e).or(k6e).or(M6e).or(D6e).or($6e).or(B6e).or(F6e).or(L6e)
        })).or(Oe.object({
            type: Pn("APP_UPDATE_EMAIL"),
            payload: b6e
        })).or(Oe.object({
            type: Pn("APP_AWAIT_UPDATE_EMAIL")
        })).or(Oe.object({
            type: Pn("APP_SYNC_THEME"),
            payload: _6e
        })).or(Oe.object({
            type: Pn("APP_SYNC_DAPP_DATA"),
            payload: E6e
        })),
        frameEvent: Oe.object({
            type: Pn("FRAME_SWITCH_NETWORK_ERROR"),
            payload: ll
        }).or(Oe.object({
            type: Pn("FRAME_SWITCH_NETWORK_SUCCESS"),
            payload: T6e
        })).or(Oe.object({
            type: Pn("FRAME_CONNECT_EMAIL_ERROR"),
            payload: ll
        })).or(Oe.object({
            type: Pn("FRAME_CONNECT_EMAIL_SUCCESS"),
            payload: x6e
        })).or(Oe.object({
            type: Pn("FRAME_CONNECT_OTP_ERROR"),
            payload: ll
        })).or(Oe.object({
            type: Pn("FRAME_CONNECT_OTP_SUCCESS")
        })).or(Oe.object({
            type: Pn("FRAME_CONNECT_DEVICE_ERROR"),
            payload: ll
        })).or(Oe.object({
            type: Pn("FRAME_CONNECT_DEVICE_SUCCESS")
        })).or(Oe.object({
            type: Pn("FRAME_GET_USER_ERROR"),
            payload: ll
        })).or(Oe.object({
            type: Pn("FRAME_GET_USER_SUCCESS"),
            payload: S6e
        })).or(Oe.object({
            type: Pn("FRAME_SIGN_OUT_ERROR"),
            payload: ll
        })).or(Oe.object({
            type: Pn("FRAME_SIGN_OUT_SUCCESS")
        })).or(Oe.object({
            type: Pn("FRAME_IS_CONNECTED_ERROR"),
            payload: ll
        })).or(Oe.object({
            type: Pn("FRAME_IS_CONNECTED_SUCCESS"),
            payload: C6e
        })).or(Oe.object({
            type: Pn("FRAME_GET_CHAIN_ID_ERROR"),
            payload: ll
        })).or(Oe.object({
            type: Pn("FRAME_GET_CHAIN_ID_SUCCESS"),
            payload: A6e
        })).or(Oe.object({
            type: Pn("FRAME_RPC_REQUEST_ERROR"),
            payload: ll
        })).or(Oe.object({
            type: Pn("FRAME_RPC_REQUEST_SUCCESS"),
            payload: R6e
        })).or(Oe.object({
            type: Pn("FRAME_SESSION_UPDATE"),
            payload: sW
        })).or(Oe.object({
            type: Pn("FRAME_UPDATE_EMAIL_ERROR"),
            payload: ll
        })).or(Oe.object({
            type: Pn("FRAME_UPDATE_EMAIL_SUCCESS")
        })).or(Oe.object({
            type: Pn("FRAME_AWAIT_UPDATE_EMAIL_ERROR"),
            payload: ll
        })).or(Oe.object({
            type: Pn("FRAME_AWAIT_UPDATE_EMAIL_SUCCESS"),
            payload: I6e
        })).or(Oe.object({
            type: Pn("FRAME_SYNC_THEME_ERROR"),
            payload: ll
        })).or(Oe.object({
            type: Pn("FRAME_SYNC_THEME_SUCCESS")
        })).or(Oe.object({
            type: Pn("FRAME_SYNC_DAPP_DATA_ERROR"),
            payload: ll
        })).or(Oe.object({
            type: Pn("FRAME_SYNC_DAPP_DATA_SUCCESS")
        }))
    },
    dl = {
        set(t, e) {
            localStorage.setItem(`${Pt.STORAGE_KEY}${t}`, e)
        },
        get(t) {
            return localStorage.getItem(`${Pt.STORAGE_KEY}${t}`)
        },
        delete(t) {
            localStorage.removeItem(`${Pt.STORAGE_KEY}${t}`)
        }
    },
    U6e = ["ASIA/SHANGHAI", "ASIA/URUMQI", "ASIA/CHONGQING", "ASIA/HARBIN", "ASIA/KASHGAR", "ASIA/MACAU", "ASIA/HONG_KONG", "ASIA/MACAO", "ASIA/BEIJING", "ASIA/HARBIN"],
    Dx = 30 * 1e3,
    ev = {
        getBlockchainApiUrl() {
            try {
                const {
                    timeZone: t
                } = new Intl.DateTimeFormat().resolvedOptions(), e = t.toUpperCase();
                return U6e.includes(e) ? "https://rpc.walletconnect.org" : "https://rpc.walletconnect.com"
            } catch {
                return !1
            }
        },
        checkIfAllowedToTriggerEmail() {
            const t = dl.get(Pt.LAST_EMAIL_LOGIN_TIME);
            if (t) {
                const e = Date.now() - Number(t);
                if (e < Dx) {
                    const n = Math.ceil((Dx - e) / 1e3);
                    throw new Error(`Please try again after ${n} seconds`)
                }
            }
        },
        getTimeToNextEmailLogin() {
            const t = dl.get(Pt.LAST_EMAIL_LOGIN_TIME);
            if (t) {
                const e = Date.now() - Number(t);
                if (e < Dx) return Math.ceil((Dx - e) / 1e3)
            }
            return 0
        }
    };
class j6e {
    constructor(e, n = !1) {
        if (this.iframe = null, this.rpcUrl = ev.getBlockchainApiUrl(), this.events = {
                onFrameEvent: r => {
                    window.addEventListener("message", ({
                        data: i
                    }) => {
                        var o;
                        if (!((o = i.type) != null && o.includes(Pt.FRAME_EVENT_KEY))) return;
                        const s = Mx.frameEvent.parse(i);
                        r(s)
                    })
                },
                onAppEvent: r => {
                    window.addEventListener("message", ({
                        data: i
                    }) => {
                        var o;
                        if (!((o = i.type) != null && o.includes(Pt.APP_EVENT_KEY))) return;
                        const s = Mx.appEvent.parse(i);
                        r(s)
                    })
                },
                postAppEvent: r => {
                    var i;
                    if (!((i = this.iframe) != null && i.contentWindow)) throw new Error("W3mFrame: iframe is not set");
                    Mx.appEvent.parse(r), window.postMessage(r), this.iframe.contentWindow.postMessage(r, "*")
                },
                postFrameEvent: r => {
                    if (!parent) throw new Error("W3mFrame: parent is not set");
                    Mx.frameEvent.parse(r), parent.postMessage(r, "*")
                }
            }, this.projectId = e, this.frameLoadPromise = new Promise((r, i) => {
                this.frameLoadPromiseResolver = {
                    resolve: r,
                    reject: i
                }
            }), n) {
            this.frameLoadPromise = new Promise((i, s) => {
                this.frameLoadPromiseResolver = {
                    resolve: i,
                    reject: s
                }
            });
            const r = document.createElement("iframe");
            r.id = "w3m-iframe", r.src = `${Pt.SECURE_SITE_SDK}?projectId=${e}`, r.style.position = "fixed", r.style.zIndex = "999999", r.style.display = "none", r.style.opacity = "0", r.style.borderRadius = "clamp(0px, var(--wui-border-radius-l), 44px)", document.body.appendChild(r), this.iframe = r, this.iframe.onload = () => {
                var i;
                (i = this.frameLoadPromiseResolver) == null || i.resolve(void 0)
            }, this.iframe.onerror = () => {
                var i;
                (i = this.frameLoadPromiseResolver) == null || i.reject("Unable to load email login dependency")
            }
        }
    }
    get networks() {
        const e = [1, 5, 11155111, 10, 420, 42161, 421613, 137, 80001, 42220, 1313161554, 1313161555, 56, 97, 43114, 43113, 324, 280, 100, 8453, 84531, 7777777, 999].map(n => ({
            [n]: {
                rpcUrl: `${this.rpcUrl}/v1/?chainId=eip155:${n}&projectId=${this.projectId}`,
                chainId: n
            }
        }));
        return Object.assign({}, ...e)
    }
}
class H6e {
    constructor(e) {
        this.connectEmailResolver = void 0, this.connectDeviceResolver = void 0, this.connectOtpResolver = void 0, this.connectResolver = void 0, this.disconnectResolver = void 0, this.isConnectedResolver = void 0, this.getChainIdResolver = void 0, this.switchChainResolver = void 0, this.rpcRequestResolver = void 0, this.updateEmailResolver = void 0, this.awaitUpdateEmailResolver = void 0, this.syncThemeResolver = void 0, this.syncDappDataResolver = void 0, this.w3mFrame = new j6e(e, !0), this.w3mFrame.events.onFrameEvent(n => {
            switch (console.log(" received", n), n.type) {
                case Pt.FRAME_CONNECT_EMAIL_SUCCESS:
                    return this.onConnectEmailSuccess(n);
                case Pt.FRAME_CONNECT_EMAIL_ERROR:
                    return this.onConnectEmailError(n);
                case Pt.FRAME_CONNECT_DEVICE_SUCCESS:
                    return this.onConnectDeviceSuccess();
                case Pt.FRAME_CONNECT_DEVICE_ERROR:
                    return this.onConnectDeviceError(n);
                case Pt.FRAME_CONNECT_OTP_SUCCESS:
                    return this.onConnectOtpSuccess();
                case Pt.FRAME_CONNECT_OTP_ERROR:
                    return this.onConnectOtpError(n);
                case Pt.FRAME_GET_USER_SUCCESS:
                    return this.onConnectSuccess(n);
                case Pt.FRAME_GET_USER_ERROR:
                    return this.onConnectError(n);
                case Pt.FRAME_IS_CONNECTED_SUCCESS:
                    return this.onIsConnectedSuccess(n);
                case Pt.FRAME_IS_CONNECTED_ERROR:
                    return this.onIsConnectedError(n);
                case Pt.FRAME_GET_CHAIN_ID_SUCCESS:
                    return this.onGetChainIdSuccess(n);
                case Pt.FRAME_GET_CHAIN_ID_ERROR:
                    return this.onGetChainIdError(n);
                case Pt.FRAME_SIGN_OUT_SUCCESS:
                    return this.onSignOutSuccess();
                case Pt.FRAME_SIGN_OUT_ERROR:
                    return this.onSignOutError(n);
                case Pt.FRAME_SWITCH_NETWORK_SUCCESS:
                    return this.onSwitchChainSuccess(n);
                case Pt.FRAME_SWITCH_NETWORK_ERROR:
                    return this.onSwitchChainError(n);
                case Pt.FRAME_RPC_REQUEST_SUCCESS:
                    return this.onRpcRequestSuccess(n);
                case Pt.FRAME_RPC_REQUEST_ERROR:
                    return this.onRpcRequestError(n);
                case Pt.FRAME_SESSION_UPDATE:
                    return this.onSessionUpdate(n);
                case Pt.FRAME_UPDATE_EMAIL_SUCCESS:
                    return this.onUpdateEmailSuccess();
                case Pt.FRAME_UPDATE_EMAIL_ERROR:
                    return this.onUpdateEmailError(n);
                case Pt.FRAME_AWAIT_UPDATE_EMAIL_SUCCESS:
                    return this.onAwaitUpdateEmailSuccess(n);
                case Pt.FRAME_AWAIT_UPDATE_EMAIL_ERROR:
                    return this.onAwaitUpdateEmailError(n);
                case Pt.FRAME_SYNC_THEME_SUCCESS:
                    return this.onSyncThemeSuccess();
                case Pt.FRAME_SYNC_THEME_ERROR:
                    return this.onSyncThemeError(n);
                case Pt.FRAME_SYNC_DAPP_DATA_SUCCESS:
                    return this.onSyncDappDataSuccess();
                case Pt.FRAME_SYNC_DAPP_DATA_ERROR:
                    return this.onSyncDappDataError(n);
                default:
                    return null
            }
        })
    }
    getLoginEmailUsed() {
        return !!dl.get(Pt.EMAIL_LOGIN_USED_KEY)
    }
    getEmail() {
        return dl.get(Pt.EMAIL)
    }
    async connectEmail(e) {
        return await this.w3mFrame.frameLoadPromise, ev.checkIfAllowedToTriggerEmail(), this.w3mFrame.events.postAppEvent({
            type: Pt.APP_CONNECT_EMAIL,
            payload: e
        }), new Promise((n, r) => {
            this.connectEmailResolver = {
                resolve: n,
                reject: r
            }
        })
    }
    async connectDevice() {
        return await this.w3mFrame.frameLoadPromise, this.w3mFrame.events.postAppEvent({
            type: Pt.APP_CONNECT_DEVICE
        }), new Promise((e, n) => {
            this.connectDeviceResolver = {
                resolve: e,
                reject: n
            }
        })
    }
    async connectOtp(e) {
        return await this.w3mFrame.frameLoadPromise, this.w3mFrame.events.postAppEvent({
            type: Pt.APP_CONNECT_OTP,
            payload: e
        }), new Promise((n, r) => {
            this.connectOtpResolver = {
                resolve: n,
                reject: r
            }
        })
    }
    async isConnected() {
        return await this.w3mFrame.frameLoadPromise, this.w3mFrame.events.postAppEvent({
            type: Pt.APP_IS_CONNECTED,
            payload: void 0
        }), new Promise((e, n) => {
            this.isConnectedResolver = {
                resolve: e,
                reject: n
            }
        })
    }
    async getChainId() {
        return await this.w3mFrame.frameLoadPromise, this.w3mFrame.events.postAppEvent({
            type: Pt.APP_GET_CHAIN_ID
        }), new Promise((e, n) => {
            this.getChainIdResolver = {
                resolve: e,
                reject: n
            }
        })
    }
    async updateEmail(e) {
        return await this.w3mFrame.frameLoadPromise, ev.checkIfAllowedToTriggerEmail(), this.w3mFrame.events.postAppEvent({
            type: Pt.APP_UPDATE_EMAIL,
            payload: e
        }), new Promise((n, r) => {
            this.updateEmailResolver = {
                resolve: n,
                reject: r
            }
        })
    }
    async awaitUpdateEmail() {
        return await this.w3mFrame.frameLoadPromise, this.w3mFrame.events.postAppEvent({
            type: Pt.APP_AWAIT_UPDATE_EMAIL
        }), new Promise((e, n) => {
            this.awaitUpdateEmailResolver = {
                resolve: e,
                reject: n
            }
        })
    }
    async syncTheme(e) {
        return await this.w3mFrame.frameLoadPromise, this.w3mFrame.events.postAppEvent({
            type: Pt.APP_SYNC_THEME,
            payload: e
        }), new Promise((n, r) => {
            this.syncThemeResolver = {
                resolve: n,
                reject: r
            }
        })
    }
    async syncDappData(e) {
        return await this.w3mFrame.frameLoadPromise, this.w3mFrame.events.postAppEvent({
            type: Pt.APP_SYNC_DAPP_DATA,
            payload: e
        }), new Promise((n, r) => {
            this.syncDappDataResolver = {
                resolve: n,
                reject: r
            }
        })
    }
    async connect(e) {
        const n = (e == null ? void 0 : e.chainId) ? ? this.getLastUsedChainId() ? ? 1;
        return await this.w3mFrame.frameLoadPromise, this.w3mFrame.events.postAppEvent({
            type: Pt.APP_GET_USER,
            payload: {
                chainId: n
            }
        }), new Promise((r, i) => {
            this.connectResolver = {
                resolve: r,
                reject: i
            }
        })
    }
    async switchNetwork(e) {
        return await this.w3mFrame.frameLoadPromise, this.w3mFrame.events.postAppEvent({
            type: Pt.APP_SWITCH_NETWORK,
            payload: {
                chainId: e
            }
        }), new Promise((n, r) => {
            this.switchChainResolver = {
                resolve: n,
                reject: r
            }
        })
    }
    async disconnect() {
        return await this.w3mFrame.frameLoadPromise, this.w3mFrame.events.postAppEvent({
            type: Pt.APP_SIGN_OUT
        }), new Promise((e, n) => {
            this.disconnectResolver = {
                resolve: e,
                reject: n
            }
        })
    }
    async request(e) {
        return await this.w3mFrame.frameLoadPromise, ite.GET_CHAIN_ID === e.method ? this.getLastUsedChainId() : (this.w3mFrame.events.postAppEvent({
            type: Pt.APP_RPC_REQUEST,
            payload: e
        }), new Promise((n, r) => {
            this.rpcRequestResolver = {
                resolve: n,
                reject: r
            }
        }))
    }
    onRpcRequest(e) {
        this.w3mFrame.events.onAppEvent(n => {
            n.type.includes(Pt.RPC_METHOD_KEY) && e(n)
        })
    }
    onRpcResponse(e) {
        this.w3mFrame.events.onFrameEvent(n => {
            n.type.includes(Pt.RPC_METHOD_KEY) && e(n)
        })
    }
    onIsConnected(e) {
        this.w3mFrame.events.onFrameEvent(n => {
            n.type === Pt.FRAME_GET_USER_SUCCESS && e()
        })
    }
    onConnectEmailSuccess(e) {
        var n;
        (n = this.connectEmailResolver) == null || n.resolve(e.payload), this.setNewLastEmailLoginTime()
    }
    onConnectEmailError(e) {
        var n;
        (n = this.connectEmailResolver) == null || n.reject(e.payload.message)
    }
    onConnectDeviceSuccess() {
        var e;
        (e = this.connectDeviceResolver) == null || e.resolve(void 0)
    }
    onConnectDeviceError(e) {
        var n;
        (n = this.connectDeviceResolver) == null || n.reject(e.payload.message)
    }
    onConnectOtpSuccess() {
        var e;
        (e = this.connectOtpResolver) == null || e.resolve(void 0)
    }
    onConnectOtpError(e) {
        var n;
        (n = this.connectOtpResolver) == null || n.reject(e.payload.message)
    }
    onConnectSuccess(e) {
        var n;
        this.setEmailLoginSuccess(e.payload.email), this.setLastUsedChainId(e.payload.chainId), (n = this.connectResolver) == null || n.resolve(e.payload)
    }
    onConnectError(e) {
        var n;
        (n = this.connectResolver) == null || n.reject(e.payload.message)
    }
    onIsConnectedSuccess(e) {
        var n;
        e.payload.isConnected || this.deleteEmailLoginCache(), (n = this.isConnectedResolver) == null || n.resolve(e.payload)
    }
    onIsConnectedError(e) {
        var n;
        (n = this.isConnectedResolver) == null || n.reject(e.payload.message)
    }
    onGetChainIdSuccess(e) {
        var n;
        this.setLastUsedChainId(e.payload.chainId), (n = this.getChainIdResolver) == null || n.resolve(e.payload)
    }
    onGetChainIdError(e) {
        var n;
        (n = this.getChainIdResolver) == null || n.reject(e.payload.message)
    }
    onSignOutSuccess() {
        var e;
        (e = this.disconnectResolver) == null || e.resolve(void 0), this.deleteEmailLoginCache()
    }
    onSignOutError(e) {
        var n;
        (n = this.disconnectResolver) == null || n.reject(e.payload.message)
    }
    onSwitchChainSuccess(e) {
        var n;
        this.setLastUsedChainId(e.payload.chainId), (n = this.switchChainResolver) == null || n.resolve(e.payload)
    }
    onSwitchChainError(e) {
        var n;
        (n = this.switchChainResolver) == null || n.reject(e.payload.message)
    }
    onRpcRequestSuccess(e) {
        var n;
        (n = this.rpcRequestResolver) == null || n.resolve(e.payload)
    }
    onRpcRequestError(e) {
        var n;
        (n = this.rpcRequestResolver) == null || n.reject(e.payload.message)
    }
    onSessionUpdate(e) {}
    onUpdateEmailSuccess() {
        var e;
        (e = this.updateEmailResolver) == null || e.resolve(void 0), this.setNewLastEmailLoginTime()
    }
    onUpdateEmailError(e) {
        var n;
        (n = this.updateEmailResolver) == null || n.reject(e.payload.message)
    }
    onAwaitUpdateEmailSuccess(e) {
        var n;
        this.setEmailLoginSuccess(e.payload.email), (n = this.awaitUpdateEmailResolver) == null || n.resolve(e.payload)
    }
    onAwaitUpdateEmailError(e) {
        var n;
        (n = this.awaitUpdateEmailResolver) == null || n.reject(e.payload.message)
    }
    onSyncThemeSuccess() {
        var e;
        (e = this.syncThemeResolver) == null || e.resolve(void 0)
    }
    onSyncThemeError(e) {
        var n;
        (n = this.syncThemeResolver) == null || n.reject(e.payload.message)
    }
    onSyncDappDataSuccess() {
        var e;
        (e = this.syncDappDataResolver) == null || e.resolve(void 0)
    }
    onSyncDappDataError(e) {
        var n;
        (n = this.syncDappDataResolver) == null || n.reject(e.payload.message)
    }
    setNewLastEmailLoginTime() {
        dl.set(Pt.LAST_EMAIL_LOGIN_TIME, Date.now().toString())
    }
    setEmailLoginSuccess(e) {
        dl.set(Pt.EMAIL, e), dl.set(Pt.EMAIL_LOGIN_USED_KEY, "true"), dl.delete(Pt.LAST_EMAIL_LOGIN_TIME)
    }
    deleteEmailLoginCache() {
        dl.delete(Pt.EMAIL_LOGIN_USED_KEY), dl.delete(Pt.EMAIL), dl.delete(Pt.LAST_USED_CHAIN_KEY)
    }
    setLastUsedChainId(e) {
        dl.set(Pt.LAST_USED_CHAIN_KEY, `${e}`)
    }
    getLastUsedChainId() {
        return Number(dl.get(Pt.LAST_USED_CHAIN_KEY))
    }
}
var OT = function(t, e, n, r) {
    var i = arguments.length,
        s = i < 3 ? e : r === null ? r = Object.getOwnPropertyDescriptor(e, n) : r,
        o;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function") s = Reflect.decorate(t, e, n, r);
    else
        for (var a = t.length - 1; a >= 0; a--)(o = t[a]) && (s = (i < 3 ? o(s) : i > 3 ? o(e, n, s) : o(e, n)) || s);
    return i > 3 && s && Object.defineProperty(e, n, s), s
};
const z6e = 6;
let zb = class extends Dn {
    constructor() {
        var e;
        super(...arguments), this.email = (e = Dt.state.data) == null ? void 0 : e.email, this.emailConnector = Wr.getEmailConnector(), this.loading = !1, this.timeoutTimeLeft = ev.getTimeToNextEmailLogin(), this.error = "", this.otp = ""
    }
    firstUpdated() {
        this.startOTPTimeout()
    }
    disconnectedCallback() {
        clearTimeout(this.OTPTimeout)
    }
    render() {
        if (!this.email) throw new Error("w3m-email-verify-otp-view: No email provided");
        const e = !!this.timeoutTimeLeft;
        return $e `
      <wui-flex
        flexDirection="column"
        alignItems="center"
        .padding=${["l","0","l","0"]}
        gap="l"
      >
        <wui-flex flexDirection="column" alignItems="center">
          <wui-text variant="paragraph-400" color="fg-100"> Enter the code we sent to </wui-text>
          <wui-text variant="paragraph-500" color="fg-100">${this.email}</wui-text>
        </wui-flex>

        <wui-text variant="small-400" color="fg-200">The code expires in 20 minutes</wui-text>

        ${this.loading?$e`<wui-loading-spinner size="xl" color="accent-100"></wui-loading-spinner>`:$e` <wui-flex flexDirection="column" alignItems="center" gap="xs">
              <wui-otp
                dissabled
                length="6"
                @inputChange=${this.onOtpInputChange.bind(this)}
                .otp=${this.otp}
              ></wui-otp>
              ${this.error?$e`<wui-text variant="small-400" color="error-100"
                    >${this.error}. Try Again</wui-text
                  >`:null}
            </wui-flex>`}

        <wui-flex alignItems="center">
          <wui-text variant="small-400" color="fg-200">Didn't receive it?</wui-text>
          <wui-link @click=${this.onResendCode.bind(this)} .disabled=${e}>
            Resend ${e?`in ${this.timeoutTimeLeft}s`:"Code"}
          </wui-link>
        </wui-flex>
      </wui-flex>
    `
    }
    startOTPTimeout() {
        this.timeoutTimeLeft = ev.getTimeToNextEmailLogin(), this.OTPTimeout = setInterval(() => {
            this.timeoutTimeLeft > 0 ? this.timeoutTimeLeft = ev.getTimeToNextEmailLogin() : clearInterval(this.OTPTimeout)
        }, 1e3)
    }
    async onOtpInputChange(e) {
        try {
            this.loading || (this.otp = e.detail, this.emailConnector && this.otp.length === z6e && (this.loading = !0, await this.emailConnector.provider.connectOtp({
                otp: this.otp
            }), wn.sendEvent({
                type: "track",
                event: "EMAIL_VERIFICATION_CODE_PASS"
            }), await ir.connectExternal(this.emailConnector), Vr.close(), wn.sendEvent({
                type: "track",
                event: "CONNECT_SUCCESS",
                properties: {
                    method: "email"
                }
            })))
        } catch (n) {
            wn.sendEvent({
                type: "track",
                event: "EMAIL_VERIFICATION_CODE_FAIL"
            }), this.error = Yt.parseError(n), this.loading = !1
        }
    }
    async onResendCode() {
        try {
            if (!this.loading && !this.timeoutTimeLeft) {
                this.error = "", this.otp = "";
                const e = Wr.getEmailConnector();
                if (!e || !this.email) throw new Error("w3m-email-login-widget: Unable to resend email");
                this.loading = !0, await e.provider.connectEmail({
                    email: this.email
                }), wn.sendEvent({
                    type: "track",
                    event: "EMAIL_VERIFICATION_CODE_SENT"
                }), this.startOTPTimeout(), qi.showSuccess("Code email resent")
            }
        } catch (e) {
            qi.showError(e)
        } finally {
            this.loading = !1
        }
    }
};
zb.styles = y_e;
OT([Nt()], zb.prototype, "loading", void 0);
OT([Nt()], zb.prototype, "timeoutTimeLeft", void 0);
OT([Nt()], zb.prototype, "error", void 0);
zb = OT([Qe("w3m-email-verify-otp-view")], zb);
const W6e = bi `
  wui-icon-box {
    height: var(--wui-icon-box-size-xl);
    width: var(--wui-icon-box-size-xl);
  }
`;
var hte = function(t, e, n, r) {
    var i = arguments.length,
        s = i < 3 ? e : r === null ? r = Object.getOwnPropertyDescriptor(e, n) : r,
        o;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function") s = Reflect.decorate(t, e, n, r);
    else
        for (var a = t.length - 1; a >= 0; a--)(o = t[a]) && (s = (i < 3 ? o(s) : i > 3 ? o(e, n, s) : o(e, n)) || s);
    return i > 3 && s && Object.defineProperty(e, n, s), s
};
let wC = class extends Dn {
    constructor() {
        var e;
        super(), this.email = (e = Dt.state.data) == null ? void 0 : e.email, this.emailConnector = Wr.getEmailConnector(), this.loading = !1, this.listenForDeviceApproval()
    }
    render() {
        if (!this.email) throw new Error("w3m-email-verify-device-view: No email provided");
        if (!this.emailConnector) throw new Error("w3m-email-verify-device-view: No email connector provided");
        return $e `
      <wui-flex
        flexDirection="column"
        alignItems="center"
        .padding=${["xxl","s","xxl","s"]}
        gap="l"
      >
        <wui-icon-box
          size="xl"
          iconcolor="accent-100"
          backgroundcolor="accent-100"
          icon="verify"
          background="opaque"
        ></wui-icon-box>

        <wui-flex flexDirection="column" alignItems="center" gap="s">
          <wui-flex flexDirection="column" alignItems="center">
            <wui-text variant="paragraph-400" color="fg-100">
              Approve the login link we sent to
            </wui-text>
            <wui-text variant="paragraph-400" color="fg-100"><b>${this.email}</b></wui-text>
          </wui-flex>

          <wui-text variant="small-400" color="fg-200" align="center">
            The code expires in 20 minutes
          </wui-text>

          <wui-flex alignItems="center" id="w3m-resend-section">
            <wui-text variant="small-400" color="fg-100" align="center">
              Didn't receive it?
            </wui-text>
            <wui-link @click=${this.onResendCode.bind(this)} .disabled=${this.loading}>
              Resend email
            </wui-link>
          </wui-flex>
        </wui-flex>
      </wui-flex>
    `
    }
    async listenForDeviceApproval() {
        this.emailConnector && (await this.emailConnector.provider.connectDevice(), wn.sendEvent({
            type: "track",
            event: "DEVICE_REGISTERED_FOR_EMAIL"
        }), wn.sendEvent({
            type: "track",
            event: "EMAIL_VERIFICATION_CODE_SENT"
        }), Dt.replace("EmailVerifyOtp", {
            email: this.email
        }))
    }
    async onResendCode() {
        try {
            if (!this.loading) {
                if (!this.emailConnector || !this.email) throw new Error("w3m-email-login-widget: Unable to resend email");
                this.loading = !0, await this.emailConnector.provider.connectEmail({
                    email: this.email
                }), qi.showSuccess("Code email resent")
            }
        } catch (e) {
            qi.showError(e)
        } finally {
            this.loading = !1
        }
    }
};
wC.styles = W6e;
hte([Nt()], wC.prototype, "loading", void 0);
wC = hte([Qe("w3m-email-verify-device-view")], wC);
const V6e = bi `
  div {
    width: 100%;
    height: 400px;
  }

  [data-ready='false'] {
    transform: scale(1.05);
  }

  @media (max-width: 430px) {
    [data-ready='false'] {
      transform: translateY(-50px);
    }
  }
`;
var pte = function(t, e, n, r) {
    var i = arguments.length,
        s = i < 3 ? e : r === null ? r = Object.getOwnPropertyDescriptor(e, n) : r,
        o;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function") s = Reflect.decorate(t, e, n, r);
    else
        for (var a = t.length - 1; a >= 0; a--)(o = t[a]) && (s = (i < 3 ? o(s) : i > 3 ? o(e, n, s) : o(e, n)) || s);
    return i > 3 && s && Object.defineProperty(e, n, s), s
};
let vC = class extends Dn {
    constructor() {
        super(), this.bodyObserver = void 0, this.unsubscribe = [], this.iframe = document.getElementById("w3m-iframe"), this.ready = !1, this.unsubscribe.push(Vr.subscribeKey("open", e => {
            e || this.onHideIframe()
        }))
    }
    disconnectedCallback() {
        var e;
        this.unsubscribe.forEach(n => n()), (e = this.bodyObserver) == null || e.unobserve(window.document.body)
    }
    firstUpdated() {
        this.iframe.style.display = "block";
        const n = this.renderRoot.querySelector("div");
        this.bodyObserver = new ResizeObserver(() => {
            const i = (n == null ? void 0 : n.getBoundingClientRect()) ? ? {
                left: 0,
                top: 0,
                width: 0,
                height: 0
            };
            this.iframe.style.width = `${i.width}px`, this.iframe.style.height = `${i.height-10}px`, this.iframe.style.left = `${i.left}px`, this.iframe.style.top = `${i.top+10/2}px`, this.ready = !0
        }), this.bodyObserver.observe(window.document.body)
    }
    render() {
        return this.ready && this.onShowIframe(), $e `<div data-ready=${this.ready}></div>`
    }
    onShowIframe() {
        const e = window.innerWidth <= 430;
        this.iframe.animate([{
            opacity: 0,
            transform: e ? "translateY(50px)" : "scale(.95)"
        }, {
            opacity: 1,
            transform: e ? "translateY(0)" : "scale(1)"
        }], {
            duration: 200,
            easing: "ease",
            fill: "forwards",
            delay: 300
        })
    }
    async onHideIframe() {
        await this.iframe.animate([{
            opacity: 1
        }, {
            opacity: 0
        }], {
            duration: 200,
            easing: "ease",
            fill: "forwards"
        }).finished, this.iframe.style.display = "none"
    }
};
vC.styles = V6e;
pte([Nt()], vC.prototype, "ready", void 0);
vC = pte([Qe("w3m-approve-transaction-view")], vC);
var G6e = function(t, e, n, r) {
    var i = arguments.length,
        s = i < 3 ? e : r === null ? r = Object.getOwnPropertyDescriptor(e, n) : r,
        o;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function") s = Reflect.decorate(t, e, n, r);
    else
        for (var a = t.length - 1; a >= 0; a--)(o = t[a]) && (s = (i < 3 ? o(s) : i > 3 ? o(e, n, s) : o(e, n)) || s);
    return i > 3 && s && Object.defineProperty(e, n, s), s
};
let oW = class extends Dn {
    render() {
        return $e `
      <wui-flex flexDirection="column" alignItems="center" gap="xl" padding="xl">
        <wui-text variant="paragraph-400" color="fg-100">Follow the instructions on</wui-text>
        <wui-chip
          icon="externalLink"
          variant="fill"
          href=${ah.SECURE_SITE_DASHBOARD}
          imageSrc=${ah.SECURE_SITE_FAVICON}
        >
        </wui-chip>
        <wui-text variant="small-400" color="fg-200">
          You will have to reconnect for security reasons
        </wui-text>
      </wui-flex>
    `
    }
};
oW = G6e([Qe("w3m-upgrade-wallet-view")], oW);
/**
 * @license
 * Copyright 2020 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const q6e = t => t.strings === void 0;
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const K6e = {
        ATTRIBUTE: 1,
        CHILD: 2,
        PROPERTY: 3,
        BOOLEAN_ATTRIBUTE: 4,
        EVENT: 5,
        ELEMENT: 6
    },
    Y6e = t => (...e) => ({
        _$litDirective$: t,
        values: e
    });
let Z6e = class {
    constructor(e) {}
    get _$AU() {
        return this._$AM._$AU
    }
    _$AT(e, n, r) {
        this.t = e, this._$AM = n, this.i = r
    }
    _$AS(e, n) {
        return this.update(e, n)
    }
    update(e, n) {
        return this.render(...n)
    }
};
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const H3 = (t, e) => {
        var r;
        const n = t._$AN;
        if (n === void 0) return !1;
        for (const i of n)(r = i._$AO) == null || r.call(i, e, !1), H3(i, e);
        return !0
    },
    bC = t => {
        let e, n;
        do {
            if ((e = t._$AM) === void 0) break;
            n = e._$AN, n.delete(t), t = e
        } while ((n == null ? void 0 : n.size) === 0)
    },
    gte = t => {
        for (let e; e = t._$AM; t = e) {
            let n = e._$AN;
            if (n === void 0) e._$AN = n = new Set;
            else if (n.has(t)) break;
            n.add(t), X6e(e)
        }
    };

function Q6e(t) {
    this._$AN !== void 0 ? (bC(this), this._$AM = t, gte(this)) : this._$AM = t
}

function J6e(t, e = !1, n = 0) {
    const r = this._$AH,
        i = this._$AN;
    if (i !== void 0 && i.size !== 0)
        if (e)
            if (Array.isArray(r))
                for (let s = n; s < r.length; s++) H3(r[s], !1), bC(r[s]);
            else r != null && (H3(r, !1), bC(r));
    else H3(this, t)
}
const X6e = t => {
    t.type == K6e.CHILD && (t._$AP ? ? (t._$AP = J6e), t._$AQ ? ? (t._$AQ = Q6e))
};
let eEe = class extends Z6e {
    constructor() {
        super(...arguments), this._$AN = void 0
    }
    _$AT(e, n, r) {
        super._$AT(e, n, r), gte(this), this.isConnected = e._$AU
    }
    _$AO(e, n = !0) {
        var r, i;
        e !== this.isConnected && (this.isConnected = e, e ? (r = this.reconnected) == null || r.call(this) : (i = this.disconnected) == null || i.call(this)), n && (H3(this, e), bC(this))
    }
    setValue(e) {
        if (q6e(this.t)) this.t._$AI(e, this);
        else {
            const n = [...this.t._$AH];
            n[this.i] = e, this.t._$AI(n, this, 0)
        }
    }
    disconnected() {}
    reconnected() {}
};
/**
 * @license
 * Copyright 2020 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const mte = () => new tEe;
let tEe = class {};
const GR = new WeakMap,
    yte = Y6e(class extends eEe {
        render(t) {
            return as
        }
        update(t, [e]) {
            var r;
            const n = e !== this.Y;
            return n && this.Y !== void 0 && this.rt(void 0), (n || this.lt !== this.ct) && (this.Y = e, this.ht = (r = t.options) == null ? void 0 : r.host, this.rt(this.ct = t.element)), as
        }
        rt(t) {
            if (this.isConnected || (t = void 0), typeof this.Y == "function") {
                const e = this.ht ? ? globalThis;
                let n = GR.get(e);
                n === void 0 && (n = new WeakMap, GR.set(e, n)), n.get(this.Y) !== void 0 && this.Y.call(this.ht, void 0), n.set(this.Y, t), t !== void 0 && this.Y.call(this.ht, t)
            } else this.Y.value = t
        }
        get lt() {
            var t, e;
            return typeof this.Y == "function" ? (t = GR.get(this.ht ? ? globalThis)) == null ? void 0 : t.get(this.Y) : (e = this.Y) == null ? void 0 : e.value
        }
        disconnected() {
            this.lt === this.ct && this.rt(void 0)
        }
        reconnected() {
            this.rt(this.ct)
        }
    }),
    nEe = bi `
  wui-email-input {
    width: 100%;
  }

  form {
    width: 100%;
    display: block;
    position: relative;
  }
`;
var Q$ = function(t, e, n, r) {
    var i = arguments.length,
        s = i < 3 ? e : r === null ? r = Object.getOwnPropertyDescriptor(e, n) : r,
        o;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function") s = Reflect.decorate(t, e, n, r);
    else
        for (var a = t.length - 1; a >= 0; a--)(o = t[a]) && (s = (i < 3 ? o(s) : i > 3 ? o(e, n, s) : o(e, n)) || s);
    return i > 3 && s && Object.defineProperty(e, n, s), s
};
let j_ = class extends Dn {
    constructor() {
        var e;
        super(...arguments), this.formRef = mte(), this.initialValue = ((e = Dt.state.data) == null ? void 0 : e.email) ? ? "", this.email = "", this.loading = !1
    }
    firstUpdated() {
        var e;
        (e = this.formRef.value) == null || e.addEventListener("keydown", n => {
            n.key === "Enter" && this.onSubmitEmail(n)
        })
    }
    render() {
        const e = !this.loading && this.email.length > 3 && this.email !== this.initialValue;
        return $e `
      <wui-flex flexDirection="column" padding="m" gap="m">
        <form ${yte(this.formRef)} @submit=${this.onSubmitEmail.bind(this)}>
          <wui-email-input
            value=${this.initialValue}
            .disabled=${this.loading}
            @inputChange=${this.onEmailInputChange.bind(this)}
          >
          </wui-email-input>
          <input type="submit" hidden />
        </form>

        <wui-flex gap="s">
          <wui-button size="md" variant="shade" fullWidth @click=${Dt.goBack}>
            Cancel
          </wui-button>

          <wui-button
            size="md"
            variant="fill"
            fullWidth
            @click=${this.onSubmitEmail.bind(this)}
            .disabled=${!e}
            .loading=${this.loading}
          >
            Save
          </wui-button>
        </wui-flex>
      </wui-flex>
    `
    }
    onEmailInputChange(e) {
        this.email = e.detail
    }
    async onSubmitEmail(e) {
        try {
            if (this.loading) return;
            this.loading = !0, e.preventDefault();
            const n = Wr.getEmailConnector();
            if (!n) throw new Error("w3m-update-email-wallet: Email connector not found");
            await n.provider.updateEmail({
                email: this.email
            }), wn.sendEvent({
                type: "track",
                event: "EMAIL_EDIT"
            }), Dt.replace("UpdateEmailWalletWaiting", {
                email: this.email
            })
        } catch (n) {
            qi.showError(n), this.loading = !1
        }
    }
};
j_.styles = nEe;
Q$([Nt()], j_.prototype, "email", void 0);
Q$([Nt()], j_.prototype, "loading", void 0);
j_ = Q$([Qe("w3m-update-email-wallet-view")], j_);
const rEe = bi `
  wui-icon-box {
    height: var(--wui-icon-box-size-xl);
    width: var(--wui-icon-box-size-xl);
  }
`;
var wte = function(t, e, n, r) {
    var i = arguments.length,
        s = i < 3 ? e : r === null ? r = Object.getOwnPropertyDescriptor(e, n) : r,
        o;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function") s = Reflect.decorate(t, e, n, r);
    else
        for (var a = t.length - 1; a >= 0; a--)(o = t[a]) && (s = (i < 3 ? o(s) : i > 3 ? o(e, n, s) : o(e, n)) || s);
    return i > 3 && s && Object.defineProperty(e, n, s), s
};
let _C = class extends Dn {
    constructor() {
        var e;
        super(), this.email = (e = Dt.state.data) == null ? void 0 : e.email, this.emailConnector = Wr.getEmailConnector(), this.loading = !1, this.listenForEmailUpdateApproval()
    }
    render() {
        if (!this.email) throw new Error("w3m-update-email-wallet-waiting-view: No email provided");
        if (!this.emailConnector) throw new Error("w3m-update-email-wallet-waiting-view: No email connector provided");
        return $e `
      <wui-flex
        flexDirection="column"
        alignItems="center"
        .padding=${["xxl","s","xxl","s"]}
        gap="l"
      >
        <wui-icon-box
          size="xl"
          iconcolor="accent-100"
          backgroundcolor="accent-100"
          icon="mail"
          background="opaque"
        ></wui-icon-box>

        <wui-flex flexDirection="column" alignItems="center" gap="s">
          <wui-flex flexDirection="column" alignItems="center">
            <wui-text variant="paragraph-400" color="fg-100">
              Approve verification link we sent to
            </wui-text>
            <wui-text variant="paragraph-400" color="fg-100">${this.email}</wui-text>
          </wui-flex>

          <wui-text variant="small-400" color="fg-200" align="center">
            You will receive an approval request on your former mail to confirm the new one
          </wui-text>

          <wui-flex alignItems="center" id="w3m-resend-section">
            <wui-text variant="small-400" color="fg-100" align="center">
              Didn't receive it?
            </wui-text>
            <wui-link @click=${this.onResendCode.bind(this)} .disabled=${this.loading}>
              Resend email
            </wui-link>
          </wui-flex>
        </wui-flex>
      </wui-flex>
    `
    }
    async listenForEmailUpdateApproval() {
        this.emailConnector && (await this.emailConnector.provider.awaitUpdateEmail(), Dt.replace("Account"), qi.showSuccess("Email updated"))
    }
    async onResendCode() {
        try {
            if (!this.loading) {
                if (!this.emailConnector || !this.email) throw new Error("w3m-update-email-wallet-waiting-view: Unable to resend email");
                this.loading = !0, await this.emailConnector.provider.updateEmail({
                    email: this.email
                }), this.listenForEmailUpdateApproval(), qi.showSuccess("Code email resent")
            }
        } catch (e) {
            qi.showError(e)
        } finally {
            this.loading = !1
        }
    }
};
_C.styles = rEe;
wte([Nt()], _C.prototype, "loading", void 0);
_C = wte([Qe("w3m-update-email-wallet-waiting-view")], _C);
const iEe = bi `
  wui-grid {
    max-height: clamp(360px, 400px, 80vh);
    overflow: scroll;
    scrollbar-width: none;
    grid-auto-rows: min-content;
    grid-template-columns: repeat(auto-fill, 76px);
  }

  @media (max-width: 435px) {
    wui-grid {
      grid-template-columns: repeat(auto-fill, 77px);
    }
  }

  wui-grid[data-scroll='false'] {
    overflow: hidden;
  }

  wui-grid::-webkit-scrollbar {
    display: none;
  }

  wui-loading-spinner {
    padding-top: var(--wui-spacing-l);
    padding-bottom: var(--wui-spacing-l);
    justify-content: center;
    grid-column: 1 / span 4;
  }
`;

function vte(t) {
    const {
        connectors: e
    } = Wr.state, n = e.filter(s => s.type === "ANNOUNCED").reduce((s, o) => {
        var a;
        return (a = o.info) != null && a.rdns && (s[o.info.rdns] = !0), s
    }, {});
    return t.map(s => ({ ...s,
        installed: !!s.rdns && !!n[s.rdns ? ? ""]
    })).sort((s, o) => Number(o.installed) - Number(s.installed))
}
var mE = function(t, e, n, r) {
    var i = arguments.length,
        s = i < 3 ? e : r === null ? r = Object.getOwnPropertyDescriptor(e, n) : r,
        o;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function") s = Reflect.decorate(t, e, n, r);
    else
        for (var a = t.length - 1; a >= 0; a--)(o = t[a]) && (s = (i < 3 ? o(s) : i > 3 ? o(e, n, s) : o(e, n)) || s);
    return i > 3 && s && Object.defineProperty(e, n, s), s
};
const aW = "local-paginator";
let Om = class extends Dn {
    constructor() {
        super(), this.unsubscribe = [], this.paginationObserver = void 0, this.initial = !Vn.state.wallets.length, this.wallets = Vn.state.wallets, this.recommended = Vn.state.recommended, this.featured = Vn.state.featured, this.unsubscribe.push(Vn.subscribeKey("wallets", e => this.wallets = e), Vn.subscribeKey("recommended", e => this.recommended = e), Vn.subscribeKey("featured", e => this.featured = e))
    }
    firstUpdated() {
        this.initialFetch(), this.createPaginationObserver()
    }
    disconnectedCallback() {
        var e;
        this.unsubscribe.forEach(n => n()), (e = this.paginationObserver) == null || e.disconnect()
    }
    render() {
        return $e `
      <wui-grid
        data-scroll=${!this.initial}
        .padding=${["0","s","s","s"]}
        columnGap="xxs"
        rowGap="l"
        justifyContent="space-between"
      >
        ${this.initial?this.shimmerTemplate(16):this.walletsTemplate()}
        ${this.paginationLoaderTemplate()}
      </wui-grid>
    `
    }
    async initialFetch() {
        var n;
        const e = (n = this.shadowRoot) == null ? void 0 : n.querySelector("wui-grid");
        this.initial && e && (await Vn.fetchWallets({
            page: 1
        }), await e.animate([{
            opacity: 1
        }, {
            opacity: 0
        }], {
            duration: 200,
            fill: "forwards",
            easing: "ease"
        }).finished, this.initial = !1, e.animate([{
            opacity: 0
        }, {
            opacity: 1
        }], {
            duration: 200,
            fill: "forwards",
            easing: "ease"
        }))
    }
    shimmerTemplate(e, n) {
        return [...Array(e)].map(() => $e `
        <wui-card-select-loader type="wallet" id=${pr(n)}></wui-card-select-loader>
      `)
    }
    walletsTemplate() {
        const e = [...this.featured, ...this.recommended, ...this.wallets];
        return vte(e).map(r => $e `
        <wui-card-select
          imageSrc=${pr(Wi.getWalletImage(r))}
          type="wallet"
          name=${r.name}
          @click=${()=>this.onConnectWallet(r)}
          .installed=${r.installed}
        ></wui-card-select>
      `)
    }
    paginationLoaderTemplate() {
        const {
            wallets: e,
            recommended: n,
            featured: r,
            count: i
        } = Vn.state, s = window.innerWidth < 352 ? 3 : 4, o = e.length + n.length;
        let l = Math.ceil(o / s) * s - o + s;
        return l -= e.length ? r.length % s : 0, i === 0 && r.length > 0 ? null : i === 0 || [...r, ...e, ...n].length < i ? this.shimmerTemplate(l, aW) : null
    }
    createPaginationObserver() {
        var n;
        const e = (n = this.shadowRoot) == null ? void 0 : n.querySelector(`#${aW}`);
        e && (this.paginationObserver = new IntersectionObserver(([r]) => {
            if (r != null && r.isIntersecting && !this.initial) {
                const {
                    page: i,
                    count: s,
                    wallets: o
                } = Vn.state;
                o.length < s && Vn.fetchWallets({
                    page: i + 1
                })
            }
        }), this.paginationObserver.observe(e))
    }
    onConnectWallet(e) {
        const {
            connectors: n
        } = Wr.state, r = n.find(({
            explorerId: i
        }) => i === e.id);
        r ? Dt.push("ConnectingExternal", {
            connector: r
        }) : Dt.push("ConnectingWalletConnect", {
            wallet: e
        })
    }
};
Om.styles = iEe;
mE([Nt()], Om.prototype, "initial", void 0);
mE([Nt()], Om.prototype, "wallets", void 0);
mE([Nt()], Om.prototype, "recommended", void 0);
mE([Nt()], Om.prototype, "featured", void 0);
Om = mE([Qe("w3m-all-wallets-list")], Om);
const sEe = bi `
  wui-grid,
  wui-loading-spinner,
  wui-flex {
    height: 360px;
  }

  wui-grid {
    overflow: scroll;
    scrollbar-width: none;
    grid-auto-rows: min-content;
  }

  wui-grid[data-scroll='false'] {
    overflow: hidden;
  }

  wui-grid::-webkit-scrollbar {
    display: none;
  }

  wui-loading-spinner {
    justify-content: center;
    align-items: center;
  }
`;
var J$ = function(t, e, n, r) {
    var i = arguments.length,
        s = i < 3 ? e : r === null ? r = Object.getOwnPropertyDescriptor(e, n) : r,
        o;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function") s = Reflect.decorate(t, e, n, r);
    else
        for (var a = t.length - 1; a >= 0; a--)(o = t[a]) && (s = (i < 3 ? o(s) : i > 3 ? o(e, n, s) : o(e, n)) || s);
    return i > 3 && s && Object.defineProperty(e, n, s), s
};
let H_ = class extends Dn {
    constructor() {
        super(...arguments), this.prevQuery = "", this.loading = !0, this.query = ""
    }
    render() {
        return this.onSearch(), this.loading ? $e `<wui-loading-spinner color="accent-100"></wui-loading-spinner>` : this.walletsTemplate()
    }
    async onSearch() {
        this.query !== this.prevQuery && (this.prevQuery = this.query, this.loading = !0, await Vn.searchWallet({
            search: this.query
        }), this.loading = !1)
    }
    walletsTemplate() {
        const {
            search: e
        } = Vn.state, n = vte(e);
        return e.length ? $e `
      <wui-grid
        .padding=${["0","s","s","s"]}
        gridTemplateColumns="repeat(4, 1fr)"
        rowGap="l"
        columnGap="xs"
      >
        ${n.map(r=>$e`
            <wui-card-select
              imageSrc=${pr(Wi.getWalletImage(r))}
              type="wallet"
              name=${r.name}
              @click=${()=>this.onConnectWallet(r)}
              .installed=${r.installed}
            ></wui-card-select>
          `)}
      </wui-grid>
    ` : $e `
        <wui-flex justifyContent="center" alignItems="center" gap="s" flexDirection="column">
          <wui-icon-box
            size="lg"
            iconColor="fg-200"
            backgroundColor="fg-300"
            icon="wallet"
            background="transparent"
          ></wui-icon-box>
          <wui-text color="fg-200" variant="paragraph-500">No Wallet found</wui-text>
        </wui-flex>
      `
    }
    onConnectWallet(e) {
        const {
            connectors: n
        } = Wr.state, r = n.find(({
            explorerId: i
        }) => i === e.id);
        r ? Dt.push("ConnectingExternal", {
            connector: r
        }) : Dt.push("ConnectingWalletConnect", {
            wallet: e
        })
    }
};
H_.styles = sEe;
J$([Nt()], H_.prototype, "loading", void 0);
J$([$i()], H_.prototype, "query", void 0);
H_ = J$([Qe("w3m-all-wallets-search")], H_);
var NT = function(t, e, n, r) {
    var i = arguments.length,
        s = i < 3 ? e : r === null ? r = Object.getOwnPropertyDescriptor(e, n) : r,
        o;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function") s = Reflect.decorate(t, e, n, r);
    else
        for (var a = t.length - 1; a >= 0; a--)(o = t[a]) && (s = (i < 3 ? o(s) : i > 3 ? o(e, n, s) : o(e, n)) || s);
    return i > 3 && s && Object.defineProperty(e, n, s), s
};
let z_ = class extends Dn {
    constructor() {
        super(), this.platformTabs = [], this.unsubscribe = [], this.platforms = [], this.onSelectPlatfrom = void 0, this.buffering = !1, this.unsubscribe.push(ir.subscribeKey("buffering", e => this.buffering = e))
    }
    disconnectCallback() {
        this.unsubscribe.forEach(e => e())
    }
    render() {
        const e = this.generateTabs();
        return $e `
      <wui-flex justifyContent="center" .padding=${["l","0","0","0"]}>
        <wui-tabs
          ?disabled=${this.buffering}
          .tabs=${e}
          .onTabChange=${this.onTabChange.bind(this)}
        ></wui-tabs>
      </wui-flex>
    `
    }
    generateTabs() {
        const e = this.platforms.map(n => n === "browser" ? {
            label: "Browser",
            icon: "extension",
            platform: "browser"
        } : n === "mobile" ? {
            label: "Mobile",
            icon: "mobile",
            platform: "mobile"
        } : n === "qrcode" ? {
            label: "Mobile",
            icon: "mobile",
            platform: "qrcode"
        } : n === "web" ? {
            label: "Webapp",
            icon: "browser",
            platform: "web"
        } : n === "desktop" ? {
            label: "Desktop",
            icon: "desktop",
            platform: "desktop"
        } : {
            label: "Browser",
            icon: "extension",
            platform: "unsupported"
        });
        return this.platformTabs = e.map(({
            platform: n
        }) => n), e
    }
    onTabChange(e) {
        var r;
        const n = this.platformTabs[e];
        n && ((r = this.onSelectPlatfrom) == null || r.call(this, n))
    }
};
NT([$i({
    type: Array
})], z_.prototype, "platforms", void 0);
NT([$i()], z_.prototype, "onSelectPlatfrom", void 0);
NT([Nt()], z_.prototype, "buffering", void 0);
z_ = NT([Qe("w3m-connecting-header")], z_);
var oEe = function(t, e, n, r) {
    var i = arguments.length,
        s = i < 3 ? e : r === null ? r = Object.getOwnPropertyDescriptor(e, n) : r,
        o;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function") s = Reflect.decorate(t, e, n, r);
    else
        for (var a = t.length - 1; a >= 0; a--)(o = t[a]) && (s = (i < 3 ? o(s) : i > 3 ? o(e, n, s) : o(e, n)) || s);
    return i > 3 && s && Object.defineProperty(e, n, s), s
};
let lW = class extends Za {
    constructor() {
        if (super(), !this.wallet) throw new Error("w3m-connecting-wc-browser: No wallet provided");
        this.onConnect = this.onConnectProxy.bind(this), this.onAutoConnect = this.onConnectProxy.bind(this), wn.sendEvent({
            type: "track",
            event: "SELECT_WALLET",
            properties: {
                name: this.wallet.name,
                platform: "browser"
            }
        })
    }
    async onConnectProxy() {
        try {
            this.error = !1;
            const {
                connectors: e
            } = Wr.state, n = e.find(i => {
                var s, o;
                return i.type === "ANNOUNCED" && ((s = i.info) == null ? void 0 : s.rdns) === ((o = this.wallet) == null ? void 0 : o.rdns)
            }), r = e.find(i => i.type === "INJECTED");
            n ? await ir.connectExternal(n) : r && await ir.connectExternal(r), Vr.close(), wn.sendEvent({
                type: "track",
                event: "CONNECT_SUCCESS",
                properties: {
                    method: "browser"
                }
            })
        } catch (e) {
            wn.sendEvent({
                type: "track",
                event: "CONNECT_ERROR",
                properties: {
                    message: (e == null ? void 0 : e.message) ? ? "Unknown"
                }
            }), this.error = !0
        }
    }
};
lW = oEe([Qe("w3m-connecting-wc-browser")], lW);
var aEe = function(t, e, n, r) {
    var i = arguments.length,
        s = i < 3 ? e : r === null ? r = Object.getOwnPropertyDescriptor(e, n) : r,
        o;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function") s = Reflect.decorate(t, e, n, r);
    else
        for (var a = t.length - 1; a >= 0; a--)(o = t[a]) && (s = (i < 3 ? o(s) : i > 3 ? o(e, n, s) : o(e, n)) || s);
    return i > 3 && s && Object.defineProperty(e, n, s), s
};
let cW = class extends Za {
    constructor() {
        if (super(), !this.wallet) throw new Error("w3m-connecting-wc-desktop: No wallet provided");
        this.onConnect = this.onConnectProxy.bind(this), this.onRender = this.onRenderProxy.bind(this), wn.sendEvent({
            type: "track",
            event: "SELECT_WALLET",
            properties: {
                name: this.wallet.name,
                platform: "desktop"
            }
        })
    }
    onRenderProxy() {
        !this.ready && this.uri && (this.ready = !0, this.timeout = setTimeout(() => {
            var e;
            (e = this.onConnect) == null || e.call(this)
        }, 200))
    }
    onConnectProxy() {
        var e;
        if ((e = this.wallet) != null && e.desktop_link && this.uri) try {
            this.error = !1;
            const {
                desktop_link: n,
                name: r
            } = this.wallet, {
                redirect: i,
                href: s
            } = Yt.formatNativeUrl(n, this.uri);
            ir.setWcLinking({
                name: r,
                href: s
            }), ir.setRecentWallet(this.wallet), Yt.openHref(i, "_blank")
        } catch {
            this.error = !0
        }
    }
};
cW = aEe([Qe("w3m-connecting-wc-desktop")], cW);
var lEe = function(t, e, n, r) {
    var i = arguments.length,
        s = i < 3 ? e : r === null ? r = Object.getOwnPropertyDescriptor(e, n) : r,
        o;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function") s = Reflect.decorate(t, e, n, r);
    else
        for (var a = t.length - 1; a >= 0; a--)(o = t[a]) && (s = (i < 3 ? o(s) : i > 3 ? o(e, n, s) : o(e, n)) || s);
    return i > 3 && s && Object.defineProperty(e, n, s), s
};
let uW = class extends Za {
    constructor() {
        if (super(), !this.wallet) throw new Error("w3m-connecting-wc-mobile: No wallet provided");
        this.onConnect = this.onConnectProxy.bind(this), this.onRender = this.onRenderProxy.bind(this), document.addEventListener("visibilitychange", this.onBuffering.bind(this)), wn.sendEvent({
            type: "track",
            event: "SELECT_WALLET",
            properties: {
                name: this.wallet.name,
                platform: "mobile"
            }
        })
    }
    disconnectedCallback() {
        super.disconnectedCallback(), document.removeEventListener("visibilitychange", this.onBuffering.bind(this))
    }
    onRenderProxy() {
        var e;
        !this.ready && this.uri && (this.ready = !0, (e = this.onConnect) == null || e.call(this))
    }
    onConnectProxy() {
        var e;
        if ((e = this.wallet) != null && e.mobile_link && this.uri) try {
            this.error = !1;
            const {
                mobile_link: n,
                name: r
            } = this.wallet, {
                redirect: i,
                href: s
            } = Yt.formatNativeUrl(n, this.uri);
            ir.setWcLinking({
                name: r,
                href: s
            }), ir.setRecentWallet(this.wallet), Yt.openHref(i, "_self")
        } catch {
            this.error = !0
        }
    }
    onBuffering() {
        const e = Yt.isIos();
        (document == null ? void 0 : document.visibilityState) === "visible" && !this.error && e && (ir.setBuffering(!0), setTimeout(() => {
            ir.setBuffering(!1)
        }, 5e3))
    }
};
uW = lEe([Qe("w3m-connecting-wc-mobile")], uW);
const cEe = bi `
  @keyframes fadein {
    from {
      opacity: 0;
    }
    to {
      opacity: 1;
    }
  }

  wui-shimmer {
    width: 100%;
    aspect-ratio: 1 / 1;
    border-radius: clamp(0px, var(--wui-border-radius-l), 40px) !important;
  }

  wui-qr-code {
    opacity: 0;
    animation-duration: 200ms;
    animation-timing-function: ease;
    animation-name: fadein;
    animation-fill-mode: forwards;
  }
`;
var uEe = function(t, e, n, r) {
    var i = arguments.length,
        s = i < 3 ? e : r === null ? r = Object.getOwnPropertyDescriptor(e, n) : r,
        o;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function") s = Reflect.decorate(t, e, n, r);
    else
        for (var a = t.length - 1; a >= 0; a--)(o = t[a]) && (s = (i < 3 ? o(s) : i > 3 ? o(e, n, s) : o(e, n)) || s);
    return i > 3 && s && Object.defineProperty(e, n, s), s
};
let qP = class extends Za {
    constructor() {
        var e;
        super(), this.forceUpdate = () => {
            this.requestUpdate()
        }, window.addEventListener("resize", this.forceUpdate), wn.sendEvent({
            type: "track",
            event: "SELECT_WALLET",
            properties: {
                name: ((e = this.wallet) == null ? void 0 : e.name) ? ? "WalletConnect",
                platform: "qrcode"
            }
        })
    }
    disconnectedCallback() {
        super.disconnectedCallback(), window.removeEventListener("resize", this.forceUpdate)
    }
    render() {
        return this.onRenderProxy(), $e `
      <wui-flex padding="xl" flexDirection="column" gap="xl" alignItems="center">
        <wui-shimmer borderRadius="l" width="100%"> ${this.qrCodeTemplate()} </wui-shimmer>

        <wui-text variant="paragraph-500" color="fg-100">
          Scan this QR Code with your phone
        </wui-text>
        ${this.copyTemplate()}
      </wui-flex>

      <w3m-mobile-download-links .wallet=${this.wallet}></w3m-mobile-download-links>
    `
    }
    onRenderProxy() {
        !this.ready && this.uri && (this.timeout = setTimeout(() => {
            this.ready = !0
        }, 200))
    }
    qrCodeTemplate() {
        if (!this.uri || !this.ready) return null;
        const e = this.getBoundingClientRect().width - 40,
            n = this.wallet ? this.wallet.name : void 0;
        return ir.setWcLinking(void 0), ir.setRecentWallet(this.wallet), $e ` <wui-qr-code
      size=${e}
      theme=${Na.state.themeMode}
      uri=${this.uri}
      imageSrc=${pr(Wi.getWalletImage(this.wallet))}
      alt=${pr(n)}
    ></wui-qr-code>`
    }
    copyTemplate() {
        const e = !this.uri || !this.ready;
        return $e `<wui-link
      .disabled=${e}
      @click=${this.onCopyUri}
      color="fg-200"
      data-testid="copy-wc2-uri"
    >
      <wui-icon size="xs" color="fg-200" slot="iconLeft" name="copy"></wui-icon>
      Copy link
    </wui-link>`
    }
};
qP.styles = cEe;
qP = uEe([Qe("w3m-connecting-wc-qrcode")], qP);
const fEe = bi `
  :host {
    display: flex;
    justify-content: center;
    gap: var(--wui-spacing-2xl);
  }

  wui-visual-thumbnail:nth-child(1) {
    z-index: 1;
  }
`;
var dEe = function(t, e, n, r) {
    var i = arguments.length,
        s = i < 3 ? e : r === null ? r = Object.getOwnPropertyDescriptor(e, n) : r,
        o;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function") s = Reflect.decorate(t, e, n, r);
    else
        for (var a = t.length - 1; a >= 0; a--)(o = t[a]) && (s = (i < 3 ? o(s) : i > 3 ? o(e, n, s) : o(e, n)) || s);
    return i > 3 && s && Object.defineProperty(e, n, s), s
};
let KP = class extends Dn {
    constructor() {
        var e;
        super(...arguments), this.dappImageUrl = (e = _r.state.metadata) == null ? void 0 : e.icons, this.walletImageUrl = ia.getConnectedWalletImageUrl()
    }
    firstUpdated() {
        var n;
        const e = (n = this.shadowRoot) == null ? void 0 : n.querySelectorAll("wui-visual-thumbnail");
        e != null && e[0] && this.createAnimation(e[0], "translate(18px)"), e != null && e[1] && this.createAnimation(e[1], "translate(-18px)")
    }
    render() {
        var e;
        return $e `
      <wui-visual-thumbnail
        ?borderRadiusFull=${!0}
        .imageSrc=${(e=this.dappImageUrl)==null?void 0:e[0]}
      ></wui-visual-thumbnail>
      <wui-visual-thumbnail .imageSrc=${this.walletImageUrl}></wui-visual-thumbnail>
    `
    }
    createAnimation(e, n) {
        e.animate([{
            transform: "translateX(0px)"
        }, {
            transform: n
        }], {
            duration: 1600,
            easing: "cubic-bezier(0.56, 0, 0.48, 1)",
            direction: "alternate",
            iterations: 1 / 0
        })
    }
};
KP.styles = fEe;
KP = dEe([Qe("w3m-connecting-siwe")], KP);
var hEe = function(t, e, n, r) {
    var i = arguments.length,
        s = i < 3 ? e : r === null ? r = Object.getOwnPropertyDescriptor(e, n) : r,
        o;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function") s = Reflect.decorate(t, e, n, r);
    else
        for (var a = t.length - 1; a >= 0; a--)(o = t[a]) && (s = (i < 3 ? o(s) : i > 3 ? o(e, n, s) : o(e, n)) || s);
    return i > 3 && s && Object.defineProperty(e, n, s), s
};
let fW = class extends Dn {
    constructor() {
        var e;
        if (super(), this.wallet = (e = Dt.state.data) == null ? void 0 : e.wallet, !this.wallet) throw new Error("w3m-connecting-wc-unsupported: No wallet provided");
        wn.sendEvent({
            type: "track",
            event: "SELECT_WALLET",
            properties: {
                name: this.wallet.name,
                platform: "browser"
            }
        })
    }
    render() {
        return $e `
      <wui-flex
        flexDirection="column"
        alignItems="center"
        .padding=${["3xl","xl","xl","xl"]}
        gap="xl"
      >
        <wui-wallet-image
          size="lg"
          imageSrc=${pr(Wi.getWalletImage(this.wallet))}
        ></wui-wallet-image>

        <wui-text variant="paragraph-500" color="fg-100">Not Detected</wui-text>
      </wui-flex>

      <w3m-mobile-download-links .wallet=${this.wallet}></w3m-mobile-download-links>
    `
    }
};
fW = hEe([Qe("w3m-connecting-wc-unsupported")], fW);
var pEe = function(t, e, n, r) {
    var i = arguments.length,
        s = i < 3 ? e : r === null ? r = Object.getOwnPropertyDescriptor(e, n) : r,
        o;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function") s = Reflect.decorate(t, e, n, r);
    else
        for (var a = t.length - 1; a >= 0; a--)(o = t[a]) && (s = (i < 3 ? o(s) : i > 3 ? o(e, n, s) : o(e, n)) || s);
    return i > 3 && s && Object.defineProperty(e, n, s), s
};
let dW = class extends Za {
    constructor() {
        if (super(), !this.wallet) throw new Error("w3m-connecting-wc-web: No wallet provided");
        this.onConnect = this.onConnectProxy.bind(this), this.secondaryBtnLabel = "Open", this.secondaryLabel = "Open and continue in a new browser tab", this.secondaryBtnIcon = "externalLink", wn.sendEvent({
            type: "track",
            event: "SELECT_WALLET",
            properties: {
                name: this.wallet.name,
                platform: "web"
            }
        })
    }
    onConnectProxy() {
        var e;
        if ((e = this.wallet) != null && e.webapp_link && this.uri) try {
            this.error = !1;
            const {
                webapp_link: n,
                name: r
            } = this.wallet, {
                redirect: i,
                href: s
            } = Yt.formatUniversalUrl(n, this.uri);
            ir.setWcLinking({
                name: r,
                href: s
            }), ir.setRecentWallet(this.wallet), Yt.openHref(i, "_blank")
        } catch {
            this.error = !0
        }
    }
};
dW = pEe([Qe("w3m-connecting-wc-web")], dW);
const gEe = bi `
  wui-icon-link[data-hidden='true'] {
    opacity: 0 !important;
    pointer-events: none;
  }
`;
var PT = function(t, e, n, r) {
    var i = arguments.length,
        s = i < 3 ? e : r === null ? r = Object.getOwnPropertyDescriptor(e, n) : r,
        o;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function") s = Reflect.decorate(t, e, n, r);
    else
        for (var a = t.length - 1; a >= 0; a--)(o = t[a]) && (s = (i < 3 ? o(s) : i > 3 ? o(e, n, s) : o(e, n)) || s);
    return i > 3 && s && Object.defineProperty(e, n, s), s
};

function hW() {
    var o, a, l, c, u, f, h;
    const t = (a = (o = Dt.state.data) == null ? void 0 : o.connector) == null ? void 0 : a.name,
        e = (c = (l = Dt.state.data) == null ? void 0 : l.wallet) == null ? void 0 : c.name,
        n = (f = (u = Dt.state.data) == null ? void 0 : u.network) == null ? void 0 : f.name,
        r = e ? ? t,
        i = Wr.getConnectors();
    return {
        Connect: `Connect ${i.length===1&&((h=i[0])==null?void 0:h.id)==="w3m-email"?"Email":""} Wallet`,
        Account: void 0,
        ConnectingExternal: r ? ? "Connect Wallet",
        ConnectingWalletConnect: r ? ? "WalletConnect",
        ConnectingSiwe: "Sign In",
        Networks: "Choose Network",
        SwitchNetwork: n ? ? "Switch Network",
        AllWallets: "All Wallets",
        WhatIsANetwork: "What is a network?",
        WhatIsAWallet: "What is a wallet?",
        GetWallet: "Get a wallet",
        Downloads: r ? `Get ${r}` : "Downloads",
        EmailVerifyOtp: "Confirm Email",
        EmailVerifyDevice: "Register Device",
        ApproveTransaction: "Approve Transaction",
        Transactions: "Activity",
        UpgradeEmailWallet: "Upgrade your Wallet",
        UpdateEmailWallet: "Edit Email",
        UpdateEmailWalletWaiting: "Approve Email"
    }
}
let Wb = class extends Dn {
    constructor() {
        super(), this.unsubscribe = [], this.heading = hW()[Dt.state.view], this.buffering = !1, this.showBack = !1, this.unsubscribe.push(Dt.subscribeKey("view", e => {
            this.onViewChange(e), this.onHistoryChange()
        }), ir.subscribeKey("buffering", e => this.buffering = e))
    }
    disconnectCallback() {
        this.unsubscribe.forEach(e => e())
    }
    render() {
        return $e `
      <wui-flex .padding=${this.getPadding()} justifyContent="space-between" alignItems="center">
        ${this.dynamicButtonTemplate()} ${this.titleTemplate()}
        <wui-icon-link
          ?disabled=${this.buffering}
          icon="close"
          @click=${this.onClose.bind(this)}
          data-testid="w3m-header-close"
        ></wui-icon-link>
      </wui-flex>
      ${this.separatorTemplate()}
    `
    }
    onWalletHelp() {
        wn.sendEvent({
            type: "track",
            event: "CLICK_WALLET_HELP"
        }), Dt.push("WhatIsAWallet")
    }
    async onClose() {
        ss.state.isSiweEnabled && ss.state.status !== "success" && await ir.disconnect(), Vr.close()
    }
    titleTemplate() {
        return $e `<wui-text variant="paragraph-700" color="fg-100">${this.heading}</wui-text>`
    }
    dynamicButtonTemplate() {
        const {
            view: e
        } = Dt.state, n = e === "Connect", r = e === "ApproveTransaction";
        return this.showBack && !r ? $e `<wui-icon-link
        id="dynamic"
        icon="chevronLeft"
        ?disabled=${this.buffering}
        @click=${this.onGoBack.bind(this)}
      ></wui-icon-link>` : $e `<wui-icon-link
      data-hidden=${!n}
      id="dynamic"
      icon="helpCircle"
      @click=${this.onWalletHelp.bind(this)}
    ></wui-icon-link>`
    }
    separatorTemplate() {
        return this.heading ? $e `<wui-separator></wui-separator>` : null
    }
    getPadding() {
        return this.heading ? ["l", "2l", "l", "2l"] : ["l", "2l", "0", "2l"]
    }
    async onViewChange(e) {
        var r;
        const n = (r = this.shadowRoot) == null ? void 0 : r.querySelector("wui-text");
        if (n) {
            const i = hW()[e];
            await n.animate([{
                opacity: 1
            }, {
                opacity: 0
            }], {
                duration: 200,
                fill: "forwards",
                easing: "ease"
            }).finished, this.heading = i, n.animate([{
                opacity: 0
            }, {
                opacity: 1
            }], {
                duration: 200,
                fill: "forwards",
                easing: "ease"
            })
        }
    }
    async onHistoryChange() {
        var r;
        const {
            history: e
        } = Dt.state, n = (r = this.shadowRoot) == null ? void 0 : r.querySelector("#dynamic");
        e.length > 1 && !this.showBack && n ? (await n.animate([{
            opacity: 1
        }, {
            opacity: 0
        }], {
            duration: 200,
            fill: "forwards",
            easing: "ease"
        }).finished, this.showBack = !0, n.animate([{
            opacity: 0
        }, {
            opacity: 1
        }], {
            duration: 200,
            fill: "forwards",
            easing: "ease"
        })) : e.length <= 1 && this.showBack && n && (await n.animate([{
            opacity: 1
        }, {
            opacity: 0
        }], {
            duration: 200,
            fill: "forwards",
            easing: "ease"
        }).finished, this.showBack = !1, n.animate([{
            opacity: 0
        }, {
            opacity: 1
        }], {
            duration: 200,
            fill: "forwards",
            easing: "ease"
        }))
    }
    onGoBack() {
        Dt.state.view === "ConnectingSiwe" ? Dt.push("Connect") : Dt.goBack()
    }
};
Wb.styles = [gEe];
PT([Nt()], Wb.prototype, "heading", void 0);
PT([Nt()], Wb.prototype, "buffering", void 0);
PT([Nt()], Wb.prototype, "showBack", void 0);
Wb = PT([Qe("w3m-header")], Wb);
var bte = function(t, e, n, r) {
    var i = arguments.length,
        s = i < 3 ? e : r === null ? r = Object.getOwnPropertyDescriptor(e, n) : r,
        o;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function") s = Reflect.decorate(t, e, n, r);
    else
        for (var a = t.length - 1; a >= 0; a--)(o = t[a]) && (s = (i < 3 ? o(s) : i > 3 ? o(e, n, s) : o(e, n)) || s);
    return i > 3 && s && Object.defineProperty(e, n, s), s
};
let YP = class extends Dn {
    constructor() {
        super(...arguments), this.data = []
    }
    render() {
        return $e `
      <wui-flex flexDirection="column" alignItems="center" gap="l">
        ${this.data.map(e=>$e`
            <wui-flex flexDirection="column" alignItems="center" gap="xl">
              <wui-flex flexDirection="row" justifyContent="center" gap="1xs">
                ${e.images.map(n=>$e`<wui-visual name=${n}></wui-visual>`)}
              </wui-flex>
            </wui-flex>
            <wui-flex flexDirection="column" alignItems="center" gap="xxs">
              <wui-text variant="paragraph-500" color="fg-100" align="center">
                ${e.title}
              </wui-text>
              <wui-text variant="small-500" color="fg-200" align="center">${e.text}</wui-text>
            </wui-flex>
          `)}
      </wui-flex>
    `
    }
};
bte([$i({
    type: Array
})], YP.prototype, "data", void 0);
YP = bte([Qe("w3m-help-widget")], YP);
const mEe = bi `
  wui-flex {
    background-color: var(--wui-gray-glass-005);
  }

  a {
    text-decoration: none;
    color: var(--wui-color-fg-175);
    font-weight: 500;
  }
`;
var yEe = function(t, e, n, r) {
    var i = arguments.length,
        s = i < 3 ? e : r === null ? r = Object.getOwnPropertyDescriptor(e, n) : r,
        o;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function") s = Reflect.decorate(t, e, n, r);
    else
        for (var a = t.length - 1; a >= 0; a--)(o = t[a]) && (s = (i < 3 ? o(s) : i > 3 ? o(e, n, s) : o(e, n)) || s);
    return i > 3 && s && Object.defineProperty(e, n, s), s
};
let ZP = class extends Dn {
    render() {
        const {
            termsConditionsUrl: e,
            privacyPolicyUrl: n
        } = _r.state;
        return !e && !n ? null : $e `
      <wui-flex .padding=${["m","s","s","s"]} justifyContent="center">
        <wui-text color="fg-250" variant="small-400" align="center">
          By connecting your wallet, you agree to our <br />
          ${this.termsTemplate()} ${this.andTemplate()} ${this.privacyTemplate()}
        </wui-text>
      </wui-flex>
    `
    }
    andTemplate() {
        const {
            termsConditionsUrl: e,
            privacyPolicyUrl: n
        } = _r.state;
        return e && n ? "and" : ""
    }
    termsTemplate() {
        const {
            termsConditionsUrl: e
        } = _r.state;
        return e ? $e `<a href=${e}>Terms of Service</a>` : null
    }
    privacyTemplate() {
        const {
            privacyPolicyUrl: e
        } = _r.state;
        return e ? $e `<a href=${e}>Privacy Policy</a>` : null
    }
};
ZP.styles = [mEe];
ZP = yEe([Qe("w3m-legal-footer")], ZP);
const wEe = bi `
  :host {
    display: block;
    padding: 0 var(--wui-spacing-xl) var(--wui-spacing-xl);
  }
`;
var _te = function(t, e, n, r) {
    var i = arguments.length,
        s = i < 3 ? e : r === null ? r = Object.getOwnPropertyDescriptor(e, n) : r,
        o;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function") s = Reflect.decorate(t, e, n, r);
    else
        for (var a = t.length - 1; a >= 0; a--)(o = t[a]) && (s = (i < 3 ? o(s) : i > 3 ? o(e, n, s) : o(e, n)) || s);
    return i > 3 && s && Object.defineProperty(e, n, s), s
};
let EC = class extends Dn {
    constructor() {
        super(...arguments), this.wallet = void 0
    }
    render() {
        if (!this.wallet) return this.style.display = "none", null;
        const {
            name: e,
            app_store: n,
            play_store: r,
            chrome_store: i,
            homepage: s
        } = this.wallet, o = Yt.isMobile(), a = Yt.isIos(), l = Yt.isAndroid(), c = [n, r, s, i].filter(Boolean).length > 1, u = Mr.getTruncateString({
            string: e,
            charsStart: 12,
            charsEnd: 0,
            truncate: "end"
        });
        return c && !o ? $e `
        <wui-cta-button
          label=${`Don't have ${u}?`}
          buttonLabel="Get"
          @click=${()=>Dt.push("Downloads",{wallet:this.wallet})}
        ></wui-cta-button>
      ` : !c && s ? $e `
        <wui-cta-button
          label=${`Don't have ${u}?`}
          buttonLabel="Get"
          @click=${this.onHomePage.bind(this)}
        ></wui-cta-button>
      ` : n && a ? $e `
        <wui-cta-button
          label=${`Don't have ${u}?`}
          buttonLabel="Get"
          @click=${this.onAppStore.bind(this)}
        ></wui-cta-button>
      ` : r && l ? $e `
        <wui-cta-button
          label=${`Don't have ${u}?`}
          buttonLabel="Get"
          @click=${this.onPlayStore.bind(this)}
        ></wui-cta-button>
      ` : (this.style.display = "none", null)
    }
    onAppStore() {
        var e;
        (e = this.wallet) != null && e.app_store && Yt.openHref(this.wallet.app_store, "_blank")
    }
    onPlayStore() {
        var e;
        (e = this.wallet) != null && e.play_store && Yt.openHref(this.wallet.play_store, "_blank")
    }
    onHomePage() {
        var e;
        (e = this.wallet) != null && e.homepage && Yt.openHref(this.wallet.homepage, "_blank")
    }
};
EC.styles = [wEe];
_te([$i({
    type: Object
})], EC.prototype, "wallet", void 0);
EC = _te([Qe("w3m-mobile-download-links")], EC);
const vEe = bi `
  :host {
    display: block;
    position: absolute;
    opacity: 0;
    pointer-events: none;
    top: 11px;
    left: 50%;
    width: max-content;
  }
`;
var Ete = function(t, e, n, r) {
    var i = arguments.length,
        s = i < 3 ? e : r === null ? r = Object.getOwnPropertyDescriptor(e, n) : r,
        o;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function") s = Reflect.decorate(t, e, n, r);
    else
        for (var a = t.length - 1; a >= 0; a--)(o = t[a]) && (s = (i < 3 ? o(s) : i > 3 ? o(e, n, s) : o(e, n)) || s);
    return i > 3 && s && Object.defineProperty(e, n, s), s
};
const bEe = {
    success: {
        backgroundColor: "success-100",
        iconColor: "success-100",
        icon: "checkmark"
    },
    error: {
        backgroundColor: "error-100",
        iconColor: "error-100",
        icon: "close"
    }
};
let xC = class extends Dn {
    constructor() {
        super(), this.unsubscribe = [], this.timeout = void 0, this.open = qi.state.open, this.unsubscribe.push(qi.subscribeKey("open", e => {
            this.open = e, this.onOpen()
        }))
    }
    disconnectedCallback() {
        clearTimeout(this.timeout), this.unsubscribe.forEach(e => e())
    }
    render() {
        const {
            message: e,
            variant: n
        } = qi.state, r = bEe[n];
        return $e `
      <wui-snackbar
        message=${e}
        backgroundColor=${r.backgroundColor}
        iconColor=${r.iconColor}
        icon=${r.icon}
      ></wui-snackbar>
    `
    }
    onOpen() {
        clearTimeout(this.timeout), this.open ? (this.animate([{
            opacity: 0,
            transform: "translateX(-50%) scale(0.85)"
        }, {
            opacity: 1,
            transform: "translateX(-50%) scale(1)"
        }], {
            duration: 150,
            fill: "forwards",
            easing: "ease"
        }), this.timeout = setTimeout(() => qi.hide(), 2500)) : this.animate([{
            opacity: 1,
            transform: "translateX(-50%) scale(1)"
        }, {
            opacity: 0,
            transform: "translateX(-50%) scale(0.85)"
        }], {
            duration: 150,
            fill: "forwards",
            easing: "ease"
        })
    }
};
xC.styles = vEe;
Ete([Nt()], xC.prototype, "open", void 0);
xC = Ete([Qe("w3m-snackbar")], xC);
const _Ee = bi `
  wui-separator {
    margin: var(--wui-spacing-s) calc(var(--wui-spacing-s) * -1);
    width: calc(100% + var(--wui-spacing-s) * 2);
  }

  wui-email-input {
    width: 100%;
  }

  form {
    width: 100%;
    display: block;
    position: relative;
  }

  wui-icon-link,
  wui-loading-spinner {
    position: absolute;
    top: 21px;
    transform: translateY(-50%);
  }

  wui-icon-link {
    right: var(--wui-spacing-xs);
  }

  wui-loading-spinner {
    right: var(--wui-spacing-m);
  }

  .alphaBanner {
    padding: 10px 12px 10px 10px;
    border-radius: var(--wui-border-radius-s);
    background: var(--wui-accent-glass-010);
    margin-bottom: var(--wui-spacing-s);
  }
`;
var yE = function(t, e, n, r) {
    var i = arguments.length,
        s = i < 3 ? e : r === null ? r = Object.getOwnPropertyDescriptor(e, n) : r,
        o;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function") s = Reflect.decorate(t, e, n, r);
    else
        for (var a = t.length - 1; a >= 0; a--)(o = t[a]) && (s = (i < 3 ? o(s) : i > 3 ? o(e, n, s) : o(e, n)) || s);
    return i > 3 && s && Object.defineProperty(e, n, s), s
};
let Nm = class extends Dn {
    constructor() {
        super(), this.unsubscribe = [], this.formRef = mte(), this.connectors = Wr.state.connectors, this.email = "", this.loading = !1, this.error = "", this.unsubscribe.push(Wr.subscribeKey("connectors", e => this.connectors = e))
    }
    disconnectedCallback() {
        this.unsubscribe.forEach(e => e())
    }
    firstUpdated() {
        var e;
        (e = this.formRef.value) == null || e.addEventListener("keydown", n => {
            n.key === "Enter" && this.onSubmitEmail(n)
        })
    }
    render() {
        const e = this.connectors.length > 1;
        return this.connectors.find(r => r.type === "EMAIL") ? $e `
      ${this.alphaWarningTemplate()}
      <form ${yte(this.formRef)} @submit=${this.onSubmitEmail.bind(this)}>
        <wui-email-input
          @focus=${this.onFocusEvent.bind(this)}
          .disabled=${this.loading}
          @inputChange=${this.onEmailInputChange.bind(this)}
          .errorMessage=${this.error}
        >
        </wui-email-input>

        ${this.submitButtonTemplate()}${this.loadingTemplate()}
        <input type="submit" hidden />
      </form>

      ${e?$e`<wui-separator text="or"></wui-separator>`:null}
    ` : null
    }
    alphaWarningTemplate() {
        return $e `
          <wui-flex class="alphaBanner" gap="xs" alignItems="center" justifyContent="center">
            <wui-icon-box
              size="sm"
              icon="alpha"
              iconColor="accent-100"
              background="opaque"
              backgroundColor="accent-100"
            ></wui-icon-box>
            <wui-text variant="small-400" color="accent-100">
              This is an alpha version to test before launch
            </wui-text>
          </wui-flex>
        `
    }
    submitButtonTemplate() {
        return !this.loading && this.email.length > 3 ? $e `
          <wui-icon-link
            size="sm"
            icon="chevronRight"
            iconcolor="accent-100"
            @click=${this.onSubmitEmail.bind(this)}
          >
          </wui-icon-link>
        ` : null
    }
    loadingTemplate() {
        return this.loading ? $e `<wui-loading-spinner size="md" color="accent-100"></wui-loading-spinner>` : null
    }
    onEmailInputChange(e) {
        this.email = e.detail, this.error = ""
    }
    async onSubmitEmail(e) {
        try {
            if (this.loading) return;
            this.loading = !0, e.preventDefault();
            const n = Wr.getEmailConnector();
            if (!n) throw new Error("w3m-email-login-widget: Email connector not found");
            const {
                action: r
            } = await n.provider.connectEmail({
                email: this.email
            });
            wn.sendEvent({
                type: "track",
                event: "EMAIL_SUBMITTED"
            }), r === "VERIFY_OTP" ? (wn.sendEvent({
                type: "track",
                event: "EMAIL_VERIFICATION_CODE_SENT"
            }), Dt.push("EmailVerifyOtp", {
                email: this.email
            })) : r === "VERIFY_DEVICE" && Dt.push("EmailVerifyDevice", {
                email: this.email
            })
        } catch (n) {
            const r = Yt.parseError(n);
            r != null && r.includes("Invalid email") ? this.error = "Invalid email. Try again." : qi.showError(n)
        } finally {
            this.loading = !1
        }
    }
    onFocusEvent() {
        wn.sendEvent({
            type: "track",
            event: "EMAIL_LOGIN_SELECTED"
        })
    }
};
Nm.styles = _Ee;
yE([Nt()], Nm.prototype, "connectors", void 0);
yE([Nt()], Nm.prototype, "email", void 0);
yE([Nt()], Nm.prototype, "loading", void 0);
yE([Nt()], Nm.prototype, "error", void 0);
Nm = yE([Qe("w3m-email-login-widget")], Nm);
const EEe = "modulepreload",
    xEe = function(t) {
        return "/" + t
    },
    pW = {},
    Pi = function(e, n, r) {
        let i = Promise.resolve();
        if (n && n.length > 0) {
            document.getElementsByTagName("link");
            const o = document.querySelector("meta[property=csp-nonce]"),
                a = (o == null ? void 0 : o.nonce) || (o == null ? void 0 : o.getAttribute("nonce"));
            i = Promise.allSettled(n.map(l => {
                if (l = xEe(l), l in pW) return;
                pW[l] = !0;
                const c = l.endsWith(".css"),
                    u = c ? '[rel="stylesheet"]' : "";
                if (document.querySelector(`link[href="${l}"]${u}`)) return;
                const f = document.createElement("link");
                if (f.rel = c ? "stylesheet" : EEe, c || (f.as = "script"), f.crossOrigin = "", f.href = l, a && f.setAttribute("nonce", a), document.head.appendChild(f), c) return new Promise((h, g) => {
                    f.addEventListener("load", h), f.addEventListener("error", () => g(new Error(`Unable to preload CSS for ${l}`)))
                })
            }))
        }

        function s(o) {
            const a = new Event("vite:preloadError", {
                cancelable: !0
            });
            if (a.payload = o, window.dispatchEvent(a), !a.defaultPrevented) throw o
        }
        return i.then(o => {
            for (const a of o || []) a.status === "rejected" && s(a.reason);
            return e().catch(s)
        })
    };
let gW = !1;
class SEe {
    constructor(e) {
        this.initPromise = void 0, this.setIsConnected = n => {
            hr.setIsConnected(n)
        }, this.setCaipAddress = n => {
            hr.setCaipAddress(n)
        }, this.setBalance = (n, r) => {
            hr.setBalance(n, r)
        }, this.setProfileName = n => {
            hr.setProfileName(n)
        }, this.setProfileImage = n => {
            hr.setProfileImage(n)
        }, this.resetAccount = () => {
            hr.resetAccount()
        }, this.setCaipNetwork = n => {
            Gi.setCaipNetwork(n)
        }, this.getCaipNetwork = () => Gi.state.caipNetwork, this.setRequestedCaipNetworks = n => {
            Gi.setRequestedCaipNetworks(n)
        }, this.getApprovedCaipNetworksData = () => Gi.getApprovedCaipNetworksData(), this.resetNetwork = () => {
            Gi.resetNetwork()
        }, this.setConnectors = n => {
            Wr.setConnectors(n)
        }, this.addConnector = n => {
            Wr.addConnector(n)
        }, this.getConnectors = () => Wr.getConnectors(), this.resetWcConnection = () => {
            ir.resetWcConnection()
        }, this.fetchIdentity = n => XX.fetchIdentity(n), this.setAddressExplorerUrl = n => {
            hr.setAddressExplorerUrl(n)
        }, this.setSIWENonce = n => {
            ss.setNonce(n)
        }, this.setSIWESession = n => {
            ss.setSession(n)
        }, this.setSIWEStatus = n => {
            ss.setStatus(n)
        }, this.setSIWEMessage = n => {
            ss.setMessage(n)
        }, this.initControllers(e), this.initOrContinue()
    }
    async open(e) {
        await this.initOrContinue(), Vr.open(e)
    }
    async close() {
        await this.initOrContinue(), Vr.close()
    }
    setLoading(e) {
        Vr.setLoading(e)
    }
    getThemeMode() {
        return Na.state.themeMode
    }
    getThemeVariables() {
        return Na.state.themeVariables
    }
    setThemeMode(e) {
        Na.setThemeMode(e), I$(Na.state.themeMode);
        try {
            const n = Wr.getEmailConnector();
            n && n.provider.syncTheme({
                themeMode: Na.getSnapshot().themeMode
            })
        } catch {
            console.info("Unable to sync theme to email connector")
        }
    }
    setThemeVariables(e) {
        Na.setThemeVariables(e), uee(Na.state.themeVariables);
        try {
            const n = Wr.getEmailConnector();
            n && n.provider.syncTheme({
                themeVariables: Na.getSnapshot().themeVariables
            })
        } catch {
            console.info("Unable to sync theme to email connector")
        }
    }
    subscribeTheme(e) {
        return Na.subscribe(e)
    }
    getState() {
        return { ...Sb.state
        }
    }
    subscribeState(e) {
        return Sb.subscribe(e)
    }
    getEvent() {
        return { ...wn.state
        }
    }
    subscribeEvents(e) {
        return wn.subscribe(e)
    }
    subscribeSIWEState(e) {
        return ss.subscribe(e)
    }
    initControllers(e) {
        if (Gi.setClient(e.networkControllerClient), Gi.setDefaultCaipNetwork(e.defaultChain), _r.setProjectId(e.projectId), _r.setIncludeWalletIds(e.includeWalletIds), _r.setExcludeWalletIds(e.excludeWalletIds), _r.setFeaturedWalletIds(e.featuredWalletIds), _r.setTokens(e.tokens), _r.setTermsConditionsUrl(e.termsConditionsUrl), _r.setPrivacyPolicyUrl(e.privacyPolicyUrl), _r.setCustomWallets(e.customWallets), _r.setEnableAnalytics(e.enableAnalytics), _r.setSdkVersion(e._sdkVersion), ir.setClient(e.connectionControllerClient), e.siweControllerClient) {
            const n = e.siweControllerClient;
            ss.setSIWEClient(n)
        }
        e.metadata && _r.setMetadata(e.metadata), e.themeMode && Na.setThemeMode(e.themeMode), e.themeVariables && Na.setThemeVariables(e.themeVariables)
    }
    async initOrContinue() {
        return !this.initPromise && !gW && Yt.isClient() && (gW = !0, this.initPromise = new Promise(async e => {
            await Promise.all([Pi(() => Promise.resolve().then(() => I3e), void 0), Pi(() => Promise.resolve().then(() => J3e), void 0)]);
            const n = document.createElement("w3m-modal");
            document.body.insertAdjacentElement("beforeend", n), e()
        })), this.initPromise
    }
}
const yt = {
        WALLET_CONNECT_CONNECTOR_ID: "walletConnect",
        INJECTED_CONNECTOR_ID: "injected",
        COINBASE_CONNECTOR_ID: "coinbaseWallet",
        SAFE_CONNECTOR_ID: "safe",
        LEDGER_CONNECTOR_ID: "ledger",
        EIP6963_CONNECTOR_ID: "eip6963",
        EMAIL_CONNECTOR_ID: "w3mEmail",
        EIP155: "eip155",
        ADD_CHAIN_METHOD: "wallet_addEthereumChain",
        EIP6963_ANNOUNCE_EVENT: "eip6963:announceProvider",
        EIP6963_REQUEST_EVENT: "eip6963:requestProvider",
        VERSION: "3.5.7"
    },
    xo = {
        ConnectorExplorerIds: {
            [yt.COINBASE_CONNECTOR_ID]: "fd20dc426fb37566d803205b19bbc1d4096b248ac04548e3cfb6b3a38bd033aa",
            [yt.SAFE_CONNECTOR_ID]: "225affb176778569276e484e1b92637ad061b01e13a048b35a9d280c3b58970f",
            [yt.LEDGER_CONNECTOR_ID]: "19177a98252e07ddfc9af2083ba8e07ef627cb6103467ffebb3f8f4205fd7927"
        },
        EIP155NetworkImageIds: {
            1: "692ed6ba-e569-459a-556a-776476829e00",
            42161: "600a9a04-c1b9-42ca-6785-9b4b6ff85200",
            43114: "30c46e53-e989-45fb-4549-be3bd4eb3b00",
            56: "93564157-2e8e-4ce7-81df-b264dbee9b00",
            250: "06b26297-fe0c-4733-5d6b-ffa5498aac00",
            10: "ab9c186a-c52f-464b-2906-ca59d760a400",
            137: "41d04d42-da3b-4453-8506-668cc0727900",
            100: "02b53f6a-e3d4-479e-1cb4-21178987d100",
            9001: "f926ff41-260d-4028-635e-91913fc28e00",
            324: "b310f07f-4ef7-49f3-7073-2a0a39685800",
            314: "5a73b3dd-af74-424e-cae0-0de859ee9400",
            4689: "34e68754-e536-40da-c153-6ef2e7188a00",
            1088: "3897a66d-40b9-4833-162f-a2c90531c900",
            1284: "161038da-44ae-4ec7-1208-0ea569454b00",
            1285: "f1d73bb6-5450-4e18-38f7-fb6484264a00",
            7777777: "845c60df-d429-4991-e687-91ae45791600",
            42220: "ab781bbc-ccc6-418d-d32d-789b15da1f00",
            8453: "7289c336-3981-4081-c5f4-efc26ac64a00",
            1313161554: "3ff73439-a619-4894-9262-4470c773a100"
        },
        ConnectorImageIds: {
            [yt.COINBASE_CONNECTOR_ID]: "0c2840c3-5b04-4c44-9661-fbd4b49e1800",
            [yt.SAFE_CONNECTOR_ID]: "461db637-8616-43ce-035a-d89b8a1d5800",
            [yt.LEDGER_CONNECTOR_ID]: "54a1aa77-d202-4f8d-0fb2-5d2bb6db0300",
            [yt.WALLET_CONNECT_CONNECTOR_ID]: "ef1a1fcf-7fe8-4d69-bd6d-fda1345b4400",
            [yt.INJECTED_CONNECTOR_ID]: "07ba87ed-43aa-4adf-4540-9e6a2b9cae00"
        },
        ConnectorNamesMap: {
            [yt.INJECTED_CONNECTOR_ID]: "Browser Wallet",
            [yt.WALLET_CONNECT_CONNECTOR_ID]: "WalletConnect",
            [yt.COINBASE_CONNECTOR_ID]: "Coinbase",
            [yt.LEDGER_CONNECTOR_ID]: "Ledger",
            [yt.SAFE_CONNECTOR_ID]: "Safe"
        },
        ConnectorTypesMap: {
            [yt.INJECTED_CONNECTOR_ID]: "INJECTED",
            [yt.WALLET_CONNECT_CONNECTOR_ID]: "WALLET_CONNECT",
            [yt.EIP6963_CONNECTOR_ID]: "ANNOUNCED",
            [yt.EMAIL_CONNECTOR_ID]: "EMAIL"
        },
        WalletConnectRpcChainIds: [1, 5, 11155111, 10, 420, 42161, 421613, 137, 80001, 42220, 1313161554, 1313161555, 56, 97, 43114, 43113, 100, 8453, 84531, 7777777, 999, 324, 280]
    },
    $x = {
        caipNetworkIdToNumber(t) {
            return t ? Number(t.split(":")[1]) : void 0
        },
        getCaipTokens(t) {
            if (!t) return;
            const e = {};
            return Object.entries(t).forEach(([n, r]) => {
                e[`${yt.EIP155}:${n}`] = r
            }), e
        }
    };
var X$ = {
        exports: {}
    },
    tv = typeof Reflect == "object" ? Reflect : null,
    mW = tv && typeof tv.apply == "function" ? tv.apply : function(e, n, r) {
        return Function.prototype.apply.call(e, n, r)
    },
    ZS;
tv && typeof tv.ownKeys == "function" ? ZS = tv.ownKeys : Object.getOwnPropertySymbols ? ZS = function(e) {
    return Object.getOwnPropertyNames(e).concat(Object.getOwnPropertySymbols(e))
} : ZS = function(e) {
    return Object.getOwnPropertyNames(e)
};

function CEe(t) {
    console && console.warn && console.warn(t)
}
var xte = Number.isNaN || function(e) {
    return e !== e
};

function $r() {
    $r.init.call(this)
}
X$.exports = $r;
X$.exports.once = REe;
$r.EventEmitter = $r;
$r.prototype._events = void 0;
$r.prototype._eventsCount = 0;
$r.prototype._maxListeners = void 0;
var yW = 10;

function kT(t) {
    if (typeof t != "function") throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof t)
}
Object.defineProperty($r, "defaultMaxListeners", {
    enumerable: !0,
    get: function() {
        return yW
    },
    set: function(t) {
        if (typeof t != "number" || t < 0 || xte(t)) throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + t + ".");
        yW = t
    }
});
$r.init = function() {
    (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) && (this._events = Object.create(null), this._eventsCount = 0), this._maxListeners = this._maxListeners || void 0
};
$r.prototype.setMaxListeners = function(e) {
    if (typeof e != "number" || e < 0 || xte(e)) throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + e + ".");
    return this._maxListeners = e, this
};

function Ste(t) {
    return t._maxListeners === void 0 ? $r.defaultMaxListeners : t._maxListeners
}
$r.prototype.getMaxListeners = function() {
    return Ste(this)
};
$r.prototype.emit = function(e) {
    for (var n = [], r = 1; r < arguments.length; r++) n.push(arguments[r]);
    var i = e === "error",
        s = this._events;
    if (s !== void 0) i = i && s.error === void 0;
    else if (!i) return !1;
    if (i) {
        var o;
        if (n.length > 0 && (o = n[0]), o instanceof Error) throw o;
        var a = new Error("Unhandled error." + (o ? " (" + o.message + ")" : ""));
        throw a.context = o, a
    }
    var l = s[e];
    if (l === void 0) return !1;
    if (typeof l == "function") mW(l, this, n);
    else
        for (var c = l.length, u = Rte(l, c), r = 0; r < c; ++r) mW(u[r], this, n);
    return !0
};

function Cte(t, e, n, r) {
    var i, s, o;
    if (kT(n), s = t._events, s === void 0 ? (s = t._events = Object.create(null), t._eventsCount = 0) : (s.newListener !== void 0 && (t.emit("newListener", e, n.listener ? n.listener : n), s = t._events), o = s[e]), o === void 0) o = s[e] = n, ++t._eventsCount;
    else if (typeof o == "function" ? o = s[e] = r ? [n, o] : [o, n] : r ? o.unshift(n) : o.push(n), i = Ste(t), i > 0 && o.length > i && !o.warned) {
        o.warned = !0;
        var a = new Error("Possible EventEmitter memory leak detected. " + o.length + " " + String(e) + " listeners added. Use emitter.setMaxListeners() to increase limit");
        a.name = "MaxListenersExceededWarning", a.emitter = t, a.type = e, a.count = o.length, CEe(a)
    }
    return t
}
$r.prototype.addListener = function(e, n) {
    return Cte(this, e, n, !1)
};
$r.prototype.on = $r.prototype.addListener;
$r.prototype.prependListener = function(e, n) {
    return Cte(this, e, n, !0)
};

function AEe() {
    if (!this.fired) return this.target.removeListener(this.type, this.wrapFn), this.fired = !0, arguments.length === 0 ? this.listener.call(this.target) : this.listener.apply(this.target, arguments)
}

function Ate(t, e, n) {
    var r = {
            fired: !1,
            wrapFn: void 0,
            target: t,
            type: e,
            listener: n
        },
        i = AEe.bind(r);
    return i.listener = n, r.wrapFn = i, i
}
$r.prototype.once = function(e, n) {
    return kT(n), this.on(e, Ate(this, e, n)), this
};
$r.prototype.prependOnceListener = function(e, n) {
    return kT(n), this.prependListener(e, Ate(this, e, n)), this
};
$r.prototype.removeListener = function(e, n) {
    var r, i, s, o, a;
    if (kT(n), i = this._events, i === void 0) return this;
    if (r = i[e], r === void 0) return this;
    if (r === n || r.listener === n) --this._eventsCount === 0 ? this._events = Object.create(null) : (delete i[e], i.removeListener && this.emit("removeListener", e, r.listener || n));
    else if (typeof r != "function") {
        for (s = -1, o = r.length - 1; o >= 0; o--)
            if (r[o] === n || r[o].listener === n) {
                a = r[o].listener, s = o;
                break
            }
        if (s < 0) return this;
        s === 0 ? r.shift() : TEe(r, s), r.length === 1 && (i[e] = r[0]), i.removeListener !== void 0 && this.emit("removeListener", e, a || n)
    }
    return this
};
$r.prototype.off = $r.prototype.removeListener;
$r.prototype.removeAllListeners = function(e) {
    var n, r, i;
    if (r = this._events, r === void 0) return this;
    if (r.removeListener === void 0) return arguments.length === 0 ? (this._events = Object.create(null), this._eventsCount = 0) : r[e] !== void 0 && (--this._eventsCount === 0 ? this._events = Object.create(null) : delete r[e]), this;
    if (arguments.length === 0) {
        var s = Object.keys(r),
            o;
        for (i = 0; i < s.length; ++i) o = s[i], o !== "removeListener" && this.removeAllListeners(o);
        return this.removeAllListeners("removeListener"), this._events = Object.create(null), this._eventsCount = 0, this
    }
    if (n = r[e], typeof n == "function") this.removeListener(e, n);
    else if (n !== void 0)
        for (i = n.length - 1; i >= 0; i--) this.removeListener(e, n[i]);
    return this
};

function Tte(t, e, n) {
    var r = t._events;
    if (r === void 0) return [];
    var i = r[e];
    return i === void 0 ? [] : typeof i == "function" ? n ? [i.listener || i] : [i] : n ? IEe(i) : Rte(i, i.length)
}
$r.prototype.listeners = function(e) {
    return Tte(this, e, !0)
};
$r.prototype.rawListeners = function(e) {
    return Tte(this, e, !1)
};
$r.listenerCount = function(t, e) {
    return typeof t.listenerCount == "function" ? t.listenerCount(e) : Ite.call(t, e)
};
$r.prototype.listenerCount = Ite;

function Ite(t) {
    var e = this._events;
    if (e !== void 0) {
        var n = e[t];
        if (typeof n == "function") return 1;
        if (n !== void 0) return n.length
    }
    return 0
}
$r.prototype.eventNames = function() {
    return this._eventsCount > 0 ? ZS(this._events) : []
};

function Rte(t, e) {
    for (var n = new Array(e), r = 0; r < e; ++r) n[r] = t[r];
    return n
}

function TEe(t, e) {
    for (; e + 1 < t.length; e++) t[e] = t[e + 1];
    t.pop()
}

function IEe(t) {
    for (var e = new Array(t.length), n = 0; n < e.length; ++n) e[n] = t[n].listener || t[n];
    return e
}

function REe(t, e) {
    return new Promise(function(n, r) {
        function i(o) {
            t.removeListener(e, s), r(o)
        }

        function s() {
            typeof t.removeListener == "function" && t.removeListener("error", i), n([].slice.call(arguments))
        }
        Ote(t, e, s, {
            once: !0
        }), e !== "error" && OEe(t, i, {
            once: !0
        })
    })
}

function OEe(t, e, n) {
    typeof t.on == "function" && Ote(t, "error", e, n)
}

function Ote(t, e, n, r) {
    if (typeof t.on == "function") r.once ? t.once(e, n) : t.on(e, n);
    else if (typeof t.addEventListener == "function") t.addEventListener(e, function i(s) {
        r.once && t.removeEventListener(e, i), n(s)
    });
    else throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof t)
}
var uo = X$.exports;
const eL = co(uo);
var tL = {},
    MT = {},
    An = {},
    Nte = {};
(function(t) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });

    function e(a, l) {
        var c = a >>> 16 & 65535,
            u = a & 65535,
            f = l >>> 16 & 65535,
            h = l & 65535;
        return u * h + (c * h + u * f << 16 >>> 0) | 0
    }
    t.mul = Math.imul || e;

    function n(a, l) {
        return a + l | 0
    }
    t.add = n;

    function r(a, l) {
        return a - l | 0
    }
    t.sub = r;

    function i(a, l) {
        return a << l | a >>> 32 - l
    }
    t.rotl = i;

    function s(a, l) {
        return a << 32 - l | a >>> l
    }
    t.rotr = s;

    function o(a) {
        return typeof a == "number" && isFinite(a) && Math.floor(a) === a
    }
    t.isInteger = Number.isInteger || o, t.MAX_SAFE_INTEGER = 9007199254740991, t.isSafeInteger = function(a) {
        return t.isInteger(a) && a >= -t.MAX_SAFE_INTEGER && a <= t.MAX_SAFE_INTEGER
    }
})(Nte);
Object.defineProperty(An, "__esModule", {
    value: !0
});
var Pte = Nte;

function NEe(t, e) {
    return e === void 0 && (e = 0), (t[e + 0] << 8 | t[e + 1]) << 16 >> 16
}
An.readInt16BE = NEe;

function PEe(t, e) {
    return e === void 0 && (e = 0), (t[e + 0] << 8 | t[e + 1]) >>> 0
}
An.readUint16BE = PEe;

function kEe(t, e) {
    return e === void 0 && (e = 0), (t[e + 1] << 8 | t[e]) << 16 >> 16
}
An.readInt16LE = kEe;

function MEe(t, e) {
    return e === void 0 && (e = 0), (t[e + 1] << 8 | t[e]) >>> 0
}
An.readUint16LE = MEe;

function kte(t, e, n) {
    return e === void 0 && (e = new Uint8Array(2)), n === void 0 && (n = 0), e[n + 0] = t >>> 8, e[n + 1] = t >>> 0, e
}
An.writeUint16BE = kte;
An.writeInt16BE = kte;

function Mte(t, e, n) {
    return e === void 0 && (e = new Uint8Array(2)), n === void 0 && (n = 0), e[n + 0] = t >>> 0, e[n + 1] = t >>> 8, e
}
An.writeUint16LE = Mte;
An.writeInt16LE = Mte;

function QP(t, e) {
    return e === void 0 && (e = 0), t[e] << 24 | t[e + 1] << 16 | t[e + 2] << 8 | t[e + 3]
}
An.readInt32BE = QP;

function JP(t, e) {
    return e === void 0 && (e = 0), (t[e] << 24 | t[e + 1] << 16 | t[e + 2] << 8 | t[e + 3]) >>> 0
}
An.readUint32BE = JP;

function XP(t, e) {
    return e === void 0 && (e = 0), t[e + 3] << 24 | t[e + 2] << 16 | t[e + 1] << 8 | t[e]
}
An.readInt32LE = XP;

function ek(t, e) {
    return e === void 0 && (e = 0), (t[e + 3] << 24 | t[e + 2] << 16 | t[e + 1] << 8 | t[e]) >>> 0
}
An.readUint32LE = ek;

function SC(t, e, n) {
    return e === void 0 && (e = new Uint8Array(4)), n === void 0 && (n = 0), e[n + 0] = t >>> 24, e[n + 1] = t >>> 16, e[n + 2] = t >>> 8, e[n + 3] = t >>> 0, e
}
An.writeUint32BE = SC;
An.writeInt32BE = SC;

function CC(t, e, n) {
    return e === void 0 && (e = new Uint8Array(4)), n === void 0 && (n = 0), e[n + 0] = t >>> 0, e[n + 1] = t >>> 8, e[n + 2] = t >>> 16, e[n + 3] = t >>> 24, e
}
An.writeUint32LE = CC;
An.writeInt32LE = CC;

function DEe(t, e) {
    e === void 0 && (e = 0);
    var n = QP(t, e),
        r = QP(t, e + 4);
    return n * 4294967296 + r - (r >> 31) * 4294967296
}
An.readInt64BE = DEe;

function $Ee(t, e) {
    e === void 0 && (e = 0);
    var n = JP(t, e),
        r = JP(t, e + 4);
    return n * 4294967296 + r
}
An.readUint64BE = $Ee;

function LEe(t, e) {
    e === void 0 && (e = 0);
    var n = XP(t, e),
        r = XP(t, e + 4);
    return r * 4294967296 + n - (n >> 31) * 4294967296
}
An.readInt64LE = LEe;

function BEe(t, e) {
    e === void 0 && (e = 0);
    var n = ek(t, e),
        r = ek(t, e + 4);
    return r * 4294967296 + n
}
An.readUint64LE = BEe;

function Dte(t, e, n) {
    return e === void 0 && (e = new Uint8Array(8)), n === void 0 && (n = 0), SC(t / 4294967296 >>> 0, e, n), SC(t >>> 0, e, n + 4), e
}
An.writeUint64BE = Dte;
An.writeInt64BE = Dte;

function $te(t, e, n) {
    return e === void 0 && (e = new Uint8Array(8)), n === void 0 && (n = 0), CC(t >>> 0, e, n), CC(t / 4294967296 >>> 0, e, n + 4), e
}
An.writeUint64LE = $te;
An.writeInt64LE = $te;

function FEe(t, e, n) {
    if (n === void 0 && (n = 0), t % 8 !== 0) throw new Error("readUintBE supports only bitLengths divisible by 8");
    if (t / 8 > e.length - n) throw new Error("readUintBE: array is too short for the given bitLength");
    for (var r = 0, i = 1, s = t / 8 + n - 1; s >= n; s--) r += e[s] * i, i *= 256;
    return r
}
An.readUintBE = FEe;

function UEe(t, e, n) {
    if (n === void 0 && (n = 0), t % 8 !== 0) throw new Error("readUintLE supports only bitLengths divisible by 8");
    if (t / 8 > e.length - n) throw new Error("readUintLE: array is too short for the given bitLength");
    for (var r = 0, i = 1, s = n; s < n + t / 8; s++) r += e[s] * i, i *= 256;
    return r
}
An.readUintLE = UEe;

function jEe(t, e, n, r) {
    if (n === void 0 && (n = new Uint8Array(t / 8)), r === void 0 && (r = 0), t % 8 !== 0) throw new Error("writeUintBE supports only bitLengths divisible by 8");
    if (!Pte.isSafeInteger(e)) throw new Error("writeUintBE value must be an integer");
    for (var i = 1, s = t / 8 + r - 1; s >= r; s--) n[s] = e / i & 255, i *= 256;
    return n
}
An.writeUintBE = jEe;

function HEe(t, e, n, r) {
    if (n === void 0 && (n = new Uint8Array(t / 8)), r === void 0 && (r = 0), t % 8 !== 0) throw new Error("writeUintLE supports only bitLengths divisible by 8");
    if (!Pte.isSafeInteger(e)) throw new Error("writeUintLE value must be an integer");
    for (var i = 1, s = r; s < r + t / 8; s++) n[s] = e / i & 255, i *= 256;
    return n
}
An.writeUintLE = HEe;

function zEe(t, e) {
    e === void 0 && (e = 0);
    var n = new DataView(t.buffer, t.byteOffset, t.byteLength);
    return n.getFloat32(e)
}
An.readFloat32BE = zEe;

function WEe(t, e) {
    e === void 0 && (e = 0);
    var n = new DataView(t.buffer, t.byteOffset, t.byteLength);
    return n.getFloat32(e, !0)
}
An.readFloat32LE = WEe;

function VEe(t, e) {
    e === void 0 && (e = 0);
    var n = new DataView(t.buffer, t.byteOffset, t.byteLength);
    return n.getFloat64(e)
}
An.readFloat64BE = VEe;

function GEe(t, e) {
    e === void 0 && (e = 0);
    var n = new DataView(t.buffer, t.byteOffset, t.byteLength);
    return n.getFloat64(e, !0)
}
An.readFloat64LE = GEe;

function qEe(t, e, n) {
    e === void 0 && (e = new Uint8Array(4)), n === void 0 && (n = 0);
    var r = new DataView(e.buffer, e.byteOffset, e.byteLength);
    return r.setFloat32(n, t), e
}
An.writeFloat32BE = qEe;

function KEe(t, e, n) {
    e === void 0 && (e = new Uint8Array(4)), n === void 0 && (n = 0);
    var r = new DataView(e.buffer, e.byteOffset, e.byteLength);
    return r.setFloat32(n, t, !0), e
}
An.writeFloat32LE = KEe;

function YEe(t, e, n) {
    e === void 0 && (e = new Uint8Array(8)), n === void 0 && (n = 0);
    var r = new DataView(e.buffer, e.byteOffset, e.byteLength);
    return r.setFloat64(n, t), e
}
An.writeFloat64BE = YEe;

function ZEe(t, e, n) {
    e === void 0 && (e = new Uint8Array(8)), n === void 0 && (n = 0);
    var r = new DataView(e.buffer, e.byteOffset, e.byteLength);
    return r.setFloat64(n, t, !0), e
}
An.writeFloat64LE = ZEe;
var kl = {};
Object.defineProperty(kl, "__esModule", {
    value: !0
});

function QEe(t) {
    for (var e = 0; e < t.length; e++) t[e] = 0;
    return t
}
kl.wipe = QEe;
Object.defineProperty(MT, "__esModule", {
    value: !0
});
var yo = An,
    tk = kl,
    JEe = 20;

function XEe(t, e, n) {
    for (var r = 1634760805, i = 857760878, s = 2036477234, o = 1797285236, a = n[3] << 24 | n[2] << 16 | n[1] << 8 | n[0], l = n[7] << 24 | n[6] << 16 | n[5] << 8 | n[4], c = n[11] << 24 | n[10] << 16 | n[9] << 8 | n[8], u = n[15] << 24 | n[14] << 16 | n[13] << 8 | n[12], f = n[19] << 24 | n[18] << 16 | n[17] << 8 | n[16], h = n[23] << 24 | n[22] << 16 | n[21] << 8 | n[20], g = n[27] << 24 | n[26] << 16 | n[25] << 8 | n[24], y = n[31] << 24 | n[30] << 16 | n[29] << 8 | n[28], _ = e[3] << 24 | e[2] << 16 | e[1] << 8 | e[0], C = e[7] << 24 | e[6] << 16 | e[5] << 8 | e[4], b = e[11] << 24 | e[10] << 16 | e[9] << 8 | e[8], w = e[15] << 24 | e[14] << 16 | e[13] << 8 | e[12], S = r, I = i, P = s, M = o, A = a, E = l, $ = c, H = u, K = f, te = h, U = g, m = y, v = _, T = C, N = b, O = w, L = 0; L < JEe; L += 2) S = S + A | 0, v ^= S, v = v >>> 16 | v << 16, K = K + v | 0, A ^= K, A = A >>> 20 | A << 12, I = I + E | 0, T ^= I, T = T >>> 16 | T << 16, te = te + T | 0, E ^= te, E = E >>> 20 | E << 12, P = P + $ | 0, N ^= P, N = N >>> 16 | N << 16, U = U + N | 0, $ ^= U, $ = $ >>> 20 | $ << 12, M = M + H | 0, O ^= M, O = O >>> 16 | O << 16, m = m + O | 0, H ^= m, H = H >>> 20 | H << 12, P = P + $ | 0, N ^= P, N = N >>> 24 | N << 8, U = U + N | 0, $ ^= U, $ = $ >>> 25 | $ << 7, M = M + H | 0, O ^= M, O = O >>> 24 | O << 8, m = m + O | 0, H ^= m, H = H >>> 25 | H << 7, I = I + E | 0, T ^= I, T = T >>> 24 | T << 8, te = te + T | 0, E ^= te, E = E >>> 25 | E << 7, S = S + A | 0, v ^= S, v = v >>> 24 | v << 8, K = K + v | 0, A ^= K, A = A >>> 25 | A << 7, S = S + E | 0, O ^= S, O = O >>> 16 | O << 16, U = U + O | 0, E ^= U, E = E >>> 20 | E << 12, I = I + $ | 0, v ^= I, v = v >>> 16 | v << 16, m = m + v | 0, $ ^= m, $ = $ >>> 20 | $ << 12, P = P + H | 0, T ^= P, T = T >>> 16 | T << 16, K = K + T | 0, H ^= K, H = H >>> 20 | H << 12, M = M + A | 0, N ^= M, N = N >>> 16 | N << 16, te = te + N | 0, A ^= te, A = A >>> 20 | A << 12, P = P + H | 0, T ^= P, T = T >>> 24 | T << 8, K = K + T | 0, H ^= K, H = H >>> 25 | H << 7, M = M + A | 0, N ^= M, N = N >>> 24 | N << 8, te = te + N | 0, A ^= te, A = A >>> 25 | A << 7, I = I + $ | 0, v ^= I, v = v >>> 24 | v << 8, m = m + v | 0, $ ^= m, $ = $ >>> 25 | $ << 7, S = S + E | 0, O ^= S, O = O >>> 24 | O << 8, U = U + O | 0, E ^= U, E = E >>> 25 | E << 7;
    yo.writeUint32LE(S + r | 0, t, 0), yo.writeUint32LE(I + i | 0, t, 4), yo.writeUint32LE(P + s | 0, t, 8), yo.writeUint32LE(M + o | 0, t, 12), yo.writeUint32LE(A + a | 0, t, 16), yo.writeUint32LE(E + l | 0, t, 20), yo.writeUint32LE($ + c | 0, t, 24), yo.writeUint32LE(H + u | 0, t, 28), yo.writeUint32LE(K + f | 0, t, 32), yo.writeUint32LE(te + h | 0, t, 36), yo.writeUint32LE(U + g | 0, t, 40), yo.writeUint32LE(m + y | 0, t, 44), yo.writeUint32LE(v + _ | 0, t, 48), yo.writeUint32LE(T + C | 0, t, 52), yo.writeUint32LE(N + b | 0, t, 56), yo.writeUint32LE(O + w | 0, t, 60)
}

function Lte(t, e, n, r, i) {
    if (i === void 0 && (i = 0), t.length !== 32) throw new Error("ChaCha: key size must be 32 bytes");
    if (r.length < n.length) throw new Error("ChaCha: destination is shorter than source");
    var s, o;
    if (i === 0) {
        if (e.length !== 8 && e.length !== 12) throw new Error("ChaCha nonce must be 8 or 12 bytes");
        s = new Uint8Array(16), o = s.length - e.length, s.set(e, o)
    } else {
        if (e.length !== 16) throw new Error("ChaCha nonce with counter must be 16 bytes");
        s = e, o = i
    }
    for (var a = new Uint8Array(64), l = 0; l < n.length; l += 64) {
        XEe(a, s, t);
        for (var c = l; c < l + 64 && c < n.length; c++) r[c] = n[c] ^ a[c - l];
        t4e(s, 0, o)
    }
    return tk.wipe(a), i === 0 && tk.wipe(s), r
}
MT.streamXOR = Lte;

function e4e(t, e, n, r) {
    return r === void 0 && (r = 0), tk.wipe(n), Lte(t, e, n, n, r)
}
MT.stream = e4e;

function t4e(t, e, n) {
    for (var r = 1; n--;) r = r + (t[e] & 255) | 0, t[e] = r & 255, r >>>= 8, e++;
    if (r > 0) throw new Error("ChaCha: counter overflow")
}
var Bte = {},
    sg = {};
Object.defineProperty(sg, "__esModule", {
    value: !0
});

function n4e(t, e, n) {
    return ~(t - 1) & e | t - 1 & n
}
sg.select = n4e;

function r4e(t, e) {
    return (t | 0) - (e | 0) - 1 >>> 31 & 1
}
sg.lessOrEqual = r4e;

function Fte(t, e) {
    if (t.length !== e.length) return 0;
    for (var n = 0, r = 0; r < t.length; r++) n |= t[r] ^ e[r];
    return 1 & n - 1 >>> 8
}
sg.compare = Fte;

function i4e(t, e) {
    return t.length === 0 || e.length === 0 ? !1 : Fte(t, e) !== 0
}
sg.equal = i4e;
(function(t) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    var e = sg,
        n = kl;
    t.DIGEST_LENGTH = 16;
    var r = function() {
        function o(a) {
            this.digestLength = t.DIGEST_LENGTH, this._buffer = new Uint8Array(16), this._r = new Uint16Array(10), this._h = new Uint16Array(10), this._pad = new Uint16Array(8), this._leftover = 0, this._fin = 0, this._finished = !1;
            var l = a[0] | a[1] << 8;
            this._r[0] = l & 8191;
            var c = a[2] | a[3] << 8;
            this._r[1] = (l >>> 13 | c << 3) & 8191;
            var u = a[4] | a[5] << 8;
            this._r[2] = (c >>> 10 | u << 6) & 7939;
            var f = a[6] | a[7] << 8;
            this._r[3] = (u >>> 7 | f << 9) & 8191;
            var h = a[8] | a[9] << 8;
            this._r[4] = (f >>> 4 | h << 12) & 255, this._r[5] = h >>> 1 & 8190;
            var g = a[10] | a[11] << 8;
            this._r[6] = (h >>> 14 | g << 2) & 8191;
            var y = a[12] | a[13] << 8;
            this._r[7] = (g >>> 11 | y << 5) & 8065;
            var _ = a[14] | a[15] << 8;
            this._r[8] = (y >>> 8 | _ << 8) & 8191, this._r[9] = _ >>> 5 & 127, this._pad[0] = a[16] | a[17] << 8, this._pad[1] = a[18] | a[19] << 8, this._pad[2] = a[20] | a[21] << 8, this._pad[3] = a[22] | a[23] << 8, this._pad[4] = a[24] | a[25] << 8, this._pad[5] = a[26] | a[27] << 8, this._pad[6] = a[28] | a[29] << 8, this._pad[7] = a[30] | a[31] << 8
        }
        return o.prototype._blocks = function(a, l, c) {
            for (var u = this._fin ? 0 : 2048, f = this._h[0], h = this._h[1], g = this._h[2], y = this._h[3], _ = this._h[4], C = this._h[5], b = this._h[6], w = this._h[7], S = this._h[8], I = this._h[9], P = this._r[0], M = this._r[1], A = this._r[2], E = this._r[3], $ = this._r[4], H = this._r[5], K = this._r[6], te = this._r[7], U = this._r[8], m = this._r[9]; c >= 16;) {
                var v = a[l + 0] | a[l + 1] << 8;
                f += v & 8191;
                var T = a[l + 2] | a[l + 3] << 8;
                h += (v >>> 13 | T << 3) & 8191;
                var N = a[l + 4] | a[l + 5] << 8;
                g += (T >>> 10 | N << 6) & 8191;
                var O = a[l + 6] | a[l + 7] << 8;
                y += (N >>> 7 | O << 9) & 8191;
                var L = a[l + 8] | a[l + 9] << 8;
                _ += (O >>> 4 | L << 12) & 8191, C += L >>> 1 & 8191;
                var G = a[l + 10] | a[l + 11] << 8;
                b += (L >>> 14 | G << 2) & 8191;
                var j = a[l + 12] | a[l + 13] << 8;
                w += (G >>> 11 | j << 5) & 8191;
                var R = a[l + 14] | a[l + 15] << 8;
                S += (j >>> 8 | R << 8) & 8191, I += R >>> 5 | u;
                var Y = 0,
                    ve = Y;
                ve += f * P, ve += h * (5 * m), ve += g * (5 * U), ve += y * (5 * te), ve += _ * (5 * K), Y = ve >>> 13, ve &= 8191, ve += C * (5 * H), ve += b * (5 * $), ve += w * (5 * E), ve += S * (5 * A), ve += I * (5 * M), Y += ve >>> 13, ve &= 8191;
                var V = Y;
                V += f * M, V += h * P, V += g * (5 * m), V += y * (5 * U), V += _ * (5 * te), Y = V >>> 13, V &= 8191, V += C * (5 * K), V += b * (5 * H), V += w * (5 * $), V += S * (5 * E), V += I * (5 * A), Y += V >>> 13, V &= 8191;
                var X = Y;
                X += f * A, X += h * M, X += g * P, X += y * (5 * m), X += _ * (5 * U), Y = X >>> 13, X &= 8191, X += C * (5 * te), X += b * (5 * K), X += w * (5 * H), X += S * (5 * $), X += I * (5 * E), Y += X >>> 13, X &= 8191;
                var q = Y;
                q += f * E, q += h * A, q += g * M, q += y * P, q += _ * (5 * m), Y = q >>> 13, q &= 8191, q += C * (5 * U), q += b * (5 * te), q += w * (5 * K), q += S * (5 * H), q += I * (5 * $), Y += q >>> 13, q &= 8191;
                var ne = Y;
                ne += f * $, ne += h * E, ne += g * A, ne += y * M, ne += _ * P, Y = ne >>> 13, ne &= 8191, ne += C * (5 * m), ne += b * (5 * U), ne += w * (5 * te), ne += S * (5 * K), ne += I * (5 * H), Y += ne >>> 13, ne &= 8191;
                var ie = Y;
                ie += f * H, ie += h * $, ie += g * E, ie += y * A, ie += _ * M, Y = ie >>> 13, ie &= 8191, ie += C * P, ie += b * (5 * m), ie += w * (5 * U), ie += S * (5 * te), ie += I * (5 * K), Y += ie >>> 13, ie &= 8191;
                var k = Y;
                k += f * K, k += h * H, k += g * $, k += y * E, k += _ * A, Y = k >>> 13, k &= 8191, k += C * M, k += b * P, k += w * (5 * m), k += S * (5 * U), k += I * (5 * te), Y += k >>> 13, k &= 8191;
                var z = Y;
                z += f * te, z += h * K, z += g * H, z += y * $, z += _ * E, Y = z >>> 13, z &= 8191, z += C * A, z += b * M, z += w * P, z += S * (5 * m), z += I * (5 * U), Y += z >>> 13, z &= 8191;
                var Z = Y;
                Z += f * U, Z += h * te, Z += g * K, Z += y * H, Z += _ * $, Y = Z >>> 13, Z &= 8191, Z += C * E, Z += b * A, Z += w * M, Z += S * P, Z += I * (5 * m), Y += Z >>> 13, Z &= 8191;
                var ge = Y;
                ge += f * m, ge += h * U, ge += g * te, ge += y * K, ge += _ * H, Y = ge >>> 13, ge &= 8191, ge += C * $, ge += b * E, ge += w * A, ge += S * M, ge += I * P, Y += ge >>> 13, ge &= 8191, Y = (Y << 2) + Y | 0, Y = Y + ve | 0, ve = Y & 8191, Y = Y >>> 13, V += Y, f = ve, h = V, g = X, y = q, _ = ne, C = ie, b = k, w = z, S = Z, I = ge, l += 16, c -= 16
            }
            this._h[0] = f, this._h[1] = h, this._h[2] = g, this._h[3] = y, this._h[4] = _, this._h[5] = C, this._h[6] = b, this._h[7] = w, this._h[8] = S, this._h[9] = I
        }, o.prototype.finish = function(a, l) {
            l === void 0 && (l = 0);
            var c = new Uint16Array(10),
                u, f, h, g;
            if (this._leftover) {
                for (g = this._leftover, this._buffer[g++] = 1; g < 16; g++) this._buffer[g] = 0;
                this._fin = 1, this._blocks(this._buffer, 0, 16)
            }
            for (u = this._h[1] >>> 13, this._h[1] &= 8191, g = 2; g < 10; g++) this._h[g] += u, u = this._h[g] >>> 13, this._h[g] &= 8191;
            for (this._h[0] += u * 5, u = this._h[0] >>> 13, this._h[0] &= 8191, this._h[1] += u, u = this._h[1] >>> 13, this._h[1] &= 8191, this._h[2] += u, c[0] = this._h[0] + 5, u = c[0] >>> 13, c[0] &= 8191, g = 1; g < 10; g++) c[g] = this._h[g] + u, u = c[g] >>> 13, c[g] &= 8191;
            for (c[9] -= 8192, f = (u ^ 1) - 1, g = 0; g < 10; g++) c[g] &= f;
            for (f = ~f, g = 0; g < 10; g++) this._h[g] = this._h[g] & f | c[g];
            for (this._h[0] = (this._h[0] | this._h[1] << 13) & 65535, this._h[1] = (this._h[1] >>> 3 | this._h[2] << 10) & 65535, this._h[2] = (this._h[2] >>> 6 | this._h[3] << 7) & 65535, this._h[3] = (this._h[3] >>> 9 | this._h[4] << 4) & 65535, this._h[4] = (this._h[4] >>> 12 | this._h[5] << 1 | this._h[6] << 14) & 65535, this._h[5] = (this._h[6] >>> 2 | this._h[7] << 11) & 65535, this._h[6] = (this._h[7] >>> 5 | this._h[8] << 8) & 65535, this._h[7] = (this._h[8] >>> 8 | this._h[9] << 5) & 65535, h = this._h[0] + this._pad[0], this._h[0] = h & 65535, g = 1; g < 8; g++) h = (this._h[g] + this._pad[g] | 0) + (h >>> 16) | 0, this._h[g] = h & 65535;
            return a[l + 0] = this._h[0] >>> 0, a[l + 1] = this._h[0] >>> 8, a[l + 2] = this._h[1] >>> 0, a[l + 3] = this._h[1] >>> 8, a[l + 4] = this._h[2] >>> 0, a[l + 5] = this._h[2] >>> 8, a[l + 6] = this._h[3] >>> 0, a[l + 7] = this._h[3] >>> 8, a[l + 8] = this._h[4] >>> 0, a[l + 9] = this._h[4] >>> 8, a[l + 10] = this._h[5] >>> 0, a[l + 11] = this._h[5] >>> 8, a[l + 12] = this._h[6] >>> 0, a[l + 13] = this._h[6] >>> 8, a[l + 14] = this._h[7] >>> 0, a[l + 15] = this._h[7] >>> 8, this._finished = !0, this
        }, o.prototype.update = function(a) {
            var l = 0,
                c = a.length,
                u;
            if (this._leftover) {
                u = 16 - this._leftover, u > c && (u = c);
                for (var f = 0; f < u; f++) this._buffer[this._leftover + f] = a[l + f];
                if (c -= u, l += u, this._leftover += u, this._leftover < 16) return this;
                this._blocks(this._buffer, 0, 16), this._leftover = 0
            }
            if (c >= 16 && (u = c - c % 16, this._blocks(a, l, u), l += u, c -= u), c) {
                for (var f = 0; f < c; f++) this._buffer[this._leftover + f] = a[l + f];
                this._leftover += c
            }
            return this
        }, o.prototype.digest = function() {
            if (this._finished) throw new Error("Poly1305 was finished");
            var a = new Uint8Array(16);
            return this.finish(a), a
        }, o.prototype.clean = function() {
            return n.wipe(this._buffer), n.wipe(this._r), n.wipe(this._h), n.wipe(this._pad), this._leftover = 0, this._fin = 0, this._finished = !0, this
        }, o
    }();
    t.Poly1305 = r;

    function i(o, a) {
        var l = new r(o);
        l.update(a);
        var c = l.digest();
        return l.clean(), c
    }
    t.oneTimeAuth = i;

    function s(o, a) {
        return o.length !== t.DIGEST_LENGTH || a.length !== t.DIGEST_LENGTH ? !1 : e.equal(o, a)
    }
    t.equal = s
})(Bte);
(function(t) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    var e = MT,
        n = Bte,
        r = kl,
        i = An,
        s = sg;
    t.KEY_LENGTH = 32, t.NONCE_LENGTH = 12, t.TAG_LENGTH = 16;
    var o = new Uint8Array(16),
        a = function() {
            function l(c) {
                if (this.nonceLength = t.NONCE_LENGTH, this.tagLength = t.TAG_LENGTH, c.length !== t.KEY_LENGTH) throw new Error("ChaCha20Poly1305 needs 32-byte key");
                this._key = new Uint8Array(c)
            }
            return l.prototype.seal = function(c, u, f, h) {
                if (c.length > 16) throw new Error("ChaCha20Poly1305: incorrect nonce length");
                var g = new Uint8Array(16);
                g.set(c, g.length - c.length);
                var y = new Uint8Array(32);
                e.stream(this._key, g, y, 4);
                var _ = u.length + this.tagLength,
                    C;
                if (h) {
                    if (h.length !== _) throw new Error("ChaCha20Poly1305: incorrect destination length");
                    C = h
                } else C = new Uint8Array(_);
                return e.streamXOR(this._key, g, u, C, 4), this._authenticate(C.subarray(C.length - this.tagLength, C.length), y, C.subarray(0, C.length - this.tagLength), f), r.wipe(g), C
            }, l.prototype.open = function(c, u, f, h) {
                if (c.length > 16) throw new Error("ChaCha20Poly1305: incorrect nonce length");
                if (u.length < this.tagLength) return null;
                var g = new Uint8Array(16);
                g.set(c, g.length - c.length);
                var y = new Uint8Array(32);
                e.stream(this._key, g, y, 4);
                var _ = new Uint8Array(this.tagLength);
                if (this._authenticate(_, y, u.subarray(0, u.length - this.tagLength), f), !s.equal(_, u.subarray(u.length - this.tagLength, u.length))) return null;
                var C = u.length - this.tagLength,
                    b;
                if (h) {
                    if (h.length !== C) throw new Error("ChaCha20Poly1305: incorrect destination length");
                    b = h
                } else b = new Uint8Array(C);
                return e.streamXOR(this._key, g, u.subarray(0, u.length - this.tagLength), b, 4), r.wipe(g), b
            }, l.prototype.clean = function() {
                return r.wipe(this._key), this
            }, l.prototype._authenticate = function(c, u, f, h) {
                var g = new n.Poly1305(u);
                h && (g.update(h), h.length % 16 > 0 && g.update(o.subarray(h.length % 16))), g.update(f), f.length % 16 > 0 && g.update(o.subarray(f.length % 16));
                var y = new Uint8Array(8);
                h && i.writeUint64LE(h.length, y), g.update(y), i.writeUint64LE(f.length, y), g.update(y);
                for (var _ = g.digest(), C = 0; C < _.length; C++) c[C] = _[C];
                g.clean(), r.wipe(_), r.wipe(y)
            }, l
        }();
    t.ChaCha20Poly1305 = a
})(tL);
var Ute = {},
    wE = {},
    nL = {};
Object.defineProperty(nL, "__esModule", {
    value: !0
});

function s4e(t) {
    return typeof t.saveState < "u" && typeof t.restoreState < "u" && typeof t.cleanSavedState < "u"
}
nL.isSerializableHash = s4e;
Object.defineProperty(wE, "__esModule", {
    value: !0
});
var nf = nL,
    o4e = sg,
    a4e = kl,
    jte = function() {
        function t(e, n) {
            this._finished = !1, this._inner = new e, this._outer = new e, this.blockSize = this._outer.blockSize, this.digestLength = this._outer.digestLength;
            var r = new Uint8Array(this.blockSize);
            n.length > this.blockSize ? this._inner.update(n).finish(r).clean() : r.set(n);
            for (var i = 0; i < r.length; i++) r[i] ^= 54;
            this._inner.update(r);
            for (var i = 0; i < r.length; i++) r[i] ^= 106;
            this._outer.update(r), nf.isSerializableHash(this._inner) && nf.isSerializableHash(this._outer) && (this._innerKeyedState = this._inner.saveState(), this._outerKeyedState = this._outer.saveState()), a4e.wipe(r)
        }
        return t.prototype.reset = function() {
            if (!nf.isSerializableHash(this._inner) || !nf.isSerializableHash(this._outer)) throw new Error("hmac: can't reset() because hash doesn't implement restoreState()");
            return this._inner.restoreState(this._innerKeyedState), this._outer.restoreState(this._outerKeyedState), this._finished = !1, this
        }, t.prototype.clean = function() {
            nf.isSerializableHash(this._inner) && this._inner.cleanSavedState(this._innerKeyedState), nf.isSerializableHash(this._outer) && this._outer.cleanSavedState(this._outerKeyedState), this._inner.clean(), this._outer.clean()
        }, t.prototype.update = function(e) {
            return this._inner.update(e), this
        }, t.prototype.finish = function(e) {
            return this._finished ? (this._outer.finish(e), this) : (this._inner.finish(e), this._outer.update(e.subarray(0, this.digestLength)).finish(e), this._finished = !0, this)
        }, t.prototype.digest = function() {
            var e = new Uint8Array(this.digestLength);
            return this.finish(e), e
        }, t.prototype.saveState = function() {
            if (!nf.isSerializableHash(this._inner)) throw new Error("hmac: can't saveState() because hash doesn't implement it");
            return this._inner.saveState()
        }, t.prototype.restoreState = function(e) {
            if (!nf.isSerializableHash(this._inner) || !nf.isSerializableHash(this._outer)) throw new Error("hmac: can't restoreState() because hash doesn't implement it");
            return this._inner.restoreState(e), this._outer.restoreState(this._outerKeyedState), this._finished = !1, this
        }, t.prototype.cleanSavedState = function(e) {
            if (!nf.isSerializableHash(this._inner)) throw new Error("hmac: can't cleanSavedState() because hash doesn't implement it");
            this._inner.cleanSavedState(e)
        }, t
    }();
wE.HMAC = jte;

function l4e(t, e, n) {
    var r = new jte(t, e);
    r.update(n);
    var i = r.digest();
    return r.clean(), i
}
wE.hmac = l4e;
wE.equal = o4e.equal;
Object.defineProperty(Ute, "__esModule", {
    value: !0
});
var wW = wE,
    vW = kl,
    c4e = function() {
        function t(e, n, r, i) {
            r === void 0 && (r = new Uint8Array(0)), this._counter = new Uint8Array(1), this._hash = e, this._info = i;
            var s = wW.hmac(this._hash, r, n);
            this._hmac = new wW.HMAC(e, s), this._buffer = new Uint8Array(this._hmac.digestLength), this._bufpos = this._buffer.length
        }
        return t.prototype._fillBuffer = function() {
            this._counter[0]++;
            var e = this._counter[0];
            if (e === 0) throw new Error("hkdf: cannot expand more");
            this._hmac.reset(), e > 1 && this._hmac.update(this._buffer), this._info && this._hmac.update(this._info), this._hmac.update(this._counter), this._hmac.finish(this._buffer), this._bufpos = 0
        }, t.prototype.expand = function(e) {
            for (var n = new Uint8Array(e), r = 0; r < n.length; r++) this._bufpos === this._buffer.length && this._fillBuffer(), n[r] = this._buffer[this._bufpos++];
            return n
        }, t.prototype.clean = function() {
            this._hmac.clean(), vW.wipe(this._buffer), vW.wipe(this._counter), this._bufpos = 0
        }, t
    }(),
    u4e = Ute.HKDF = c4e,
    T2 = {},
    DT = {},
    $T = {};
Object.defineProperty($T, "__esModule", {
    value: !0
});
$T.BrowserRandomSource = void 0;
const bW = 65536;
class f4e {
    constructor() {
        this.isAvailable = !1, this.isInstantiated = !1;
        const e = typeof self < "u" ? self.crypto || self.msCrypto : null;
        e && e.getRandomValues !== void 0 && (this._crypto = e, this.isAvailable = !0, this.isInstantiated = !0)
    }
    randomBytes(e) {
        if (!this.isAvailable || !this._crypto) throw new Error("Browser random byte generator is not available.");
        const n = new Uint8Array(e);
        for (let r = 0; r < n.length; r += bW) this._crypto.getRandomValues(n.subarray(r, r + Math.min(n.length - r, bW)));
        return n
    }
}
$T.BrowserRandomSource = f4e;

function d4e(t) {
    throw new Error('Could not dynamically require "' + t + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.')
}
var LT = {};
const h4e = {},
    p4e = Object.freeze(Object.defineProperty({
        __proto__: null,
        default: h4e
    }, Symbol.toStringTag, {
        value: "Module"
    })),
    vE = Fu(p4e);
Object.defineProperty(LT, "__esModule", {
    value: !0
});
LT.NodeRandomSource = void 0;
const g4e = kl;
class m4e {
    constructor() {
        if (this.isAvailable = !1, this.isInstantiated = !1, typeof d4e < "u") {
            const e = vE;
            e && e.randomBytes && (this._crypto = e, this.isAvailable = !0, this.isInstantiated = !0)
        }
    }
    randomBytes(e) {
        if (!this.isAvailable || !this._crypto) throw new Error("Node.js random byte generator is not available.");
        let n = this._crypto.randomBytes(e);
        if (n.length !== e) throw new Error("NodeRandomSource: got fewer bytes than requested");
        const r = new Uint8Array(e);
        for (let i = 0; i < r.length; i++) r[i] = n[i];
        return (0, g4e.wipe)(n), r
    }
}
LT.NodeRandomSource = m4e;
Object.defineProperty(DT, "__esModule", {
    value: !0
});
DT.SystemRandomSource = void 0;
const y4e = $T,
    w4e = LT;
class v4e {
    constructor() {
        if (this.isAvailable = !1, this.name = "", this._source = new y4e.BrowserRandomSource, this._source.isAvailable) {
            this.isAvailable = !0, this.name = "Browser";
            return
        }
        if (this._source = new w4e.NodeRandomSource, this._source.isAvailable) {
            this.isAvailable = !0, this.name = "Node";
            return
        }
    }
    randomBytes(e) {
        if (!this.isAvailable) throw new Error("System random byte generator is not available.");
        return this._source.randomBytes(e)
    }
}
DT.SystemRandomSource = v4e;
(function(t) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    }), t.randomStringForEntropy = t.randomString = t.randomUint32 = t.randomBytes = t.defaultRandomSource = void 0;
    const e = DT,
        n = An,
        r = kl;
    t.defaultRandomSource = new e.SystemRandomSource;

    function i(c, u = t.defaultRandomSource) {
        return u.randomBytes(c)
    }
    t.randomBytes = i;

    function s(c = t.defaultRandomSource) {
        const u = i(4, c),
            f = (0, n.readUint32LE)(u);
        return (0, r.wipe)(u), f
    }
    t.randomUint32 = s;
    const o = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";

    function a(c, u = o, f = t.defaultRandomSource) {
        if (u.length < 2) throw new Error("randomString charset is too short");
        if (u.length > 256) throw new Error("randomString charset is too long");
        let h = "";
        const g = u.length,
            y = 256 - 256 % g;
        for (; c > 0;) {
            const _ = i(Math.ceil(c * 256 / y), f);
            for (let C = 0; C < _.length && c > 0; C++) {
                const b = _[C];
                b < y && (h += u.charAt(b % g), c--)
            }(0, r.wipe)(_)
        }
        return h
    }
    t.randomString = a;

    function l(c, u = o, f = t.defaultRandomSource) {
        const h = Math.ceil(c / (Math.log(u.length) / Math.LN2));
        return a(h, u, f)
    }
    t.randomStringForEntropy = l
})(T2);
var BT = {};
(function(t) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    var e = An,
        n = kl;
    t.DIGEST_LENGTH = 32, t.BLOCK_SIZE = 64;
    var r = function() {
        function a() {
            this.digestLength = t.DIGEST_LENGTH, this.blockSize = t.BLOCK_SIZE, this._state = new Int32Array(8), this._temp = new Int32Array(64), this._buffer = new Uint8Array(128), this._bufferLength = 0, this._bytesHashed = 0, this._finished = !1, this.reset()
        }
        return a.prototype._initState = function() {
            this._state[0] = 1779033703, this._state[1] = 3144134277, this._state[2] = 1013904242, this._state[3] = 2773480762, this._state[4] = 1359893119, this._state[5] = 2600822924, this._state[6] = 528734635, this._state[7] = 1541459225
        }, a.prototype.reset = function() {
            return this._initState(), this._bufferLength = 0, this._bytesHashed = 0, this._finished = !1, this
        }, a.prototype.clean = function() {
            n.wipe(this._buffer), n.wipe(this._temp), this.reset()
        }, a.prototype.update = function(l, c) {
            if (c === void 0 && (c = l.length), this._finished) throw new Error("SHA256: can't update because hash was finished.");
            var u = 0;
            if (this._bytesHashed += c, this._bufferLength > 0) {
                for (; this._bufferLength < this.blockSize && c > 0;) this._buffer[this._bufferLength++] = l[u++], c--;
                this._bufferLength === this.blockSize && (s(this._temp, this._state, this._buffer, 0, this.blockSize), this._bufferLength = 0)
            }
            for (c >= this.blockSize && (u = s(this._temp, this._state, l, u, c), c %= this.blockSize); c > 0;) this._buffer[this._bufferLength++] = l[u++], c--;
            return this
        }, a.prototype.finish = function(l) {
            if (!this._finished) {
                var c = this._bytesHashed,
                    u = this._bufferLength,
                    f = c / 536870912 | 0,
                    h = c << 3,
                    g = c % 64 < 56 ? 64 : 128;
                this._buffer[u] = 128;
                for (var y = u + 1; y < g - 8; y++) this._buffer[y] = 0;
                e.writeUint32BE(f, this._buffer, g - 8), e.writeUint32BE(h, this._buffer, g - 4), s(this._temp, this._state, this._buffer, 0, g), this._finished = !0
            }
            for (var y = 0; y < this.digestLength / 4; y++) e.writeUint32BE(this._state[y], l, y * 4);
            return this
        }, a.prototype.digest = function() {
            var l = new Uint8Array(this.digestLength);
            return this.finish(l), l
        }, a.prototype.saveState = function() {
            if (this._finished) throw new Error("SHA256: cannot save finished state");
            return {
                state: new Int32Array(this._state),
                buffer: this._bufferLength > 0 ? new Uint8Array(this._buffer) : void 0,
                bufferLength: this._bufferLength,
                bytesHashed: this._bytesHashed
            }
        }, a.prototype.restoreState = function(l) {
            return this._state.set(l.state), this._bufferLength = l.bufferLength, l.buffer && this._buffer.set(l.buffer), this._bytesHashed = l.bytesHashed, this._finished = !1, this
        }, a.prototype.cleanSavedState = function(l) {
            n.wipe(l.state), l.buffer && n.wipe(l.buffer), l.bufferLength = 0, l.bytesHashed = 0
        }, a
    }();
    t.SHA256 = r;
    var i = new Int32Array([1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298]);

    function s(a, l, c, u, f) {
        for (; f >= 64;) {
            for (var h = l[0], g = l[1], y = l[2], _ = l[3], C = l[4], b = l[5], w = l[6], S = l[7], I = 0; I < 16; I++) {
                var P = u + I * 4;
                a[I] = e.readUint32BE(c, P)
            }
            for (var I = 16; I < 64; I++) {
                var M = a[I - 2],
                    A = (M >>> 17 | M << 15) ^ (M >>> 19 | M << 13) ^ M >>> 10;
                M = a[I - 15];
                var E = (M >>> 7 | M << 25) ^ (M >>> 18 | M << 14) ^ M >>> 3;
                a[I] = (A + a[I - 7] | 0) + (E + a[I - 16] | 0)
            }
            for (var I = 0; I < 64; I++) {
                var A = (((C >>> 6 | C << 26) ^ (C >>> 11 | C << 21) ^ (C >>> 25 | C << 7)) + (C & b ^ ~C & w) | 0) + (S + (i[I] + a[I] | 0) | 0) | 0,
                    E = ((h >>> 2 | h << 30) ^ (h >>> 13 | h << 19) ^ (h >>> 22 | h << 10)) + (h & g ^ h & y ^ g & y) | 0;
                S = w, w = b, b = C, C = _ + A | 0, _ = y, y = g, g = h, h = A + E | 0
            }
            l[0] += h, l[1] += g, l[2] += y, l[3] += _, l[4] += C, l[5] += b, l[6] += w, l[7] += S, u += 64, f -= 64
        }
        return u
    }

    function o(a) {
        var l = new r;
        l.update(a);
        var c = l.digest();
        return l.clean(), c
    }
    t.hash = o
})(BT);
var rL = {};
(function(t) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    }), t.sharedKey = t.generateKeyPair = t.generateKeyPairFromSeed = t.scalarMultBase = t.scalarMult = t.SHARED_KEY_LENGTH = t.SECRET_KEY_LENGTH = t.PUBLIC_KEY_LENGTH = void 0;
    const e = T2,
        n = kl;
    t.PUBLIC_KEY_LENGTH = 32, t.SECRET_KEY_LENGTH = 32, t.SHARED_KEY_LENGTH = 32;

    function r(I) {
        const P = new Float64Array(16);
        if (I)
            for (let M = 0; M < I.length; M++) P[M] = I[M];
        return P
    }
    const i = new Uint8Array(32);
    i[0] = 9;
    const s = r([56129, 1]);

    function o(I) {
        let P = 1;
        for (let M = 0; M < 16; M++) {
            let A = I[M] + P + 65535;
            P = Math.floor(A / 65536), I[M] = A - P * 65536
        }
        I[0] += P - 1 + 37 * (P - 1)
    }

    function a(I, P, M) {
        const A = ~(M - 1);
        for (let E = 0; E < 16; E++) {
            const $ = A & (I[E] ^ P[E]);
            I[E] ^= $, P[E] ^= $
        }
    }

    function l(I, P) {
        const M = r(),
            A = r();
        for (let E = 0; E < 16; E++) A[E] = P[E];
        o(A), o(A), o(A);
        for (let E = 0; E < 2; E++) {
            M[0] = A[0] - 65517;
            for (let H = 1; H < 15; H++) M[H] = A[H] - 65535 - (M[H - 1] >> 16 & 1), M[H - 1] &= 65535;
            M[15] = A[15] - 32767 - (M[14] >> 16 & 1);
            const $ = M[15] >> 16 & 1;
            M[14] &= 65535, a(A, M, 1 - $)
        }
        for (let E = 0; E < 16; E++) I[2 * E] = A[E] & 255, I[2 * E + 1] = A[E] >> 8
    }

    function c(I, P) {
        for (let M = 0; M < 16; M++) I[M] = P[2 * M] + (P[2 * M + 1] << 8);
        I[15] &= 32767
    }

    function u(I, P, M) {
        for (let A = 0; A < 16; A++) I[A] = P[A] + M[A]
    }

    function f(I, P, M) {
        for (let A = 0; A < 16; A++) I[A] = P[A] - M[A]
    }

    function h(I, P, M) {
        let A, E, $ = 0,
            H = 0,
            K = 0,
            te = 0,
            U = 0,
            m = 0,
            v = 0,
            T = 0,
            N = 0,
            O = 0,
            L = 0,
            G = 0,
            j = 0,
            R = 0,
            Y = 0,
            ve = 0,
            V = 0,
            X = 0,
            q = 0,
            ne = 0,
            ie = 0,
            k = 0,
            z = 0,
            Z = 0,
            ge = 0,
            me = 0,
            Re = 0,
            He = 0,
            Be = 0,
            bt = 0,
            mn = 0,
            at = M[0],
            tt = M[1],
            _t = M[2],
            ot = M[3],
            lt = M[4],
            wt = M[5],
            Xe = M[6],
            Q = M[7],
            D = M[8],
            B = M[9],
            se = M[10],
            de = M[11],
            ye = M[12],
            Se = M[13],
            nt = M[14],
            Ke = M[15];
        A = P[0], $ += A * at, H += A * tt, K += A * _t, te += A * ot, U += A * lt, m += A * wt, v += A * Xe, T += A * Q, N += A * D, O += A * B, L += A * se, G += A * de, j += A * ye, R += A * Se, Y += A * nt, ve += A * Ke, A = P[1], H += A * at, K += A * tt, te += A * _t, U += A * ot, m += A * lt, v += A * wt, T += A * Xe, N += A * Q, O += A * D, L += A * B, G += A * se, j += A * de, R += A * ye, Y += A * Se, ve += A * nt, V += A * Ke, A = P[2], K += A * at, te += A * tt, U += A * _t, m += A * ot, v += A * lt, T += A * wt, N += A * Xe, O += A * Q, L += A * D, G += A * B, j += A * se, R += A * de, Y += A * ye, ve += A * Se, V += A * nt, X += A * Ke, A = P[3], te += A * at, U += A * tt, m += A * _t, v += A * ot, T += A * lt, N += A * wt, O += A * Xe, L += A * Q, G += A * D, j += A * B, R += A * se, Y += A * de, ve += A * ye, V += A * Se, X += A * nt, q += A * Ke, A = P[4], U += A * at, m += A * tt, v += A * _t, T += A * ot, N += A * lt, O += A * wt, L += A * Xe, G += A * Q, j += A * D, R += A * B, Y += A * se, ve += A * de, V += A * ye, X += A * Se, q += A * nt, ne += A * Ke, A = P[5], m += A * at, v += A * tt, T += A * _t, N += A * ot, O += A * lt, L += A * wt, G += A * Xe, j += A * Q, R += A * D, Y += A * B, ve += A * se, V += A * de, X += A * ye, q += A * Se, ne += A * nt, ie += A * Ke, A = P[6], v += A * at, T += A * tt, N += A * _t, O += A * ot, L += A * lt, G += A * wt, j += A * Xe, R += A * Q, Y += A * D, ve += A * B, V += A * se, X += A * de, q += A * ye, ne += A * Se, ie += A * nt, k += A * Ke, A = P[7], T += A * at, N += A * tt, O += A * _t, L += A * ot, G += A * lt, j += A * wt, R += A * Xe, Y += A * Q, ve += A * D, V += A * B, X += A * se, q += A * de, ne += A * ye, ie += A * Se, k += A * nt, z += A * Ke, A = P[8], N += A * at, O += A * tt, L += A * _t, G += A * ot, j += A * lt, R += A * wt, Y += A * Xe, ve += A * Q, V += A * D, X += A * B, q += A * se, ne += A * de, ie += A * ye, k += A * Se, z += A * nt, Z += A * Ke, A = P[9], O += A * at, L += A * tt, G += A * _t, j += A * ot, R += A * lt, Y += A * wt, ve += A * Xe, V += A * Q, X += A * D, q += A * B, ne += A * se, ie += A * de, k += A * ye, z += A * Se, Z += A * nt, ge += A * Ke, A = P[10], L += A * at, G += A * tt, j += A * _t, R += A * ot, Y += A * lt, ve += A * wt, V += A * Xe, X += A * Q, q += A * D, ne += A * B, ie += A * se, k += A * de, z += A * ye, Z += A * Se, ge += A * nt, me += A * Ke, A = P[11], G += A * at, j += A * tt, R += A * _t, Y += A * ot, ve += A * lt, V += A * wt, X += A * Xe, q += A * Q, ne += A * D, ie += A * B, k += A * se, z += A * de, Z += A * ye, ge += A * Se, me += A * nt, Re += A * Ke, A = P[12], j += A * at, R += A * tt, Y += A * _t, ve += A * ot, V += A * lt, X += A * wt, q += A * Xe, ne += A * Q, ie += A * D, k += A * B, z += A * se, Z += A * de, ge += A * ye, me += A * Se, Re += A * nt, He += A * Ke, A = P[13], R += A * at, Y += A * tt, ve += A * _t, V += A * ot, X += A * lt, q += A * wt, ne += A * Xe, ie += A * Q, k += A * D, z += A * B, Z += A * se, ge += A * de, me += A * ye, Re += A * Se, He += A * nt, Be += A * Ke, A = P[14], Y += A * at, ve += A * tt, V += A * _t, X += A * ot, q += A * lt, ne += A * wt, ie += A * Xe, k += A * Q, z += A * D, Z += A * B, ge += A * se, me += A * de, Re += A * ye, He += A * Se, Be += A * nt, bt += A * Ke, A = P[15], ve += A * at, V += A * tt, X += A * _t, q += A * ot, ne += A * lt, ie += A * wt, k += A * Xe, z += A * Q, Z += A * D, ge += A * B, me += A * se, Re += A * de, He += A * ye, Be += A * Se, bt += A * nt, mn += A * Ke, $ += 38 * V, H += 38 * X, K += 38 * q, te += 38 * ne, U += 38 * ie, m += 38 * k, v += 38 * z, T += 38 * Z, N += 38 * ge, O += 38 * me, L += 38 * Re, G += 38 * He, j += 38 * Be, R += 38 * bt, Y += 38 * mn, E = 1, A = $ + E + 65535, E = Math.floor(A / 65536), $ = A - E * 65536, A = H + E + 65535, E = Math.floor(A / 65536), H = A - E * 65536, A = K + E + 65535, E = Math.floor(A / 65536), K = A - E * 65536, A = te + E + 65535, E = Math.floor(A / 65536), te = A - E * 65536, A = U + E + 65535, E = Math.floor(A / 65536), U = A - E * 65536, A = m + E + 65535, E = Math.floor(A / 65536), m = A - E * 65536, A = v + E + 65535, E = Math.floor(A / 65536), v = A - E * 65536, A = T + E + 65535, E = Math.floor(A / 65536), T = A - E * 65536, A = N + E + 65535, E = Math.floor(A / 65536), N = A - E * 65536, A = O + E + 65535, E = Math.floor(A / 65536), O = A - E * 65536, A = L + E + 65535, E = Math.floor(A / 65536), L = A - E * 65536, A = G + E + 65535, E = Math.floor(A / 65536), G = A - E * 65536, A = j + E + 65535, E = Math.floor(A / 65536), j = A - E * 65536, A = R + E + 65535, E = Math.floor(A / 65536), R = A - E * 65536, A = Y + E + 65535, E = Math.floor(A / 65536), Y = A - E * 65536, A = ve + E + 65535, E = Math.floor(A / 65536), ve = A - E * 65536, $ += E - 1 + 37 * (E - 1), E = 1, A = $ + E + 65535, E = Math.floor(A / 65536), $ = A - E * 65536, A = H + E + 65535, E = Math.floor(A / 65536), H = A - E * 65536, A = K + E + 65535, E = Math.floor(A / 65536), K = A - E * 65536, A = te + E + 65535, E = Math.floor(A / 65536), te = A - E * 65536, A = U + E + 65535, E = Math.floor(A / 65536), U = A - E * 65536, A = m + E + 65535, E = Math.floor(A / 65536), m = A - E * 65536, A = v + E + 65535, E = Math.floor(A / 65536), v = A - E * 65536, A = T + E + 65535, E = Math.floor(A / 65536), T = A - E * 65536, A = N + E + 65535, E = Math.floor(A / 65536), N = A - E * 65536, A = O + E + 65535, E = Math.floor(A / 65536), O = A - E * 65536, A = L + E + 65535, E = Math.floor(A / 65536), L = A - E * 65536, A = G + E + 65535, E = Math.floor(A / 65536), G = A - E * 65536, A = j + E + 65535, E = Math.floor(A / 65536), j = A - E * 65536, A = R + E + 65535, E = Math.floor(A / 65536), R = A - E * 65536, A = Y + E + 65535, E = Math.floor(A / 65536), Y = A - E * 65536, A = ve + E + 65535, E = Math.floor(A / 65536), ve = A - E * 65536, $ += E - 1 + 37 * (E - 1), I[0] = $, I[1] = H, I[2] = K, I[3] = te, I[4] = U, I[5] = m, I[6] = v, I[7] = T, I[8] = N, I[9] = O, I[10] = L, I[11] = G, I[12] = j, I[13] = R, I[14] = Y, I[15] = ve
    }

    function g(I, P) {
        h(I, P, P)
    }

    function y(I, P) {
        const M = r();
        for (let A = 0; A < 16; A++) M[A] = P[A];
        for (let A = 253; A >= 0; A--) g(M, M), A !== 2 && A !== 4 && h(M, M, P);
        for (let A = 0; A < 16; A++) I[A] = M[A]
    }

    function _(I, P) {
        const M = new Uint8Array(32),
            A = new Float64Array(80),
            E = r(),
            $ = r(),
            H = r(),
            K = r(),
            te = r(),
            U = r();
        for (let N = 0; N < 31; N++) M[N] = I[N];
        M[31] = I[31] & 127 | 64, M[0] &= 248, c(A, P);
        for (let N = 0; N < 16; N++) $[N] = A[N];
        E[0] = K[0] = 1;
        for (let N = 254; N >= 0; --N) {
            const O = M[N >>> 3] >>> (N & 7) & 1;
            a(E, $, O), a(H, K, O), u(te, E, H), f(E, E, H), u(H, $, K), f($, $, K), g(K, te), g(U, E), h(E, H, E), h(H, $, te), u(te, E, H), f(E, E, H), g($, E), f(H, K, U), h(E, H, s), u(E, E, K), h(H, H, E), h(E, K, U), h(K, $, A), g($, te), a(E, $, O), a(H, K, O)
        }
        for (let N = 0; N < 16; N++) A[N + 16] = E[N], A[N + 32] = H[N], A[N + 48] = $[N], A[N + 64] = K[N];
        const m = A.subarray(32),
            v = A.subarray(16);
        y(m, m), h(v, v, m);
        const T = new Uint8Array(32);
        return l(T, v), T
    }
    t.scalarMult = _;

    function C(I) {
        return _(I, i)
    }
    t.scalarMultBase = C;

    function b(I) {
        if (I.length !== t.SECRET_KEY_LENGTH) throw new Error(`x25519: seed must be ${t.SECRET_KEY_LENGTH} bytes`);
        const P = new Uint8Array(I);
        return {
            publicKey: C(P),
            secretKey: P
        }
    }
    t.generateKeyPairFromSeed = b;

    function w(I) {
        const P = (0, e.randomBytes)(32, I),
            M = b(P);
        return (0, n.wipe)(P), M
    }
    t.generateKeyPair = w;

    function S(I, P, M = !1) {
        if (I.length !== t.PUBLIC_KEY_LENGTH) throw new Error("X25519: incorrect secret key length");
        if (P.length !== t.PUBLIC_KEY_LENGTH) throw new Error("X25519: incorrect public key length");
        const A = _(I, P);
        if (M) {
            let E = 0;
            for (let $ = 0; $ < A.length; $++) E |= A[$];
            if (E === 0) throw new Error("X25519: invalid shared key")
        }
        return A
    }
    t.sharedKey = S
})(rL);

function iL(t) {
    return globalThis.Buffer != null ? new Uint8Array(t.buffer, t.byteOffset, t.byteLength) : t
}

function Hte(t = 0) {
    return globalThis.Buffer != null && globalThis.Buffer.allocUnsafe != null ? iL(globalThis.Buffer.allocUnsafe(t)) : new Uint8Array(t)
}

function nk(t, e) {
    e || (e = t.reduce((i, s) => i + s.length, 0));
    const n = Hte(e);
    let r = 0;
    for (const i of t) n.set(i, r), r += i.length;
    return iL(n)
}

function b4e(t, e) {
    if (t.length >= 255) throw new TypeError("Alphabet too long");
    for (var n = new Uint8Array(256), r = 0; r < n.length; r++) n[r] = 255;
    for (var i = 0; i < t.length; i++) {
        var s = t.charAt(i),
            o = s.charCodeAt(0);
        if (n[o] !== 255) throw new TypeError(s + " is ambiguous");
        n[o] = i
    }
    var a = t.length,
        l = t.charAt(0),
        c = Math.log(a) / Math.log(256),
        u = Math.log(256) / Math.log(a);

    function f(y) {
        if (y instanceof Uint8Array || (ArrayBuffer.isView(y) ? y = new Uint8Array(y.buffer, y.byteOffset, y.byteLength) : Array.isArray(y) && (y = Uint8Array.from(y))), !(y instanceof Uint8Array)) throw new TypeError("Expected Uint8Array");
        if (y.length === 0) return "";
        for (var _ = 0, C = 0, b = 0, w = y.length; b !== w && y[b] === 0;) b++, _++;
        for (var S = (w - b) * u + 1 >>> 0, I = new Uint8Array(S); b !== w;) {
            for (var P = y[b], M = 0, A = S - 1;
                (P !== 0 || M < C) && A !== -1; A--, M++) P += 256 * I[A] >>> 0, I[A] = P % a >>> 0, P = P / a >>> 0;
            if (P !== 0) throw new Error("Non-zero carry");
            C = M, b++
        }
        for (var E = S - C; E !== S && I[E] === 0;) E++;
        for (var $ = l.repeat(_); E < S; ++E) $ += t.charAt(I[E]);
        return $
    }

    function h(y) {
        if (typeof y != "string") throw new TypeError("Expected String");
        if (y.length === 0) return new Uint8Array;
        var _ = 0;
        if (y[_] !== " ") {
            for (var C = 0, b = 0; y[_] === l;) C++, _++;
            for (var w = (y.length - _) * c + 1 >>> 0, S = new Uint8Array(w); y[_];) {
                var I = n[y.charCodeAt(_)];
                if (I === 255) return;
                for (var P = 0, M = w - 1;
                    (I !== 0 || P < b) && M !== -1; M--, P++) I += a * S[M] >>> 0, S[M] = I % 256 >>> 0, I = I / 256 >>> 0;
                if (I !== 0) throw new Error("Non-zero carry");
                b = P, _++
            }
            if (y[_] !== " ") {
                for (var A = w - b; A !== w && S[A] === 0;) A++;
                for (var E = new Uint8Array(C + (w - A)), $ = C; A !== w;) E[$++] = S[A++];
                return E
            }
        }
    }

    function g(y) {
        var _ = h(y);
        if (_) return _;
        throw new Error(`Non-${e} character`)
    }
    return {
        encode: f,
        decodeUnsafe: h,
        decode: g
    }
}
var _4e = b4e,
    E4e = _4e;
const x4e = t => {
        if (t instanceof Uint8Array && t.constructor.name === "Uint8Array") return t;
        if (t instanceof ArrayBuffer) return new Uint8Array(t);
        if (ArrayBuffer.isView(t)) return new Uint8Array(t.buffer, t.byteOffset, t.byteLength);
        throw new Error("Unknown type, must be binary type")
    },
    S4e = t => new TextEncoder().encode(t),
    C4e = t => new TextDecoder().decode(t);
class A4e {
    constructor(e, n, r) {
        this.name = e, this.prefix = n, this.baseEncode = r
    }
    encode(e) {
        if (e instanceof Uint8Array) return `${this.prefix}${this.baseEncode(e)}`;
        throw Error("Unknown type, must be binary type")
    }
}
class T4e {
    constructor(e, n, r) {
        if (this.name = e, this.prefix = n, n.codePointAt(0) === void 0) throw new Error("Invalid prefix character");
        this.prefixCodePoint = n.codePointAt(0), this.baseDecode = r
    }
    decode(e) {
        if (typeof e == "string") {
            if (e.codePointAt(0) !== this.prefixCodePoint) throw Error(`Unable to decode multibase string ${JSON.stringify(e)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
            return this.baseDecode(e.slice(this.prefix.length))
        } else throw Error("Can only multibase decode strings")
    }
    or(e) {
        return zte(this, e)
    }
}
class I4e {
    constructor(e) {
        this.decoders = e
    }
    or(e) {
        return zte(this, e)
    }
    decode(e) {
        const n = e[0],
            r = this.decoders[n];
        if (r) return r.decode(e);
        throw RangeError(`Unable to decode multibase string ${JSON.stringify(e)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`)
    }
}
const zte = (t, e) => new I4e({ ...t.decoders || {
        [t.prefix]: t
    },
    ...e.decoders || {
        [e.prefix]: e
    }
});
class R4e {
    constructor(e, n, r, i) {
        this.name = e, this.prefix = n, this.baseEncode = r, this.baseDecode = i, this.encoder = new A4e(e, n, r), this.decoder = new T4e(e, n, i)
    }
    encode(e) {
        return this.encoder.encode(e)
    }
    decode(e) {
        return this.decoder.decode(e)
    }
}
const FT = ({
        name: t,
        prefix: e,
        encode: n,
        decode: r
    }) => new R4e(t, e, n, r),
    bE = ({
        prefix: t,
        name: e,
        alphabet: n
    }) => {
        const {
            encode: r,
            decode: i
        } = E4e(n, e);
        return FT({
            prefix: t,
            name: e,
            encode: r,
            decode: s => x4e(i(s))
        })
    },
    O4e = (t, e, n, r) => {
        const i = {};
        for (let u = 0; u < e.length; ++u) i[e[u]] = u;
        let s = t.length;
        for (; t[s - 1] === "=";) --s;
        const o = new Uint8Array(s * n / 8 | 0);
        let a = 0,
            l = 0,
            c = 0;
        for (let u = 0; u < s; ++u) {
            const f = i[t[u]];
            if (f === void 0) throw new SyntaxError(`Non-${r} character`);
            l = l << n | f, a += n, a >= 8 && (a -= 8, o[c++] = 255 & l >> a)
        }
        if (a >= n || 255 & l << 8 - a) throw new SyntaxError("Unexpected end of data");
        return o
    },
    N4e = (t, e, n) => {
        const r = e[e.length - 1] === "=",
            i = (1 << n) - 1;
        let s = "",
            o = 0,
            a = 0;
        for (let l = 0; l < t.length; ++l)
            for (a = a << 8 | t[l], o += 8; o > n;) o -= n, s += e[i & a >> o];
        if (o && (s += e[i & a << n - o]), r)
            for (; s.length * n & 7;) s += "=";
        return s
    },
    fo = ({
        name: t,
        prefix: e,
        bitsPerChar: n,
        alphabet: r
    }) => FT({
        prefix: e,
        name: t,
        encode(i) {
            return N4e(i, r, n)
        },
        decode(i) {
            return O4e(i, r, n, t)
        }
    }),
    P4e = FT({
        prefix: "\0",
        name: "identity",
        encode: t => C4e(t),
        decode: t => S4e(t)
    }),
    k4e = Object.freeze(Object.defineProperty({
        __proto__: null,
        identity: P4e
    }, Symbol.toStringTag, {
        value: "Module"
    })),
    M4e = fo({
        prefix: "0",
        name: "base2",
        alphabet: "01",
        bitsPerChar: 1
    }),
    D4e = Object.freeze(Object.defineProperty({
        __proto__: null,
        base2: M4e
    }, Symbol.toStringTag, {
        value: "Module"
    })),
    $4e = fo({
        prefix: "7",
        name: "base8",
        alphabet: "01234567",
        bitsPerChar: 3
    }),
    L4e = Object.freeze(Object.defineProperty({
        __proto__: null,
        base8: $4e
    }, Symbol.toStringTag, {
        value: "Module"
    })),
    B4e = bE({
        prefix: "9",
        name: "base10",
        alphabet: "0123456789"
    }),
    F4e = Object.freeze(Object.defineProperty({
        __proto__: null,
        base10: B4e
    }, Symbol.toStringTag, {
        value: "Module"
    })),
    U4e = fo({
        prefix: "f",
        name: "base16",
        alphabet: "0123456789abcdef",
        bitsPerChar: 4
    }),
    j4e = fo({
        prefix: "F",
        name: "base16upper",
        alphabet: "0123456789ABCDEF",
        bitsPerChar: 4
    }),
    H4e = Object.freeze(Object.defineProperty({
        __proto__: null,
        base16: U4e,
        base16upper: j4e
    }, Symbol.toStringTag, {
        value: "Module"
    })),
    z4e = fo({
        prefix: "b",
        name: "base32",
        alphabet: "abcdefghijklmnopqrstuvwxyz234567",
        bitsPerChar: 5
    }),
    W4e = fo({
        prefix: "B",
        name: "base32upper",
        alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
        bitsPerChar: 5
    }),
    V4e = fo({
        prefix: "c",
        name: "base32pad",
        alphabet: "abcdefghijklmnopqrstuvwxyz234567=",
        bitsPerChar: 5
    }),
    G4e = fo({
        prefix: "C",
        name: "base32padupper",
        alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",
        bitsPerChar: 5
    }),
    q4e = fo({
        prefix: "v",
        name: "base32hex",
        alphabet: "0123456789abcdefghijklmnopqrstuv",
        bitsPerChar: 5
    }),
    K4e = fo({
        prefix: "V",
        name: "base32hexupper",
        alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV",
        bitsPerChar: 5
    }),
    Y4e = fo({
        prefix: "t",
        name: "base32hexpad",
        alphabet: "0123456789abcdefghijklmnopqrstuv=",
        bitsPerChar: 5
    }),
    Z4e = fo({
        prefix: "T",
        name: "base32hexpadupper",
        alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=",
        bitsPerChar: 5
    }),
    Q4e = fo({
        prefix: "h",
        name: "base32z",
        alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769",
        bitsPerChar: 5
    }),
    J4e = Object.freeze(Object.defineProperty({
        __proto__: null,
        base32: z4e,
        base32hex: q4e,
        base32hexpad: Y4e,
        base32hexpadupper: Z4e,
        base32hexupper: K4e,
        base32pad: V4e,
        base32padupper: G4e,
        base32upper: W4e,
        base32z: Q4e
    }, Symbol.toStringTag, {
        value: "Module"
    })),
    X4e = bE({
        prefix: "k",
        name: "base36",
        alphabet: "0123456789abcdefghijklmnopqrstuvwxyz"
    }),
    exe = bE({
        prefix: "K",
        name: "base36upper",
        alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"
    }),
    txe = Object.freeze(Object.defineProperty({
        __proto__: null,
        base36: X4e,
        base36upper: exe
    }, Symbol.toStringTag, {
        value: "Module"
    })),
    nxe = bE({
        name: "base58btc",
        prefix: "z",
        alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
    }),
    rxe = bE({
        name: "base58flickr",
        prefix: "Z",
        alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"
    }),
    ixe = Object.freeze(Object.defineProperty({
        __proto__: null,
        base58btc: nxe,
        base58flickr: rxe
    }, Symbol.toStringTag, {
        value: "Module"
    })),
    sxe = fo({
        prefix: "m",
        name: "base64",
        alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
        bitsPerChar: 6
    }),
    oxe = fo({
        prefix: "M",
        name: "base64pad",
        alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
        bitsPerChar: 6
    }),
    axe = fo({
        prefix: "u",
        name: "base64url",
        alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",
        bitsPerChar: 6
    }),
    lxe = fo({
        prefix: "U",
        name: "base64urlpad",
        alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",
        bitsPerChar: 6
    }),
    cxe = Object.freeze(Object.defineProperty({
        __proto__: null,
        base64: sxe,
        base64pad: oxe,
        base64url: axe,
        base64urlpad: lxe
    }, Symbol.toStringTag, {
        value: "Module"
    })),
    Wte = Array.from(""),
    uxe = Wte.reduce((t, e, n) => (t[n] = e, t), []),
    fxe = Wte.reduce((t, e, n) => (t[e.codePointAt(0)] = n, t), []);

function dxe(t) {
    return t.reduce((e, n) => (e += uxe[n], e), "")
}

function hxe(t) {
    const e = [];
    for (const n of t) {
        const r = fxe[n.codePointAt(0)];
        if (r === void 0) throw new Error(`Non-base256emoji character: ${n}`);
        e.push(r)
    }
    return new Uint8Array(e)
}
const pxe = FT({
        prefix: "",
        name: "base256emoji",
        encode: dxe,
        decode: hxe
    }),
    gxe = Object.freeze(Object.defineProperty({
        __proto__: null,
        base256emoji: pxe
    }, Symbol.toStringTag, {
        value: "Module"
    }));
new TextEncoder;
new TextDecoder;
const _W = { ...k4e,
    ...D4e,
    ...L4e,
    ...F4e,
    ...H4e,
    ...J4e,
    ...txe,
    ...ixe,
    ...cxe,
    ...gxe
};

function Vte(t, e, n, r) {
    return {
        name: t,
        prefix: e,
        encoder: {
            name: t,
            prefix: e,
            encode: n
        },
        decoder: {
            decode: r
        }
    }
}
const EW = Vte("utf8", "u", t => "u" + new TextDecoder("utf8").decode(t), t => new TextEncoder().encode(t.substring(1))),
    qR = Vte("ascii", "a", t => {
        let e = "a";
        for (let n = 0; n < t.length; n++) e += String.fromCharCode(t[n]);
        return e
    }, t => {
        t = t.substring(1);
        const e = Hte(t.length);
        for (let n = 0; n < t.length; n++) e[n] = t.charCodeAt(n);
        return e
    }),
    Gte = {
        utf8: EW,
        "utf-8": EW,
        hex: _W.base16,
        latin1: qR,
        ascii: qR,
        binary: qR,
        ..._W
    };

function Ua(t, e = "utf8") {
    const n = Gte[e];
    if (!n) throw new Error(`Unsupported encoding "${e}"`);
    return (e === "utf8" || e === "utf-8") && globalThis.Buffer != null && globalThis.Buffer.from != null ? iL(globalThis.Buffer.from(t, "utf-8")) : n.decoder.decode(`${n.prefix}${t}`)
}

function ha(t, e = "utf8") {
    const n = Gte[e];
    if (!n) throw new Error(`Unsupported encoding "${e}"`);
    return (e === "utf8" || e === "utf-8") && globalThis.Buffer != null && globalThis.Buffer.from != null ? globalThis.Buffer.from(t.buffer, t.byteOffset, t.byteLength).toString("utf8") : n.encoder.encode(t).substring(1)
}
var xW = function(t, e, n) {
        if (n || arguments.length === 2)
            for (var r = 0, i = e.length, s; r < i; r++)(s || !(r in e)) && (s || (s = Array.prototype.slice.call(e, 0, r)), s[r] = e[r]);
        return t.concat(s || Array.prototype.slice.call(e))
    },
    mxe = function() {
        function t(e, n, r) {
            this.name = e, this.version = n, this.os = r, this.type = "browser"
        }
        return t
    }(),
    yxe = function() {
        function t(e) {
            this.version = e, this.type = "node", this.name = "node", this.os = process.platform
        }
        return t
    }(),
    wxe = function() {
        function t(e, n, r, i) {
            this.name = e, this.version = n, this.os = r, this.bot = i, this.type = "bot-device"
        }
        return t
    }(),
    vxe = function() {
        function t() {
            this.type = "bot", this.bot = !0, this.name = "bot", this.version = null, this.os = null
        }
        return t
    }(),
    bxe = function() {
        function t() {
            this.type = "react-native", this.name = "react-native", this.version = null, this.os = null
        }
        return t
    }(),
    _xe = /alexa|bot|crawl(er|ing)|facebookexternalhit|feedburner|google web preview|nagios|postrank|pingdom|slurp|spider|yahoo!|yandex/,
    Exe = /(nuhk|curl|Googlebot|Yammybot|Openbot|Slurp|MSNBot|Ask\ Jeeves\/Teoma|ia_archiver)/,
    SW = 3,
    xxe = [
        ["aol", /AOLShield\/([0-9\._]+)/],
        ["edge", /Edge\/([0-9\._]+)/],
        ["edge-ios", /EdgiOS\/([0-9\._]+)/],
        ["yandexbrowser", /YaBrowser\/([0-9\._]+)/],
        ["kakaotalk", /KAKAOTALK\s([0-9\.]+)/],
        ["samsung", /SamsungBrowser\/([0-9\.]+)/],
        ["silk", /\bSilk\/([0-9._-]+)\b/],
        ["miui", /MiuiBrowser\/([0-9\.]+)$/],
        ["beaker", /BeakerBrowser\/([0-9\.]+)/],
        ["edge-chromium", /EdgA?\/([0-9\.]+)/],
        ["chromium-webview", /(?!Chrom.*OPR)wv\).*Chrom(?:e|ium)\/([0-9\.]+)(:?\s|$)/],
        ["chrome", /(?!Chrom.*OPR)Chrom(?:e|ium)\/([0-9\.]+)(:?\s|$)/],
        ["phantomjs", /PhantomJS\/([0-9\.]+)(:?\s|$)/],
        ["crios", /CriOS\/([0-9\.]+)(:?\s|$)/],
        ["firefox", /Firefox\/([0-9\.]+)(?:\s|$)/],
        ["fxios", /FxiOS\/([0-9\.]+)/],
        ["opera-mini", /Opera Mini.*Version\/([0-9\.]+)/],
        ["opera", /Opera\/([0-9\.]+)(?:\s|$)/],
        ["opera", /OPR\/([0-9\.]+)(:?\s|$)/],
        ["pie", /^Microsoft Pocket Internet Explorer\/(\d+\.\d+)$/],
        ["pie", /^Mozilla\/\d\.\d+\s\(compatible;\s(?:MSP?IE|MSInternet Explorer) (\d+\.\d+);.*Windows CE.*\)$/],
        ["netfront", /^Mozilla\/\d\.\d+.*NetFront\/(\d.\d)/],
        ["ie", /Trident\/7\.0.*rv\:([0-9\.]+).*\).*Gecko$/],
        ["ie", /MSIE\s([0-9\.]+);.*Trident\/[4-7].0/],
        ["ie", /MSIE\s(7\.0)/],
        ["bb10", /BB10;\sTouch.*Version\/([0-9\.]+)/],
        ["android", /Android\s([0-9\.]+)/],
        ["ios", /Version\/([0-9\._]+).*Mobile.*Safari.*/],
        ["safari", /Version\/([0-9\._]+).*Safari/],
        ["facebook", /FB[AS]V\/([0-9\.]+)/],
        ["instagram", /Instagram\s([0-9\.]+)/],
        ["ios-webview", /AppleWebKit\/([0-9\.]+).*Mobile/],
        ["ios-webview", /AppleWebKit\/([0-9\.]+).*Gecko\)$/],
        ["curl", /^curl\/([0-9\.]+)$/],
        ["searchbot", _xe]
    ],
    CW = [
        ["iOS", /iP(hone|od|ad)/],
        ["Android OS", /Android/],
        ["BlackBerry OS", /BlackBerry|BB10/],
        ["Windows Mobile", /IEMobile/],
        ["Amazon OS", /Kindle/],
        ["Windows 3.11", /Win16/],
        ["Windows 95", /(Windows 95)|(Win95)|(Windows_95)/],
        ["Windows 98", /(Windows 98)|(Win98)/],
        ["Windows 2000", /(Windows NT 5.0)|(Windows 2000)/],
        ["Windows XP", /(Windows NT 5.1)|(Windows XP)/],
        ["Windows Server 2003", /(Windows NT 5.2)/],
        ["Windows Vista", /(Windows NT 6.0)/],
        ["Windows 7", /(Windows NT 6.1)/],
        ["Windows 8", /(Windows NT 6.2)/],
        ["Windows 8.1", /(Windows NT 6.3)/],
        ["Windows 10", /(Windows NT 10.0)/],
        ["Windows ME", /Windows ME/],
        ["Windows CE", /Windows CE|WinCE|Microsoft Pocket Internet Explorer/],
        ["Open BSD", /OpenBSD/],
        ["Sun OS", /SunOS/],
        ["Chrome OS", /CrOS/],
        ["Linux", /(Linux)|(X11)/],
        ["Mac OS", /(Mac_PowerPC)|(Macintosh)/],
        ["QNX", /QNX/],
        ["BeOS", /BeOS/],
        ["OS/2", /OS\/2/]
    ];

function Sxe(t) {
    return typeof document > "u" && typeof navigator < "u" && navigator.product === "ReactNative" ? new bxe : typeof navigator < "u" ? Axe(navigator.userAgent) : Ixe()
}

function Cxe(t) {
    return t !== "" && xxe.reduce(function(e, n) {
        var r = n[0],
            i = n[1];
        if (e) return e;
        var s = i.exec(t);
        return !!s && [r, s]
    }, !1)
}

function Axe(t) {
    var e = Cxe(t);
    if (!e) return null;
    var n = e[0],
        r = e[1];
    if (n === "searchbot") return new vxe;
    var i = r[1] && r[1].split(".").join("_").split("_").slice(0, 3);
    i ? i.length < SW && (i = xW(xW([], i, !0), Rxe(SW - i.length), !0)) : i = [];
    var s = i.join("."),
        o = Txe(t),
        a = Exe.exec(t);
    return a && a[1] ? new wxe(n, s, o, a[1]) : new mxe(n, s, o)
}

function Txe(t) {
    for (var e = 0, n = CW.length; e < n; e++) {
        var r = CW[e],
            i = r[0],
            s = r[1],
            o = s.exec(t);
        if (o) return i
    }
    return null
}

function Ixe() {
    var t = typeof process < "u" && process.version;
    return t ? new yxe(process.version.slice(1)) : null
}

function Rxe(t) {
    for (var e = [], n = 0; n < t; n++) e.push("0");
    return e
}
var Bt = {};
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var rk = function(t, e) {
    return rk = Object.setPrototypeOf || {
        __proto__: []
    }
    instanceof Array && function(n, r) {
        n.__proto__ = r
    } || function(n, r) {
        for (var i in r) r.hasOwnProperty(i) && (n[i] = r[i])
    }, rk(t, e)
};

function Ve(t, e) {
    rk(t, e);

    function n() {
        this.constructor = t
    }
    t.prototype = e === null ? Object.create(e) : (n.prototype = e.prototype, new n)
}
var ik = function() {
    return ik = Object.assign || function(e) {
        for (var n, r = 1, i = arguments.length; r < i; r++) {
            n = arguments[r];
            for (var s in n) Object.prototype.hasOwnProperty.call(n, s) && (e[s] = n[s])
        }
        return e
    }, ik.apply(this, arguments)
};

function Oxe(t, e) {
    var n = {};
    for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && e.indexOf(r) < 0 && (n[r] = t[r]);
    if (t != null && typeof Object.getOwnPropertySymbols == "function")
        for (var i = 0, r = Object.getOwnPropertySymbols(t); i < r.length; i++) e.indexOf(r[i]) < 0 && Object.prototype.propertyIsEnumerable.call(t, r[i]) && (n[r[i]] = t[r[i]]);
    return n
}

function Nxe(t, e, n, r) {
    var i = arguments.length,
        s = i < 3 ? e : r === null ? r = Object.getOwnPropertyDescriptor(e, n) : r,
        o;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function") s = Reflect.decorate(t, e, n, r);
    else
        for (var a = t.length - 1; a >= 0; a--)(o = t[a]) && (s = (i < 3 ? o(s) : i > 3 ? o(e, n, s) : o(e, n)) || s);
    return i > 3 && s && Object.defineProperty(e, n, s), s
}

function Pxe(t, e) {
    return function(n, r) {
        e(n, r, t)
    }
}

function kxe(t, e) {
    if (typeof Reflect == "object" && typeof Reflect.metadata == "function") return Reflect.metadata(t, e)
}

function Mxe(t, e, n, r) {
    function i(s) {
        return s instanceof n ? s : new n(function(o) {
            o(s)
        })
    }
    return new(n || (n = Promise))(function(s, o) {
        function a(u) {
            try {
                c(r.next(u))
            } catch (f) {
                o(f)
            }
        }

        function l(u) {
            try {
                c(r.throw(u))
            } catch (f) {
                o(f)
            }
        }

        function c(u) {
            u.done ? s(u.value) : i(u.value).then(a, l)
        }
        c((r = r.apply(t, e || [])).next())
    })
}

function Dxe(t, e) {
    var n = {
            label: 0,
            sent: function() {
                if (s[0] & 1) throw s[1];
                return s[1]
            },
            trys: [],
            ops: []
        },
        r, i, s, o;
    return o = {
        next: a(0),
        throw: a(1),
        return: a(2)
    }, typeof Symbol == "function" && (o[Symbol.iterator] = function() {
        return this
    }), o;

    function a(c) {
        return function(u) {
            return l([c, u])
        }
    }

    function l(c) {
        if (r) throw new TypeError("Generator is already executing.");
        for (; n;) try {
            if (r = 1, i && (s = c[0] & 2 ? i.return : c[0] ? i.throw || ((s = i.return) && s.call(i), 0) : i.next) && !(s = s.call(i, c[1])).done) return s;
            switch (i = 0, s && (c = [c[0] & 2, s.value]), c[0]) {
                case 0:
                case 1:
                    s = c;
                    break;
                case 4:
                    return n.label++, {
                        value: c[1],
                        done: !1
                    };
                case 5:
                    n.label++, i = c[1], c = [0];
                    continue;
                case 7:
                    c = n.ops.pop(), n.trys.pop();
                    continue;
                default:
                    if (s = n.trys, !(s = s.length > 0 && s[s.length - 1]) && (c[0] === 6 || c[0] === 2)) {
                        n = 0;
                        continue
                    }
                    if (c[0] === 3 && (!s || c[1] > s[0] && c[1] < s[3])) {
                        n.label = c[1];
                        break
                    }
                    if (c[0] === 6 && n.label < s[1]) {
                        n.label = s[1], s = c;
                        break
                    }
                    if (s && n.label < s[2]) {
                        n.label = s[2], n.ops.push(c);
                        break
                    }
                    s[2] && n.ops.pop(), n.trys.pop();
                    continue
            }
            c = e.call(t, n)
        } catch (u) {
            c = [6, u], i = 0
        } finally {
            r = s = 0
        }
        if (c[0] & 5) throw c[1];
        return {
            value: c[0] ? c[1] : void 0,
            done: !0
        }
    }
}

function $xe(t, e, n, r) {
    r === void 0 && (r = n), t[r] = e[n]
}

function Lxe(t, e) {
    for (var n in t) n !== "default" && !e.hasOwnProperty(n) && (e[n] = t[n])
}

function sk(t) {
    var e = typeof Symbol == "function" && Symbol.iterator,
        n = e && t[e],
        r = 0;
    if (n) return n.call(t);
    if (t && typeof t.length == "number") return {
        next: function() {
            return t && r >= t.length && (t = void 0), {
                value: t && t[r++],
                done: !t
            }
        }
    };
    throw new TypeError(e ? "Object is not iterable." : "Symbol.iterator is not defined.")
}

function qte(t, e) {
    var n = typeof Symbol == "function" && t[Symbol.iterator];
    if (!n) return t;
    var r = n.call(t),
        i, s = [],
        o;
    try {
        for (;
            (e === void 0 || e-- > 0) && !(i = r.next()).done;) s.push(i.value)
    } catch (a) {
        o = {
            error: a
        }
    } finally {
        try {
            i && !i.done && (n = r.return) && n.call(r)
        } finally {
            if (o) throw o.error
        }
    }
    return s
}

function Bxe() {
    for (var t = [], e = 0; e < arguments.length; e++) t = t.concat(qte(arguments[e]));
    return t
}

function Fxe() {
    for (var t = 0, e = 0, n = arguments.length; e < n; e++) t += arguments[e].length;
    for (var r = Array(t), i = 0, e = 0; e < n; e++)
        for (var s = arguments[e], o = 0, a = s.length; o < a; o++, i++) r[i] = s[o];
    return r
}

function W_(t) {
    return this instanceof W_ ? (this.v = t, this) : new W_(t)
}

function Uxe(t, e, n) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var r = n.apply(t, e || []),
        i, s = [];
    return i = {}, o("next"), o("throw"), o("return"), i[Symbol.asyncIterator] = function() {
        return this
    }, i;

    function o(h) {
        r[h] && (i[h] = function(g) {
            return new Promise(function(y, _) {
                s.push([h, g, y, _]) > 1 || a(h, g)
            })
        })
    }

    function a(h, g) {
        try {
            l(r[h](g))
        } catch (y) {
            f(s[0][3], y)
        }
    }

    function l(h) {
        h.value instanceof W_ ? Promise.resolve(h.value.v).then(c, u) : f(s[0][2], h)
    }

    function c(h) {
        a("next", h)
    }

    function u(h) {
        a("throw", h)
    }

    function f(h, g) {
        h(g), s.shift(), s.length && a(s[0][0], s[0][1])
    }
}

function jxe(t) {
    var e, n;
    return e = {}, r("next"), r("throw", function(i) {
        throw i
    }), r("return"), e[Symbol.iterator] = function() {
        return this
    }, e;

    function r(i, s) {
        e[i] = t[i] ? function(o) {
            return (n = !n) ? {
                value: W_(t[i](o)),
                done: i === "return"
            } : s ? s(o) : o
        } : s
    }
}

function Hxe(t) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var e = t[Symbol.asyncIterator],
        n;
    return e ? e.call(t) : (t = typeof sk == "function" ? sk(t) : t[Symbol.iterator](), n = {}, r("next"), r("throw"), r("return"), n[Symbol.asyncIterator] = function() {
        return this
    }, n);

    function r(s) {
        n[s] = t[s] && function(o) {
            return new Promise(function(a, l) {
                o = t[s](o), i(a, l, o.done, o.value)
            })
        }
    }

    function i(s, o, a, l) {
        Promise.resolve(l).then(function(c) {
            s({
                value: c,
                done: a
            })
        }, o)
    }
}

function zxe(t, e) {
    return Object.defineProperty ? Object.defineProperty(t, "raw", {
        value: e
    }) : t.raw = e, t
}

function Wxe(t) {
    if (t && t.__esModule) return t;
    var e = {};
    if (t != null)
        for (var n in t) Object.hasOwnProperty.call(t, n) && (e[n] = t[n]);
    return e.default = t, e
}

function Vxe(t) {
    return t && t.__esModule ? t : {
        default: t
    }
}

function Gxe(t, e) {
    if (!e.has(t)) throw new TypeError("attempted to get private field on non-instance");
    return e.get(t)
}

function qxe(t, e, n) {
    if (!e.has(t)) throw new TypeError("attempted to set private field on non-instance");
    return e.set(t, n), n
}
const Kxe = Object.freeze(Object.defineProperty({
        __proto__: null,
        get __assign() {
            return ik
        },
        __asyncDelegator: jxe,
        __asyncGenerator: Uxe,
        __asyncValues: Hxe,
        __await: W_,
        __awaiter: Mxe,
        __classPrivateFieldGet: Gxe,
        __classPrivateFieldSet: qxe,
        __createBinding: $xe,
        __decorate: Nxe,
        __exportStar: Lxe,
        __extends: Ve,
        __generator: Dxe,
        __importDefault: Vxe,
        __importStar: Wxe,
        __makeTemplateObject: zxe,
        __metadata: kxe,
        __param: Pxe,
        __read: qte,
        __rest: Oxe,
        __spread: Bxe,
        __spreadArrays: Fxe,
        __values: sk
    }, Symbol.toStringTag, {
        value: "Module"
    })),
    Uh = Fu(Kxe);
var KR = {},
    M5 = {},
    AW;

function Yxe() {
    if (AW) return M5;
    AW = 1, Object.defineProperty(M5, "__esModule", {
        value: !0
    }), M5.delay = void 0;

    function t(e) {
        return new Promise(n => {
            setTimeout(() => {
                n(!0)
            }, e)
        })
    }
    return M5.delay = t, M5
}
var Mg = {},
    YR = {},
    Dg = {},
    TW;

function Zxe() {
    return TW || (TW = 1, Object.defineProperty(Dg, "__esModule", {
        value: !0
    }), Dg.ONE_THOUSAND = Dg.ONE_HUNDRED = void 0, Dg.ONE_HUNDRED = 100, Dg.ONE_THOUSAND = 1e3), Dg
}
var ZR = {},
    IW;

function Qxe() {
    return IW || (IW = 1, function(t) {
        Object.defineProperty(t, "__esModule", {
            value: !0
        }), t.ONE_YEAR = t.FOUR_WEEKS = t.THREE_WEEKS = t.TWO_WEEKS = t.ONE_WEEK = t.THIRTY_DAYS = t.SEVEN_DAYS = t.FIVE_DAYS = t.THREE_DAYS = t.ONE_DAY = t.TWENTY_FOUR_HOURS = t.TWELVE_HOURS = t.SIX_HOURS = t.THREE_HOURS = t.ONE_HOUR = t.SIXTY_MINUTES = t.THIRTY_MINUTES = t.TEN_MINUTES = t.FIVE_MINUTES = t.ONE_MINUTE = t.SIXTY_SECONDS = t.THIRTY_SECONDS = t.TEN_SECONDS = t.FIVE_SECONDS = t.ONE_SECOND = void 0, t.ONE_SECOND = 1, t.FIVE_SECONDS = 5, t.TEN_SECONDS = 10, t.THIRTY_SECONDS = 30, t.SIXTY_SECONDS = 60, t.ONE_MINUTE = t.SIXTY_SECONDS, t.FIVE_MINUTES = t.ONE_MINUTE * 5, t.TEN_MINUTES = t.ONE_MINUTE * 10, t.THIRTY_MINUTES = t.ONE_MINUTE * 30, t.SIXTY_MINUTES = t.ONE_MINUTE * 60, t.ONE_HOUR = t.SIXTY_MINUTES, t.THREE_HOURS = t.ONE_HOUR * 3, t.SIX_HOURS = t.ONE_HOUR * 6, t.TWELVE_HOURS = t.ONE_HOUR * 12, t.TWENTY_FOUR_HOURS = t.ONE_HOUR * 24, t.ONE_DAY = t.TWENTY_FOUR_HOURS, t.THREE_DAYS = t.ONE_DAY * 3, t.FIVE_DAYS = t.ONE_DAY * 5, t.SEVEN_DAYS = t.ONE_DAY * 7, t.THIRTY_DAYS = t.ONE_DAY * 30, t.ONE_WEEK = t.SEVEN_DAYS, t.TWO_WEEKS = t.ONE_WEEK * 2, t.THREE_WEEKS = t.ONE_WEEK * 3, t.FOUR_WEEKS = t.ONE_WEEK * 4, t.ONE_YEAR = t.ONE_DAY * 365
    }(ZR)), ZR
}
var RW;

function Kte() {
    return RW || (RW = 1, function(t) {
        Object.defineProperty(t, "__esModule", {
            value: !0
        });
        const e = Uh;
        e.__exportStar(Zxe(), t), e.__exportStar(Qxe(), t)
    }(YR)), YR
}
var OW;

function Jxe() {
    if (OW) return Mg;
    OW = 1, Object.defineProperty(Mg, "__esModule", {
        value: !0
    }), Mg.fromMiliseconds = Mg.toMiliseconds = void 0;
    const t = Kte();

    function e(r) {
        return r * t.ONE_THOUSAND
    }
    Mg.toMiliseconds = e;

    function n(r) {
        return Math.floor(r / t.ONE_THOUSAND)
    }
    return Mg.fromMiliseconds = n, Mg
}
var NW;

function Xxe() {
    return NW || (NW = 1, function(t) {
        Object.defineProperty(t, "__esModule", {
            value: !0
        });
        const e = Uh;
        e.__exportStar(Yxe(), t), e.__exportStar(Jxe(), t)
    }(KR)), KR
}
var Qy = {},
    PW;

function eSe() {
    if (PW) return Qy;
    PW = 1, Object.defineProperty(Qy, "__esModule", {
        value: !0
    }), Qy.Watch = void 0;
    class t {
        constructor() {
            this.timestamps = new Map
        }
        start(n) {
            if (this.timestamps.has(n)) throw new Error(`Watch already started for label: ${n}`);
            this.timestamps.set(n, {
                started: Date.now()
            })
        }
        stop(n) {
            const r = this.get(n);
            if (typeof r.elapsed < "u") throw new Error(`Watch already stopped for label: ${n}`);
            const i = Date.now() - r.started;
            this.timestamps.set(n, {
                started: r.started,
                elapsed: i
            })
        }
        get(n) {
            const r = this.timestamps.get(n);
            if (typeof r > "u") throw new Error(`No timestamp found for label: ${n}`);
            return r
        }
        elapsed(n) {
            const r = this.get(n);
            return r.elapsed || Date.now() - r.started
        }
    }
    return Qy.Watch = t, Qy.default = t, Qy
}
var QR = {},
    D5 = {},
    kW;

function tSe() {
    if (kW) return D5;
    kW = 1, Object.defineProperty(D5, "__esModule", {
        value: !0
    }), D5.IWatch = void 0;
    class t {}
    return D5.IWatch = t, D5
}
var MW;

function nSe() {
    return MW || (MW = 1, function(t) {
        Object.defineProperty(t, "__esModule", {
            value: !0
        }), Uh.__exportStar(tSe(), t)
    }(QR)), QR
}(function(t) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    const e = Uh;
    e.__exportStar(Xxe(), t), e.__exportStar(eSe(), t), e.__exportStar(nSe(), t), e.__exportStar(Kte(), t)
})(Bt);
var qr = {};
Object.defineProperty(qr, "__esModule", {
    value: !0
});
qr.getLocalStorage = qr.getLocalStorageOrThrow = qr.getCrypto = qr.getCryptoOrThrow = Yte = qr.getLocation = qr.getLocationOrThrow = oL = qr.getNavigator = qr.getNavigatorOrThrow = sL = qr.getDocument = qr.getDocumentOrThrow = qr.getFromWindowOrThrow = qr.getFromWindow = void 0;

function hy(t) {
    let e;
    return typeof window < "u" && typeof window[t] < "u" && (e = window[t]), e
}
qr.getFromWindow = hy;

function I2(t) {
    const e = hy(t);
    if (!e) throw new Error(`${t} is not defined in Window`);
    return e
}
qr.getFromWindowOrThrow = I2;

function rSe() {
    return I2("document")
}
qr.getDocumentOrThrow = rSe;

function iSe() {
    return hy("document")
}
var sL = qr.getDocument = iSe;

function sSe() {
    return I2("navigator")
}
qr.getNavigatorOrThrow = sSe;

function oSe() {
    return hy("navigator")
}
var oL = qr.getNavigator = oSe;

function aSe() {
    return I2("location")
}
qr.getLocationOrThrow = aSe;

function lSe() {
    return hy("location")
}
var Yte = qr.getLocation = lSe;

function cSe() {
    return I2("crypto")
}
qr.getCryptoOrThrow = cSe;

function uSe() {
    return hy("crypto")
}
qr.getCrypto = uSe;

function fSe() {
    return I2("localStorage")
}
qr.getLocalStorageOrThrow = fSe;

function dSe() {
    return hy("localStorage")
}
qr.getLocalStorage = dSe;
var aL = {};
Object.defineProperty(aL, "__esModule", {
    value: !0
});
var Zte = aL.getWindowMetadata = void 0;
const DW = qr;

function hSe() {
    let t, e;
    try {
        t = DW.getDocumentOrThrow(), e = DW.getLocationOrThrow()
    } catch {
        return null
    }

    function n() {
        const f = t.getElementsByTagName("link"),
            h = [];
        for (let g = 0; g < f.length; g++) {
            const y = f[g],
                _ = y.getAttribute("rel");
            if (_ && _.toLowerCase().indexOf("icon") > -1) {
                const C = y.getAttribute("href");
                if (C)
                    if (C.toLowerCase().indexOf("https:") === -1 && C.toLowerCase().indexOf("http:") === -1 && C.indexOf("//") !== 0) {
                        let b = e.protocol + "//" + e.host;
                        if (C.indexOf("/") === 0) b += C;
                        else {
                            const w = e.pathname.split("/");
                            w.pop();
                            const S = w.join("/");
                            b += S + "/" + C
                        }
                        h.push(b)
                    } else if (C.indexOf("//") === 0) {
                    const b = e.protocol + C;
                    h.push(b)
                } else h.push(C)
            }
        }
        return h
    }

    function r(...f) {
        const h = t.getElementsByTagName("meta");
        for (let g = 0; g < h.length; g++) {
            const y = h[g],
                _ = ["itemprop", "property", "name"].map(C => y.getAttribute(C)).filter(C => C ? f.includes(C) : !1);
            if (_.length && _) {
                const C = y.getAttribute("content");
                if (C) return C
            }
        }
        return ""
    }

    function i() {
        let f = r("name", "og:site_name", "og:title", "twitter:title");
        return f || (f = t.title), f
    }

    function s() {
        return r("description", "og:description", "twitter:description", "keywords")
    }
    const o = i(),
        a = s(),
        l = e.origin,
        c = n();
    return {
        description: a,
        url: l,
        icons: c,
        name: o
    }
}
Zte = aL.getWindowMetadata = hSe;
var V_ = {},
    pSe = t => encodeURIComponent(t).replace(/[!'()*]/g, e => `%${e.charCodeAt(0).toString(16).toUpperCase()}`),
    Qte = "%[a-f0-9]{2}",
    $W = new RegExp("(" + Qte + ")|([^%]+?)", "gi"),
    LW = new RegExp("(" + Qte + ")+", "gi");

function ok(t, e) {
    try {
        return [decodeURIComponent(t.join(""))]
    } catch {}
    if (t.length === 1) return t;
    e = e || 1;
    var n = t.slice(0, e),
        r = t.slice(e);
    return Array.prototype.concat.call([], ok(n), ok(r))
}

function gSe(t) {
    try {
        return decodeURIComponent(t)
    } catch {
        for (var e = t.match($W) || [], n = 1; n < e.length; n++) t = ok(e, n).join(""), e = t.match($W) || [];
        return t
    }
}

function mSe(t) {
    for (var e = {
            "%FE%FF": "",
            "%FF%FE": ""
        }, n = LW.exec(t); n;) {
        try {
            e[n[0]] = decodeURIComponent(n[0])
        } catch {
            var r = gSe(n[0]);
            r !== n[0] && (e[n[0]] = r)
        }
        n = LW.exec(t)
    }
    e["%C2"] = "";
    for (var i = Object.keys(e), s = 0; s < i.length; s++) {
        var o = i[s];
        t = t.replace(new RegExp(o, "g"), e[o])
    }
    return t
}
var ySe = function(t) {
        if (typeof t != "string") throw new TypeError("Expected `encodedURI` to be of type `string`, got `" + typeof t + "`");
        try {
            return t = t.replace(/\+/g, " "), decodeURIComponent(t)
        } catch {
            return mSe(t)
        }
    },
    wSe = (t, e) => {
        if (!(typeof t == "string" && typeof e == "string")) throw new TypeError("Expected the arguments to be of type `string`");
        if (e === "") return [t];
        const n = t.indexOf(e);
        return n === -1 ? [t] : [t.slice(0, n), t.slice(n + e.length)]
    },
    vSe = function(t, e) {
        for (var n = {}, r = Object.keys(t), i = Array.isArray(e), s = 0; s < r.length; s++) {
            var o = r[s],
                a = t[o];
            (i ? e.indexOf(o) !== -1 : e(o, a, t)) && (n[o] = a)
        }
        return n
    };
(function(t) {
    const e = pSe,
        n = ySe,
        r = wSe,
        i = vSe,
        s = w => w == null,
        o = Symbol("encodeFragmentIdentifier");

    function a(w) {
        switch (w.arrayFormat) {
            case "index":
                return S => (I, P) => {
                    const M = I.length;
                    return P === void 0 || w.skipNull && P === null || w.skipEmptyString && P === "" ? I : P === null ? [...I, [u(S, w), "[", M, "]"].join("")] : [...I, [u(S, w), "[", u(M, w), "]=", u(P, w)].join("")]
                };
            case "bracket":
                return S => (I, P) => P === void 0 || w.skipNull && P === null || w.skipEmptyString && P === "" ? I : P === null ? [...I, [u(S, w), "[]"].join("")] : [...I, [u(S, w), "[]=", u(P, w)].join("")];
            case "colon-list-separator":
                return S => (I, P) => P === void 0 || w.skipNull && P === null || w.skipEmptyString && P === "" ? I : P === null ? [...I, [u(S, w), ":list="].join("")] : [...I, [u(S, w), ":list=", u(P, w)].join("")];
            case "comma":
            case "separator":
            case "bracket-separator":
                {
                    const S = w.arrayFormat === "bracket-separator" ? "[]=" : "=";
                    return I => (P, M) => M === void 0 || w.skipNull && M === null || w.skipEmptyString && M === "" ? P : (M = M === null ? "" : M, P.length === 0 ? [
                        [u(I, w), S, u(M, w)].join("")
                    ] : [
                        [P, u(M, w)].join(w.arrayFormatSeparator)
                    ])
                }
            default:
                return S => (I, P) => P === void 0 || w.skipNull && P === null || w.skipEmptyString && P === "" ? I : P === null ? [...I, u(S, w)] : [...I, [u(S, w), "=", u(P, w)].join("")]
        }
    }

    function l(w) {
        let S;
        switch (w.arrayFormat) {
            case "index":
                return (I, P, M) => {
                    if (S = /\[(\d*)\]$/.exec(I), I = I.replace(/\[\d*\]$/, ""), !S) {
                        M[I] = P;
                        return
                    }
                    M[I] === void 0 && (M[I] = {}), M[I][S[1]] = P
                };
            case "bracket":
                return (I, P, M) => {
                    if (S = /(\[\])$/.exec(I), I = I.replace(/\[\]$/, ""), !S) {
                        M[I] = P;
                        return
                    }
                    if (M[I] === void 0) {
                        M[I] = [P];
                        return
                    }
                    M[I] = [].concat(M[I], P)
                };
            case "colon-list-separator":
                return (I, P, M) => {
                    if (S = /(:list)$/.exec(I), I = I.replace(/:list$/, ""), !S) {
                        M[I] = P;
                        return
                    }
                    if (M[I] === void 0) {
                        M[I] = [P];
                        return
                    }
                    M[I] = [].concat(M[I], P)
                };
            case "comma":
            case "separator":
                return (I, P, M) => {
                    const A = typeof P == "string" && P.includes(w.arrayFormatSeparator),
                        E = typeof P == "string" && !A && f(P, w).includes(w.arrayFormatSeparator);
                    P = E ? f(P, w) : P;
                    const $ = A || E ? P.split(w.arrayFormatSeparator).map(H => f(H, w)) : P === null ? P : f(P, w);
                    M[I] = $
                };
            case "bracket-separator":
                return (I, P, M) => {
                    const A = /(\[\])$/.test(I);
                    if (I = I.replace(/\[\]$/, ""), !A) {
                        M[I] = P && f(P, w);
                        return
                    }
                    const E = P === null ? [] : P.split(w.arrayFormatSeparator).map($ => f($, w));
                    if (M[I] === void 0) {
                        M[I] = E;
                        return
                    }
                    M[I] = [].concat(M[I], E)
                };
            default:
                return (I, P, M) => {
                    if (M[I] === void 0) {
                        M[I] = P;
                        return
                    }
                    M[I] = [].concat(M[I], P)
                }
        }
    }

    function c(w) {
        if (typeof w != "string" || w.length !== 1) throw new TypeError("arrayFormatSeparator must be single character string")
    }

    function u(w, S) {
        return S.encode ? S.strict ? e(w) : encodeURIComponent(w) : w
    }

    function f(w, S) {
        return S.decode ? n(w) : w
    }

    function h(w) {
        return Array.isArray(w) ? w.sort() : typeof w == "object" ? h(Object.keys(w)).sort((S, I) => Number(S) - Number(I)).map(S => w[S]) : w
    }

    function g(w) {
        const S = w.indexOf("#");
        return S !== -1 && (w = w.slice(0, S)), w
    }

    function y(w) {
        let S = "";
        const I = w.indexOf("#");
        return I !== -1 && (S = w.slice(I)), S
    }

    function _(w) {
        w = g(w);
        const S = w.indexOf("?");
        return S === -1 ? "" : w.slice(S + 1)
    }

    function C(w, S) {
        return S.parseNumbers && !Number.isNaN(Number(w)) && typeof w == "string" && w.trim() !== "" ? w = Number(w) : S.parseBooleans && w !== null && (w.toLowerCase() === "true" || w.toLowerCase() === "false") && (w = w.toLowerCase() === "true"), w
    }

    function b(w, S) {
        S = Object.assign({
            decode: !0,
            sort: !0,
            arrayFormat: "none",
            arrayFormatSeparator: ",",
            parseNumbers: !1,
            parseBooleans: !1
        }, S), c(S.arrayFormatSeparator);
        const I = l(S),
            P = Object.create(null);
        if (typeof w != "string" || (w = w.trim().replace(/^[?#&]/, ""), !w)) return P;
        for (const M of w.split("&")) {
            if (M === "") continue;
            let [A, E] = r(S.decode ? M.replace(/\+/g, " ") : M, "=");
            E = E === void 0 ? null : ["comma", "separator", "bracket-separator"].includes(S.arrayFormat) ? E : f(E, S), I(f(A, S), E, P)
        }
        for (const M of Object.keys(P)) {
            const A = P[M];
            if (typeof A == "object" && A !== null)
                for (const E of Object.keys(A)) A[E] = C(A[E], S);
            else P[M] = C(A, S)
        }
        return S.sort === !1 ? P : (S.sort === !0 ? Object.keys(P).sort() : Object.keys(P).sort(S.sort)).reduce((M, A) => {
            const E = P[A];
            return E && typeof E == "object" && !Array.isArray(E) ? M[A] = h(E) : M[A] = E, M
        }, Object.create(null))
    }
    t.extract = _, t.parse = b, t.stringify = (w, S) => {
        if (!w) return "";
        S = Object.assign({
            encode: !0,
            strict: !0,
            arrayFormat: "none",
            arrayFormatSeparator: ","
        }, S), c(S.arrayFormatSeparator);
        const I = E => S.skipNull && s(w[E]) || S.skipEmptyString && w[E] === "",
            P = a(S),
            M = {};
        for (const E of Object.keys(w)) I(E) || (M[E] = w[E]);
        const A = Object.keys(M);
        return S.sort !== !1 && A.sort(S.sort), A.map(E => {
            const $ = w[E];
            return $ === void 0 ? "" : $ === null ? u(E, S) : Array.isArray($) ? $.length === 0 && S.arrayFormat === "bracket-separator" ? u(E, S) + "[]" : $.reduce(P(E), []).join("&") : u(E, S) + "=" + u($, S)
        }).filter(E => E.length > 0).join("&")
    }, t.parseUrl = (w, S) => {
        S = Object.assign({
            decode: !0
        }, S);
        const [I, P] = r(w, "#");
        return Object.assign({
            url: I.split("?")[0] || "",
            query: b(_(w), S)
        }, S && S.parseFragmentIdentifier && P ? {
            fragmentIdentifier: f(P, S)
        } : {})
    }, t.stringifyUrl = (w, S) => {
        S = Object.assign({
            encode: !0,
            strict: !0,
            [o]: !0
        }, S);
        const I = g(w.url).split("?")[0] || "",
            P = t.extract(w.url),
            M = t.parse(P, {
                sort: !1
            }),
            A = Object.assign(M, w.query);
        let E = t.stringify(A, S);
        E && (E = `?${E}`);
        let $ = y(w.url);
        return w.fragmentIdentifier && ($ = `#${S[o]?u(w.fragmentIdentifier,S):w.fragmentIdentifier}`), `${I}${E}${$}`
    }, t.pick = (w, S, I) => {
        I = Object.assign({
            parseFragmentIdentifier: !0,
            [o]: !1
        }, I);
        const {
            url: P,
            query: M,
            fragmentIdentifier: A
        } = t.parseUrl(w, I);
        return t.stringifyUrl({
            url: P,
            query: i(M, S),
            fragmentIdentifier: A
        }, I)
    }, t.exclude = (w, S, I) => {
        const P = Array.isArray(S) ? M => !S.includes(M) : (M, A) => !S(M, A);
        return t.pick(w, P, I)
    }
})(V_);
const bSe = {
        waku: {
            publish: "waku_publish",
            batchPublish: "waku_batchPublish",
            subscribe: "waku_subscribe",
            batchSubscribe: "waku_batchSubscribe",
            subscription: "waku_subscription",
            unsubscribe: "waku_unsubscribe",
            batchUnsubscribe: "waku_batchUnsubscribe",
            batchFetchMessages: "waku_batchFetchMessages"
        },
        irn: {
            publish: "irn_publish",
            batchPublish: "irn_batchPublish",
            subscribe: "irn_subscribe",
            batchSubscribe: "irn_batchSubscribe",
            subscription: "irn_subscription",
            unsubscribe: "irn_unsubscribe",
            batchUnsubscribe: "irn_batchUnsubscribe",
            batchFetchMessages: "irn_batchFetchMessages"
        },
        iridium: {
            publish: "iridium_publish",
            batchPublish: "iridium_batchPublish",
            subscribe: "iridium_subscribe",
            batchSubscribe: "iridium_batchSubscribe",
            subscription: "iridium_subscription",
            unsubscribe: "iridium_unsubscribe",
            batchUnsubscribe: "iridium_batchUnsubscribe",
            batchFetchMessages: "iridium_batchFetchMessages"
        }
    },
    _Se = ":";

function ESe(t) {
    const [e, n] = t.split(_Se);
    return {
        namespace: e,
        reference: n
    }
}

function xSe(t, e = []) {
    const n = [];
    return Object.keys(t).forEach(r => {
        if (e.length && !e.includes(r)) return;
        const i = t[r];
        n.push(...i.accounts)
    }), n
}

function Jte(t, e) {
    return t.includes(":") ? [t] : e.chains || []
}
const Xte = "base10",
    ca = "base16",
    ak = "base64pad",
    lL = "utf8",
    ene = 0,
    py = 1,
    SSe = 0,
    BW = 1,
    lk = 12,
    cL = 32;

function CSe() {
    const t = rL.generateKeyPair();
    return {
        privateKey: ha(t.secretKey, ca),
        publicKey: ha(t.publicKey, ca)
    }
}

function ck() {
    const t = T2.randomBytes(cL);
    return ha(t, ca)
}

function ASe(t, e) {
    const n = rL.sharedKey(Ua(t, ca), Ua(e, ca), !0),
        r = new u4e(BT.SHA256, n).expand(cL);
    return ha(r, ca)
}

function TSe(t) {
    const e = BT.hash(Ua(t, ca));
    return ha(e, ca)
}

function nv(t) {
    const e = BT.hash(Ua(t, lL));
    return ha(e, ca)
}

function ISe(t) {
    return Ua(`${t}`, Xte)
}

function _E(t) {
    return Number(ha(t, Xte))
}

function RSe(t) {
    const e = ISe(typeof t.type < "u" ? t.type : ene);
    if (_E(e) === py && typeof t.senderPublicKey > "u") throw new Error("Missing sender public key for type 1 envelope");
    const n = typeof t.senderPublicKey < "u" ? Ua(t.senderPublicKey, ca) : void 0,
        r = typeof t.iv < "u" ? Ua(t.iv, ca) : T2.randomBytes(lk),
        i = new tL.ChaCha20Poly1305(Ua(t.symKey, ca)).seal(r, Ua(t.message, lL));
    return NSe({
        type: e,
        sealed: i,
        iv: r,
        senderPublicKey: n
    })
}

function OSe(t) {
    const e = new tL.ChaCha20Poly1305(Ua(t.symKey, ca)),
        {
            sealed: n,
            iv: r
        } = AC(t.encoded),
        i = e.open(r, n);
    if (i === null) throw new Error("Failed to decrypt");
    return ha(i, lL)
}

function NSe(t) {
    if (_E(t.type) === py) {
        if (typeof t.senderPublicKey > "u") throw new Error("Missing sender public key for type 1 envelope");
        return ha(nk([t.type, t.senderPublicKey, t.iv, t.sealed]), ak)
    }
    return ha(nk([t.type, t.iv, t.sealed]), ak)
}

function AC(t) {
    const e = Ua(t, ak),
        n = e.slice(SSe, BW),
        r = BW;
    if (_E(n) === py) {
        const a = r + cL,
            l = a + lk,
            c = e.slice(r, a),
            u = e.slice(a, l),
            f = e.slice(l);
        return {
            type: n,
            sealed: f,
            iv: u,
            senderPublicKey: c
        }
    }
    const i = r + lk,
        s = e.slice(r, i),
        o = e.slice(i);
    return {
        type: n,
        sealed: o,
        iv: s
    }
}

function PSe(t, e) {
    const n = AC(t);
    return tne({
        type: _E(n.type),
        senderPublicKey: typeof n.senderPublicKey < "u" ? ha(n.senderPublicKey, ca) : void 0,
        receiverPublicKey: e == null ? void 0 : e.receiverPublicKey
    })
}

function tne(t) {
    const e = (t == null ? void 0 : t.type) || ene;
    if (e === py) {
        if (typeof(t == null ? void 0 : t.senderPublicKey) > "u") throw new Error("missing sender public key");
        if (typeof(t == null ? void 0 : t.receiverPublicKey) > "u") throw new Error("missing receiver public key")
    }
    return {
        type: e,
        senderPublicKey: t == null ? void 0 : t.senderPublicKey,
        receiverPublicKey: t == null ? void 0 : t.receiverPublicKey
    }
}

function FW(t) {
    return t.type === py && typeof t.senderPublicKey == "string" && typeof t.receiverPublicKey == "string"
}
var kSe = Object.defineProperty,
    UW = Object.getOwnPropertySymbols,
    MSe = Object.prototype.hasOwnProperty,
    DSe = Object.prototype.propertyIsEnumerable,
    jW = (t, e, n) => e in t ? kSe(t, e, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: n
    }) : t[e] = n,
    HW = (t, e) => {
        for (var n in e || (e = {})) MSe.call(e, n) && jW(t, n, e[n]);
        if (UW)
            for (var n of UW(e)) DSe.call(e, n) && jW(t, n, e[n]);
        return t
    };
const $Se = "ReactNative",
    El = {
        reactNative: "react-native",
        node: "node",
        browser: "browser",
        unknown: "unknown"
    },
    LSe = "js";

function uL() {
    return typeof process < "u" && typeof process.versions < "u" && typeof process.versions.node < "u"
}

function R2() {
    return !sL() && !!oL() && navigator.product === $Se
}

function O2() {
    return !uL() && !!oL() && !!sL()
}

function EE() {
    return R2() ? El.reactNative : uL() ? El.node : O2() ? El.browser : El.unknown
}

function BSe() {
    var t;
    try {
        return R2() && typeof global < "u" && typeof(global == null ? void 0 : global.Application) < "u" ? (t = global.Application) == null ? void 0 : t.applicationId : void 0
    } catch {
        return
    }
}

function FSe(t, e) {
    let n = V_.parse(t);
    return n = HW(HW({}, n), e), t = V_.stringify(n), t
}

function USe() {
    return Zte() || {
        name: "",
        description: "",
        url: "",
        icons: [""]
    }
}

function jSe() {
    if (EE() === El.reactNative && typeof global < "u" && typeof(global == null ? void 0 : global.Platform) < "u") {
        const {
            OS: n,
            Version: r
        } = global.Platform;
        return [n, r].join("-")
    }
    const t = Sxe();
    if (t === null) return "unknown";
    const e = t.os ? t.os.replace(" ", "").toLowerCase() : "unknown";
    return t.type === "browser" ? [e, t.name, t.version].join("-") : [e, t.version].join("-")
}

function HSe() {
    var t;
    const e = EE();
    return e === El.browser ? [e, ((t = Yte()) == null ? void 0 : t.host) || "unknown"].join(":") : e
}

function zSe(t, e, n) {
    const r = jSe(),
        i = HSe();
    return [
        [t, e].join("-"), [LSe, n].join("-"), r, i
    ].join("/")
}

function WSe({
    protocol: t,
    version: e,
    relayUrl: n,
    sdkVersion: r,
    auth: i,
    projectId: s,
    useOnCloseEvent: o,
    bundleId: a
}) {
    const l = n.split("?"),
        c = zSe(t, e, r),
        u = {
            auth: i,
            ua: c,
            projectId: s,
            useOnCloseEvent: o || void 0,
            origin: a || void 0
        },
        f = FSe(l[1] || "", u);
    return l[0] + "?" + f
}

function l1(t, e) {
    return t.filter(n => e.includes(n)).length === t.length
}

function nne(t) {
    return Object.fromEntries(t.entries())
}

function rne(t) {
    return new Map(Object.entries(t))
}

function bw(t = Bt.FIVE_MINUTES, e) {
    const n = Bt.toMiliseconds(t || Bt.FIVE_MINUTES);
    let r, i, s;
    return {
        resolve: o => {
            s && r && (clearTimeout(s), r(o))
        },
        reject: o => {
            s && i && (clearTimeout(s), i(o))
        },
        done: () => new Promise((o, a) => {
            s = setTimeout(() => {
                a(new Error(e))
            }, n), r = o, i = a
        })
    }
}

function G_(t, e, n) {
    return new Promise(async (r, i) => {
        const s = setTimeout(() => i(new Error(n)), e);
        try {
            const o = await t;
            r(o)
        } catch (o) {
            i(o)
        }
        clearTimeout(s)
    })
}

function ine(t, e) {
    if (typeof e == "string" && e.startsWith(`${t}:`)) return e;
    if (t.toLowerCase() === "topic") {
        if (typeof e != "string") throw new Error('Value must be "string" for expirer target type: topic');
        return `topic:${e}`
    } else if (t.toLowerCase() === "id") {
        if (typeof e != "number") throw new Error('Value must be "number" for expirer target type: id');
        return `id:${e}`
    }
    throw new Error(`Unknown expirer target type: ${t}`)
}

function VSe(t) {
    return ine("topic", t)
}

function GSe(t) {
    return ine("id", t)
}

function sne(t) {
    const [e, n] = t.split(":"), r = {
        id: void 0,
        topic: void 0
    };
    if (e === "topic" && typeof n == "string") r.topic = n;
    else if (e === "id" && Number.isInteger(Number(n))) r.id = Number(n);
    else throw new Error(`Invalid target, expected id:number or topic:string, got ${e}:${n}`);
    return r
}

function hu(t, e) {
    return Bt.fromMiliseconds(Date.now() + Bt.toMiliseconds(t))
}

function S0(t) {
    return Date.now() >= Bt.toMiliseconds(t)
}

function ws(t, e) {
    return `${t}${e?`:${e}`:""}`
}

function JR(t = [], e = []) {
    return [...new Set([...t, ...e])]
}
async function qSe({
    id: t,
    topic: e,
    wcDeepLink: n
}) {
    try {
        if (!n) return;
        const r = typeof n == "string" ? JSON.parse(n) : n;
        let i = r == null ? void 0 : r.href;
        if (typeof i != "string") return;
        i.endsWith("/") && (i = i.slice(0, -1));
        const s = `${i}/wc?requestId=${t}&sessionTopic=${e}`,
            o = EE();
        o === El.browser ? s.startsWith("https://") ? window.open(s, "_blank", "noreferrer noopener") : window.open(s, "_self", "noreferrer noopener") : o === El.reactNative && typeof(global == null ? void 0 : global.Linking) < "u" && await global.Linking.openURL(s)
    } catch (r) {
        console.error(r)
    }
}
async function KSe(t, e) {
    try {
        return await t.getItem(e) || (O2() ? localStorage.getItem(e) : void 0)
    } catch (n) {
        console.error(n)
    }
}
const YSe = "irn";

function uk(t) {
    return (t == null ? void 0 : t.relay) || {
        protocol: YSe
    }
}

function QS(t) {
    const e = bSe[t];
    if (typeof e > "u") throw new Error(`Relay Protocol not supported: ${t}`);
    return e
}
var ZSe = Object.defineProperty,
    zW = Object.getOwnPropertySymbols,
    QSe = Object.prototype.hasOwnProperty,
    JSe = Object.prototype.propertyIsEnumerable,
    WW = (t, e, n) => e in t ? ZSe(t, e, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: n
    }) : t[e] = n,
    XSe = (t, e) => {
        for (var n in e || (e = {})) QSe.call(e, n) && WW(t, n, e[n]);
        if (zW)
            for (var n of zW(e)) JSe.call(e, n) && WW(t, n, e[n]);
        return t
    };

function e8e(t, e = "-") {
    const n = {},
        r = "relay" + e;
    return Object.keys(t).forEach(i => {
        if (i.startsWith(r)) {
            const s = i.replace(r, ""),
                o = t[i];
            n[s] = o
        }
    }), n
}

function VW(t) {
    t = t.includes("wc://") ? t.replace("wc://", "") : t, t = t.includes("wc:") ? t.replace("wc:", "") : t;
    const e = t.indexOf(":"),
        n = t.indexOf("?") !== -1 ? t.indexOf("?") : void 0,
        r = t.substring(0, e),
        i = t.substring(e + 1, n).split("@"),
        s = typeof n < "u" ? t.substring(n) : "",
        o = V_.parse(s);
    return {
        protocol: r,
        topic: t8e(i[0]),
        version: parseInt(i[1], 10),
        symKey: o.symKey,
        relay: e8e(o)
    }
}

function t8e(t) {
    return t.startsWith("//") ? t.substring(2) : t
}

function n8e(t, e = "-") {
    const n = "relay",
        r = {};
    return Object.keys(t).forEach(i => {
        const s = n + e + i;
        t[i] && (r[s] = t[i])
    }), r
}

function r8e(t) {
    return `${t.protocol}:${t.topic}@${t.version}?` + V_.stringify(XSe({
        symKey: t.symKey
    }, n8e(t.relay)))
}

function N2(t) {
    const e = [];
    return t.forEach(n => {
        const [r, i] = n.split(":");
        e.push(`${r}:${i}`)
    }), e
}

function i8e(t) {
    const e = [];
    return Object.values(t).forEach(n => {
        e.push(...N2(n.accounts))
    }), e
}

function s8e(t, e) {
    const n = [];
    return Object.values(t).forEach(r => {
        N2(r.accounts).includes(e) && n.push(...r.methods)
    }), n
}

function o8e(t, e) {
    const n = [];
    return Object.values(t).forEach(r => {
        N2(r.accounts).includes(e) && n.push(...r.events)
    }), n
}

function a8e(t, e) {
    const n = JS(t, e);
    if (n) throw new Error(n.message);
    const r = {};
    for (const [i, s] of Object.entries(t)) r[i] = {
        methods: s.methods,
        events: s.events,
        chains: s.accounts.map(o => `${o.split(":")[0]}:${o.split(":")[1]}`)
    };
    return r
}

function fL(t) {
    return t.includes(":")
}

function b3(t) {
    return fL(t) ? t.split(":")[0] : t
}
const l8e = {
        INVALID_METHOD: {
            message: "Invalid method.",
            code: 1001
        },
        INVALID_EVENT: {
            message: "Invalid event.",
            code: 1002
        },
        INVALID_UPDATE_REQUEST: {
            message: "Invalid update request.",
            code: 1003
        },
        INVALID_EXTEND_REQUEST: {
            message: "Invalid extend request.",
            code: 1004
        },
        INVALID_SESSION_SETTLE_REQUEST: {
            message: "Invalid session settle request.",
            code: 1005
        },
        UNAUTHORIZED_METHOD: {
            message: "Unauthorized method.",
            code: 3001
        },
        UNAUTHORIZED_EVENT: {
            message: "Unauthorized event.",
            code: 3002
        },
        UNAUTHORIZED_UPDATE_REQUEST: {
            message: "Unauthorized update request.",
            code: 3003
        },
        UNAUTHORIZED_EXTEND_REQUEST: {
            message: "Unauthorized extend request.",
            code: 3004
        },
        USER_REJECTED: {
            message: "User rejected.",
            code: 5e3
        },
        USER_REJECTED_CHAINS: {
            message: "User rejected chains.",
            code: 5001
        },
        USER_REJECTED_METHODS: {
            message: "User rejected methods.",
            code: 5002
        },
        USER_REJECTED_EVENTS: {
            message: "User rejected events.",
            code: 5003
        },
        UNSUPPORTED_CHAINS: {
            message: "Unsupported chains.",
            code: 5100
        },
        UNSUPPORTED_METHODS: {
            message: "Unsupported methods.",
            code: 5101
        },
        UNSUPPORTED_EVENTS: {
            message: "Unsupported events.",
            code: 5102
        },
        UNSUPPORTED_ACCOUNTS: {
            message: "Unsupported accounts.",
            code: 5103
        },
        UNSUPPORTED_NAMESPACE_KEY: {
            message: "Unsupported namespace key.",
            code: 5104
        },
        USER_DISCONNECTED: {
            message: "User disconnected.",
            code: 6e3
        },
        SESSION_SETTLEMENT_FAILED: {
            message: "Session settlement failed.",
            code: 7e3
        },
        WC_METHOD_UNSUPPORTED: {
            message: "Unsupported wc_ method.",
            code: 10001
        }
    },
    c8e = {
        NOT_INITIALIZED: {
            message: "Not initialized.",
            code: 1
        },
        NO_MATCHING_KEY: {
            message: "No matching key.",
            code: 2
        },
        RESTORE_WILL_OVERRIDE: {
            message: "Restore will override.",
            code: 3
        },
        RESUBSCRIBED: {
            message: "Resubscribed.",
            code: 4
        },
        MISSING_OR_INVALID: {
            message: "Missing or invalid.",
            code: 5
        },
        EXPIRED: {
            message: "Expired.",
            code: 6
        },
        UNKNOWN_TYPE: {
            message: "Unknown type.",
            code: 7
        },
        MISMATCHED_TOPIC: {
            message: "Mismatched topic.",
            code: 8
        },
        NON_CONFORMING_NAMESPACES: {
            message: "Non conforming namespaces.",
            code: 9
        }
    };

function ut(t, e) {
    const {
        message: n,
        code: r
    } = c8e[t];
    return {
        message: e ? `${n} ${e}` : n,
        code: r
    }
}

function Vi(t, e) {
    const {
        message: n,
        code: r
    } = l8e[t];
    return {
        message: e ? `${n} ${e}` : n,
        code: r
    }
}

function sd(t, e) {
    return !!Array.isArray(t)
}

function rv(t) {
    return Object.getPrototypeOf(t) === Object.prototype && Object.keys(t).length
}

function Fa(t) {
    return typeof t > "u"
}

function Ks(t, e) {
    return e && Fa(t) ? !0 : typeof t == "string" && !!t.trim().length
}

function dL(t, e) {
    return typeof t == "number" && !isNaN(t)
}

function u8e(t, e) {
    const {
        requiredNamespaces: n
    } = e, r = Object.keys(t.namespaces), i = Object.keys(n);
    let s = !0;
    return l1(i, r) ? (r.forEach(o => {
        const {
            accounts: a,
            methods: l,
            events: c
        } = t.namespaces[o], u = N2(a), f = n[o];
        (!l1(Jte(o, f), u) || !l1(f.methods, l) || !l1(f.events, c)) && (s = !1)
    }), s) : !1
}

function TC(t) {
    return Ks(t, !1) && t.includes(":") ? t.split(":").length === 2 : !1
}

function f8e(t) {
    if (Ks(t, !1) && t.includes(":")) {
        const e = t.split(":");
        if (e.length === 3) {
            const n = e[0] + ":" + e[1];
            return !!e[2] && TC(n)
        }
    }
    return !1
}

function d8e(t) {
    if (Ks(t, !1)) try {
        return typeof new URL(t) < "u"
    } catch {
        return !1
    }
    return !1
}

function h8e(t) {
    var e;
    return (e = t == null ? void 0 : t.proposer) == null ? void 0 : e.publicKey
}

function p8e(t) {
    return t == null ? void 0 : t.topic
}

function g8e(t, e) {
    let n = null;
    return Ks(t == null ? void 0 : t.publicKey, !1) || (n = ut("MISSING_OR_INVALID", `${e} controller public key should be a string`)), n
}

function GW(t) {
    let e = !0;
    return sd(t) ? t.length && (e = t.every(n => Ks(n, !1))) : e = !1, e
}

function m8e(t, e, n) {
    let r = null;
    return sd(e) && e.length ? e.forEach(i => {
        r || TC(i) || (r = Vi("UNSUPPORTED_CHAINS", `${n}, chain ${i} should be a string and conform to "namespace:chainId" format`))
    }) : TC(t) || (r = Vi("UNSUPPORTED_CHAINS", `${n}, chains must be defined as "namespace:chainId" e.g. "eip155:1": {...} in the namespace key OR as an array of CAIP-2 chainIds e.g. eip155: { chains: ["eip155:1", "eip155:5"] }`)), r
}

function y8e(t, e, n) {
    let r = null;
    return Object.entries(t).forEach(([i, s]) => {
        if (r) return;
        const o = m8e(i, Jte(i, s), `${e} ${n}`);
        o && (r = o)
    }), r
}

function w8e(t, e) {
    let n = null;
    return sd(t) ? t.forEach(r => {
        n || f8e(r) || (n = Vi("UNSUPPORTED_ACCOUNTS", `${e}, account ${r} should be a string and conform to "namespace:chainId:address" format`))
    }) : n = Vi("UNSUPPORTED_ACCOUNTS", `${e}, accounts should be an array of strings conforming to "namespace:chainId:address" format`), n
}

function v8e(t, e) {
    let n = null;
    return Object.values(t).forEach(r => {
        if (n) return;
        const i = w8e(r == null ? void 0 : r.accounts, `${e} namespace`);
        i && (n = i)
    }), n
}

function b8e(t, e) {
    let n = null;
    return GW(t == null ? void 0 : t.methods) ? GW(t == null ? void 0 : t.events) || (n = Vi("UNSUPPORTED_EVENTS", `${e}, events should be an array of strings or empty array for no events`)) : n = Vi("UNSUPPORTED_METHODS", `${e}, methods should be an array of strings or empty array for no methods`), n
}

function one(t, e) {
    let n = null;
    return Object.values(t).forEach(r => {
        if (n) return;
        const i = b8e(r, `${e}, namespace`);
        i && (n = i)
    }), n
}

function _8e(t, e, n) {
    let r = null;
    if (t && rv(t)) {
        const i = one(t, e);
        i && (r = i);
        const s = y8e(t, e, n);
        s && (r = s)
    } else r = ut("MISSING_OR_INVALID", `${e}, ${n} should be an object with data`);
    return r
}

function JS(t, e) {
    let n = null;
    if (t && rv(t)) {
        const r = one(t, e);
        r && (n = r);
        const i = v8e(t, e);
        i && (n = i)
    } else n = ut("MISSING_OR_INVALID", `${e}, namespaces should be an object with data`);
    return n
}

function ane(t) {
    return Ks(t.protocol, !0)
}

function E8e(t, e) {
    let n = !1;
    return t ? t && sd(t) && t.length && t.forEach(r => {
        n = ane(r)
    }) : n = !0, n
}

function x8e(t) {
    return typeof t == "number"
}

function Pa(t) {
    return typeof t < "u" && typeof t !== null
}

function S8e(t) {
    return !(!t || typeof t != "object" || !t.code || !dL(t.code) || !t.message || !Ks(t.message, !1))
}

function C8e(t) {
    return !(Fa(t) || !Ks(t.method, !1))
}

function A8e(t) {
    return !(Fa(t) || Fa(t.result) && Fa(t.error) || !dL(t.id) || !Ks(t.jsonrpc, !1))
}

function T8e(t) {
    return !(Fa(t) || !Ks(t.name, !1))
}

function qW(t, e) {
    return !(!TC(e) || !i8e(t).includes(e))
}

function I8e(t, e, n) {
    return Ks(n, !1) ? s8e(t, e).includes(n) : !1
}

function R8e(t, e, n) {
    return Ks(n, !1) ? o8e(t, e).includes(n) : !1
}

function KW(t, e, n) {
    let r = null;
    const i = O8e(t),
        s = N8e(e),
        o = Object.keys(i),
        a = Object.keys(s),
        l = YW(Object.keys(t)),
        c = YW(Object.keys(e)),
        u = l.filter(f => !c.includes(f));
    return u.length && (r = ut("NON_CONFORMING_NAMESPACES", `${n} namespaces keys don't satisfy requiredNamespaces.
      Required: ${u.toString()}
      Received: ${Object.keys(e).toString()}`)), l1(o, a) || (r = ut("NON_CONFORMING_NAMESPACES", `${n} namespaces chains don't satisfy required namespaces.
      Required: ${o.toString()}
      Approved: ${a.toString()}`)), Object.keys(e).forEach(f => {
        if (!f.includes(":") || r) return;
        const h = N2(e[f].accounts);
        h.includes(f) || (r = ut("NON_CONFORMING_NAMESPACES", `${n} namespaces accounts don't satisfy namespace accounts for ${f}
        Required: ${f}
        Approved: ${h.toString()}`))
    }), o.forEach(f => {
        r || (l1(i[f].methods, s[f].methods) ? l1(i[f].events, s[f].events) || (r = ut("NON_CONFORMING_NAMESPACES", `${n} namespaces events don't satisfy namespace events for ${f}`)) : r = ut("NON_CONFORMING_NAMESPACES", `${n} namespaces methods don't satisfy namespace methods for ${f}`))
    }), r
}

function O8e(t) {
    const e = {};
    return Object.keys(t).forEach(n => {
        var r;
        n.includes(":") ? e[n] = t[n] : (r = t[n].chains) == null || r.forEach(i => {
            e[i] = {
                methods: t[n].methods,
                events: t[n].events
            }
        })
    }), e
}

function YW(t) {
    return [...new Set(t.map(e => e.includes(":") ? e.split(":")[0] : e))]
}

function N8e(t) {
    const e = {};
    return Object.keys(t).forEach(n => {
        if (n.includes(":")) e[n] = t[n];
        else {
            const r = N2(t[n].accounts);
            r == null || r.forEach(i => {
                e[i] = {
                    accounts: t[n].accounts.filter(s => s.includes(`${i}:`)),
                    methods: t[n].methods,
                    events: t[n].events
                }
            })
        }
    }), e
}

function P8e(t, e) {
    return dL(t) && t <= e.max && t >= e.min
}

function ZW() {
    const t = EE();
    return new Promise(e => {
        switch (t) {
            case El.browser:
                e(k8e());
                break;
            case El.reactNative:
                e(M8e());
                break;
            case El.node:
                e(D8e());
                break;
            default:
                e(!0)
        }
    })
}

function k8e() {
    return O2() && (navigator == null ? void 0 : navigator.onLine)
}
async function M8e() {
    if (R2() && typeof global < "u" && global != null && global.NetInfo) {
        const t = await (global == null ? void 0 : global.NetInfo.fetch());
        return t == null ? void 0 : t.isConnected
    }
    return !0
}

function D8e() {
    return !0
}

function $8e(t) {
    switch (EE()) {
        case El.browser:
            L8e(t);
            break;
        case El.reactNative:
            B8e(t);
            break
    }
}

function L8e(t) {
    !R2() && O2() && (window.addEventListener("online", () => t(!0)), window.addEventListener("offline", () => t(!1)))
}

function B8e(t) {
    R2() && typeof global < "u" && global != null && global.NetInfo && (global == null || global.NetInfo.addEventListener(e => t(e == null ? void 0 : e.isConnected)))
}
const XR = {};
let Lx = class {
    static get(e) {
        return XR[e]
    }
    static set(e, n) {
        XR[e] = n
    }
    static delete(e) {
        delete XR[e]
    }
};
const F8e = /"(?:_|\\u0{2}5[Ff]){2}(?:p|\\u0{2}70)(?:r|\\u0{2}72)(?:o|\\u0{2}6[Ff])(?:t|\\u0{2}74)(?:o|\\u0{2}6[Ff])(?:_|\\u0{2}5[Ff]){2}"\s*:/,
    U8e = /"(?:c|\\u0063)(?:o|\\u006[Ff])(?:n|\\u006[Ee])(?:s|\\u0073)(?:t|\\u0074)(?:r|\\u0072)(?:u|\\u0075)(?:c|\\u0063)(?:t|\\u0074)(?:o|\\u006[Ff])(?:r|\\u0072)"\s*:/,
    j8e = /^\s*["[{]|^\s*-?\d{1,16}(\.\d{1,17})?([Ee][+-]?\d+)?\s*$/;

function H8e(t, e) {
    if (t === "__proto__" || t === "constructor" && e && typeof e == "object" && "prototype" in e) {
        z8e(t);
        return
    }
    return e
}

function z8e(t) {
    console.warn(`[destr] Dropping "${t}" key to prevent prototype pollution.`)
}

function Bx(t, e = {}) {
    if (typeof t != "string") return t;
    const n = t.trim();
    if (t[0] === '"' && t.endsWith('"') && !t.includes("\\")) return n.slice(1, -1);
    if (n.length <= 9) {
        const r = n.toLowerCase();
        if (r === "true") return !0;
        if (r === "false") return !1;
        if (r === "undefined") return;
        if (r === "null") return null;
        if (r === "nan") return Number.NaN;
        if (r === "infinity") return Number.POSITIVE_INFINITY;
        if (r === "-infinity") return Number.NEGATIVE_INFINITY
    }
    if (!j8e.test(t)) {
        if (e.strict) throw new SyntaxError("[destr] Invalid JSON");
        return t
    }
    try {
        if (F8e.test(t) || U8e.test(t)) {
            if (e.strict) throw new Error("[destr] Possible prototype pollution");
            return JSON.parse(t, H8e)
        }
        return JSON.parse(t)
    } catch (r) {
        if (e.strict) throw r;
        return t
    }
}

function W8e(t) {
    return !t || typeof t.then != "function" ? Promise.resolve(t) : t
}

function Us(t, ...e) {
    try {
        return W8e(t(...e))
    } catch (n) {
        return Promise.reject(n)
    }
}

function V8e(t) {
    const e = typeof t;
    return t === null || e !== "object" && e !== "function"
}

function G8e(t) {
    const e = Object.getPrototypeOf(t);
    return !e || e.isPrototypeOf(Object)
}

function XS(t) {
    if (V8e(t)) return String(t);
    if (G8e(t) || Array.isArray(t)) return JSON.stringify(t);
    if (typeof t.toJSON == "function") return XS(t.toJSON());
    throw new Error("[unstorage] Cannot stringify value!")
}

function lne() {
    if (typeof Buffer > "u") throw new TypeError("[unstorage] Buffer is not supported!")
}
const fk = "base64:";

function q8e(t) {
    if (typeof t == "string") return t;
    lne();
    const e = Buffer.from(t).toString("base64");
    return fk + e
}

function K8e(t) {
    return typeof t != "string" || !t.startsWith(fk) ? t : (lne(), Buffer.from(t.slice(fk.length), "base64"))
}

function Ra(t) {
    return t ? t.split("?")[0].replace(/[/\\]/g, ":").replace(/:+/g, ":").replace(/^:|:$/g, "") : ""
}

function Y8e(...t) {
    return Ra(t.join(":"))
}

function Fx(t) {
    return t = Ra(t), t ? t + ":" : ""
}
const Z8e = "memory",
    Q8e = () => {
        const t = new Map;
        return {
            name: Z8e,
            getInstance: () => t,
            hasItem(e) {
                return t.has(e)
            },
            getItem(e) {
                return t.get(e) ? ? null
            },
            getItemRaw(e) {
                return t.get(e) ? ? null
            },
            setItem(e, n) {
                t.set(e, n)
            },
            setItemRaw(e, n) {
                t.set(e, n)
            },
            removeItem(e) {
                t.delete(e)
            },
            getKeys() {
                return [...t.keys()]
            },
            clear() {
                t.clear()
            },
            dispose() {
                t.clear()
            }
        }
    };

function J8e(t = {}) {
    const e = {
            mounts: {
                "": t.driver || Q8e()
            },
            mountpoints: [""],
            watching: !1,
            watchListeners: [],
            unwatch: {}
        },
        n = c => {
            for (const u of e.mountpoints)
                if (c.startsWith(u)) return {
                    base: u,
                    relativeKey: c.slice(u.length),
                    driver: e.mounts[u]
                };
            return {
                base: "",
                relativeKey: c,
                driver: e.mounts[""]
            }
        },
        r = (c, u) => e.mountpoints.filter(f => f.startsWith(c) || u && c.startsWith(f)).map(f => ({
            relativeBase: c.length > f.length ? c.slice(f.length) : void 0,
            mountpoint: f,
            driver: e.mounts[f]
        })),
        i = (c, u) => {
            if (e.watching) {
                u = Ra(u);
                for (const f of e.watchListeners) f(c, u)
            }
        },
        s = async () => {
            if (!e.watching) {
                e.watching = !0;
                for (const c in e.mounts) e.unwatch[c] = await QW(e.mounts[c], i, c)
            }
        },
        o = async () => {
            if (e.watching) {
                for (const c in e.unwatch) await e.unwatch[c]();
                e.unwatch = {}, e.watching = !1
            }
        },
        a = (c, u, f) => {
            const h = new Map,
                g = y => {
                    let _ = h.get(y.base);
                    return _ || (_ = {
                        driver: y.driver,
                        base: y.base,
                        items: []
                    }, h.set(y.base, _)), _
                };
            for (const y of c) {
                const _ = typeof y == "string",
                    C = Ra(_ ? y : y.key),
                    b = _ ? void 0 : y.value,
                    w = _ || !y.options ? u : { ...u,
                        ...y.options
                    },
                    S = n(C);
                g(S).items.push({
                    key: C,
                    value: b,
                    relativeKey: S.relativeKey,
                    options: w
                })
            }
            return Promise.all([...h.values()].map(y => f(y))).then(y => y.flat())
        },
        l = {
            hasItem(c, u = {}) {
                c = Ra(c);
                const {
                    relativeKey: f,
                    driver: h
                } = n(c);
                return Us(h.hasItem, f, u)
            },
            getItem(c, u = {}) {
                c = Ra(c);
                const {
                    relativeKey: f,
                    driver: h
                } = n(c);
                return Us(h.getItem, f, u).then(g => Bx(g))
            },
            getItems(c, u) {
                return a(c, u, f => f.driver.getItems ? Us(f.driver.getItems, f.items.map(h => ({
                    key: h.relativeKey,
                    options: h.options
                })), u).then(h => h.map(g => ({
                    key: Y8e(f.base, g.key),
                    value: Bx(g.value)
                }))) : Promise.all(f.items.map(h => Us(f.driver.getItem, h.relativeKey, h.options).then(g => ({
                    key: h.key,
                    value: Bx(g)
                })))))
            },
            getItemRaw(c, u = {}) {
                c = Ra(c);
                const {
                    relativeKey: f,
                    driver: h
                } = n(c);
                return h.getItemRaw ? Us(h.getItemRaw, f, u) : Us(h.getItem, f, u).then(g => K8e(g))
            },
            async setItem(c, u, f = {}) {
                if (u === void 0) return l.removeItem(c);
                c = Ra(c);
                const {
                    relativeKey: h,
                    driver: g
                } = n(c);
                g.setItem && (await Us(g.setItem, h, XS(u), f), g.watch || i("update", c))
            },
            async setItems(c, u) {
                await a(c, u, async f => {
                    if (f.driver.setItems) return Us(f.driver.setItems, f.items.map(h => ({
                        key: h.relativeKey,
                        value: XS(h.value),
                        options: h.options
                    })), u);
                    f.driver.setItem && await Promise.all(f.items.map(h => Us(f.driver.setItem, h.relativeKey, XS(h.value), h.options)))
                })
            },
            async setItemRaw(c, u, f = {}) {
                if (u === void 0) return l.removeItem(c, f);
                c = Ra(c);
                const {
                    relativeKey: h,
                    driver: g
                } = n(c);
                if (g.setItemRaw) await Us(g.setItemRaw, h, u, f);
                else if (g.setItem) await Us(g.setItem, h, q8e(u), f);
                else return;
                g.watch || i("update", c)
            },
            async removeItem(c, u = {}) {
                typeof u == "boolean" && (u = {
                    removeMeta: u
                }), c = Ra(c);
                const {
                    relativeKey: f,
                    driver: h
                } = n(c);
                h.removeItem && (await Us(h.removeItem, f, u), (u.removeMeta || u.removeMata) && await Us(h.removeItem, f + "$", u), h.watch || i("remove", c))
            },
            async getMeta(c, u = {}) {
                typeof u == "boolean" && (u = {
                    nativeOnly: u
                }), c = Ra(c);
                const {
                    relativeKey: f,
                    driver: h
                } = n(c), g = Object.create(null);
                if (h.getMeta && Object.assign(g, await Us(h.getMeta, f, u)), !u.nativeOnly) {
                    const y = await Us(h.getItem, f + "$", u).then(_ => Bx(_));
                    y && typeof y == "object" && (typeof y.atime == "string" && (y.atime = new Date(y.atime)), typeof y.mtime == "string" && (y.mtime = new Date(y.mtime)), Object.assign(g, y))
                }
                return g
            },
            setMeta(c, u, f = {}) {
                return this.setItem(c + "$", u, f)
            },
            removeMeta(c, u = {}) {
                return this.removeItem(c + "$", u)
            },
            async getKeys(c, u = {}) {
                c = Fx(c);
                const f = r(c, !0);
                let h = [];
                const g = [];
                for (const y of f) {
                    const _ = await Us(y.driver.getKeys, y.relativeBase, u);
                    for (const C of _) {
                        const b = y.mountpoint + Ra(C);
                        h.some(w => b.startsWith(w)) || g.push(b)
                    }
                    h = [y.mountpoint, ...h.filter(C => !C.startsWith(y.mountpoint))]
                }
                return c ? g.filter(y => y.startsWith(c) && y[y.length - 1] !== "$") : g.filter(y => y[y.length - 1] !== "$")
            },
            async clear(c, u = {}) {
                c = Fx(c), await Promise.all(r(c, !1).map(async f => {
                    if (f.driver.clear) return Us(f.driver.clear, f.relativeBase, u);
                    if (f.driver.removeItem) {
                        const h = await f.driver.getKeys(f.relativeBase || "", u);
                        return Promise.all(h.map(g => f.driver.removeItem(g, u)))
                    }
                }))
            },
            async dispose() {
                await Promise.all(Object.values(e.mounts).map(c => JW(c)))
            },
            async watch(c) {
                return await s(), e.watchListeners.push(c), async () => {
                    e.watchListeners = e.watchListeners.filter(u => u !== c), e.watchListeners.length === 0 && await o()
                }
            },
            async unwatch() {
                e.watchListeners = [], await o()
            },
            mount(c, u) {
                if (c = Fx(c), c && e.mounts[c]) throw new Error(`already mounted at ${c}`);
                return c && (e.mountpoints.push(c), e.mountpoints.sort((f, h) => h.length - f.length)), e.mounts[c] = u, e.watching && Promise.resolve(QW(u, i, c)).then(f => {
                    e.unwatch[c] = f
                }).catch(console.error), l
            },
            async unmount(c, u = !0) {
                c = Fx(c), !(!c || !e.mounts[c]) && (e.watching && c in e.unwatch && (e.unwatch[c](), delete e.unwatch[c]), u && await JW(e.mounts[c]), e.mountpoints = e.mountpoints.filter(f => f !== c), delete e.mounts[c])
            },
            getMount(c = "") {
                c = Ra(c) + ":";
                const u = n(c);
                return {
                    driver: u.driver,
                    base: u.base
                }
            },
            getMounts(c = "", u = {}) {
                return c = Ra(c), r(c, u.parents).map(h => ({
                    driver: h.driver,
                    base: h.mountpoint
                }))
            },
            keys: (c, u = {}) => l.getKeys(c, u),
            get: (c, u = {}) => l.getItem(c, u),
            set: (c, u, f = {}) => l.setItem(c, u, f),
            has: (c, u = {}) => l.hasItem(c, u),
            del: (c, u = {}) => l.removeItem(c, u),
            remove: (c, u = {}) => l.removeItem(c, u)
        };
    return l
}

function QW(t, e, n) {
    return t.watch ? t.watch((r, i) => e(r, n + i)) : () => {}
}
async function JW(t) {
    typeof t.dispose == "function" && await Us(t.dispose)
}

function gy(t) {
    return new Promise((e, n) => {
        t.oncomplete = t.onsuccess = () => e(t.result), t.onabort = t.onerror = () => n(t.error)
    })
}

function cne(t, e) {
    const n = indexedDB.open(t);
    n.onupgradeneeded = () => n.result.createObjectStore(e);
    const r = gy(n);
    return (i, s) => r.then(o => s(o.transaction(e, i).objectStore(e)))
}
let eO;

function xE() {
    return eO || (eO = cne("keyval-store", "keyval")), eO
}

function XW(t, e = xE()) {
    return e("readonly", n => gy(n.get(t)))
}

function X8e(t, e, n = xE()) {
    return n("readwrite", r => (r.put(e, t), gy(r.transaction)))
}

function eCe(t, e = xE()) {
    return e("readwrite", n => (n.delete(t), gy(n.transaction)))
}

function tCe(t = xE()) {
    return t("readwrite", e => (e.clear(), gy(e.transaction)))
}

function nCe(t, e) {
    return t.openCursor().onsuccess = function() {
        this.result && (e(this.result), this.result.continue())
    }, gy(t.transaction)
}

function rCe(t = xE()) {
    return t("readonly", e => {
        if (e.getAllKeys) return gy(e.getAllKeys());
        const n = [];
        return nCe(e, r => n.push(r.key)).then(() => n)
    })
}
const iCe = t => JSON.stringify(t, (e, n) => typeof n == "bigint" ? n.toString() + "n" : n),
    sCe = t => {
        const e = /([\[:])?(\d{17,}|(?:[9](?:[1-9]07199254740991|0[1-9]7199254740991|00[8-9]199254740991|007[2-9]99254740991|007199[3-9]54740991|0071992[6-9]4740991|00719925[5-9]740991|007199254[8-9]40991|0071992547[5-9]0991|00719925474[1-9]991|00719925474099[2-9])))([,\}\]])/g,
            n = t.replace(e, '$1"$2n"$3');
        return JSON.parse(n, (r, i) => typeof i == "string" && i.match(/^\d+n$/) ? BigInt(i.substring(0, i.length - 1)) : i)
    };

function SE(t) {
    if (typeof t != "string") throw new Error(`Cannot safe json parse value of type ${typeof t}`);
    try {
        return sCe(t)
    } catch {
        return t
    }
}

function Pm(t) {
    return typeof t == "string" ? t : iCe(t) || ""
}
const oCe = "idb-keyval";
var aCe = (t = {}) => {
    const e = t.base && t.base.length > 0 ? `${t.base}:` : "",
        n = i => e + i;
    let r;
    return t.dbName && t.storeName && (r = cne(t.dbName, t.storeName)), {
        name: oCe,
        options: t,
        async hasItem(i) {
            return !(typeof await XW(n(i), r) > "u")
        },
        async getItem(i) {
            return await XW(n(i), r) ? ? null
        },
        setItem(i, s) {
            return X8e(n(i), s, r)
        },
        removeItem(i) {
            return eCe(n(i), r)
        },
        getKeys() {
            return rCe(r)
        },
        clear() {
            return tCe(r)
        }
    }
};
const lCe = "WALLET_CONNECT_V2_INDEXED_DB",
    cCe = "keyvaluestorage";
let uCe = class {
    constructor() {
        this.indexedDb = J8e({
            driver: aCe({
                dbName: lCe,
                storeName: cCe
            })
        })
    }
    async getKeys() {
        return this.indexedDb.getKeys()
    }
    async getEntries() {
        return (await this.indexedDb.getItems(await this.indexedDb.getKeys())).map(e => [e.key, e.value])
    }
    async getItem(e) {
        const n = await this.indexedDb.getItem(e);
        if (n !== null) return n
    }
    async setItem(e, n) {
        await this.indexedDb.setItem(e, Pm(n))
    }
    async removeItem(e) {
        await this.indexedDb.removeItem(e)
    }
};
var tO = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {},
    e8 = {
        exports: {}
    };
(function() {
    let t;

    function e() {}
    t = e, t.prototype.getItem = function(n) {
        return this.hasOwnProperty(n) ? String(this[n]) : null
    }, t.prototype.setItem = function(n, r) {
        this[n] = String(r)
    }, t.prototype.removeItem = function(n) {
        delete this[n]
    }, t.prototype.clear = function() {
        const n = this;
        Object.keys(n).forEach(function(r) {
            n[r] = void 0, delete n[r]
        })
    }, t.prototype.key = function(n) {
        return n = n || 0, Object.keys(this)[n]
    }, t.prototype.__defineGetter__("length", function() {
        return Object.keys(this).length
    }), typeof tO < "u" && tO.localStorage ? e8.exports = tO.localStorage : typeof window < "u" && window.localStorage ? e8.exports = window.localStorage : e8.exports = new e
})();

function fCe(t) {
    var e;
    return [t[0], SE((e = t[1]) != null ? e : "")]
}
let dCe = class {
    constructor() {
        this.localStorage = e8.exports
    }
    async getKeys() {
        return Object.keys(this.localStorage)
    }
    async getEntries() {
        return Object.entries(this.localStorage).map(fCe)
    }
    async getItem(e) {
        const n = this.localStorage.getItem(e);
        if (n !== null) return SE(n)
    }
    async setItem(e, n) {
        this.localStorage.setItem(e, Pm(n))
    }
    async removeItem(e) {
        this.localStorage.removeItem(e)
    }
};
const hCe = "wc_storage_version",
    eV = 1,
    pCe = async (t, e, n) => {
        const r = hCe,
            i = await e.getItem(r);
        if (i && i >= eV) {
            n(e);
            return
        }
        const s = await t.getKeys();
        if (!s.length) {
            n(e);
            return
        }
        const o = [];
        for (; s.length;) {
            const a = s.shift();
            if (!a) continue;
            const l = a.toLowerCase();
            if (l.includes("wc@") || l.includes("walletconnect") || l.includes("wc_") || l.includes("wallet_connect")) {
                const c = await t.getItem(a);
                await e.setItem(a, c), o.push(a)
            }
        }
        await e.setItem(r, eV), n(e), gCe(t, o)
    },
    gCe = async (t, e) => {
        e.length && e.forEach(async n => {
            await t.removeItem(n)
        })
    };
let mCe = class {
    constructor() {
        this.initialized = !1, this.setInitialized = n => {
            this.storage = n, this.initialized = !0
        };
        const e = new dCe;
        this.storage = e;
        try {
            const n = new uCe;
            pCe(e, n, this.setInitialized)
        } catch {
            this.initialized = !0
        }
    }
    async getKeys() {
        return await this.initialize(), this.storage.getKeys()
    }
    async getEntries() {
        return await this.initialize(), this.storage.getEntries()
    }
    async getItem(e) {
        return await this.initialize(), this.storage.getItem(e)
    }
    async setItem(e, n) {
        return await this.initialize(), this.storage.setItem(e, n)
    }
    async removeItem(e) {
        return await this.initialize(), this.storage.removeItem(e)
    }
    async initialize() {
        this.initialized || await new Promise(e => {
            const n = setInterval(() => {
                this.initialized && (clearInterval(n), e())
            }, 20)
        })
    }
};
var P2 = {},
    $5 = {},
    nO = {},
    L5 = {};
class my {}
const yCe = Object.freeze(Object.defineProperty({
        __proto__: null,
        IEvents: my
    }, Symbol.toStringTag, {
        value: "Module"
    })),
    wCe = Fu(yCe);
var tV;

function vCe() {
    if (tV) return L5;
    tV = 1, Object.defineProperty(L5, "__esModule", {
        value: !0
    }), L5.IHeartBeat = void 0;
    const t = wCe;
    class e extends t.IEvents {
        constructor(r) {
            super()
        }
    }
    return L5.IHeartBeat = e, L5
}
var nV;

function une() {
    return nV || (nV = 1, function(t) {
        Object.defineProperty(t, "__esModule", {
            value: !0
        }), Uh.__exportStar(vCe(), t)
    }(nO)), nO
}
var rO = {},
    $g = {},
    rV;

function bCe() {
    if (rV) return $g;
    rV = 1, Object.defineProperty($g, "__esModule", {
        value: !0
    }), $g.HEARTBEAT_EVENTS = $g.HEARTBEAT_INTERVAL = void 0;
    const t = Bt;
    return $g.HEARTBEAT_INTERVAL = t.FIVE_SECONDS, $g.HEARTBEAT_EVENTS = {
        pulse: "heartbeat_pulse"
    }, $g
}
var iV;

function fne() {
    return iV || (iV = 1, function(t) {
        Object.defineProperty(t, "__esModule", {
            value: !0
        }), Uh.__exportStar(bCe(), t)
    }(rO)), rO
}
var sV;

function _Ce() {
    if (sV) return $5;
    sV = 1, Object.defineProperty($5, "__esModule", {
        value: !0
    }), $5.HeartBeat = void 0;
    const t = Uh,
        e = uo,
        n = Bt,
        r = une(),
        i = fne();
    class s extends r.IHeartBeat {
        constructor(a) {
            super(a), this.events = new e.EventEmitter, this.interval = i.HEARTBEAT_INTERVAL, this.interval = (a == null ? void 0 : a.interval) || i.HEARTBEAT_INTERVAL
        }
        static init(a) {
            return t.__awaiter(this, void 0, void 0, function*() {
                const l = new s(a);
                return yield l.init(), l
            })
        }
        init() {
            return t.__awaiter(this, void 0, void 0, function*() {
                yield this.initialize()
            })
        }
        stop() {
            clearInterval(this.intervalRef)
        }
        on(a, l) {
            this.events.on(a, l)
        }
        once(a, l) {
            this.events.once(a, l)
        }
        off(a, l) {
            this.events.off(a, l)
        }
        removeListener(a, l) {
            this.events.removeListener(a, l)
        }
        initialize() {
            return t.__awaiter(this, void 0, void 0, function*() {
                this.intervalRef = setInterval(() => this.pulse(), n.toMiliseconds(this.interval))
            })
        }
        pulse() {
            this.events.emit(i.HEARTBEAT_EVENTS.pulse)
        }
    }
    return $5.HeartBeat = s, $5
}(function(t) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    const e = Uh;
    e.__exportStar(_Ce(), t), e.__exportStar(une(), t), e.__exportStar(fne(), t)
})(P2);

function ECe(t) {
    try {
        return JSON.stringify(t)
    } catch {
        return '"[Circular]"'
    }
}
var xCe = SCe;

function SCe(t, e, n) {
    var r = n && n.stringify || ECe,
        i = 1;
    if (typeof t == "object" && t !== null) {
        var s = e.length + i;
        if (s === 1) return t;
        var o = new Array(s);
        o[0] = r(t);
        for (var a = 1; a < s; a++) o[a] = r(e[a]);
        return o.join(" ")
    }
    if (typeof t != "string") return t;
    var l = e.length;
    if (l === 0) return t;
    for (var c = "", u = 1 - i, f = -1, h = t && t.length || 0, g = 0; g < h;) {
        if (t.charCodeAt(g) === 37 && g + 1 < h) {
            switch (f = f > -1 ? f : 0, t.charCodeAt(g + 1)) {
                case 100:
                case 102:
                    if (u >= l || e[u] == null) break;
                    f < g && (c += t.slice(f, g)), c += Number(e[u]), f = g + 2, g++;
                    break;
                case 105:
                    if (u >= l || e[u] == null) break;
                    f < g && (c += t.slice(f, g)), c += Math.floor(Number(e[u])), f = g + 2, g++;
                    break;
                case 79:
                case 111:
                case 106:
                    if (u >= l || e[u] === void 0) break;
                    f < g && (c += t.slice(f, g));
                    var y = typeof e[u];
                    if (y === "string") {
                        c += "'" + e[u] + "'", f = g + 2, g++;
                        break
                    }
                    if (y === "function") {
                        c += e[u].name || "<anonymous>", f = g + 2, g++;
                        break
                    }
                    c += r(e[u]), f = g + 2, g++;
                    break;
                case 115:
                    if (u >= l) break;
                    f < g && (c += t.slice(f, g)), c += String(e[u]), f = g + 2, g++;
                    break;
                case 37:
                    f < g && (c += t.slice(f, g)), c += "%", f = g + 2, g++, u--;
                    break
            }++u
        }++g
    }
    return f === -1 ? t : (f < h && (c += t.slice(f)), c)
}
const oV = xCe;
var CCe = Gf;
const q_ = DCe().console || {},
    ACe = {
        mapHttpRequest: Ux,
        mapHttpResponse: Ux,
        wrapRequestSerializer: iO,
        wrapResponseSerializer: iO,
        wrapErrorSerializer: iO,
        req: Ux,
        res: Ux,
        err: NCe
    };

function TCe(t, e) {
    return Array.isArray(t) ? t.filter(function(r) {
        return r !== "!stdSerializers.err"
    }) : t === !0 ? Object.keys(e) : !1
}

function Gf(t) {
    t = t || {}, t.browser = t.browser || {};
    const e = t.browser.transmit;
    if (e && typeof e.send != "function") throw Error("pino: transmit option must have a send function");
    const n = t.browser.write || q_;
    t.browser.write && (t.browser.asObject = !0);
    const r = t.serializers || {},
        i = TCe(t.browser.serialize, r);
    let s = t.browser.serialize;
    Array.isArray(t.browser.serialize) && t.browser.serialize.indexOf("!stdSerializers.err") > -1 && (s = !1);
    const o = ["error", "fatal", "warn", "info", "debug", "trace"];
    typeof n == "function" && (n.error = n.fatal = n.warn = n.info = n.debug = n.trace = n), t.enabled === !1 && (t.level = "silent");
    const a = t.level || "info",
        l = Object.create(n);
    l.log || (l.log = K_), Object.defineProperty(l, "levelVal", {
        get: u
    }), Object.defineProperty(l, "level", {
        get: f,
        set: h
    });
    const c = {
        transmit: e,
        serialize: i,
        asObject: t.browser.asObject,
        levels: o,
        timestamp: PCe(t)
    };
    l.levels = Gf.levels, l.level = a, l.setMaxListeners = l.getMaxListeners = l.emit = l.addListener = l.on = l.prependListener = l.once = l.prependOnceListener = l.removeListener = l.removeAllListeners = l.listeners = l.listenerCount = l.eventNames = l.write = l.flush = K_, l.serializers = r, l._serialize = i, l._stdErrSerialize = s, l.child = g, e && (l._logEvent = dk());

    function u() {
        return this.level === "silent" ? 1 / 0 : this.levels.values[this.level]
    }

    function f() {
        return this._level
    }

    function h(y) {
        if (y !== "silent" && !this.levels.values[y]) throw Error("unknown level " + y);
        this._level = y, Jy(c, l, "error", "log"), Jy(c, l, "fatal", "error"), Jy(c, l, "warn", "error"), Jy(c, l, "info", "log"), Jy(c, l, "debug", "log"), Jy(c, l, "trace", "log")
    }

    function g(y, _) {
        if (!y) throw new Error("missing bindings for child Pino");
        _ = _ || {}, i && y.serializers && (_.serializers = y.serializers);
        const C = _.serializers;
        if (i && C) {
            var b = Object.assign({}, r, C),
                w = t.browser.serialize === !0 ? Object.keys(b) : i;
            delete y.serializers, UT([y], w, b, this._stdErrSerialize)
        }

        function S(I) {
            this._childLevel = (I._childLevel | 0) + 1, this.error = Xy(I, y, "error"), this.fatal = Xy(I, y, "fatal"), this.warn = Xy(I, y, "warn"), this.info = Xy(I, y, "info"), this.debug = Xy(I, y, "debug"), this.trace = Xy(I, y, "trace"), b && (this.serializers = b, this._serialize = w), e && (this._logEvent = dk([].concat(I._logEvent.bindings, y)))
        }
        return S.prototype = this, new S(this)
    }
    return l
}
Gf.levels = {
    values: {
        fatal: 60,
        error: 50,
        warn: 40,
        info: 30,
        debug: 20,
        trace: 10
    },
    labels: {
        10: "trace",
        20: "debug",
        30: "info",
        40: "warn",
        50: "error",
        60: "fatal"
    }
};
Gf.stdSerializers = ACe;
Gf.stdTimeFunctions = Object.assign({}, {
    nullTime: dne,
    epochTime: hne,
    unixTime: kCe,
    isoTime: MCe
});

function Jy(t, e, n, r) {
    const i = Object.getPrototypeOf(e);
    e[n] = e.levelVal > e.levels.values[n] ? K_ : i[n] ? i[n] : q_[n] || q_[r] || K_, ICe(t, e, n)
}

function ICe(t, e, n) {
    !t.transmit && e[n] === K_ || (e[n] = function(r) {
        return function() {
            const s = t.timestamp(),
                o = new Array(arguments.length),
                a = Object.getPrototypeOf && Object.getPrototypeOf(this) === q_ ? q_ : this;
            for (var l = 0; l < o.length; l++) o[l] = arguments[l];
            if (t.serialize && !t.asObject && UT(o, this._serialize, this.serializers, this._stdErrSerialize), t.asObject ? r.call(a, RCe(this, n, o, s)) : r.apply(a, o), t.transmit) {
                const c = t.transmit.level || e.level,
                    u = Gf.levels.values[c],
                    f = Gf.levels.values[n];
                if (f < u) return;
                OCe(this, {
                    ts: s,
                    methodLevel: n,
                    methodValue: f,
                    transmitLevel: c,
                    transmitValue: Gf.levels.values[t.transmit.level || e.level],
                    send: t.transmit.send,
                    val: e.levelVal
                }, o)
            }
        }
    }(e[n]))
}

function RCe(t, e, n, r) {
    t._serialize && UT(n, t._serialize, t.serializers, t._stdErrSerialize);
    const i = n.slice();
    let s = i[0];
    const o = {};
    r && (o.time = r), o.level = Gf.levels.values[e];
    let a = (t._childLevel | 0) + 1;
    if (a < 1 && (a = 1), s !== null && typeof s == "object") {
        for (; a-- && typeof i[0] == "object";) Object.assign(o, i.shift());
        s = i.length ? oV(i.shift(), i) : void 0
    } else typeof s == "string" && (s = oV(i.shift(), i));
    return s !== void 0 && (o.msg = s), o
}

function UT(t, e, n, r) {
    for (const i in t)
        if (r && t[i] instanceof Error) t[i] = Gf.stdSerializers.err(t[i]);
        else if (typeof t[i] == "object" && !Array.isArray(t[i]))
        for (const s in t[i]) e && e.indexOf(s) > -1 && s in n && (t[i][s] = n[s](t[i][s]))
}

function Xy(t, e, n) {
    return function() {
        const r = new Array(1 + arguments.length);
        r[0] = e;
        for (var i = 1; i < r.length; i++) r[i] = arguments[i - 1];
        return t[n].apply(this, r)
    }
}

function OCe(t, e, n) {
    const r = e.send,
        i = e.ts,
        s = e.methodLevel,
        o = e.methodValue,
        a = e.val,
        l = t._logEvent.bindings;
    UT(n, t._serialize || Object.keys(t.serializers), t.serializers, t._stdErrSerialize === void 0 ? !0 : t._stdErrSerialize), t._logEvent.ts = i, t._logEvent.messages = n.filter(function(c) {
        return l.indexOf(c) === -1
    }), t._logEvent.level.label = s, t._logEvent.level.value = o, r(s, t._logEvent, a), t._logEvent = dk(l)
}

function dk(t) {
    return {
        ts: 0,
        messages: [],
        bindings: t || [],
        level: {
            label: "",
            value: 0
        }
    }
}

function NCe(t) {
    const e = {
        type: t.constructor.name,
        msg: t.message,
        stack: t.stack
    };
    for (const n in t) e[n] === void 0 && (e[n] = t[n]);
    return e
}

function PCe(t) {
    return typeof t.timestamp == "function" ? t.timestamp : t.timestamp === !1 ? dne : hne
}

function Ux() {
    return {}
}

function iO(t) {
    return t
}

function K_() {}

function dne() {
    return !1
}

function hne() {
    return Date.now()
}

function kCe() {
    return Math.round(Date.now() / 1e3)
}

function MCe() {
    return new Date(Date.now()).toISOString()
}

function DCe() {
    function t(e) {
        return typeof e < "u" && e
    }
    try {
        return typeof globalThis < "u" || Object.defineProperty(Object.prototype, "globalThis", {
            get: function() {
                return delete Object.prototype.globalThis, this.globalThis = this
            },
            configurable: !0
        }), globalThis
    } catch {
        return t(self) || t(window) || t(this) || {}
    }
}
const jT = co(CCe),
    $Ce = {
        level: "info"
    },
    CE = "custom_context";
var LCe = Object.defineProperty,
    BCe = Object.defineProperties,
    FCe = Object.getOwnPropertyDescriptors,
    aV = Object.getOwnPropertySymbols,
    UCe = Object.prototype.hasOwnProperty,
    jCe = Object.prototype.propertyIsEnumerable,
    lV = (t, e, n) => e in t ? LCe(t, e, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: n
    }) : t[e] = n,
    HCe = (t, e) => {
        for (var n in e || (e = {})) UCe.call(e, n) && lV(t, n, e[n]);
        if (aV)
            for (var n of aV(e)) jCe.call(e, n) && lV(t, n, e[n]);
        return t
    },
    zCe = (t, e) => BCe(t, FCe(e));

function HT(t) {
    return zCe(HCe({}, t), {
        level: (t == null ? void 0 : t.level) || $Ce.level
    })
}

function WCe(t, e = CE) {
    return t[e] || ""
}

function VCe(t, e, n = CE) {
    return t[n] = e, t
}

function Qa(t, e = CE) {
    let n = "";
    return typeof t.bindings > "u" ? n = WCe(t, e) : n = t.bindings().context || "", n
}

function GCe(t, e, n = CE) {
    const r = Qa(t, n);
    return r.trim() ? `${r}/${e}` : e
}

function Ja(t, e, n = CE) {
    const r = GCe(t, e, n),
        i = t.child({
            context: r
        });
    return VCe(i, r, n)
}
let qCe = class extends my {
        constructor(e) {
            super(), this.opts = e, this.protocol = "wc", this.version = 2
        }
    },
    KCe = class extends my {
        constructor(e, n) {
            super(), this.core = e, this.logger = n, this.records = new Map
        }
    },
    YCe = class {
        constructor(e, n) {
            this.logger = e, this.core = n
        }
    },
    ZCe = class extends my {
        constructor(e, n) {
            super(), this.relayer = e, this.logger = n
        }
    },
    QCe = class extends my {
        constructor(e) {
            super()
        }
    },
    JCe = class {
        constructor(e, n, r, i) {
            this.core = e, this.logger = n, this.name = r
        }
    },
    XCe = class extends my {
        constructor(e, n) {
            super(), this.relayer = e, this.logger = n
        }
    },
    eAe = class extends my {
        constructor(e, n) {
            super(), this.core = e, this.logger = n
        }
    },
    tAe = class {
        constructor(e, n) {
            this.projectId = e, this.logger = n
        }
    },
    nAe = class {
        constructor(e, n) {
            this.projectId = e, this.logger = n
        }
    },
    rAe = class {
        constructor(e) {
            this.opts = e, this.protocol = "wc", this.version = 2
        }
    },
    iAe = class {
        constructor(e) {
            this.client = e
        }
    };
var hL = {},
    pne = {};
(function(t) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    var e = An,
        n = kl;
    t.DIGEST_LENGTH = 64, t.BLOCK_SIZE = 128;
    var r = function() {
        function a() {
            this.digestLength = t.DIGEST_LENGTH, this.blockSize = t.BLOCK_SIZE, this._stateHi = new Int32Array(8), this._stateLo = new Int32Array(8), this._tempHi = new Int32Array(16), this._tempLo = new Int32Array(16), this._buffer = new Uint8Array(256), this._bufferLength = 0, this._bytesHashed = 0, this._finished = !1, this.reset()
        }
        return a.prototype._initState = function() {
            this._stateHi[0] = 1779033703, this._stateHi[1] = 3144134277, this._stateHi[2] = 1013904242, this._stateHi[3] = 2773480762, this._stateHi[4] = 1359893119, this._stateHi[5] = 2600822924, this._stateHi[6] = 528734635, this._stateHi[7] = 1541459225, this._stateLo[0] = 4089235720, this._stateLo[1] = 2227873595, this._stateLo[2] = 4271175723, this._stateLo[3] = 1595750129, this._stateLo[4] = 2917565137, this._stateLo[5] = 725511199, this._stateLo[6] = 4215389547, this._stateLo[7] = 327033209
        }, a.prototype.reset = function() {
            return this._initState(), this._bufferLength = 0, this._bytesHashed = 0, this._finished = !1, this
        }, a.prototype.clean = function() {
            n.wipe(this._buffer), n.wipe(this._tempHi), n.wipe(this._tempLo), this.reset()
        }, a.prototype.update = function(l, c) {
            if (c === void 0 && (c = l.length), this._finished) throw new Error("SHA512: can't update because hash was finished.");
            var u = 0;
            if (this._bytesHashed += c, this._bufferLength > 0) {
                for (; this._bufferLength < t.BLOCK_SIZE && c > 0;) this._buffer[this._bufferLength++] = l[u++], c--;
                this._bufferLength === this.blockSize && (s(this._tempHi, this._tempLo, this._stateHi, this._stateLo, this._buffer, 0, this.blockSize), this._bufferLength = 0)
            }
            for (c >= this.blockSize && (u = s(this._tempHi, this._tempLo, this._stateHi, this._stateLo, l, u, c), c %= this.blockSize); c > 0;) this._buffer[this._bufferLength++] = l[u++], c--;
            return this
        }, a.prototype.finish = function(l) {
            if (!this._finished) {
                var c = this._bytesHashed,
                    u = this._bufferLength,
                    f = c / 536870912 | 0,
                    h = c << 3,
                    g = c % 128 < 112 ? 128 : 256;
                this._buffer[u] = 128;
                for (var y = u + 1; y < g - 8; y++) this._buffer[y] = 0;
                e.writeUint32BE(f, this._buffer, g - 8), e.writeUint32BE(h, this._buffer, g - 4), s(this._tempHi, this._tempLo, this._stateHi, this._stateLo, this._buffer, 0, g), this._finished = !0
            }
            for (var y = 0; y < this.digestLength / 8; y++) e.writeUint32BE(this._stateHi[y], l, y * 8), e.writeUint32BE(this._stateLo[y], l, y * 8 + 4);
            return this
        }, a.prototype.digest = function() {
            var l = new Uint8Array(this.digestLength);
            return this.finish(l), l
        }, a.prototype.saveState = function() {
            if (this._finished) throw new Error("SHA256: cannot save finished state");
            return {
                stateHi: new Int32Array(this._stateHi),
                stateLo: new Int32Array(this._stateLo),
                buffer: this._bufferLength > 0 ? new Uint8Array(this._buffer) : void 0,
                bufferLength: this._bufferLength,
                bytesHashed: this._bytesHashed
            }
        }, a.prototype.restoreState = function(l) {
            return this._stateHi.set(l.stateHi), this._stateLo.set(l.stateLo), this._bufferLength = l.bufferLength, l.buffer && this._buffer.set(l.buffer), this._bytesHashed = l.bytesHashed, this._finished = !1, this
        }, a.prototype.cleanSavedState = function(l) {
            n.wipe(l.stateHi), n.wipe(l.stateLo), l.buffer && n.wipe(l.buffer), l.bufferLength = 0, l.bytesHashed = 0
        }, a
    }();
    t.SHA512 = r;
    var i = new Int32Array([1116352408, 3609767458, 1899447441, 602891725, 3049323471, 3964484399, 3921009573, 2173295548, 961987163, 4081628472, 1508970993, 3053834265, 2453635748, 2937671579, 2870763221, 3664609560, 3624381080, 2734883394, 310598401, 1164996542, 607225278, 1323610764, 1426881987, 3590304994, 1925078388, 4068182383, 2162078206, 991336113, 2614888103, 633803317, 3248222580, 3479774868, 3835390401, 2666613458, 4022224774, 944711139, 264347078, 2341262773, 604807628, 2007800933, 770255983, 1495990901, 1249150122, 1856431235, 1555081692, 3175218132, 1996064986, 2198950837, 2554220882, 3999719339, 2821834349, 766784016, 2952996808, 2566594879, 3210313671, 3203337956, 3336571891, 1034457026, 3584528711, 2466948901, 113926993, 3758326383, 338241895, 168717936, 666307205, 1188179964, 773529912, 1546045734, 1294757372, 1522805485, 1396182291, 2643833823, 1695183700, 2343527390, 1986661051, 1014477480, 2177026350, 1206759142, 2456956037, 344077627, 2730485921, 1290863460, 2820302411, 3158454273, 3259730800, 3505952657, 3345764771, 106217008, 3516065817, 3606008344, 3600352804, 1432725776, 4094571909, 1467031594, 275423344, 851169720, 430227734, 3100823752, 506948616, 1363258195, 659060556, 3750685593, 883997877, 3785050280, 958139571, 3318307427, 1322822218, 3812723403, 1537002063, 2003034995, 1747873779, 3602036899, 1955562222, 1575990012, 2024104815, 1125592928, 2227730452, 2716904306, 2361852424, 442776044, 2428436474, 593698344, 2756734187, 3733110249, 3204031479, 2999351573, 3329325298, 3815920427, 3391569614, 3928383900, 3515267271, 566280711, 3940187606, 3454069534, 4118630271, 4000239992, 116418474, 1914138554, 174292421, 2731055270, 289380356, 3203993006, 460393269, 320620315, 685471733, 587496836, 852142971, 1086792851, 1017036298, 365543100, 1126000580, 2618297676, 1288033470, 3409855158, 1501505948, 4234509866, 1607167915, 987167468, 1816402316, 1246189591]);

    function s(a, l, c, u, f, h, g) {
        for (var y = c[0], _ = c[1], C = c[2], b = c[3], w = c[4], S = c[5], I = c[6], P = c[7], M = u[0], A = u[1], E = u[2], $ = u[3], H = u[4], K = u[5], te = u[6], U = u[7], m, v, T, N, O, L, G, j; g >= 128;) {
            for (var R = 0; R < 16; R++) {
                var Y = 8 * R + h;
                a[R] = e.readUint32BE(f, Y), l[R] = e.readUint32BE(f, Y + 4)
            }
            for (var R = 0; R < 80; R++) {
                var ve = y,
                    V = _,
                    X = C,
                    q = b,
                    ne = w,
                    ie = S,
                    k = I,
                    z = P,
                    Z = M,
                    ge = A,
                    me = E,
                    Re = $,
                    He = H,
                    Be = K,
                    bt = te,
                    mn = U;
                if (m = P, v = U, O = v & 65535, L = v >>> 16, G = m & 65535, j = m >>> 16, m = (w >>> 14 | H << 18) ^ (w >>> 18 | H << 14) ^ (H >>> 9 | w << 23), v = (H >>> 14 | w << 18) ^ (H >>> 18 | w << 14) ^ (w >>> 9 | H << 23), O += v & 65535, L += v >>> 16, G += m & 65535, j += m >>> 16, m = w & S ^ ~w & I, v = H & K ^ ~H & te, O += v & 65535, L += v >>> 16, G += m & 65535, j += m >>> 16, m = i[R * 2], v = i[R * 2 + 1], O += v & 65535, L += v >>> 16, G += m & 65535, j += m >>> 16, m = a[R % 16], v = l[R % 16], O += v & 65535, L += v >>> 16, G += m & 65535, j += m >>> 16, L += O >>> 16, G += L >>> 16, j += G >>> 16, T = G & 65535 | j << 16, N = O & 65535 | L << 16, m = T, v = N, O = v & 65535, L = v >>> 16, G = m & 65535, j = m >>> 16, m = (y >>> 28 | M << 4) ^ (M >>> 2 | y << 30) ^ (M >>> 7 | y << 25), v = (M >>> 28 | y << 4) ^ (y >>> 2 | M << 30) ^ (y >>> 7 | M << 25), O += v & 65535, L += v >>> 16, G += m & 65535, j += m >>> 16, m = y & _ ^ y & C ^ _ & C, v = M & A ^ M & E ^ A & E, O += v & 65535, L += v >>> 16, G += m & 65535, j += m >>> 16, L += O >>> 16, G += L >>> 16, j += G >>> 16, z = G & 65535 | j << 16, mn = O & 65535 | L << 16, m = q, v = Re, O = v & 65535, L = v >>> 16, G = m & 65535, j = m >>> 16, m = T, v = N, O += v & 65535, L += v >>> 16, G += m & 65535, j += m >>> 16, L += O >>> 16, G += L >>> 16, j += G >>> 16, q = G & 65535 | j << 16, Re = O & 65535 | L << 16, _ = ve, C = V, b = X, w = q, S = ne, I = ie, P = k, y = z, A = Z, E = ge, $ = me, H = Re, K = He, te = Be, U = bt, M = mn, R % 16 === 15)
                    for (var Y = 0; Y < 16; Y++) m = a[Y], v = l[Y], O = v & 65535, L = v >>> 16, G = m & 65535, j = m >>> 16, m = a[(Y + 9) % 16], v = l[(Y + 9) % 16], O += v & 65535, L += v >>> 16, G += m & 65535, j += m >>> 16, T = a[(Y + 1) % 16], N = l[(Y + 1) % 16], m = (T >>> 1 | N << 31) ^ (T >>> 8 | N << 24) ^ T >>> 7, v = (N >>> 1 | T << 31) ^ (N >>> 8 | T << 24) ^ (N >>> 7 | T << 25), O += v & 65535, L += v >>> 16, G += m & 65535, j += m >>> 16, T = a[(Y + 14) % 16], N = l[(Y + 14) % 16], m = (T >>> 19 | N << 13) ^ (N >>> 29 | T << 3) ^ T >>> 6, v = (N >>> 19 | T << 13) ^ (T >>> 29 | N << 3) ^ (N >>> 6 | T << 26), O += v & 65535, L += v >>> 16, G += m & 65535, j += m >>> 16, L += O >>> 16, G += L >>> 16, j += G >>> 16, a[Y] = G & 65535 | j << 16, l[Y] = O & 65535 | L << 16
            }
            m = y, v = M, O = v & 65535, L = v >>> 16, G = m & 65535, j = m >>> 16, m = c[0], v = u[0], O += v & 65535, L += v >>> 16, G += m & 65535, j += m >>> 16, L += O >>> 16, G += L >>> 16, j += G >>> 16, c[0] = y = G & 65535 | j << 16, u[0] = M = O & 65535 | L << 16, m = _, v = A, O = v & 65535, L = v >>> 16, G = m & 65535, j = m >>> 16, m = c[1], v = u[1], O += v & 65535, L += v >>> 16, G += m & 65535, j += m >>> 16, L += O >>> 16, G += L >>> 16, j += G >>> 16, c[1] = _ = G & 65535 | j << 16, u[1] = A = O & 65535 | L << 16, m = C, v = E, O = v & 65535, L = v >>> 16, G = m & 65535, j = m >>> 16, m = c[2], v = u[2], O += v & 65535, L += v >>> 16, G += m & 65535, j += m >>> 16, L += O >>> 16, G += L >>> 16, j += G >>> 16, c[2] = C = G & 65535 | j << 16, u[2] = E = O & 65535 | L << 16, m = b, v = $, O = v & 65535, L = v >>> 16, G = m & 65535, j = m >>> 16, m = c[3], v = u[3], O += v & 65535, L += v >>> 16, G += m & 65535, j += m >>> 16, L += O >>> 16, G += L >>> 16, j += G >>> 16, c[3] = b = G & 65535 | j << 16, u[3] = $ = O & 65535 | L << 16, m = w, v = H, O = v & 65535, L = v >>> 16, G = m & 65535, j = m >>> 16, m = c[4], v = u[4], O += v & 65535, L += v >>> 16, G += m & 65535, j += m >>> 16, L += O >>> 16, G += L >>> 16, j += G >>> 16, c[4] = w = G & 65535 | j << 16, u[4] = H = O & 65535 | L << 16, m = S, v = K, O = v & 65535, L = v >>> 16, G = m & 65535, j = m >>> 16, m = c[5], v = u[5], O += v & 65535, L += v >>> 16, G += m & 65535, j += m >>> 16, L += O >>> 16, G += L >>> 16, j += G >>> 16, c[5] = S = G & 65535 | j << 16, u[5] = K = O & 65535 | L << 16, m = I, v = te, O = v & 65535, L = v >>> 16, G = m & 65535, j = m >>> 16, m = c[6], v = u[6], O += v & 65535, L += v >>> 16, G += m & 65535, j += m >>> 16, L += O >>> 16, G += L >>> 16, j += G >>> 16, c[6] = I = G & 65535 | j << 16, u[6] = te = O & 65535 | L << 16, m = P, v = U, O = v & 65535, L = v >>> 16, G = m & 65535, j = m >>> 16, m = c[7], v = u[7], O += v & 65535, L += v >>> 16, G += m & 65535, j += m >>> 16, L += O >>> 16, G += L >>> 16, j += G >>> 16, c[7] = P = G & 65535 | j << 16, u[7] = U = O & 65535 | L << 16, h += 128, g -= 128
        }
        return h
    }

    function o(a) {
        var l = new r;
        l.update(a);
        var c = l.digest();
        return l.clean(), c
    }
    t.hash = o
})(pne);
(function(t) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    }), t.convertSecretKeyToX25519 = t.convertPublicKeyToX25519 = t.verify = t.sign = t.extractPublicKeyFromSecretKey = t.generateKeyPair = t.generateKeyPairFromSeed = t.SEED_LENGTH = t.SECRET_KEY_LENGTH = t.PUBLIC_KEY_LENGTH = t.SIGNATURE_LENGTH = void 0;
    const e = T2,
        n = pne,
        r = kl;
    t.SIGNATURE_LENGTH = 64, t.PUBLIC_KEY_LENGTH = 32, t.SECRET_KEY_LENGTH = 64, t.SEED_LENGTH = 32;

    function i(q) {
        const ne = new Float64Array(16);
        if (q)
            for (let ie = 0; ie < q.length; ie++) ne[ie] = q[ie];
        return ne
    }
    const s = new Uint8Array(32);
    s[0] = 9;
    const o = i(),
        a = i([1]),
        l = i([30883, 4953, 19914, 30187, 55467, 16705, 2637, 112, 59544, 30585, 16505, 36039, 65139, 11119, 27886, 20995]),
        c = i([61785, 9906, 39828, 60374, 45398, 33411, 5274, 224, 53552, 61171, 33010, 6542, 64743, 22239, 55772, 9222]),
        u = i([54554, 36645, 11616, 51542, 42930, 38181, 51040, 26924, 56412, 64982, 57905, 49316, 21502, 52590, 14035, 8553]),
        f = i([26200, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214]),
        h = i([41136, 18958, 6951, 50414, 58488, 44335, 6150, 12099, 55207, 15867, 153, 11085, 57099, 20417, 9344, 11139]);

    function g(q, ne) {
        for (let ie = 0; ie < 16; ie++) q[ie] = ne[ie] | 0
    }

    function y(q) {
        let ne = 1;
        for (let ie = 0; ie < 16; ie++) {
            let k = q[ie] + ne + 65535;
            ne = Math.floor(k / 65536), q[ie] = k - ne * 65536
        }
        q[0] += ne - 1 + 37 * (ne - 1)
    }

    function _(q, ne, ie) {
        const k = ~(ie - 1);
        for (let z = 0; z < 16; z++) {
            const Z = k & (q[z] ^ ne[z]);
            q[z] ^= Z, ne[z] ^= Z
        }
    }

    function C(q, ne) {
        const ie = i(),
            k = i();
        for (let z = 0; z < 16; z++) k[z] = ne[z];
        y(k), y(k), y(k);
        for (let z = 0; z < 2; z++) {
            ie[0] = k[0] - 65517;
            for (let ge = 1; ge < 15; ge++) ie[ge] = k[ge] - 65535 - (ie[ge - 1] >> 16 & 1), ie[ge - 1] &= 65535;
            ie[15] = k[15] - 32767 - (ie[14] >> 16 & 1);
            const Z = ie[15] >> 16 & 1;
            ie[14] &= 65535, _(k, ie, 1 - Z)
        }
        for (let z = 0; z < 16; z++) q[2 * z] = k[z] & 255, q[2 * z + 1] = k[z] >> 8
    }

    function b(q, ne) {
        let ie = 0;
        for (let k = 0; k < 32; k++) ie |= q[k] ^ ne[k];
        return (1 & ie - 1 >>> 8) - 1
    }

    function w(q, ne) {
        const ie = new Uint8Array(32),
            k = new Uint8Array(32);
        return C(ie, q), C(k, ne), b(ie, k)
    }

    function S(q) {
        const ne = new Uint8Array(32);
        return C(ne, q), ne[0] & 1
    }

    function I(q, ne) {
        for (let ie = 0; ie < 16; ie++) q[ie] = ne[2 * ie] + (ne[2 * ie + 1] << 8);
        q[15] &= 32767
    }

    function P(q, ne, ie) {
        for (let k = 0; k < 16; k++) q[k] = ne[k] + ie[k]
    }

    function M(q, ne, ie) {
        for (let k = 0; k < 16; k++) q[k] = ne[k] - ie[k]
    }

    function A(q, ne, ie) {
        let k, z, Z = 0,
            ge = 0,
            me = 0,
            Re = 0,
            He = 0,
            Be = 0,
            bt = 0,
            mn = 0,
            at = 0,
            tt = 0,
            _t = 0,
            ot = 0,
            lt = 0,
            wt = 0,
            Xe = 0,
            Q = 0,
            D = 0,
            B = 0,
            se = 0,
            de = 0,
            ye = 0,
            Se = 0,
            nt = 0,
            Ke = 0,
            mt = 0,
            en = 0,
            vt = 0,
            hn = 0,
            ui = 0,
            bn = 0,
            On = 0,
            Un = ie[0],
            Lt = ie[1],
            jt = ie[2],
            qn = ie[3],
            Ht = ie[4],
            zt = ie[5],
            Jn = ie[6],
            Vt = ie[7],
            Ft = ie[8],
            Xn = ie[9],
            Kt = ie[10],
            Qt = ie[11],
            fe = ie[12],
            he = ie[13],
            be = ie[14],
            Pe = ie[15];
        k = ne[0], Z += k * Un, ge += k * Lt, me += k * jt, Re += k * qn, He += k * Ht, Be += k * zt, bt += k * Jn, mn += k * Vt, at += k * Ft, tt += k * Xn, _t += k * Kt, ot += k * Qt, lt += k * fe, wt += k * he, Xe += k * be, Q += k * Pe, k = ne[1], ge += k * Un, me += k * Lt, Re += k * jt, He += k * qn, Be += k * Ht, bt += k * zt, mn += k * Jn, at += k * Vt, tt += k * Ft, _t += k * Xn, ot += k * Kt, lt += k * Qt, wt += k * fe, Xe += k * he, Q += k * be, D += k * Pe, k = ne[2], me += k * Un, Re += k * Lt, He += k * jt, Be += k * qn, bt += k * Ht, mn += k * zt, at += k * Jn, tt += k * Vt, _t += k * Ft, ot += k * Xn, lt += k * Kt, wt += k * Qt, Xe += k * fe, Q += k * he, D += k * be, B += k * Pe, k = ne[3], Re += k * Un, He += k * Lt, Be += k * jt, bt += k * qn, mn += k * Ht, at += k * zt, tt += k * Jn, _t += k * Vt, ot += k * Ft, lt += k * Xn, wt += k * Kt, Xe += k * Qt, Q += k * fe, D += k * he, B += k * be, se += k * Pe, k = ne[4], He += k * Un, Be += k * Lt, bt += k * jt, mn += k * qn, at += k * Ht, tt += k * zt, _t += k * Jn, ot += k * Vt, lt += k * Ft, wt += k * Xn, Xe += k * Kt, Q += k * Qt, D += k * fe, B += k * he, se += k * be, de += k * Pe, k = ne[5], Be += k * Un, bt += k * Lt, mn += k * jt, at += k * qn, tt += k * Ht, _t += k * zt, ot += k * Jn, lt += k * Vt, wt += k * Ft, Xe += k * Xn, Q += k * Kt, D += k * Qt, B += k * fe, se += k * he, de += k * be, ye += k * Pe, k = ne[6], bt += k * Un, mn += k * Lt, at += k * jt, tt += k * qn, _t += k * Ht, ot += k * zt, lt += k * Jn, wt += k * Vt, Xe += k * Ft, Q += k * Xn, D += k * Kt, B += k * Qt, se += k * fe, de += k * he, ye += k * be, Se += k * Pe, k = ne[7], mn += k * Un, at += k * Lt, tt += k * jt, _t += k * qn, ot += k * Ht, lt += k * zt, wt += k * Jn, Xe += k * Vt, Q += k * Ft, D += k * Xn, B += k * Kt, se += k * Qt, de += k * fe, ye += k * he, Se += k * be, nt += k * Pe, k = ne[8], at += k * Un, tt += k * Lt, _t += k * jt, ot += k * qn, lt += k * Ht, wt += k * zt, Xe += k * Jn, Q += k * Vt, D += k * Ft, B += k * Xn, se += k * Kt, de += k * Qt, ye += k * fe, Se += k * he, nt += k * be, Ke += k * Pe, k = ne[9], tt += k * Un, _t += k * Lt, ot += k * jt, lt += k * qn, wt += k * Ht, Xe += k * zt, Q += k * Jn, D += k * Vt, B += k * Ft, se += k * Xn, de += k * Kt, ye += k * Qt, Se += k * fe, nt += k * he, Ke += k * be, mt += k * Pe, k = ne[10], _t += k * Un, ot += k * Lt, lt += k * jt, wt += k * qn, Xe += k * Ht, Q += k * zt, D += k * Jn, B += k * Vt, se += k * Ft, de += k * Xn, ye += k * Kt, Se += k * Qt, nt += k * fe, Ke += k * he, mt += k * be, en += k * Pe, k = ne[11], ot += k * Un, lt += k * Lt, wt += k * jt, Xe += k * qn, Q += k * Ht, D += k * zt, B += k * Jn, se += k * Vt, de += k * Ft, ye += k * Xn, Se += k * Kt, nt += k * Qt, Ke += k * fe, mt += k * he, en += k * be, vt += k * Pe, k = ne[12], lt += k * Un, wt += k * Lt, Xe += k * jt, Q += k * qn, D += k * Ht, B += k * zt, se += k * Jn, de += k * Vt, ye += k * Ft, Se += k * Xn, nt += k * Kt, Ke += k * Qt, mt += k * fe, en += k * he, vt += k * be, hn += k * Pe, k = ne[13], wt += k * Un, Xe += k * Lt, Q += k * jt, D += k * qn, B += k * Ht, se += k * zt, de += k * Jn, ye += k * Vt, Se += k * Ft, nt += k * Xn, Ke += k * Kt, mt += k * Qt, en += k * fe, vt += k * he, hn += k * be, ui += k * Pe, k = ne[14], Xe += k * Un, Q += k * Lt, D += k * jt, B += k * qn, se += k * Ht, de += k * zt, ye += k * Jn, Se += k * Vt, nt += k * Ft, Ke += k * Xn, mt += k * Kt, en += k * Qt, vt += k * fe, hn += k * he, ui += k * be, bn += k * Pe, k = ne[15], Q += k * Un, D += k * Lt, B += k * jt, se += k * qn, de += k * Ht, ye += k * zt, Se += k * Jn, nt += k * Vt, Ke += k * Ft, mt += k * Xn, en += k * Kt, vt += k * Qt, hn += k * fe, ui += k * he, bn += k * be, On += k * Pe, Z += 38 * D, ge += 38 * B, me += 38 * se, Re += 38 * de, He += 38 * ye, Be += 38 * Se, bt += 38 * nt, mn += 38 * Ke, at += 38 * mt, tt += 38 * en, _t += 38 * vt, ot += 38 * hn, lt += 38 * ui, wt += 38 * bn, Xe += 38 * On, z = 1, k = Z + z + 65535, z = Math.floor(k / 65536), Z = k - z * 65536, k = ge + z + 65535, z = Math.floor(k / 65536), ge = k - z * 65536, k = me + z + 65535, z = Math.floor(k / 65536), me = k - z * 65536, k = Re + z + 65535, z = Math.floor(k / 65536), Re = k - z * 65536, k = He + z + 65535, z = Math.floor(k / 65536), He = k - z * 65536, k = Be + z + 65535, z = Math.floor(k / 65536), Be = k - z * 65536, k = bt + z + 65535, z = Math.floor(k / 65536), bt = k - z * 65536, k = mn + z + 65535, z = Math.floor(k / 65536), mn = k - z * 65536, k = at + z + 65535, z = Math.floor(k / 65536), at = k - z * 65536, k = tt + z + 65535, z = Math.floor(k / 65536), tt = k - z * 65536, k = _t + z + 65535, z = Math.floor(k / 65536), _t = k - z * 65536, k = ot + z + 65535, z = Math.floor(k / 65536), ot = k - z * 65536, k = lt + z + 65535, z = Math.floor(k / 65536), lt = k - z * 65536, k = wt + z + 65535, z = Math.floor(k / 65536), wt = k - z * 65536, k = Xe + z + 65535, z = Math.floor(k / 65536), Xe = k - z * 65536, k = Q + z + 65535, z = Math.floor(k / 65536), Q = k - z * 65536, Z += z - 1 + 37 * (z - 1), z = 1, k = Z + z + 65535, z = Math.floor(k / 65536), Z = k - z * 65536, k = ge + z + 65535, z = Math.floor(k / 65536), ge = k - z * 65536, k = me + z + 65535, z = Math.floor(k / 65536), me = k - z * 65536, k = Re + z + 65535, z = Math.floor(k / 65536), Re = k - z * 65536, k = He + z + 65535, z = Math.floor(k / 65536), He = k - z * 65536, k = Be + z + 65535, z = Math.floor(k / 65536), Be = k - z * 65536, k = bt + z + 65535, z = Math.floor(k / 65536), bt = k - z * 65536, k = mn + z + 65535, z = Math.floor(k / 65536), mn = k - z * 65536, k = at + z + 65535, z = Math.floor(k / 65536), at = k - z * 65536, k = tt + z + 65535, z = Math.floor(k / 65536), tt = k - z * 65536, k = _t + z + 65535, z = Math.floor(k / 65536), _t = k - z * 65536, k = ot + z + 65535, z = Math.floor(k / 65536), ot = k - z * 65536, k = lt + z + 65535, z = Math.floor(k / 65536), lt = k - z * 65536, k = wt + z + 65535, z = Math.floor(k / 65536), wt = k - z * 65536, k = Xe + z + 65535, z = Math.floor(k / 65536), Xe = k - z * 65536, k = Q + z + 65535, z = Math.floor(k / 65536), Q = k - z * 65536, Z += z - 1 + 37 * (z - 1), q[0] = Z, q[1] = ge, q[2] = me, q[3] = Re, q[4] = He, q[5] = Be, q[6] = bt, q[7] = mn, q[8] = at, q[9] = tt, q[10] = _t, q[11] = ot, q[12] = lt, q[13] = wt, q[14] = Xe, q[15] = Q
    }

    function E(q, ne) {
        A(q, ne, ne)
    }

    function $(q, ne) {
        const ie = i();
        let k;
        for (k = 0; k < 16; k++) ie[k] = ne[k];
        for (k = 253; k >= 0; k--) E(ie, ie), k !== 2 && k !== 4 && A(ie, ie, ne);
        for (k = 0; k < 16; k++) q[k] = ie[k]
    }

    function H(q, ne) {
        const ie = i();
        let k;
        for (k = 0; k < 16; k++) ie[k] = ne[k];
        for (k = 250; k >= 0; k--) E(ie, ie), k !== 1 && A(ie, ie, ne);
        for (k = 0; k < 16; k++) q[k] = ie[k]
    }

    function K(q, ne) {
        const ie = i(),
            k = i(),
            z = i(),
            Z = i(),
            ge = i(),
            me = i(),
            Re = i(),
            He = i(),
            Be = i();
        M(ie, q[1], q[0]), M(Be, ne[1], ne[0]), A(ie, ie, Be), P(k, q[0], q[1]), P(Be, ne[0], ne[1]), A(k, k, Be), A(z, q[3], ne[3]), A(z, z, c), A(Z, q[2], ne[2]), P(Z, Z, Z), M(ge, k, ie), M(me, Z, z), P(Re, Z, z), P(He, k, ie), A(q[0], ge, me), A(q[1], He, Re), A(q[2], Re, me), A(q[3], ge, He)
    }

    function te(q, ne, ie) {
        for (let k = 0; k < 4; k++) _(q[k], ne[k], ie)
    }

    function U(q, ne) {
        const ie = i(),
            k = i(),
            z = i();
        $(z, ne[2]), A(ie, ne[0], z), A(k, ne[1], z), C(q, k), q[31] ^= S(ie) << 7
    }

    function m(q, ne, ie) {
        g(q[0], o), g(q[1], a), g(q[2], a), g(q[3], o);
        for (let k = 255; k >= 0; --k) {
            const z = ie[k / 8 | 0] >> (k & 7) & 1;
            te(q, ne, z), K(ne, q), K(q, q), te(q, ne, z)
        }
    }

    function v(q, ne) {
        const ie = [i(), i(), i(), i()];
        g(ie[0], u), g(ie[1], f), g(ie[2], a), A(ie[3], u, f), m(q, ie, ne)
    }

    function T(q) {
        if (q.length !== t.SEED_LENGTH) throw new Error(`ed25519: seed must be ${t.SEED_LENGTH} bytes`);
        const ne = (0, n.hash)(q);
        ne[0] &= 248, ne[31] &= 127, ne[31] |= 64;
        const ie = new Uint8Array(32),
            k = [i(), i(), i(), i()];
        v(k, ne), U(ie, k);
        const z = new Uint8Array(64);
        return z.set(q), z.set(ie, 32), {
            publicKey: ie,
            secretKey: z
        }
    }
    t.generateKeyPairFromSeed = T;

    function N(q) {
        const ne = (0, e.randomBytes)(32, q),
            ie = T(ne);
        return (0, r.wipe)(ne), ie
    }
    t.generateKeyPair = N;

    function O(q) {
        if (q.length !== t.SECRET_KEY_LENGTH) throw new Error(`ed25519: secret key must be ${t.SECRET_KEY_LENGTH} bytes`);
        return new Uint8Array(q.subarray(32))
    }
    t.extractPublicKeyFromSecretKey = O;
    const L = new Float64Array([237, 211, 245, 92, 26, 99, 18, 88, 214, 156, 247, 162, 222, 249, 222, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 16]);

    function G(q, ne) {
        let ie, k, z, Z;
        for (k = 63; k >= 32; --k) {
            for (ie = 0, z = k - 32, Z = k - 12; z < Z; ++z) ne[z] += ie - 16 * ne[k] * L[z - (k - 32)], ie = Math.floor((ne[z] + 128) / 256), ne[z] -= ie * 256;
            ne[z] += ie, ne[k] = 0
        }
        for (ie = 0, z = 0; z < 32; z++) ne[z] += ie - (ne[31] >> 4) * L[z], ie = ne[z] >> 8, ne[z] &= 255;
        for (z = 0; z < 32; z++) ne[z] -= ie * L[z];
        for (k = 0; k < 32; k++) ne[k + 1] += ne[k] >> 8, q[k] = ne[k] & 255
    }

    function j(q) {
        const ne = new Float64Array(64);
        for (let ie = 0; ie < 64; ie++) ne[ie] = q[ie];
        for (let ie = 0; ie < 64; ie++) q[ie] = 0;
        G(q, ne)
    }

    function R(q, ne) {
        const ie = new Float64Array(64),
            k = [i(), i(), i(), i()],
            z = (0, n.hash)(q.subarray(0, 32));
        z[0] &= 248, z[31] &= 127, z[31] |= 64;
        const Z = new Uint8Array(64);
        Z.set(z.subarray(32), 32);
        const ge = new n.SHA512;
        ge.update(Z.subarray(32)), ge.update(ne);
        const me = ge.digest();
        ge.clean(), j(me), v(k, me), U(Z, k), ge.reset(), ge.update(Z.subarray(0, 32)), ge.update(q.subarray(32)), ge.update(ne);
        const Re = ge.digest();
        j(Re);
        for (let He = 0; He < 32; He++) ie[He] = me[He];
        for (let He = 0; He < 32; He++)
            for (let Be = 0; Be < 32; Be++) ie[He + Be] += Re[He] * z[Be];
        return G(Z.subarray(32), ie), Z
    }
    t.sign = R;

    function Y(q, ne) {
        const ie = i(),
            k = i(),
            z = i(),
            Z = i(),
            ge = i(),
            me = i(),
            Re = i();
        return g(q[2], a), I(q[1], ne), E(z, q[1]), A(Z, z, l), M(z, z, q[2]), P(Z, q[2], Z), E(ge, Z), E(me, ge), A(Re, me, ge), A(ie, Re, z), A(ie, ie, Z), H(ie, ie), A(ie, ie, z), A(ie, ie, Z), A(ie, ie, Z), A(q[0], ie, Z), E(k, q[0]), A(k, k, Z), w(k, z) && A(q[0], q[0], h), E(k, q[0]), A(k, k, Z), w(k, z) ? -1 : (S(q[0]) === ne[31] >> 7 && M(q[0], o, q[0]), A(q[3], q[0], q[1]), 0)
    }

    function ve(q, ne, ie) {
        const k = new Uint8Array(32),
            z = [i(), i(), i(), i()],
            Z = [i(), i(), i(), i()];
        if (ie.length !== t.SIGNATURE_LENGTH) throw new Error(`ed25519: signature must be ${t.SIGNATURE_LENGTH} bytes`);
        if (Y(Z, q)) return !1;
        const ge = new n.SHA512;
        ge.update(ie.subarray(0, 32)), ge.update(q), ge.update(ne);
        const me = ge.digest();
        return j(me), m(z, Z, me), v(Z, ie.subarray(32)), K(z, Z), U(k, z), !b(ie, k)
    }
    t.verify = ve;

    function V(q) {
        let ne = [i(), i(), i(), i()];
        if (Y(ne, q)) throw new Error("Ed25519: invalid public key");
        let ie = i(),
            k = i(),
            z = ne[1];
        P(ie, a, z), M(k, a, z), $(k, k), A(ie, ie, k);
        let Z = new Uint8Array(32);
        return C(Z, ie), Z
    }
    t.convertPublicKeyToX25519 = V;

    function X(q) {
        const ne = (0, n.hash)(q.subarray(0, 32));
        ne[0] &= 248, ne[31] &= 127, ne[31] |= 64;
        const ie = new Uint8Array(ne.subarray(0, 32));
        return (0, r.wipe)(ne), ie
    }
    t.convertSecretKeyToX25519 = X
})(hL);
const sAe = "EdDSA",
    oAe = "JWT",
    gne = ".",
    mne = "base64url",
    aAe = "utf8",
    lAe = "utf8",
    cAe = ":",
    uAe = "did",
    fAe = "key",
    cV = "base58btc",
    dAe = "z",
    hAe = "K36",
    pAe = 32;

function IC(t) {
    return ha(Ua(Pm(t), aAe), mne)
}

function yne(t) {
    const e = Ua(hAe, cV),
        n = dAe + ha(nk([e, t]), cV);
    return [uAe, fAe, n].join(cAe)
}

function gAe(t) {
    return ha(t, mne)
}

function mAe(t) {
    return Ua([IC(t.header), IC(t.payload)].join(gne), lAe)
}

function yAe(t) {
    return [IC(t.header), IC(t.payload), gAe(t.signature)].join(gne)
}

function uV(t = T2.randomBytes(pAe)) {
    return hL.generateKeyPairFromSeed(t)
}
async function wAe(t, e, n, r, i = Bt.fromMiliseconds(Date.now())) {
    const s = {
            alg: sAe,
            typ: oAe
        },
        o = yne(r.publicKey),
        a = i + n,
        l = {
            iss: o,
            sub: t,
            aud: e,
            iat: i,
            exp: a
        },
        c = mAe({
            header: s,
            payload: l
        }),
        u = hL.sign(r.secretKey, c);
    return yAe({
        header: s,
        payload: l,
        signature: u
    })
}
const vAe = "PARSE_ERROR",
    bAe = "INVALID_REQUEST",
    _Ae = "METHOD_NOT_FOUND",
    EAe = "INVALID_PARAMS",
    wne = "INTERNAL_ERROR",
    pL = "SERVER_ERROR",
    xAe = [-32700, -32600, -32601, -32602, -32603],
    z3 = {
        [vAe]: {
            code: -32700,
            message: "Parse error"
        },
        [bAe]: {
            code: -32600,
            message: "Invalid Request"
        },
        [_Ae]: {
            code: -32601,
            message: "Method not found"
        },
        [EAe]: {
            code: -32602,
            message: "Invalid params"
        },
        [wne]: {
            code: -32603,
            message: "Internal error"
        },
        [pL]: {
            code: -32e3,
            message: "Server error"
        }
    },
    vne = pL;

function SAe(t) {
    return xAe.includes(t)
}

function fV(t) {
    return Object.keys(z3).includes(t) ? z3[t] : z3[vne]
}

function CAe(t) {
    const e = Object.values(z3).find(n => n.code === t);
    return e || z3[vne]
}

function bne(t, e, n) {
    return t.message.includes("getaddrinfo ENOTFOUND") || t.message.includes("connect ECONNREFUSED") ? new Error(`Unavailable ${n} RPC url at ${e}`) : t
}
var _ne = {},
    Id = {},
    dV;

function AAe() {
    if (dV) return Id;
    dV = 1, Object.defineProperty(Id, "__esModule", {
        value: !0
    }), Id.isBrowserCryptoAvailable = Id.getSubtleCrypto = Id.getBrowerCrypto = void 0;

    function t() {
        return (st == null ? void 0 : st.crypto) || (st == null ? void 0 : st.msCrypto) || {}
    }
    Id.getBrowerCrypto = t;

    function e() {
        const r = t();
        return r.subtle || r.webkitSubtle
    }
    Id.getSubtleCrypto = e;

    function n() {
        return !!t() && !!e()
    }
    return Id.isBrowserCryptoAvailable = n, Id
}
var Rd = {},
    hV;

function TAe() {
    if (hV) return Rd;
    hV = 1, Object.defineProperty(Rd, "__esModule", {
        value: !0
    }), Rd.isBrowser = Rd.isNode = Rd.isReactNative = void 0;

    function t() {
        return typeof document > "u" && typeof navigator < "u" && navigator.product === "ReactNative"
    }
    Rd.isReactNative = t;

    function e() {
        return typeof process < "u" && typeof process.versions < "u" && typeof process.versions.node < "u"
    }
    Rd.isNode = e;

    function n() {
        return !t() && !e()
    }
    return Rd.isBrowser = n, Rd
}(function(t) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    const e = Uh;
    e.__exportStar(AAe(), t), e.__exportStar(TAe(), t)
})(_ne);

function gL(t = 3) {
    const e = Date.now() * Math.pow(10, t),
        n = Math.floor(Math.random() * Math.pow(10, t));
    return e + n
}

function mL(t = 6) {
    return BigInt(gL(t))
}

function em(t, e, n) {
    return {
        id: n || gL(),
        jsonrpc: "2.0",
        method: t,
        params: e
    }
}

function zT(t, e) {
    return {
        id: t,
        jsonrpc: "2.0",
        result: e
    }
}

function WT(t, e, n) {
    return {
        id: t,
        jsonrpc: "2.0",
        error: IAe(e)
    }
}

function IAe(t, e) {
    return typeof t > "u" ? fV(wne) : (typeof t == "string" && (t = Object.assign(Object.assign({}, fV(pL)), {
        message: t
    })), SAe(t.code) && (t = CAe(t.code)), t)
}
let RAe = class {},
    OAe = class extends RAe {
        constructor() {
            super()
        }
    },
    Ene = class extends OAe {
        constructor(e) {
            super()
        }
    };
const NAe = "^https?:",
    PAe = "^wss?:";

function kAe(t) {
    const e = t.match(new RegExp(/^\w+:/, "gi"));
    if (!(!e || !e.length)) return e[0]
}

function xne(t, e) {
    const n = kAe(t);
    return typeof n > "u" ? !1 : new RegExp(e).test(n)
}

function pV(t) {
    return xne(t, NAe)
}

function gV(t) {
    return xne(t, PAe)
}

function MAe(t) {
    return new RegExp("wss?://localhost(:d{2,5})?").test(t)
}

function Sne(t) {
    return typeof t == "object" && "id" in t && "jsonrpc" in t && t.jsonrpc === "2.0"
}

function yL(t) {
    return Sne(t) && "method" in t
}

function AE(t) {
    return Sne(t) && (Bd(t) || pc(t))
}

function Bd(t) {
    return "result" in t
}

function pc(t) {
    return "error" in t
}
let DAe = class extends Ene {
    constructor(e) {
        super(e), this.events = new uo.EventEmitter, this.hasRegisteredEventListeners = !1, this.connection = this.setConnection(e), this.connection.connected && this.registerEventListeners()
    }
    async connect(e = this.connection) {
        await this.open(e)
    }
    async disconnect() {
        await this.close()
    }
    on(e, n) {
        this.events.on(e, n)
    }
    once(e, n) {
        this.events.once(e, n)
    }
    off(e, n) {
        this.events.off(e, n)
    }
    removeListener(e, n) {
        this.events.removeListener(e, n)
    }
    async request(e, n) {
        return this.requestStrict(em(e.method, e.params || [], e.id || mL().toString()), n)
    }
    async requestStrict(e, n) {
        return new Promise(async (r, i) => {
            if (!this.connection.connected) try {
                await this.open()
            } catch (s) {
                i(s)
            }
            this.events.on(`${e.id}`, s => {
                pc(s) ? i(s.error) : r(s.result)
            });
            try {
                await this.connection.send(e, n)
            } catch (s) {
                i(s)
            }
        })
    }
    setConnection(e = this.connection) {
        return e
    }
    onPayload(e) {
        this.events.emit("payload", e), AE(e) ? this.events.emit(`${e.id}`, e) : this.events.emit("message", {
            type: e.method,
            data: e.params
        })
    }
    onClose(e) {
        e && e.code === 3e3 && this.events.emit("error", new Error(`WebSocket connection closed abnormally with code: ${e.code} ${e.reason?`(${e.reason})`:""}`)), this.events.emit("disconnect")
    }
    async open(e = this.connection) {
        this.connection === e && this.connection.connected || (this.connection.connected && this.close(), typeof e == "string" && (await this.connection.open(e), e = this.connection), this.connection = this.setConnection(e), await this.connection.open(), this.registerEventListeners(), this.events.emit("connect"))
    }
    async close() {
        await this.connection.close()
    }
    registerEventListeners() {
        this.hasRegisteredEventListeners || (this.connection.on("payload", e => this.onPayload(e)), this.connection.on("close", e => this.onClose(e)), this.connection.on("error", e => this.events.emit("error", e)), this.connection.on("register_error", e => this.onClose()), this.hasRegisteredEventListeners = !0)
    }
};
const $Ae = () => typeof WebSocket < "u" ? WebSocket : typeof global < "u" && typeof global.WebSocket < "u" ? global.WebSocket : typeof window < "u" && typeof window.WebSocket < "u" ? window.WebSocket : typeof self < "u" && typeof self.WebSocket < "u" ? self.WebSocket : require("ws"),
    LAe = () => typeof WebSocket < "u" || typeof global < "u" && typeof global.WebSocket < "u" || typeof window < "u" && typeof window.WebSocket < "u" || typeof self < "u" && typeof self.WebSocket < "u",
    mV = t => t.split("?")[0],
    yV = 10,
    BAe = $Ae();
let FAe = class {
    constructor(e) {
        if (this.url = e, this.events = new uo.EventEmitter, this.registering = !1, !gV(e)) throw new Error(`Provided URL is not compatible with WebSocket connection: ${e}`);
        this.url = e
    }
    get connected() {
        return typeof this.socket < "u"
    }
    get connecting() {
        return this.registering
    }
    on(e, n) {
        this.events.on(e, n)
    }
    once(e, n) {
        this.events.once(e, n)
    }
    off(e, n) {
        this.events.off(e, n)
    }
    removeListener(e, n) {
        this.events.removeListener(e, n)
    }
    async open(e = this.url) {
        await this.register(e)
    }
    async close() {
        return new Promise((e, n) => {
            if (typeof this.socket > "u") {
                n(new Error("Connection already closed"));
                return
            }
            this.socket.onclose = r => {
                this.onClose(r), e()
            }, this.socket.close()
        })
    }
    async send(e) {
        typeof this.socket > "u" && (this.socket = await this.register());
        try {
            this.socket.send(Pm(e))
        } catch (n) {
            this.onError(e.id, n)
        }
    }
    register(e = this.url) {
        if (!gV(e)) throw new Error(`Provided URL is not compatible with WebSocket connection: ${e}`);
        if (this.registering) {
            const n = this.events.getMaxListeners();
            return (this.events.listenerCount("register_error") >= n || this.events.listenerCount("open") >= n) && this.events.setMaxListeners(n + 1), new Promise((r, i) => {
                this.events.once("register_error", s => {
                    this.resetMaxListeners(), i(s)
                }), this.events.once("open", () => {
                    if (this.resetMaxListeners(), typeof this.socket > "u") return i(new Error("WebSocket connection is missing or invalid"));
                    r(this.socket)
                })
            })
        }
        return this.url = e, this.registering = !0, new Promise((n, r) => {
            const i = new URLSearchParams(e).get("origin"),
                s = _ne.isReactNative() ? {
                    headers: {
                        origin: i
                    }
                } : {
                    rejectUnauthorized: !MAe(e)
                },
                o = new BAe(e, [], s);
            LAe() ? o.onerror = a => {
                const l = a;
                r(this.emitError(l.error))
            } : o.on("error", a => {
                r(this.emitError(a))
            }), o.onopen = () => {
                this.onOpen(o), n(o)
            }
        })
    }
    onOpen(e) {
        e.onmessage = n => this.onPayload(n), e.onclose = n => this.onClose(n), this.socket = e, this.registering = !1, this.events.emit("open")
    }
    onClose(e) {
        this.socket = void 0, this.registering = !1, this.events.emit("close", e)
    }
    onPayload(e) {
        if (typeof e.data > "u") return;
        const n = typeof e.data == "string" ? SE(e.data) : e.data;
        this.events.emit("payload", n)
    }
    onError(e, n) {
        const r = this.parseError(n),
            i = r.message || r.toString(),
            s = WT(e, i);
        this.events.emit("payload", s)
    }
    parseError(e, n = this.url) {
        return bne(e, mV(n), "WS")
    }
    resetMaxListeners() {
        this.events.getMaxListeners() > yV && this.events.setMaxListeners(yV)
    }
    emitError(e) {
        const n = this.parseError(new Error((e == null ? void 0 : e.message) || `WebSocket connection failed for host: ${mV(this.url)}`));
        return this.events.emit("register_error", n), n
    }
};
var RC = {
    exports: {}
};
RC.exports;
(function(t, e) {
    var n = 200,
        r = "__lodash_hash_undefined__",
        i = 1,
        s = 2,
        o = 9007199254740991,
        a = "[object Arguments]",
        l = "[object Array]",
        c = "[object AsyncFunction]",
        u = "[object Boolean]",
        f = "[object Date]",
        h = "[object Error]",
        g = "[object Function]",
        y = "[object GeneratorFunction]",
        _ = "[object Map]",
        C = "[object Number]",
        b = "[object Null]",
        w = "[object Object]",
        S = "[object Promise]",
        I = "[object Proxy]",
        P = "[object RegExp]",
        M = "[object Set]",
        A = "[object String]",
        E = "[object Symbol]",
        $ = "[object Undefined]",
        H = "[object WeakMap]",
        K = "[object ArrayBuffer]",
        te = "[object DataView]",
        U = "[object Float32Array]",
        m = "[object Float64Array]",
        v = "[object Int8Array]",
        T = "[object Int16Array]",
        N = "[object Int32Array]",
        O = "[object Uint8Array]",
        L = "[object Uint8ClampedArray]",
        G = "[object Uint16Array]",
        j = "[object Uint32Array]",
        R = /[\\^$.*+?()[\]{}|]/g,
        Y = /^\[object .+?Constructor\]$/,
        ve = /^(?:0|[1-9]\d*)$/,
        V = {};
    V[U] = V[m] = V[v] = V[T] = V[N] = V[O] = V[L] = V[G] = V[j] = !0, V[a] = V[l] = V[K] = V[u] = V[te] = V[f] = V[h] = V[g] = V[_] = V[C] = V[w] = V[P] = V[M] = V[A] = V[H] = !1;
    var X = typeof st == "object" && st && st.Object === Object && st,
        q = typeof self == "object" && self && self.Object === Object && self,
        ne = X || q || Function("return this")(),
        ie = e && !e.nodeType && e,
        k = ie && !0 && t && !t.nodeType && t,
        z = k && k.exports === ie,
        Z = z && X.process,
        ge = function() {
            try {
                return Z && Z.binding && Z.binding("util")
            } catch {}
        }(),
        me = ge && ge.isTypedArray;

    function Re(ue, Ce) {
        for (var ze = -1, xt = ue == null ? 0 : ue.length, Fr = 0, _n = []; ++ze < xt;) {
            var ei = ue[ze];
            Ce(ei, ze, ue) && (_n[Fr++] = ei)
        }
        return _n
    }

    function He(ue, Ce) {
        for (var ze = -1, xt = Ce.length, Fr = ue.length; ++ze < xt;) ue[Fr + ze] = Ce[ze];
        return ue
    }

    function Be(ue, Ce) {
        for (var ze = -1, xt = ue == null ? 0 : ue.length; ++ze < xt;)
            if (Ce(ue[ze], ze, ue)) return !0;
        return !1
    }

    function bt(ue, Ce) {
        for (var ze = -1, xt = Array(ue); ++ze < ue;) xt[ze] = Ce(ze);
        return xt
    }

    function mn(ue) {
        return function(Ce) {
            return ue(Ce)
        }
    }

    function at(ue, Ce) {
        return ue.has(Ce)
    }

    function tt(ue, Ce) {
        return ue == null ? void 0 : ue[Ce]
    }

    function _t(ue) {
        var Ce = -1,
            ze = Array(ue.size);
        return ue.forEach(function(xt, Fr) {
            ze[++Ce] = [Fr, xt]
        }), ze
    }

    function ot(ue, Ce) {
        return function(ze) {
            return ue(Ce(ze))
        }
    }

    function lt(ue) {
        var Ce = -1,
            ze = Array(ue.size);
        return ue.forEach(function(xt) {
            ze[++Ce] = xt
        }), ze
    }
    var wt = Array.prototype,
        Xe = Function.prototype,
        Q = Object.prototype,
        D = ne["__core-js_shared__"],
        B = Xe.toString,
        se = Q.hasOwnProperty,
        de = function() {
            var ue = /[^.]+$/.exec(D && D.keys && D.keys.IE_PROTO || "");
            return ue ? "Symbol(src)_1." + ue : ""
        }(),
        ye = Q.toString,
        Se = RegExp("^" + B.call(se).replace(R, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"),
        nt = z ? ne.Buffer : void 0,
        Ke = ne.Symbol,
        mt = ne.Uint8Array,
        en = Q.propertyIsEnumerable,
        vt = wt.splice,
        hn = Ke ? Ke.toStringTag : void 0,
        ui = Object.getOwnPropertySymbols,
        bn = nt ? nt.isBuffer : void 0,
        On = ot(Object.keys, Object),
        Un = el(ne, "DataView"),
        Lt = el(ne, "Map"),
        jt = el(ne, "Promise"),
        qn = el(ne, "Set"),
        Ht = el(ne, "WeakMap"),
        zt = el(Object, "create"),
        Jn = md(Un),
        Vt = md(Lt),
        Ft = md(jt),
        Xn = md(qn),
        Kt = md(Ht),
        Qt = Ke ? Ke.prototype : void 0,
        fe = Qt ? Qt.valueOf : void 0;

    function he(ue) {
        var Ce = -1,
            ze = ue == null ? 0 : ue.length;
        for (this.clear(); ++Ce < ze;) {
            var xt = ue[Ce];
            this.set(xt[0], xt[1])
        }
    }

    function be() {
        this.__data__ = zt ? zt(null) : {}, this.size = 0
    }

    function Pe(ue) {
        var Ce = this.has(ue) && delete this.__data__[ue];
        return this.size -= Ce ? 1 : 0, Ce
    }

    function qe(ue) {
        var Ce = this.__data__;
        if (zt) {
            var ze = Ce[ue];
            return ze === r ? void 0 : ze
        }
        return se.call(Ce, ue) ? Ce[ue] : void 0
    }

    function Je(ue) {
        var Ce = this.__data__;
        return zt ? Ce[ue] !== void 0 : se.call(Ce, ue)
    }

    function Mt(ue, Ce) {
        var ze = this.__data__;
        return this.size += this.has(ue) ? 0 : 1, ze[ue] = zt && Ce === void 0 ? r : Ce, this
    }
    he.prototype.clear = be, he.prototype.delete = Pe, he.prototype.get = qe, he.prototype.has = Je, he.prototype.set = Mt;

    function Le(ue) {
        var Ce = -1,
            ze = ue == null ? 0 : ue.length;
        for (this.clear(); ++Ce < ze;) {
            var xt = ue[Ce];
            this.set(xt[0], xt[1])
        }
    }

    function rt() {
        this.__data__ = [], this.size = 0
    }

    function ct(ue) {
        var Ce = this.__data__,
            ze = xr(Ce, ue);
        if (ze < 0) return !1;
        var xt = Ce.length - 1;
        return ze == xt ? Ce.pop() : vt.call(Ce, ze, 1), --this.size, !0
    }

    function ft(ue) {
        var Ce = this.__data__,
            ze = xr(Ce, ue);
        return ze < 0 ? void 0 : Ce[ze][1]
    }

    function an(ue) {
        return xr(this.__data__, ue) > -1
    }

    function pn(ue, Ce) {
        var ze = this.__data__,
            xt = xr(ze, ue);
        return xt < 0 ? (++this.size, ze.push([ue, Ce])) : ze[xt][1] = Ce, this
    }
    Le.prototype.clear = rt, Le.prototype.delete = ct, Le.prototype.get = ft, Le.prototype.has = an, Le.prototype.set = pn;

    function ln(ue) {
        var Ce = -1,
            ze = ue == null ? 0 : ue.length;
        for (this.clear(); ++Ce < ze;) {
            var xt = ue[Ce];
            this.set(xt[0], xt[1])
        }
    }

    function cn() {
        this.size = 0, this.__data__ = {
            hash: new he,
            map: new(Lt || Le),
            string: new he
        }
    }

    function Er(ue) {
        var Ce = Yh(this, ue).delete(ue);
        return this.size -= Ce ? 1 : 0, Ce
    }

    function er(ue) {
        return Yh(this, ue).get(ue)
    }

    function Js(ue) {
        return Yh(this, ue).has(ue)
    }

    function Qi(ue, Ce) {
        var ze = Yh(this, ue),
            xt = ze.size;
        return ze.set(ue, Ce), this.size += ze.size == xt ? 0 : 1, this
    }
    ln.prototype.clear = cn, ln.prototype.delete = Er, ln.prototype.get = er, ln.prototype.has = Js, ln.prototype.set = Qi;

    function Ji(ue) {
        var Ce = -1,
            ze = ue == null ? 0 : ue.length;
        for (this.__data__ = new ln; ++Ce < ze;) this.add(ue[Ce])
    }

    function Xi(ue) {
        return this.__data__.set(ue, r), this
    }

    function Xs(ue) {
        return this.__data__.has(ue)
    }
    Ji.prototype.add = Ji.prototype.push = Xi, Ji.prototype.has = Xs;

    function Tr(ue) {
        var Ce = this.__data__ = new Le(ue);
        this.size = Ce.size
    }

    function Fl() {
        this.__data__ = new Le, this.size = 0
    }

    function Ul(ue) {
        var Ce = this.__data__,
            ze = Ce.delete(ue);
        return this.size = Ce.size, ze
    }

    function jl(ue) {
        return this.__data__.get(ue)
    }

    function un(ue) {
        return this.__data__.has(ue)
    }

    function wr(ue, Ce) {
        var ze = this.__data__;
        if (ze instanceof Le) {
            var xt = ze.__data__;
            if (!Lt || xt.length < n - 1) return xt.push([ue, Ce]), this.size = ++ze.size, this;
            ze = this.__data__ = new ln(xt)
        }
        return ze.set(ue, Ce), this.size = ze.size, this
    }
    Tr.prototype.clear = Fl, Tr.prototype.delete = Ul, Tr.prototype.get = jl, Tr.prototype.has = un, Tr.prototype.set = wr;

    function Ms(ue, Ce) {
        var ze = Dy(ue),
            xt = !ze && U4(ue),
            Fr = !ze && !xt && h5(ue),
            _n = !ze && !xt && !Fr && z4(ue),
            ei = ze || xt || Fr || _n,
            hs = ei ? bt(ue.length, String) : [],
            tr = hs.length;
        for (var Ur in ue) se.call(ue, Ur) && !(ei && (Ur == "length" || Fr && (Ur == "offset" || Ur == "parent") || _n && (Ur == "buffer" || Ur == "byteLength" || Ur == "byteOffset") || D4(Ur, tr))) && hs.push(Ur);
        return hs
    }

    function xr(ue, Ce) {
        for (var ze = ue.length; ze--;)
            if (F4(ue[ze][0], Ce)) return ze;
        return -1
    }

    function jo(ue, Ce, ze) {
        var xt = Ce(ue);
        return Dy(ue) ? xt : He(xt, ze(ue))
    }

    function Yu(ue) {
        return ue == null ? ue === void 0 ? $ : b : hn && hn in Object(ue) ? k4(ue) : pI(ue)
    }

    function yg(ue) {
        return vg(ue) && Yu(ue) == a
    }

    function wg(ue, Ce, ze, xt, Fr) {
        return ue === Ce ? !0 : ue == null || Ce == null || !vg(ue) && !vg(Ce) ? ue !== ue && Ce !== Ce : R4(ue, Ce, ze, xt, wg, Fr)
    }

    function R4(ue, Ce, ze, xt, Fr, _n) {
        var ei = Dy(ue),
            hs = Dy(Ce),
            tr = ei ? l : Zu(ue),
            Ur = hs ? l : Zu(Ce);
        tr = tr == a ? w : tr, Ur = Ur == a ? w : Ur;
        var es = tr == w,
            _a = Ur == w,
            ps = tr == Ur;
        if (ps && h5(ue)) {
            if (!h5(Ce)) return !1;
            ei = !0, es = !1
        }
        if (ps && !es) return _n || (_n = new Tr), ei || z4(ue) ? ky(ue, Ce, ze, xt, Fr, _n) : hI(ue, Ce, tr, ze, xt, Fr, _n);
        if (!(ze & i)) {
            var ti = es && se.call(ue, "__wrapped__"),
                Ho = _a && se.call(Ce, "__wrapped__");
            if (ti || Ho) {
                var jc = ti ? ue.value() : ue,
                    Hl = Ho ? Ce.value() : Ce;
                return _n || (_n = new Tr), Fr(jc, Hl, ze, xt, _n)
            }
        }
        return ps ? (_n || (_n = new Tr), P4(ue, Ce, ze, xt, Fr, _n)) : !1
    }

    function dI(ue) {
        if (!H4(ue) || L4(ue)) return !1;
        var Ce = $y(ue) ? Se : Y;
        return Ce.test(md(ue))
    }

    function O4(ue) {
        return vg(ue) && j4(ue.length) && !!V[Yu(ue)]
    }

    function N4(ue) {
        if (!B4(ue)) return On(ue);
        var Ce = [];
        for (var ze in Object(ue)) se.call(ue, ze) && ze != "constructor" && Ce.push(ze);
        return Ce
    }

    function ky(ue, Ce, ze, xt, Fr, _n) {
        var ei = ze & i,
            hs = ue.length,
            tr = Ce.length;
        if (hs != tr && !(ei && tr > hs)) return !1;
        var Ur = _n.get(ue);
        if (Ur && _n.get(Ce)) return Ur == Ce;
        var es = -1,
            _a = !0,
            ps = ze & s ? new Ji : void 0;
        for (_n.set(ue, Ce), _n.set(Ce, ue); ++es < hs;) {
            var ti = ue[es],
                Ho = Ce[es];
            if (xt) var jc = ei ? xt(Ho, ti, es, Ce, ue, _n) : xt(ti, Ho, es, ue, Ce, _n);
            if (jc !== void 0) {
                if (jc) continue;
                _a = !1;
                break
            }
            if (ps) {
                if (!Be(Ce, function(Hl, Qu) {
                        if (!at(ps, Qu) && (ti === Hl || Fr(ti, Hl, ze, xt, _n))) return ps.push(Qu)
                    })) {
                    _a = !1;
                    break
                }
            } else if (!(ti === Ho || Fr(ti, Ho, ze, xt, _n))) {
                _a = !1;
                break
            }
        }
        return _n.delete(ue), _n.delete(Ce), _a
    }

    function hI(ue, Ce, ze, xt, Fr, _n, ei) {
        switch (ze) {
            case te:
                if (ue.byteLength != Ce.byteLength || ue.byteOffset != Ce.byteOffset) return !1;
                ue = ue.buffer, Ce = Ce.buffer;
            case K:
                return !(ue.byteLength != Ce.byteLength || !_n(new mt(ue), new mt(Ce)));
            case u:
            case f:
            case C:
                return F4(+ue, +Ce);
            case h:
                return ue.name == Ce.name && ue.message == Ce.message;
            case P:
            case A:
                return ue == Ce + "";
            case _:
                var hs = _t;
            case M:
                var tr = xt & i;
                if (hs || (hs = lt), ue.size != Ce.size && !tr) return !1;
                var Ur = ei.get(ue);
                if (Ur) return Ur == Ce;
                xt |= s, ei.set(ue, Ce);
                var es = ky(hs(ue), hs(Ce), xt, Fr, _n, ei);
                return ei.delete(ue), es;
            case E:
                if (fe) return fe.call(ue) == fe.call(Ce)
        }
        return !1
    }

    function P4(ue, Ce, ze, xt, Fr, _n) {
        var ei = ze & i,
            hs = My(ue),
            tr = hs.length,
            Ur = My(Ce),
            es = Ur.length;
        if (tr != es && !ei) return !1;
        for (var _a = tr; _a--;) {
            var ps = hs[_a];
            if (!(ei ? ps in Ce : se.call(Ce, ps))) return !1
        }
        var ti = _n.get(ue);
        if (ti && _n.get(Ce)) return ti == Ce;
        var Ho = !0;
        _n.set(ue, Ce), _n.set(Ce, ue);
        for (var jc = ei; ++_a < tr;) {
            ps = hs[_a];
            var Hl = ue[ps],
                Qu = Ce[ps];
            if (xt) var p5 = ei ? xt(Qu, Hl, ps, Ce, ue, _n) : xt(Hl, Qu, ps, ue, Ce, _n);
            if (!(p5 === void 0 ? Hl === Qu || Fr(Hl, Qu, ze, xt, _n) : p5)) {
                Ho = !1;
                break
            }
            jc || (jc = ps == "constructor")
        }
        if (Ho && !jc) {
            var bg = ue.constructor,
                Ds = Ce.constructor;
            bg != Ds && "constructor" in ue && "constructor" in Ce && !(typeof bg == "function" && bg instanceof bg && typeof Ds == "function" && Ds instanceof Ds) && (Ho = !1)
        }
        return _n.delete(ue), _n.delete(Ce), Ho
    }

    function My(ue) {
        return jo(ue, yI, M4)
    }

    function Yh(ue, Ce) {
        var ze = ue.__data__;
        return $4(Ce) ? ze[typeof Ce == "string" ? "string" : "hash"] : ze.map
    }

    function el(ue, Ce) {
        var ze = tt(ue, Ce);
        return dI(ze) ? ze : void 0
    }

    function k4(ue) {
        var Ce = se.call(ue, hn),
            ze = ue[hn];
        try {
            ue[hn] = void 0;
            var xt = !0
        } catch {}
        var Fr = ye.call(ue);
        return xt && (Ce ? ue[hn] = ze : delete ue[hn]), Fr
    }
    var M4 = ui ? function(ue) {
            return ue == null ? [] : (ue = Object(ue), Re(ui(ue), function(Ce) {
                return en.call(ue, Ce)
            }))
        } : Br,
        Zu = Yu;
    (Un && Zu(new Un(new ArrayBuffer(1))) != te || Lt && Zu(new Lt) != _ || jt && Zu(jt.resolve()) != S || qn && Zu(new qn) != M || Ht && Zu(new Ht) != H) && (Zu = function(ue) {
        var Ce = Yu(ue),
            ze = Ce == w ? ue.constructor : void 0,
            xt = ze ? md(ze) : "";
        if (xt) switch (xt) {
            case Jn:
                return te;
            case Vt:
                return _;
            case Ft:
                return S;
            case Xn:
                return M;
            case Kt:
                return H
        }
        return Ce
    });

    function D4(ue, Ce) {
        return Ce = Ce ? ? o, !!Ce && (typeof ue == "number" || ve.test(ue)) && ue > -1 && ue % 1 == 0 && ue < Ce
    }

    function $4(ue) {
        var Ce = typeof ue;
        return Ce == "string" || Ce == "number" || Ce == "symbol" || Ce == "boolean" ? ue !== "__proto__" : ue === null
    }

    function L4(ue) {
        return !!de && de in ue
    }

    function B4(ue) {
        var Ce = ue && ue.constructor,
            ze = typeof Ce == "function" && Ce.prototype || Q;
        return ue === ze
    }

    function pI(ue) {
        return ye.call(ue)
    }

    function md(ue) {
        if (ue != null) {
            try {
                return B.call(ue)
            } catch {}
            try {
                return ue + ""
            } catch {}
        }
        return ""
    }

    function F4(ue, Ce) {
        return ue === Ce || ue !== ue && Ce !== Ce
    }
    var U4 = yg(function() {
            return arguments
        }()) ? yg : function(ue) {
            return vg(ue) && se.call(ue, "callee") && !en.call(ue, "callee")
        },
        Dy = Array.isArray;

    function gI(ue) {
        return ue != null && j4(ue.length) && !$y(ue)
    }
    var h5 = bn || Nr;

    function mI(ue, Ce) {
        return wg(ue, Ce)
    }

    function $y(ue) {
        if (!H4(ue)) return !1;
        var Ce = Yu(ue);
        return Ce == g || Ce == y || Ce == c || Ce == I
    }

    function j4(ue) {
        return typeof ue == "number" && ue > -1 && ue % 1 == 0 && ue <= o
    }

    function H4(ue) {
        var Ce = typeof ue;
        return ue != null && (Ce == "object" || Ce == "function")
    }

    function vg(ue) {
        return ue != null && typeof ue == "object"
    }
    var z4 = me ? mn(me) : O4;

    function yI(ue) {
        return gI(ue) ? Ms(ue) : N4(ue)
    }

    function Br() {
        return []
    }

    function Nr() {
        return !1
    }
    t.exports = mI
})(RC, RC.exports);
var UAe = RC.exports;
const jAe = co(UAe);

function HAe(t, e) {
    return e = e || {}, new Promise(function(n, r) {
        var i = new XMLHttpRequest,
            s = [],
            o = [],
            a = {},
            l = function() {
                return {
                    ok: (i.status / 100 | 0) == 2,
                    statusText: i.statusText,
                    status: i.status,
                    url: i.responseURL,
                    text: function() {
                        return Promise.resolve(i.responseText)
                    },
                    json: function() {
                        return Promise.resolve(i.responseText).then(JSON.parse)
                    },
                    blob: function() {
                        return Promise.resolve(new Blob([i.response]))
                    },
                    clone: l,
                    headers: {
                        keys: function() {
                            return s
                        },
                        entries: function() {
                            return o
                        },
                        get: function(u) {
                            return a[u.toLowerCase()]
                        },
                        has: function(u) {
                            return u.toLowerCase() in a
                        }
                    }
                }
            };
        for (var c in i.open(e.method || "get", t, !0), i.onload = function() {
                i.getAllResponseHeaders().replace(/^(.*?):[^\S\n]*([\s\S]*?)$/gm, function(u, f, h) {
                    s.push(f = f.toLowerCase()), o.push([f, h]), a[f] = a[f] ? a[f] + "," + h : h
                }), n(l())
            }, i.onerror = r, i.withCredentials = e.credentials == "include", e.headers) i.setRequestHeader(c, e.headers[c]);
        i.send(e.body || null)
    })
}
const zAe = Object.freeze(Object.defineProperty({
        __proto__: null,
        default: HAe
    }, Symbol.toStringTag, {
        value: "Module"
    })),
    wV = Fu(zAe);
var WAe = self.fetch || (self.fetch = wV.default || wV);
const VAe = co(WAe);
var GAe = {};

function qAe(t, e) {
    if (t.length >= 255) throw new TypeError("Alphabet too long");
    for (var n = new Uint8Array(256), r = 0; r < n.length; r++) n[r] = 255;
    for (var i = 0; i < t.length; i++) {
        var s = t.charAt(i),
            o = s.charCodeAt(0);
        if (n[o] !== 255) throw new TypeError(s + " is ambiguous");
        n[o] = i
    }
    var a = t.length,
        l = t.charAt(0),
        c = Math.log(a) / Math.log(256),
        u = Math.log(256) / Math.log(a);

    function f(y) {
        if (y instanceof Uint8Array || (ArrayBuffer.isView(y) ? y = new Uint8Array(y.buffer, y.byteOffset, y.byteLength) : Array.isArray(y) && (y = Uint8Array.from(y))), !(y instanceof Uint8Array)) throw new TypeError("Expected Uint8Array");
        if (y.length === 0) return "";
        for (var _ = 0, C = 0, b = 0, w = y.length; b !== w && y[b] === 0;) b++, _++;
        for (var S = (w - b) * u + 1 >>> 0, I = new Uint8Array(S); b !== w;) {
            for (var P = y[b], M = 0, A = S - 1;
                (P !== 0 || M < C) && A !== -1; A--, M++) P += 256 * I[A] >>> 0, I[A] = P % a >>> 0, P = P / a >>> 0;
            if (P !== 0) throw new Error("Non-zero carry");
            C = M, b++
        }
        for (var E = S - C; E !== S && I[E] === 0;) E++;
        for (var $ = l.repeat(_); E < S; ++E) $ += t.charAt(I[E]);
        return $
    }

    function h(y) {
        if (typeof y != "string") throw new TypeError("Expected String");
        if (y.length === 0) return new Uint8Array;
        var _ = 0;
        if (y[_] !== " ") {
            for (var C = 0, b = 0; y[_] === l;) C++, _++;
            for (var w = (y.length - _) * c + 1 >>> 0, S = new Uint8Array(w); y[_];) {
                var I = n[y.charCodeAt(_)];
                if (I === 255) return;
                for (var P = 0, M = w - 1;
                    (I !== 0 || P < b) && M !== -1; M--, P++) I += a * S[M] >>> 0, S[M] = I % 256 >>> 0, I = I / 256 >>> 0;
                if (I !== 0) throw new Error("Non-zero carry");
                b = P, _++
            }
            if (y[_] !== " ") {
                for (var A = w - b; A !== w && S[A] === 0;) A++;
                for (var E = new Uint8Array(C + (w - A)), $ = C; A !== w;) E[$++] = S[A++];
                return E
            }
        }
    }

    function g(y) {
        var _ = h(y);
        if (_) return _;
        throw new Error(`Non-${e} character`)
    }
    return {
        encode: f,
        decodeUnsafe: h,
        decode: g
    }
}
var KAe = qAe,
    YAe = KAe;
const Cne = t => {
        if (t instanceof Uint8Array && t.constructor.name === "Uint8Array") return t;
        if (t instanceof ArrayBuffer) return new Uint8Array(t);
        if (ArrayBuffer.isView(t)) return new Uint8Array(t.buffer, t.byteOffset, t.byteLength);
        throw new Error("Unknown type, must be binary type")
    },
    ZAe = t => new TextEncoder().encode(t),
    QAe = t => new TextDecoder().decode(t);
let JAe = class {
    constructor(e, n, r) {
        this.name = e, this.prefix = n, this.baseEncode = r
    }
    encode(e) {
        if (e instanceof Uint8Array) return `${this.prefix}${this.baseEncode(e)}`;
        throw Error("Unknown type, must be binary type")
    }
};
class XAe {
    constructor(e, n, r) {
        if (this.name = e, this.prefix = n, n.codePointAt(0) === void 0) throw new Error("Invalid prefix character");
        this.prefixCodePoint = n.codePointAt(0), this.baseDecode = r
    }
    decode(e) {
        if (typeof e == "string") {
            if (e.codePointAt(0) !== this.prefixCodePoint) throw Error(`Unable to decode multibase string ${JSON.stringify(e)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
            return this.baseDecode(e.slice(this.prefix.length))
        } else throw Error("Can only multibase decode strings")
    }
    or(e) {
        return Ane(this, e)
    }
}
class eTe {
    constructor(e) {
        this.decoders = e
    }
    or(e) {
        return Ane(this, e)
    }
    decode(e) {
        const n = e[0],
            r = this.decoders[n];
        if (r) return r.decode(e);
        throw RangeError(`Unable to decode multibase string ${JSON.stringify(e)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`)
    }
}
const Ane = (t, e) => new eTe({ ...t.decoders || {
        [t.prefix]: t
    },
    ...e.decoders || {
        [e.prefix]: e
    }
});
let tTe = class {
    constructor(e, n, r, i) {
        this.name = e, this.prefix = n, this.baseEncode = r, this.baseDecode = i, this.encoder = new JAe(e, n, r), this.decoder = new XAe(e, n, i)
    }
    encode(e) {
        return this.encoder.encode(e)
    }
    decode(e) {
        return this.decoder.decode(e)
    }
};
const VT = ({
        name: t,
        prefix: e,
        encode: n,
        decode: r
    }) => new tTe(t, e, n, r),
    TE = ({
        prefix: t,
        name: e,
        alphabet: n
    }) => {
        const {
            encode: r,
            decode: i
        } = YAe(n, e);
        return VT({
            prefix: t,
            name: e,
            encode: r,
            decode: s => Cne(i(s))
        })
    },
    nTe = (t, e, n, r) => {
        const i = {};
        for (let u = 0; u < e.length; ++u) i[e[u]] = u;
        let s = t.length;
        for (; t[s - 1] === "=";) --s;
        const o = new Uint8Array(s * n / 8 | 0);
        let a = 0,
            l = 0,
            c = 0;
        for (let u = 0; u < s; ++u) {
            const f = i[t[u]];
            if (f === void 0) throw new SyntaxError(`Non-${r} character`);
            l = l << n | f, a += n, a >= 8 && (a -= 8, o[c++] = 255 & l >> a)
        }
        if (a >= n || 255 & l << 8 - a) throw new SyntaxError("Unexpected end of data");
        return o
    },
    rTe = (t, e, n) => {
        const r = e[e.length - 1] === "=",
            i = (1 << n) - 1;
        let s = "",
            o = 0,
            a = 0;
        for (let l = 0; l < t.length; ++l)
            for (a = a << 8 | t[l], o += 8; o > n;) o -= n, s += e[i & a >> o];
        if (o && (s += e[i & a << n - o]), r)
            for (; s.length * n & 7;) s += "=";
        return s
    },
    ho = ({
        name: t,
        prefix: e,
        bitsPerChar: n,
        alphabet: r
    }) => VT({
        prefix: e,
        name: t,
        encode(i) {
            return rTe(i, r, n)
        },
        decode(i) {
            return nTe(i, r, n, t)
        }
    }),
    iTe = VT({
        prefix: "\0",
        name: "identity",
        encode: t => QAe(t),
        decode: t => ZAe(t)
    });
var sTe = Object.freeze({
    __proto__: null,
    identity: iTe
});
const oTe = ho({
    prefix: "0",
    name: "base2",
    alphabet: "01",
    bitsPerChar: 1
});
var aTe = Object.freeze({
    __proto__: null,
    base2: oTe
});
const lTe = ho({
    prefix: "7",
    name: "base8",
    alphabet: "01234567",
    bitsPerChar: 3
});
var cTe = Object.freeze({
    __proto__: null,
    base8: lTe
});
const uTe = TE({
    prefix: "9",
    name: "base10",
    alphabet: "0123456789"
});
var fTe = Object.freeze({
    __proto__: null,
    base10: uTe
});
const dTe = ho({
        prefix: "f",
        name: "base16",
        alphabet: "0123456789abcdef",
        bitsPerChar: 4
    }),
    hTe = ho({
        prefix: "F",
        name: "base16upper",
        alphabet: "0123456789ABCDEF",
        bitsPerChar: 4
    });
var pTe = Object.freeze({
    __proto__: null,
    base16: dTe,
    base16upper: hTe
});
const gTe = ho({
        prefix: "b",
        name: "base32",
        alphabet: "abcdefghijklmnopqrstuvwxyz234567",
        bitsPerChar: 5
    }),
    mTe = ho({
        prefix: "B",
        name: "base32upper",
        alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
        bitsPerChar: 5
    }),
    yTe = ho({
        prefix: "c",
        name: "base32pad",
        alphabet: "abcdefghijklmnopqrstuvwxyz234567=",
        bitsPerChar: 5
    }),
    wTe = ho({
        prefix: "C",
        name: "base32padupper",
        alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",
        bitsPerChar: 5
    }),
    vTe = ho({
        prefix: "v",
        name: "base32hex",
        alphabet: "0123456789abcdefghijklmnopqrstuv",
        bitsPerChar: 5
    }),
    bTe = ho({
        prefix: "V",
        name: "base32hexupper",
        alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV",
        bitsPerChar: 5
    }),
    _Te = ho({
        prefix: "t",
        name: "base32hexpad",
        alphabet: "0123456789abcdefghijklmnopqrstuv=",
        bitsPerChar: 5
    }),
    ETe = ho({
        prefix: "T",
        name: "base32hexpadupper",
        alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=",
        bitsPerChar: 5
    }),
    xTe = ho({
        prefix: "h",
        name: "base32z",
        alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769",
        bitsPerChar: 5
    });
var STe = Object.freeze({
    __proto__: null,
    base32: gTe,
    base32upper: mTe,
    base32pad: yTe,
    base32padupper: wTe,
    base32hex: vTe,
    base32hexupper: bTe,
    base32hexpad: _Te,
    base32hexpadupper: ETe,
    base32z: xTe
});
const CTe = TE({
        prefix: "k",
        name: "base36",
        alphabet: "0123456789abcdefghijklmnopqrstuvwxyz"
    }),
    ATe = TE({
        prefix: "K",
        name: "base36upper",
        alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"
    });
var TTe = Object.freeze({
    __proto__: null,
    base36: CTe,
    base36upper: ATe
});
const ITe = TE({
        name: "base58btc",
        prefix: "z",
        alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
    }),
    RTe = TE({
        name: "base58flickr",
        prefix: "Z",
        alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"
    });
var OTe = Object.freeze({
    __proto__: null,
    base58btc: ITe,
    base58flickr: RTe
});
const NTe = ho({
        prefix: "m",
        name: "base64",
        alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
        bitsPerChar: 6
    }),
    PTe = ho({
        prefix: "M",
        name: "base64pad",
        alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
        bitsPerChar: 6
    }),
    kTe = ho({
        prefix: "u",
        name: "base64url",
        alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",
        bitsPerChar: 6
    }),
    MTe = ho({
        prefix: "U",
        name: "base64urlpad",
        alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",
        bitsPerChar: 6
    });
var DTe = Object.freeze({
    __proto__: null,
    base64: NTe,
    base64pad: PTe,
    base64url: kTe,
    base64urlpad: MTe
});
const Tne = Array.from(""),
    $Te = Tne.reduce((t, e, n) => (t[n] = e, t), []),
    LTe = Tne.reduce((t, e, n) => (t[e.codePointAt(0)] = n, t), []);

function BTe(t) {
    return t.reduce((e, n) => (e += $Te[n], e), "")
}

function FTe(t) {
    const e = [];
    for (const n of t) {
        const r = LTe[n.codePointAt(0)];
        if (r === void 0) throw new Error(`Non-base256emoji character: ${n}`);
        e.push(r)
    }
    return new Uint8Array(e)
}
const UTe = VT({
    prefix: "",
    name: "base256emoji",
    encode: BTe,
    decode: FTe
});
var jTe = Object.freeze({
        __proto__: null,
        base256emoji: UTe
    }),
    HTe = Ine,
    vV = 128,
    zTe = 127,
    WTe = ~zTe,
    VTe = Math.pow(2, 31);

function Ine(t, e, n) {
    e = e || [], n = n || 0;
    for (var r = n; t >= VTe;) e[n++] = t & 255 | vV, t /= 128;
    for (; t & WTe;) e[n++] = t & 255 | vV, t >>>= 7;
    return e[n] = t | 0, Ine.bytes = n - r + 1, e
}
var GTe = hk,
    qTe = 128,
    bV = 127;

function hk(t, r) {
    var n = 0,
        r = r || 0,
        i = 0,
        s = r,
        o, a = t.length;
    do {
        if (s >= a) throw hk.bytes = 0, new RangeError("Could not decode varint");
        o = t[s++], n += i < 28 ? (o & bV) << i : (o & bV) * Math.pow(2, i), i += 7
    } while (o >= qTe);
    return hk.bytes = s - r, n
}
var KTe = Math.pow(2, 7),
    YTe = Math.pow(2, 14),
    ZTe = Math.pow(2, 21),
    QTe = Math.pow(2, 28),
    JTe = Math.pow(2, 35),
    XTe = Math.pow(2, 42),
    e9e = Math.pow(2, 49),
    t9e = Math.pow(2, 56),
    n9e = Math.pow(2, 63),
    r9e = function(t) {
        return t < KTe ? 1 : t < YTe ? 2 : t < ZTe ? 3 : t < QTe ? 4 : t < JTe ? 5 : t < XTe ? 6 : t < e9e ? 7 : t < t9e ? 8 : t < n9e ? 9 : 10
    },
    i9e = {
        encode: HTe,
        decode: GTe,
        encodingLength: r9e
    },
    Rne = i9e;
const _V = (t, e, n = 0) => (Rne.encode(t, e, n), e),
    EV = t => Rne.encodingLength(t),
    pk = (t, e) => {
        const n = e.byteLength,
            r = EV(t),
            i = r + EV(n),
            s = new Uint8Array(i + n);
        return _V(t, s, 0), _V(n, s, r), s.set(e, i), new s9e(t, n, e, s)
    };
class s9e {
    constructor(e, n, r, i) {
        this.code = e, this.size = n, this.digest = r, this.bytes = i
    }
}
const One = ({
    name: t,
    code: e,
    encode: n
}) => new o9e(t, e, n);
class o9e {
    constructor(e, n, r) {
        this.name = e, this.code = n, this.encode = r
    }
    digest(e) {
        if (e instanceof Uint8Array) {
            const n = this.encode(e);
            return n instanceof Uint8Array ? pk(this.code, n) : n.then(r => pk(this.code, r))
        } else throw Error("Unknown type, must be binary type")
    }
}
const Nne = t => async e => new Uint8Array(await crypto.subtle.digest(t, e)),
    a9e = One({
        name: "sha2-256",
        code: 18,
        encode: Nne("SHA-256")
    }),
    l9e = One({
        name: "sha2-512",
        code: 19,
        encode: Nne("SHA-512")
    });
var c9e = Object.freeze({
    __proto__: null,
    sha256: a9e,
    sha512: l9e
});
const Pne = 0,
    u9e = "identity",
    kne = Cne,
    f9e = t => pk(Pne, kne(t)),
    d9e = {
        code: Pne,
        name: u9e,
        encode: kne,
        digest: f9e
    };
var h9e = Object.freeze({
    __proto__: null,
    identity: d9e
});
new TextEncoder, new TextDecoder;
const xV = { ...sTe,
    ...aTe,
    ...cTe,
    ...fTe,
    ...pTe,
    ...STe,
    ...TTe,
    ...OTe,
    ...DTe,
    ...jTe
};
({ ...c9e,
    ...h9e
});

function Mne(t) {
    return globalThis.Buffer != null ? new Uint8Array(t.buffer, t.byteOffset, t.byteLength) : t
}

function p9e(t = 0) {
    return globalThis.Buffer != null && globalThis.Buffer.allocUnsafe != null ? Mne(globalThis.Buffer.allocUnsafe(t)) : new Uint8Array(t)
}

function Dne(t, e, n, r) {
    return {
        name: t,
        prefix: e,
        encoder: {
            name: t,
            prefix: e,
            encode: n
        },
        decoder: {
            decode: r
        }
    }
}
const SV = Dne("utf8", "u", t => "u" + new TextDecoder("utf8").decode(t), t => new TextEncoder().encode(t.substring(1))),
    sO = Dne("ascii", "a", t => {
        let e = "a";
        for (let n = 0; n < t.length; n++) e += String.fromCharCode(t[n]);
        return e
    }, t => {
        t = t.substring(1);
        const e = p9e(t.length);
        for (let n = 0; n < t.length; n++) e[n] = t.charCodeAt(n);
        return e
    }),
    g9e = {
        utf8: SV,
        "utf-8": SV,
        hex: xV.base16,
        latin1: sO,
        ascii: sO,
        binary: sO,
        ...xV
    };

function m9e(t, e = "utf8") {
    const n = g9e[e];
    if (!n) throw new Error(`Unsupported encoding "${e}"`);
    return (e === "utf8" || e === "utf-8") && globalThis.Buffer != null && globalThis.Buffer.from != null ? Mne(globalThis.Buffer.from(t, "utf-8")) : n.decoder.decode(`${n.prefix}${t}`)
}
const $ne = "wc",
    y9e = 2,
    wL = "core",
    jp = `${$ne}@2:${wL}:`,
    w9e = {
        name: wL,
        logger: "error"
    },
    v9e = {
        database: ":memory:"
    },
    b9e = "crypto",
    CV = "client_ed25519_seed",
    _9e = Bt.ONE_DAY,
    E9e = "keychain",
    x9e = "0.3",
    S9e = "messages",
    C9e = "0.3",
    A9e = Bt.SIX_HOURS,
    T9e = "publisher",
    Lne = "irn",
    I9e = "error",
    Bne = "wss://relay.walletconnect.com",
    AV = "wss://relay.walletconnect.org",
    R9e = "relayer",
    Ro = {
        message: "relayer_message",
        message_ack: "relayer_message_ack",
        connect: "relayer_connect",
        disconnect: "relayer_disconnect",
        error: "relayer_error",
        connection_stalled: "relayer_connection_stalled",
        transport_closed: "relayer_transport_closed",
        publish: "relayer_publish"
    },
    O9e = "_subscription",
    Od = {
        payload: "payload",
        connect: "connect",
        disconnect: "disconnect",
        error: "error"
    },
    N9e = Bt.ONE_SECOND,
    P9e = "2.11.0",
    k9e = 1e4,
    M9e = "0.3",
    D9e = "WALLETCONNECT_CLIENT_ID",
    nu = {
        created: "subscription_created",
        deleted: "subscription_deleted",
        expired: "subscription_expired",
        disabled: "subscription_disabled",
        sync: "subscription_sync",
        resubscribed: "subscription_resubscribed"
    },
    $9e = "subscription",
    L9e = "0.3",
    B9e = Bt.FIVE_SECONDS * 1e3,
    F9e = "pairing",
    U9e = "0.3",
    B5 = {
        wc_pairingDelete: {
            req: {
                ttl: Bt.ONE_DAY,
                prompt: !1,
                tag: 1e3
            },
            res: {
                ttl: Bt.ONE_DAY,
                prompt: !1,
                tag: 1001
            }
        },
        wc_pairingPing: {
            req: {
                ttl: Bt.THIRTY_SECONDS,
                prompt: !1,
                tag: 1002
            },
            res: {
                ttl: Bt.THIRTY_SECONDS,
                prompt: !1,
                tag: 1003
            }
        },
        unregistered_method: {
            req: {
                ttl: Bt.ONE_DAY,
                prompt: !1,
                tag: 0
            },
            res: {
                ttl: Bt.ONE_DAY,
                prompt: !1,
                tag: 0
            }
        }
    },
    _3 = {
        create: "pairing_create",
        expire: "pairing_expire",
        delete: "pairing_delete",
        ping: "pairing_ping"
    },
    rf = {
        created: "history_created",
        updated: "history_updated",
        deleted: "history_deleted",
        sync: "history_sync"
    },
    j9e = "history",
    H9e = "0.3",
    z9e = "expirer",
    ic = {
        created: "expirer_created",
        deleted: "expirer_deleted",
        expired: "expirer_expired",
        sync: "expirer_sync"
    },
    W9e = "0.3",
    oO = "verify-api",
    Iw = "https://verify.walletconnect.com",
    gk = "https://verify.walletconnect.org",
    V9e = [Iw, gk],
    G9e = "echo",
    q9e = "https://echo.walletconnect.com";
class K9e {
    constructor(e, n) {
        this.core = e, this.logger = n, this.keychain = new Map, this.name = E9e, this.version = x9e, this.initialized = !1, this.storagePrefix = jp, this.init = async () => {
            if (!this.initialized) {
                const r = await this.getKeyChain();
                typeof r < "u" && (this.keychain = r), this.initialized = !0
            }
        }, this.has = r => (this.isInitialized(), this.keychain.has(r)), this.set = async (r, i) => {
            this.isInitialized(), this.keychain.set(r, i), await this.persist()
        }, this.get = r => {
            this.isInitialized();
            const i = this.keychain.get(r);
            if (typeof i > "u") {
                const {
                    message: s
                } = ut("NO_MATCHING_KEY", `${this.name}: ${r}`);
                throw new Error(s)
            }
            return i
        }, this.del = async r => {
            this.isInitialized(), this.keychain.delete(r), await this.persist()
        }, this.core = e, this.logger = Ja(n, this.name)
    }
    get context() {
        return Qa(this.logger)
    }
    get storageKey() {
        return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name
    }
    async setKeyChain(e) {
        await this.core.storage.setItem(this.storageKey, nne(e))
    }
    async getKeyChain() {
        const e = await this.core.storage.getItem(this.storageKey);
        return typeof e < "u" ? rne(e) : void 0
    }
    async persist() {
        await this.setKeyChain(this.keychain)
    }
    isInitialized() {
        if (!this.initialized) {
            const {
                message: e
            } = ut("NOT_INITIALIZED", this.name);
            throw new Error(e)
        }
    }
}
class Y9e {
    constructor(e, n, r) {
        this.core = e, this.logger = n, this.name = b9e, this.initialized = !1, this.init = async () => {
            this.initialized || (await this.keychain.init(), this.initialized = !0)
        }, this.hasKeys = i => (this.isInitialized(), this.keychain.has(i)), this.getClientId = async () => {
            this.isInitialized();
            const i = await this.getClientSeed(),
                s = uV(i);
            return yne(s.publicKey)
        }, this.generateKeyPair = () => {
            this.isInitialized();
            const i = CSe();
            return this.setPrivateKey(i.publicKey, i.privateKey)
        }, this.signJWT = async i => {
            this.isInitialized();
            const s = await this.getClientSeed(),
                o = uV(s),
                a = ck();
            return await wAe(a, i, _9e, o)
        }, this.generateSharedKey = (i, s, o) => {
            this.isInitialized();
            const a = this.getPrivateKey(i),
                l = ASe(a, s);
            return this.setSymKey(l, o)
        }, this.setSymKey = async (i, s) => {
            this.isInitialized();
            const o = s || TSe(i);
            return await this.keychain.set(o, i), o
        }, this.deleteKeyPair = async i => {
            this.isInitialized(), await this.keychain.del(i)
        }, this.deleteSymKey = async i => {
            this.isInitialized(), await this.keychain.del(i)
        }, this.encode = async (i, s, o) => {
            this.isInitialized();
            const a = tne(o),
                l = Pm(s);
            if (FW(a)) {
                const h = a.senderPublicKey,
                    g = a.receiverPublicKey;
                i = await this.generateSharedKey(h, g)
            }
            const c = this.getSymKey(i),
                {
                    type: u,
                    senderPublicKey: f
                } = a;
            return RSe({
                type: u,
                symKey: c,
                message: l,
                senderPublicKey: f
            })
        }, this.decode = async (i, s, o) => {
            this.isInitialized();
            const a = PSe(s, o);
            if (FW(a)) {
                const l = a.receiverPublicKey,
                    c = a.senderPublicKey;
                i = await this.generateSharedKey(l, c)
            }
            try {
                const l = this.getSymKey(i),
                    c = OSe({
                        symKey: l,
                        encoded: s
                    });
                return SE(c)
            } catch (l) {
                this.logger.error(`Failed to decode message from topic: '${i}', clientId: '${await this.getClientId()}'`), this.logger.error(l)
            }
        }, this.getPayloadType = i => {
            const s = AC(i);
            return _E(s.type)
        }, this.getPayloadSenderPublicKey = i => {
            const s = AC(i);
            return s.senderPublicKey ? ha(s.senderPublicKey, ca) : void 0
        }, this.core = e, this.logger = Ja(n, this.name), this.keychain = r || new K9e(this.core, this.logger)
    }
    get context() {
        return Qa(this.logger)
    }
    async setPrivateKey(e, n) {
        return await this.keychain.set(e, n), e
    }
    getPrivateKey(e) {
        return this.keychain.get(e)
    }
    async getClientSeed() {
        let e = "";
        try {
            e = this.keychain.get(CV)
        } catch {
            e = ck(), await this.keychain.set(CV, e)
        }
        return m9e(e, "base16")
    }
    getSymKey(e) {
        return this.keychain.get(e)
    }
    isInitialized() {
        if (!this.initialized) {
            const {
                message: e
            } = ut("NOT_INITIALIZED", this.name);
            throw new Error(e)
        }
    }
}
class Z9e extends YCe {
    constructor(e, n) {
        super(e, n), this.logger = e, this.core = n, this.messages = new Map, this.name = S9e, this.version = C9e, this.initialized = !1, this.storagePrefix = jp, this.init = async () => {
            if (!this.initialized) {
                this.logger.trace("Initialized");
                try {
                    const r = await this.getRelayerMessages();
                    typeof r < "u" && (this.messages = r), this.logger.debug(`Successfully Restored records for ${this.name}`), this.logger.trace({
                        type: "method",
                        method: "restore",
                        size: this.messages.size
                    })
                } catch (r) {
                    this.logger.debug(`Failed to Restore records for ${this.name}`), this.logger.error(r)
                } finally {
                    this.initialized = !0
                }
            }
        }, this.set = async (r, i) => {
            this.isInitialized();
            const s = nv(i);
            let o = this.messages.get(r);
            return typeof o > "u" && (o = {}), typeof o[s] < "u" || (o[s] = i, this.messages.set(r, o), await this.persist()), s
        }, this.get = r => {
            this.isInitialized();
            let i = this.messages.get(r);
            return typeof i > "u" && (i = {}), i
        }, this.has = (r, i) => {
            this.isInitialized();
            const s = this.get(r),
                o = nv(i);
            return typeof s[o] < "u"
        }, this.del = async r => {
            this.isInitialized(), this.messages.delete(r), await this.persist()
        }, this.logger = Ja(e, this.name), this.core = n
    }
    get context() {
        return Qa(this.logger)
    }
    get storageKey() {
        return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name
    }
    async setRelayerMessages(e) {
        await this.core.storage.setItem(this.storageKey, nne(e))
    }
    async getRelayerMessages() {
        const e = await this.core.storage.getItem(this.storageKey);
        return typeof e < "u" ? rne(e) : void 0
    }
    async persist() {
        await this.setRelayerMessages(this.messages)
    }
    isInitialized() {
        if (!this.initialized) {
            const {
                message: e
            } = ut("NOT_INITIALIZED", this.name);
            throw new Error(e)
        }
    }
}
class Q9e extends ZCe {
    constructor(e, n) {
        super(e, n), this.relayer = e, this.logger = n, this.events = new uo.EventEmitter, this.name = T9e, this.queue = new Map, this.publishTimeout = Bt.toMiliseconds(Bt.TEN_SECONDS), this.needsTransportRestart = !1, this.publish = async (r, i, s) => {
            var o;
            this.logger.debug("Publishing Payload"), this.logger.trace({
                type: "method",
                method: "publish",
                params: {
                    topic: r,
                    message: i,
                    opts: s
                }
            });
            try {
                const a = (s == null ? void 0 : s.ttl) || A9e,
                    l = uk(s),
                    c = (s == null ? void 0 : s.prompt) || !1,
                    u = (s == null ? void 0 : s.tag) || 0,
                    f = (s == null ? void 0 : s.id) || mL().toString(),
                    h = {
                        topic: r,
                        message: i,
                        opts: {
                            ttl: a,
                            relay: l,
                            prompt: c,
                            tag: u,
                            id: f
                        }
                    },
                    g = setTimeout(() => this.queue.set(f, h), this.publishTimeout);
                try {
                    await await G_(this.rpcPublish(r, i, a, l, c, u, f), this.publishTimeout, "Failed to publish payload, please try again."), this.removeRequestFromQueue(f), this.relayer.events.emit(Ro.publish, h)
                } catch (y) {
                    if (this.logger.debug("Publishing Payload stalled"), this.needsTransportRestart = !0, (o = s == null ? void 0 : s.internal) != null && o.throwOnFailedPublish) throw this.removeRequestFromQueue(f), y;
                    return
                } finally {
                    clearTimeout(g)
                }
                this.logger.debug("Successfully Published Payload"), this.logger.trace({
                    type: "method",
                    method: "publish",
                    params: {
                        topic: r,
                        message: i,
                        opts: s
                    }
                })
            } catch (a) {
                throw this.logger.debug("Failed to Publish Payload"), this.logger.error(a), a
            }
        }, this.on = (r, i) => {
            this.events.on(r, i)
        }, this.once = (r, i) => {
            this.events.once(r, i)
        }, this.off = (r, i) => {
            this.events.off(r, i)
        }, this.removeListener = (r, i) => {
            this.events.removeListener(r, i)
        }, this.relayer = e, this.logger = Ja(n, this.name), this.registerEventListeners()
    }
    get context() {
        return Qa(this.logger)
    }
    rpcPublish(e, n, r, i, s, o, a) {
        var l, c, u, f;
        const h = {
            method: QS(i.protocol).publish,
            params: {
                topic: e,
                message: n,
                ttl: r,
                prompt: s,
                tag: o
            },
            id: a
        };
        return Fa((l = h.params) == null ? void 0 : l.prompt) && ((c = h.params) == null || delete c.prompt), Fa((u = h.params) == null ? void 0 : u.tag) && ((f = h.params) == null || delete f.tag), this.logger.debug("Outgoing Relay Payload"), this.logger.trace({
            type: "message",
            direction: "outgoing",
            request: h
        }), this.relayer.request(h)
    }
    removeRequestFromQueue(e) {
        this.queue.delete(e)
    }
    checkQueue() {
        this.queue.forEach(async e => {
            const {
                topic: n,
                message: r,
                opts: i
            } = e;
            await this.publish(n, r, i)
        })
    }
    registerEventListeners() {
        this.relayer.core.heartbeat.on(P2.HEARTBEAT_EVENTS.pulse, () => {
            if (this.needsTransportRestart) {
                this.needsTransportRestart = !1, this.relayer.events.emit(Ro.connection_stalled);
                return
            }
            this.checkQueue()
        }), this.relayer.on(Ro.message_ack, e => {
            this.removeRequestFromQueue(e.id.toString())
        })
    }
}
class J9e {
    constructor() {
        this.map = new Map, this.set = (e, n) => {
            const r = this.get(e);
            this.exists(e, n) || this.map.set(e, [...r, n])
        }, this.get = e => this.map.get(e) || [], this.exists = (e, n) => this.get(e).includes(n), this.delete = (e, n) => {
            if (typeof n > "u") {
                this.map.delete(e);
                return
            }
            if (!this.map.has(e)) return;
            const r = this.get(e);
            if (!this.exists(e, n)) return;
            const i = r.filter(s => s !== n);
            if (!i.length) {
                this.map.delete(e);
                return
            }
            this.map.set(e, i)
        }, this.clear = () => {
            this.map.clear()
        }
    }
    get topics() {
        return Array.from(this.map.keys())
    }
}
var X9e = Object.defineProperty,
    e7e = Object.defineProperties,
    t7e = Object.getOwnPropertyDescriptors,
    TV = Object.getOwnPropertySymbols,
    n7e = Object.prototype.hasOwnProperty,
    r7e = Object.prototype.propertyIsEnumerable,
    IV = (t, e, n) => e in t ? X9e(t, e, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: n
    }) : t[e] = n,
    F5 = (t, e) => {
        for (var n in e || (e = {})) n7e.call(e, n) && IV(t, n, e[n]);
        if (TV)
            for (var n of TV(e)) r7e.call(e, n) && IV(t, n, e[n]);
        return t
    },
    aO = (t, e) => e7e(t, t7e(e));
class i7e extends XCe {
    constructor(e, n) {
        super(e, n), this.relayer = e, this.logger = n, this.subscriptions = new Map, this.topicMap = new J9e, this.events = new uo.EventEmitter, this.name = $9e, this.version = L9e, this.pending = new Map, this.cached = [], this.initialized = !1, this.pendingSubscriptionWatchLabel = "pending_sub_watch_label", this.pollingInterval = 20, this.storagePrefix = jp, this.subscribeTimeout = 1e4, this.restartInProgress = !1, this.batchSubscribeTopicsLimit = 500, this.init = async () => {
            this.initialized || (this.logger.trace("Initialized"), this.registerEventListeners(), this.clientId = await this.relayer.core.crypto.getClientId())
        }, this.subscribe = async (r, i) => {
            await this.restartToComplete(), this.isInitialized(), this.logger.debug("Subscribing Topic"), this.logger.trace({
                type: "method",
                method: "subscribe",
                params: {
                    topic: r,
                    opts: i
                }
            });
            try {
                const s = uk(i),
                    o = {
                        topic: r,
                        relay: s
                    };
                this.pending.set(r, o);
                const a = await this.rpcSubscribe(r, s);
                return this.onSubscribe(a, o), this.logger.debug("Successfully Subscribed Topic"), this.logger.trace({
                    type: "method",
                    method: "subscribe",
                    params: {
                        topic: r,
                        opts: i
                    }
                }), a
            } catch (s) {
                throw this.logger.debug("Failed to Subscribe Topic"), this.logger.error(s), s
            }
        }, this.unsubscribe = async (r, i) => {
            await this.restartToComplete(), this.isInitialized(), typeof(i == null ? void 0 : i.id) < "u" ? await this.unsubscribeById(r, i.id, i) : await this.unsubscribeByTopic(r, i)
        }, this.isSubscribed = async r => this.topics.includes(r) ? !0 : await new Promise((i, s) => {
            const o = new Bt.Watch;
            o.start(this.pendingSubscriptionWatchLabel);
            const a = setInterval(() => {
                !this.pending.has(r) && this.topics.includes(r) && (clearInterval(a), o.stop(this.pendingSubscriptionWatchLabel), i(!0)), o.elapsed(this.pendingSubscriptionWatchLabel) >= B9e && (clearInterval(a), o.stop(this.pendingSubscriptionWatchLabel), s(new Error("Subscription resolution timeout")))
            }, this.pollingInterval)
        }).catch(() => !1), this.on = (r, i) => {
            this.events.on(r, i)
        }, this.once = (r, i) => {
            this.events.once(r, i)
        }, this.off = (r, i) => {
            this.events.off(r, i)
        }, this.removeListener = (r, i) => {
            this.events.removeListener(r, i)
        }, this.restart = async () => {
            this.restartInProgress = !0, await this.restore(), await this.reset(), this.restartInProgress = !1
        }, this.relayer = e, this.logger = Ja(n, this.name), this.clientId = ""
    }
    get context() {
        return Qa(this.logger)
    }
    get storageKey() {
        return this.storagePrefix + this.version + this.relayer.core.customStoragePrefix + "//" + this.name
    }
    get length() {
        return this.subscriptions.size
    }
    get ids() {
        return Array.from(this.subscriptions.keys())
    }
    get values() {
        return Array.from(this.subscriptions.values())
    }
    get topics() {
        return this.topicMap.topics
    }
    hasSubscription(e, n) {
        let r = !1;
        try {
            r = this.getSubscription(e).topic === n
        } catch {}
        return r
    }
    onEnable() {
        this.cached = [], this.initialized = !0
    }
    onDisable() {
        this.cached = this.values, this.subscriptions.clear(), this.topicMap.clear()
    }
    async unsubscribeByTopic(e, n) {
        const r = this.topicMap.get(e);
        await Promise.all(r.map(async i => await this.unsubscribeById(e, i, n)))
    }
    async unsubscribeById(e, n, r) {
        this.logger.debug("Unsubscribing Topic"), this.logger.trace({
            type: "method",
            method: "unsubscribe",
            params: {
                topic: e,
                id: n,
                opts: r
            }
        });
        try {
            const i = uk(r);
            await this.rpcUnsubscribe(e, n, i);
            const s = Vi("USER_DISCONNECTED", `${this.name}, ${e}`);
            await this.onUnsubscribe(e, n, s), this.logger.debug("Successfully Unsubscribed Topic"), this.logger.trace({
                type: "method",
                method: "unsubscribe",
                params: {
                    topic: e,
                    id: n,
                    opts: r
                }
            })
        } catch (i) {
            throw this.logger.debug("Failed to Unsubscribe Topic"), this.logger.error(i), i
        }
    }
    async rpcSubscribe(e, n) {
        const r = {
            method: QS(n.protocol).subscribe,
            params: {
                topic: e
            }
        };
        this.logger.debug("Outgoing Relay Payload"), this.logger.trace({
            type: "payload",
            direction: "outgoing",
            request: r
        });
        try {
            await await G_(this.relayer.request(r), this.subscribeTimeout)
        } catch {
            this.logger.debug("Outgoing Relay Subscribe Payload stalled"), this.relayer.events.emit(Ro.connection_stalled)
        }
        return nv(e + this.clientId)
    }
    async rpcBatchSubscribe(e) {
        if (!e.length) return;
        const n = e[0].relay,
            r = {
                method: QS(n.protocol).batchSubscribe,
                params: {
                    topics: e.map(i => i.topic)
                }
            };
        this.logger.debug("Outgoing Relay Payload"), this.logger.trace({
            type: "payload",
            direction: "outgoing",
            request: r
        });
        try {
            return await await G_(this.relayer.request(r), this.subscribeTimeout)
        } catch {
            this.logger.debug("Outgoing Relay Payload stalled"), this.relayer.events.emit(Ro.connection_stalled)
        }
    }
    rpcUnsubscribe(e, n, r) {
        const i = {
            method: QS(r.protocol).unsubscribe,
            params: {
                topic: e,
                id: n
            }
        };
        return this.logger.debug("Outgoing Relay Payload"), this.logger.trace({
            type: "payload",
            direction: "outgoing",
            request: i
        }), this.relayer.request(i)
    }
    onSubscribe(e, n) {
        this.setSubscription(e, aO(F5({}, n), {
            id: e
        })), this.pending.delete(n.topic)
    }
    onBatchSubscribe(e) {
        e.length && e.forEach(n => {
            this.setSubscription(n.id, F5({}, n)), this.pending.delete(n.topic)
        })
    }
    async onUnsubscribe(e, n, r) {
        this.events.removeAllListeners(n), this.hasSubscription(n, e) && this.deleteSubscription(n, r), await this.relayer.messages.del(e)
    }
    async setRelayerSubscriptions(e) {
        await this.relayer.core.storage.setItem(this.storageKey, e)
    }
    async getRelayerSubscriptions() {
        return await this.relayer.core.storage.getItem(this.storageKey)
    }
    setSubscription(e, n) {
        this.subscriptions.has(e) || (this.logger.debug("Setting subscription"), this.logger.trace({
            type: "method",
            method: "setSubscription",
            id: e,
            subscription: n
        }), this.addSubscription(e, n))
    }
    addSubscription(e, n) {
        this.subscriptions.set(e, F5({}, n)), this.topicMap.set(n.topic, e), this.events.emit(nu.created, n)
    }
    getSubscription(e) {
        this.logger.debug("Getting subscription"), this.logger.trace({
            type: "method",
            method: "getSubscription",
            id: e
        });
        const n = this.subscriptions.get(e);
        if (!n) {
            const {
                message: r
            } = ut("NO_MATCHING_KEY", `${this.name}: ${e}`);
            throw new Error(r)
        }
        return n
    }
    deleteSubscription(e, n) {
        this.logger.debug("Deleting subscription"), this.logger.trace({
            type: "method",
            method: "deleteSubscription",
            id: e,
            reason: n
        });
        const r = this.getSubscription(e);
        this.subscriptions.delete(e), this.topicMap.delete(r.topic, e), this.events.emit(nu.deleted, aO(F5({}, r), {
            reason: n
        }))
    }
    async persist() {
        await this.setRelayerSubscriptions(this.values), this.events.emit(nu.sync)
    }
    async reset() {
        if (this.cached.length) {
            const e = Math.ceil(this.cached.length / this.batchSubscribeTopicsLimit);
            for (let n = 0; n < e; n++) {
                const r = this.cached.splice(0, this.batchSubscribeTopicsLimit);
                await this.batchSubscribe(r)
            }
        }
        this.events.emit(nu.resubscribed)
    }
    async restore() {
        try {
            const e = await this.getRelayerSubscriptions();
            if (typeof e > "u" || !e.length) return;
            if (this.subscriptions.size) {
                const {
                    message: n
                } = ut("RESTORE_WILL_OVERRIDE", this.name);
                throw this.logger.error(n), this.logger.error(`${this.name}: ${JSON.stringify(this.values)}`), new Error(n)
            }
            this.cached = e, this.logger.debug(`Successfully Restored subscriptions for ${this.name}`), this.logger.trace({
                type: "method",
                method: "restore",
                subscriptions: this.values
            })
        } catch (e) {
            this.logger.debug(`Failed to Restore subscriptions for ${this.name}`), this.logger.error(e)
        }
    }
    async batchSubscribe(e) {
        if (!e.length) return;
        const n = await this.rpcBatchSubscribe(e);
        sd(n) && this.onBatchSubscribe(n.map((r, i) => aO(F5({}, e[i]), {
            id: r
        })))
    }
    async onConnect() {
        this.restartInProgress || (await this.restart(), this.onEnable())
    }
    onDisconnect() {
        this.onDisable()
    }
    async checkPending() {
        if (!this.initialized || this.relayer.transportExplicitlyClosed) return;
        const e = [];
        this.pending.forEach(n => {
            e.push(n)
        }), await this.batchSubscribe(e)
    }
    registerEventListeners() {
        this.relayer.core.heartbeat.on(P2.HEARTBEAT_EVENTS.pulse, async () => {
            await this.checkPending()
        }), this.relayer.on(Ro.connect, async () => {
            await this.onConnect()
        }), this.relayer.on(Ro.disconnect, () => {
            this.onDisconnect()
        }), this.events.on(nu.created, async e => {
            const n = nu.created;
            this.logger.info(`Emitting ${n}`), this.logger.debug({
                type: "event",
                event: n,
                data: e
            }), await this.persist()
        }), this.events.on(nu.deleted, async e => {
            const n = nu.deleted;
            this.logger.info(`Emitting ${n}`), this.logger.debug({
                type: "event",
                event: n,
                data: e
            }), await this.persist()
        })
    }
    isInitialized() {
        if (!this.initialized) {
            const {
                message: e
            } = ut("NOT_INITIALIZED", this.name);
            throw new Error(e)
        }
    }
    async restartToComplete() {
        this.restartInProgress && await new Promise(e => {
            const n = setInterval(() => {
                this.restartInProgress || (clearInterval(n), e())
            }, this.pollingInterval)
        })
    }
}
var s7e = Object.defineProperty,
    RV = Object.getOwnPropertySymbols,
    o7e = Object.prototype.hasOwnProperty,
    a7e = Object.prototype.propertyIsEnumerable,
    OV = (t, e, n) => e in t ? s7e(t, e, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: n
    }) : t[e] = n,
    l7e = (t, e) => {
        for (var n in e || (e = {})) o7e.call(e, n) && OV(t, n, e[n]);
        if (RV)
            for (var n of RV(e)) a7e.call(e, n) && OV(t, n, e[n]);
        return t
    };
class c7e extends QCe {
    constructor(e) {
        super(e), this.protocol = "wc", this.version = 2, this.events = new uo.EventEmitter, this.name = R9e, this.transportExplicitlyClosed = !1, this.initialized = !1, this.connectionAttemptInProgress = !1, this.connectionStatusPollingInterval = 20, this.staleConnectionErrors = ["socket hang up", "socket stalled"], this.hasExperiencedNetworkDisruption = !1, this.request = async n => {
            this.logger.debug("Publishing Request Payload");
            try {
                return await this.toEstablishConnection(), await this.provider.request(n)
            } catch (r) {
                throw this.logger.debug("Failed to Publish Request"), this.logger.error(r), r
            }
        }, this.onPayloadHandler = n => {
            this.onProviderPayload(n)
        }, this.onConnectHandler = () => {
            this.events.emit(Ro.connect)
        }, this.onDisconnectHandler = () => {
            this.onProviderDisconnect()
        }, this.onProviderErrorHandler = n => {
            this.logger.error(n), this.events.emit(Ro.error, n), this.logger.info("Fatal socket error received, closing transport"), this.transportClose()
        }, this.registerProviderListeners = () => {
            this.provider.on(Od.payload, this.onPayloadHandler), this.provider.on(Od.connect, this.onConnectHandler), this.provider.on(Od.disconnect, this.onDisconnectHandler), this.provider.on(Od.error, this.onProviderErrorHandler)
        }, this.core = e.core, this.logger = typeof e.logger < "u" && typeof e.logger != "string" ? Ja(e.logger, this.name) : jT(HT({
            level: e.logger || I9e
        })), this.messages = new Z9e(this.logger, e.core), this.subscriber = new i7e(this, this.logger), this.publisher = new Q9e(this, this.logger), this.relayUrl = (e == null ? void 0 : e.relayUrl) || Bne, this.projectId = e.projectId, this.bundleId = BSe(), this.provider = {}
    }
    async init() {
        this.logger.trace("Initialized"), this.registerEventListeners(), await this.createProvider(), await Promise.all([this.messages.init(), this.subscriber.init()]);
        try {
            await this.transportOpen()
        } catch {
            this.logger.warn(`Connection via ${this.relayUrl} failed, attempting to connect via failover domain ${AV}...`), await this.restartTransport(AV)
        }
        this.initialized = !0, setTimeout(async () => {
            this.subscriber.topics.length === 0 && (this.logger.info("No topics subscribed to after init, closing transport"), await this.transportClose(), this.transportExplicitlyClosed = !1)
        }, k9e)
    }
    get context() {
        return Qa(this.logger)
    }
    get connected() {
        return this.provider.connection.connected
    }
    get connecting() {
        return this.provider.connection.connecting
    }
    async publish(e, n, r) {
        this.isInitialized(), await this.publisher.publish(e, n, r), await this.recordMessageEvent({
            topic: e,
            message: n,
            publishedAt: Date.now()
        })
    }
    async subscribe(e, n) {
        var r;
        this.isInitialized();
        let i = ((r = this.subscriber.topicMap.get(e)) == null ? void 0 : r[0]) || "";
        if (i) return i;
        let s;
        const o = a => {
            a.topic === e && (this.subscriber.off(nu.created, o), s())
        };
        return await Promise.all([new Promise(a => {
            s = a, this.subscriber.on(nu.created, o)
        }), new Promise(async a => {
            i = await this.subscriber.subscribe(e, n), a()
        })]), i
    }
    async unsubscribe(e, n) {
        this.isInitialized(), await this.subscriber.unsubscribe(e, n)
    }
    on(e, n) {
        this.events.on(e, n)
    }
    once(e, n) {
        this.events.once(e, n)
    }
    off(e, n) {
        this.events.off(e, n)
    }
    removeListener(e, n) {
        this.events.removeListener(e, n)
    }
    async transportClose() {
        this.transportExplicitlyClosed = !0, this.hasExperiencedNetworkDisruption && this.connected ? await G_(this.provider.disconnect(), 1e3, "provider.disconnect()").catch(() => this.onProviderDisconnect()) : this.connected && await this.provider.disconnect()
    }
    async transportOpen(e) {
        if (this.transportExplicitlyClosed = !1, await this.confirmOnlineStateOrThrow(), !this.connectionAttemptInProgress) {
            e && e !== this.relayUrl && (this.relayUrl = e, await this.transportClose(), await this.createProvider()), this.connectionAttemptInProgress = !0;
            try {
                await Promise.all([new Promise(n => {
                    if (!this.initialized) return n();
                    this.subscriber.once(nu.resubscribed, () => {
                        n()
                    })
                }), new Promise(async (n, r) => {
                    try {
                        await G_(this.provider.connect(), 1e4, `Socket stalled when trying to connect to ${this.relayUrl}`)
                    } catch (i) {
                        r(i);
                        return
                    }
                    n()
                })])
            } catch (n) {
                this.logger.error(n);
                const r = n;
                if (!this.isConnectionStalled(r.message)) throw n;
                this.provider.events.emit(Od.disconnect)
            } finally {
                this.connectionAttemptInProgress = !1, this.hasExperiencedNetworkDisruption = !1
            }
        }
    }
    async restartTransport(e) {
        await this.confirmOnlineStateOrThrow(), !this.connectionAttemptInProgress && (this.relayUrl = e || this.relayUrl, await this.transportClose(), await this.createProvider(), await this.transportOpen())
    }
    async confirmOnlineStateOrThrow() {
        if (!await ZW()) throw new Error("No internet connection detected. Please restart your network and try again.")
    }
    isConnectionStalled(e) {
        return this.staleConnectionErrors.some(n => e.includes(n))
    }
    async createProvider() {
        this.provider.connection && this.unregisterProviderListeners();
        const e = await this.core.crypto.signJWT(this.relayUrl);
        this.provider = new DAe(new FAe(WSe({
            sdkVersion: P9e,
            protocol: this.protocol,
            version: this.version,
            relayUrl: this.relayUrl,
            projectId: this.projectId,
            auth: e,
            useOnCloseEvent: !0,
            bundleId: this.bundleId
        }))), this.registerProviderListeners()
    }
    async recordMessageEvent(e) {
        const {
            topic: n,
            message: r
        } = e;
        await this.messages.set(n, r)
    }
    async shouldIgnoreMessageEvent(e) {
        const {
            topic: n,
            message: r
        } = e;
        if (!r || r.length === 0) return this.logger.debug(`Ignoring invalid/empty message: ${r}`), !0;
        if (!await this.subscriber.isSubscribed(n)) return this.logger.debug(`Ignoring message for non-subscribed topic ${n}`), !0;
        const i = this.messages.has(n, r);
        return i && this.logger.debug(`Ignoring duplicate message: ${r}`), i
    }
    async onProviderPayload(e) {
        if (this.logger.debug("Incoming Relay Payload"), this.logger.trace({
                type: "payload",
                direction: "incoming",
                payload: e
            }), yL(e)) {
            if (!e.method.endsWith(O9e)) return;
            const n = e.params,
                {
                    topic: r,
                    message: i,
                    publishedAt: s
                } = n.data,
                o = {
                    topic: r,
                    message: i,
                    publishedAt: s
                };
            this.logger.debug("Emitting Relayer Payload"), this.logger.trace(l7e({
                type: "event",
                event: n.id
            }, o)), this.events.emit(n.id, o), await this.acknowledgePayload(e), await this.onMessageEvent(o)
        } else AE(e) && this.events.emit(Ro.message_ack, e)
    }
    async onMessageEvent(e) {
        await this.shouldIgnoreMessageEvent(e) || (this.events.emit(Ro.message, e), await this.recordMessageEvent(e))
    }
    async acknowledgePayload(e) {
        const n = zT(e.id, !0);
        await this.provider.connection.send(n)
    }
    unregisterProviderListeners() {
        this.provider.off(Od.payload, this.onPayloadHandler), this.provider.off(Od.connect, this.onConnectHandler), this.provider.off(Od.disconnect, this.onDisconnectHandler), this.provider.off(Od.error, this.onProviderErrorHandler)
    }
    async registerEventListeners() {
        this.events.on(Ro.connection_stalled, () => {
            this.restartTransport().catch(n => this.logger.error(n))
        });
        let e = await ZW();
        $8e(async n => {
            this.initialized && e !== n && (e = n, n ? await this.restartTransport().catch(r => this.logger.error(r)) : (this.hasExperiencedNetworkDisruption = !0, await this.transportClose().catch(r => this.logger.error(r))))
        })
    }
    onProviderDisconnect() {
        this.events.emit(Ro.disconnect), this.attemptToReconnect()
    }
    attemptToReconnect() {
        this.transportExplicitlyClosed || (this.logger.info("attemptToReconnect called. Connecting..."), setTimeout(async () => {
            await this.restartTransport().catch(e => this.logger.error(e))
        }, Bt.toMiliseconds(N9e)))
    }
    isInitialized() {
        if (!this.initialized) {
            const {
                message: e
            } = ut("NOT_INITIALIZED", this.name);
            throw new Error(e)
        }
    }
    async toEstablishConnection() {
        if (await this.confirmOnlineStateOrThrow(), !this.connected) {
            if (this.connectionAttemptInProgress) return await new Promise(e => {
                const n = setInterval(() => {
                    this.connected && (clearInterval(n), e())
                }, this.connectionStatusPollingInterval)
            });
            await this.restartTransport()
        }
    }
}
var u7e = Object.defineProperty,
    NV = Object.getOwnPropertySymbols,
    f7e = Object.prototype.hasOwnProperty,
    d7e = Object.prototype.propertyIsEnumerable,
    PV = (t, e, n) => e in t ? u7e(t, e, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: n
    }) : t[e] = n,
    kV = (t, e) => {
        for (var n in e || (e = {})) f7e.call(e, n) && PV(t, n, e[n]);
        if (NV)
            for (var n of NV(e)) d7e.call(e, n) && PV(t, n, e[n]);
        return t
    };
class GT extends JCe {
    constructor(e, n, r, i = jp, s = void 0) {
        super(e, n, r, i), this.core = e, this.logger = n, this.name = r, this.map = new Map, this.version = M9e, this.cached = [], this.initialized = !1, this.storagePrefix = jp, this.init = async () => {
            this.initialized || (this.logger.trace("Initialized"), await this.restore(), this.cached.forEach(o => {
                this.getKey && o !== null && !Fa(o) ? this.map.set(this.getKey(o), o) : h8e(o) ? this.map.set(o.id, o) : p8e(o) && this.map.set(o.topic, o)
            }), this.cached = [], this.initialized = !0)
        }, this.set = async (o, a) => {
            this.isInitialized(), this.map.has(o) ? await this.update(o, a) : (this.logger.debug("Setting value"), this.logger.trace({
                type: "method",
                method: "set",
                key: o,
                value: a
            }), this.map.set(o, a), await this.persist())
        }, this.get = o => (this.isInitialized(), this.logger.debug("Getting value"), this.logger.trace({
            type: "method",
            method: "get",
            key: o
        }), this.getData(o)), this.getAll = o => (this.isInitialized(), o ? this.values.filter(a => Object.keys(o).every(l => jAe(a[l], o[l]))) : this.values), this.update = async (o, a) => {
            this.isInitialized(), this.logger.debug("Updating value"), this.logger.trace({
                type: "method",
                method: "update",
                key: o,
                update: a
            });
            const l = kV(kV({}, this.getData(o)), a);
            this.map.set(o, l), await this.persist()
        }, this.delete = async (o, a) => {
            this.isInitialized(), this.map.has(o) && (this.logger.debug("Deleting value"), this.logger.trace({
                type: "method",
                method: "delete",
                key: o,
                reason: a
            }), this.map.delete(o), await this.persist())
        }, this.logger = Ja(n, this.name), this.storagePrefix = i, this.getKey = s
    }
    get context() {
        return Qa(this.logger)
    }
    get storageKey() {
        return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name
    }
    get length() {
        return this.map.size
    }
    get keys() {
        return Array.from(this.map.keys())
    }
    get values() {
        return Array.from(this.map.values())
    }
    async setDataStore(e) {
        await this.core.storage.setItem(this.storageKey, e)
    }
    async getDataStore() {
        return await this.core.storage.getItem(this.storageKey)
    }
    getData(e) {
        const n = this.map.get(e);
        if (!n) {
            const {
                message: r
            } = ut("NO_MATCHING_KEY", `${this.name}: ${e}`);
            throw this.logger.error(r), new Error(r)
        }
        return n
    }
    async persist() {
        await this.setDataStore(this.values)
    }
    async restore() {
        try {
            const e = await this.getDataStore();
            if (typeof e > "u" || !e.length) return;
            if (this.map.size) {
                const {
                    message: n
                } = ut("RESTORE_WILL_OVERRIDE", this.name);
                throw this.logger.error(n), new Error(n)
            }
            this.cached = e, this.logger.debug(`Successfully Restored value for ${this.name}`), this.logger.trace({
                type: "method",
                method: "restore",
                value: this.values
            })
        } catch (e) {
            this.logger.debug(`Failed to Restore value for ${this.name}`), this.logger.error(e)
        }
    }
    isInitialized() {
        if (!this.initialized) {
            const {
                message: e
            } = ut("NOT_INITIALIZED", this.name);
            throw new Error(e)
        }
    }
}
class h7e {
    constructor(e, n) {
        this.core = e, this.logger = n, this.name = F9e, this.version = U9e, this.events = new eL, this.initialized = !1, this.storagePrefix = jp, this.ignoredPayloadTypes = [py], this.registeredMethods = [], this.init = async () => {
            this.initialized || (await this.pairings.init(), await this.cleanup(), this.registerRelayerEvents(), this.registerExpirerEvents(), this.initialized = !0, this.logger.trace("Initialized"))
        }, this.register = ({
            methods: r
        }) => {
            this.isInitialized(), this.registeredMethods = [...new Set([...this.registeredMethods, ...r])]
        }, this.create = async () => {
            this.isInitialized();
            const r = ck(),
                i = await this.core.crypto.setSymKey(r),
                s = hu(Bt.FIVE_MINUTES),
                o = {
                    protocol: Lne
                },
                a = {
                    topic: i,
                    expiry: s,
                    relay: o,
                    active: !1
                },
                l = r8e({
                    protocol: this.core.protocol,
                    version: this.core.version,
                    topic: i,
                    symKey: r,
                    relay: o
                });
            return await this.pairings.set(i, a), await this.core.relayer.subscribe(i), this.core.expirer.set(i, s), {
                topic: i,
                uri: l
            }
        }, this.pair = async r => {
            this.isInitialized(), this.isValidPair(r);
            const {
                topic: i,
                symKey: s,
                relay: o
            } = VW(r.uri);
            let a;
            if (this.pairings.keys.includes(i) && (a = this.pairings.get(i), a.active)) throw new Error(`Pairing already exists: ${i}. Please try again with a new connection URI.`);
            const l = hu(Bt.FIVE_MINUTES),
                c = {
                    topic: i,
                    relay: o,
                    expiry: l,
                    active: !1
                };
            return await this.pairings.set(i, c), this.core.expirer.set(i, l), r.activatePairing && await this.activate({
                topic: i
            }), this.events.emit(_3.create, c), this.core.crypto.keychain.has(i) || (await this.core.crypto.setSymKey(s, i), await this.core.relayer.subscribe(i, {
                relay: o
            })), c
        }, this.activate = async ({
            topic: r
        }) => {
            this.isInitialized();
            const i = hu(Bt.THIRTY_DAYS);
            await this.pairings.update(r, {
                active: !0,
                expiry: i
            }), this.core.expirer.set(r, i)
        }, this.ping = async r => {
            this.isInitialized(), await this.isValidPing(r);
            const {
                topic: i
            } = r;
            if (this.pairings.keys.includes(i)) {
                const s = await this.sendRequest(i, "wc_pairingPing", {}),
                    {
                        done: o,
                        resolve: a,
                        reject: l
                    } = bw();
                this.events.once(ws("pairing_ping", s), ({
                    error: c
                }) => {
                    c ? l(c) : a()
                }), await o()
            }
        }, this.updateExpiry = async ({
            topic: r,
            expiry: i
        }) => {
            this.isInitialized(), await this.pairings.update(r, {
                expiry: i
            })
        }, this.updateMetadata = async ({
            topic: r,
            metadata: i
        }) => {
            this.isInitialized(), await this.pairings.update(r, {
                peerMetadata: i
            })
        }, this.getPairings = () => (this.isInitialized(), this.pairings.values), this.disconnect = async r => {
            this.isInitialized(), await this.isValidDisconnect(r);
            const {
                topic: i
            } = r;
            this.pairings.keys.includes(i) && (await this.sendRequest(i, "wc_pairingDelete", Vi("USER_DISCONNECTED")), await this.deletePairing(i))
        }, this.sendRequest = async (r, i, s) => {
            const o = em(i, s),
                a = await this.core.crypto.encode(r, o),
                l = B5[i].req;
            return this.core.history.set(r, o), this.core.relayer.publish(r, a, l), o.id
        }, this.sendResult = async (r, i, s) => {
            const o = zT(r, s),
                a = await this.core.crypto.encode(i, o),
                l = await this.core.history.get(i, r),
                c = B5[l.request.method].res;
            await this.core.relayer.publish(i, a, c), await this.core.history.resolve(o)
        }, this.sendError = async (r, i, s) => {
            const o = WT(r, s),
                a = await this.core.crypto.encode(i, o),
                l = await this.core.history.get(i, r),
                c = B5[l.request.method] ? B5[l.request.method].res : B5.unregistered_method.res;
            await this.core.relayer.publish(i, a, c), await this.core.history.resolve(o)
        }, this.deletePairing = async (r, i) => {
            await this.core.relayer.unsubscribe(r), await Promise.all([this.pairings.delete(r, Vi("USER_DISCONNECTED")), this.core.crypto.deleteSymKey(r), i ? Promise.resolve() : this.core.expirer.del(r)])
        }, this.cleanup = async () => {
            const r = this.pairings.getAll().filter(i => S0(i.expiry));
            await Promise.all(r.map(i => this.deletePairing(i.topic)))
        }, this.onRelayEventRequest = r => {
            const {
                topic: i,
                payload: s
            } = r;
            switch (s.method) {
                case "wc_pairingPing":
                    return this.onPairingPingRequest(i, s);
                case "wc_pairingDelete":
                    return this.onPairingDeleteRequest(i, s);
                default:
                    return this.onUnknownRpcMethodRequest(i, s)
            }
        }, this.onRelayEventResponse = async r => {
            const {
                topic: i,
                payload: s
            } = r, o = (await this.core.history.get(i, s.id)).request.method;
            switch (o) {
                case "wc_pairingPing":
                    return this.onPairingPingResponse(i, s);
                default:
                    return this.onUnknownRpcMethodResponse(o)
            }
        }, this.onPairingPingRequest = async (r, i) => {
            const {
                id: s
            } = i;
            try {
                this.isValidPing({
                    topic: r
                }), await this.sendResult(s, r, !0), this.events.emit(_3.ping, {
                    id: s,
                    topic: r
                })
            } catch (o) {
                await this.sendError(s, r, o), this.logger.error(o)
            }
        }, this.onPairingPingResponse = (r, i) => {
            const {
                id: s
            } = i;
            setTimeout(() => {
                Bd(i) ? this.events.emit(ws("pairing_ping", s), {}) : pc(i) && this.events.emit(ws("pairing_ping", s), {
                    error: i.error
                })
            }, 500)
        }, this.onPairingDeleteRequest = async (r, i) => {
            const {
                id: s
            } = i;
            try {
                this.isValidDisconnect({
                    topic: r
                }), await this.deletePairing(r), this.events.emit(_3.delete, {
                    id: s,
                    topic: r
                })
            } catch (o) {
                await this.sendError(s, r, o), this.logger.error(o)
            }
        }, this.onUnknownRpcMethodRequest = async (r, i) => {
            const {
                id: s,
                method: o
            } = i;
            try {
                if (this.registeredMethods.includes(o)) return;
                const a = Vi("WC_METHOD_UNSUPPORTED", o);
                await this.sendError(s, r, a), this.logger.error(a)
            } catch (a) {
                await this.sendError(s, r, a), this.logger.error(a)
            }
        }, this.onUnknownRpcMethodResponse = r => {
            this.registeredMethods.includes(r) || this.logger.error(Vi("WC_METHOD_UNSUPPORTED", r))
        }, this.isValidPair = r => {
            var i;
            if (!Pa(r)) {
                const {
                    message: o
                } = ut("MISSING_OR_INVALID", `pair() params: ${r}`);
                throw new Error(o)
            }
            if (!d8e(r.uri)) {
                const {
                    message: o
                } = ut("MISSING_OR_INVALID", `pair() uri: ${r.uri}`);
                throw new Error(o)
            }
            const s = VW(r.uri);
            if (!((i = s == null ? void 0 : s.relay) != null && i.protocol)) {
                const {
                    message: o
                } = ut("MISSING_OR_INVALID", "pair() uri#relay-protocol");
                throw new Error(o)
            }
            if (!(s != null && s.symKey)) {
                const {
                    message: o
                } = ut("MISSING_OR_INVALID", "pair() uri#symKey");
                throw new Error(o)
            }
        }, this.isValidPing = async r => {
            if (!Pa(r)) {
                const {
                    message: s
                } = ut("MISSING_OR_INVALID", `ping() params: ${r}`);
                throw new Error(s)
            }
            const {
                topic: i
            } = r;
            await this.isValidPairingTopic(i)
        }, this.isValidDisconnect = async r => {
            if (!Pa(r)) {
                const {
                    message: s
                } = ut("MISSING_OR_INVALID", `disconnect() params: ${r}`);
                throw new Error(s)
            }
            const {
                topic: i
            } = r;
            await this.isValidPairingTopic(i)
        }, this.isValidPairingTopic = async r => {
            if (!Ks(r, !1)) {
                const {
                    message: i
                } = ut("MISSING_OR_INVALID", `pairing topic should be a string: ${r}`);
                throw new Error(i)
            }
            if (!this.pairings.keys.includes(r)) {
                const {
                    message: i
                } = ut("NO_MATCHING_KEY", `pairing topic doesn't exist: ${r}`);
                throw new Error(i)
            }
            if (S0(this.pairings.get(r).expiry)) {
                await this.deletePairing(r);
                const {
                    message: i
                } = ut("EXPIRED", `pairing topic: ${r}`);
                throw new Error(i)
            }
        }, this.core = e, this.logger = Ja(n, this.name), this.pairings = new GT(this.core, this.logger, this.name, this.storagePrefix)
    }
    get context() {
        return Qa(this.logger)
    }
    isInitialized() {
        if (!this.initialized) {
            const {
                message: e
            } = ut("NOT_INITIALIZED", this.name);
            throw new Error(e)
        }
    }
    registerRelayerEvents() {
        this.core.relayer.on(Ro.message, async e => {
            const {
                topic: n,
                message: r
            } = e;
            if (!this.pairings.keys.includes(n) || this.ignoredPayloadTypes.includes(this.core.crypto.getPayloadType(r))) return;
            const i = await this.core.crypto.decode(n, r);
            try {
                yL(i) ? (this.core.history.set(n, i), this.onRelayEventRequest({
                    topic: n,
                    payload: i
                })) : AE(i) && (await this.core.history.resolve(i), await this.onRelayEventResponse({
                    topic: n,
                    payload: i
                }), this.core.history.delete(n, i.id))
            } catch (s) {
                this.logger.error(s)
            }
        })
    }
    registerExpirerEvents() {
        this.core.expirer.on(ic.expired, async e => {
            const {
                topic: n
            } = sne(e.target);
            n && this.pairings.keys.includes(n) && (await this.deletePairing(n, !0), this.events.emit(_3.expire, {
                topic: n
            }))
        })
    }
}
class p7e extends KCe {
    constructor(e, n) {
        super(e, n), this.core = e, this.logger = n, this.records = new Map, this.events = new uo.EventEmitter, this.name = j9e, this.version = H9e, this.cached = [], this.initialized = !1, this.storagePrefix = jp, this.init = async () => {
            this.initialized || (this.logger.trace("Initialized"), await this.restore(), this.cached.forEach(r => this.records.set(r.id, r)), this.cached = [], this.registerEventListeners(), this.initialized = !0)
        }, this.set = (r, i, s) => {
            if (this.isInitialized(), this.logger.debug("Setting JSON-RPC request history record"), this.logger.trace({
                    type: "method",
                    method: "set",
                    topic: r,
                    request: i,
                    chainId: s
                }), this.records.has(i.id)) return;
            const o = {
                id: i.id,
                topic: r,
                request: {
                    method: i.method,
                    params: i.params || null
                },
                chainId: s,
                expiry: hu(Bt.THIRTY_DAYS)
            };
            this.records.set(o.id, o), this.events.emit(rf.created, o)
        }, this.resolve = async r => {
            if (this.isInitialized(), this.logger.debug("Updating JSON-RPC response history record"), this.logger.trace({
                    type: "method",
                    method: "update",
                    response: r
                }), !this.records.has(r.id)) return;
            const i = await this.getRecord(r.id);
            typeof i.response > "u" && (i.response = pc(r) ? {
                error: r.error
            } : {
                result: r.result
            }, this.records.set(i.id, i), this.events.emit(rf.updated, i))
        }, this.get = async (r, i) => (this.isInitialized(), this.logger.debug("Getting record"), this.logger.trace({
            type: "method",
            method: "get",
            topic: r,
            id: i
        }), await this.getRecord(i)), this.delete = (r, i) => {
            this.isInitialized(), this.logger.debug("Deleting record"), this.logger.trace({
                type: "method",
                method: "delete",
                id: i
            }), this.values.forEach(s => {
                if (s.topic === r) {
                    if (typeof i < "u" && s.id !== i) return;
                    this.records.delete(s.id), this.events.emit(rf.deleted, s)
                }
            })
        }, this.exists = async (r, i) => (this.isInitialized(), this.records.has(i) ? (await this.getRecord(i)).topic === r : !1), this.on = (r, i) => {
            this.events.on(r, i)
        }, this.once = (r, i) => {
            this.events.once(r, i)
        }, this.off = (r, i) => {
            this.events.off(r, i)
        }, this.removeListener = (r, i) => {
            this.events.removeListener(r, i)
        }, this.logger = Ja(n, this.name)
    }
    get context() {
        return Qa(this.logger)
    }
    get storageKey() {
        return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name
    }
    get size() {
        return this.records.size
    }
    get keys() {
        return Array.from(this.records.keys())
    }
    get values() {
        return Array.from(this.records.values())
    }
    get pending() {
        const e = [];
        return this.values.forEach(n => {
            if (typeof n.response < "u") return;
            const r = {
                topic: n.topic,
                request: em(n.request.method, n.request.params, n.id),
                chainId: n.chainId
            };
            return e.push(r)
        }), e
    }
    async setJsonRpcRecords(e) {
        await this.core.storage.setItem(this.storageKey, e)
    }
    async getJsonRpcRecords() {
        return await this.core.storage.getItem(this.storageKey)
    }
    getRecord(e) {
        this.isInitialized();
        const n = this.records.get(e);
        if (!n) {
            const {
                message: r
            } = ut("NO_MATCHING_KEY", `${this.name}: ${e}`);
            throw new Error(r)
        }
        return n
    }
    async persist() {
        await this.setJsonRpcRecords(this.values), this.events.emit(rf.sync)
    }
    async restore() {
        try {
            const e = await this.getJsonRpcRecords();
            if (typeof e > "u" || !e.length) return;
            if (this.records.size) {
                const {
                    message: n
                } = ut("RESTORE_WILL_OVERRIDE", this.name);
                throw this.logger.error(n), new Error(n)
            }
            this.cached = e, this.logger.debug(`Successfully Restored records for ${this.name}`), this.logger.trace({
                type: "method",
                method: "restore",
                records: this.values
            })
        } catch (e) {
            this.logger.debug(`Failed to Restore records for ${this.name}`), this.logger.error(e)
        }
    }
    registerEventListeners() {
        this.events.on(rf.created, e => {
            const n = rf.created;
            this.logger.info(`Emitting ${n}`), this.logger.debug({
                type: "event",
                event: n,
                record: e
            }), this.persist()
        }), this.events.on(rf.updated, e => {
            const n = rf.updated;
            this.logger.info(`Emitting ${n}`), this.logger.debug({
                type: "event",
                event: n,
                record: e
            }), this.persist()
        }), this.events.on(rf.deleted, e => {
            const n = rf.deleted;
            this.logger.info(`Emitting ${n}`), this.logger.debug({
                type: "event",
                event: n,
                record: e
            }), this.persist()
        }), this.core.heartbeat.on(P2.HEARTBEAT_EVENTS.pulse, () => {
            this.cleanup()
        })
    }
    cleanup() {
        try {
            this.records.forEach(e => {
                Bt.toMiliseconds(e.expiry || 0) - Date.now() <= 0 && (this.logger.info(`Deleting expired history log: ${e.id}`), this.delete(e.topic, e.id))
            })
        } catch (e) {
            this.logger.warn(e)
        }
    }
    isInitialized() {
        if (!this.initialized) {
            const {
                message: e
            } = ut("NOT_INITIALIZED", this.name);
            throw new Error(e)
        }
    }
}
class g7e extends eAe {
    constructor(e, n) {
        super(e, n), this.core = e, this.logger = n, this.expirations = new Map, this.events = new uo.EventEmitter, this.name = z9e, this.version = W9e, this.cached = [], this.initialized = !1, this.storagePrefix = jp, this.init = async () => {
            this.initialized || (this.logger.trace("Initialized"), await this.restore(), this.cached.forEach(r => this.expirations.set(r.target, r)), this.cached = [], this.registerEventListeners(), this.initialized = !0)
        }, this.has = r => {
            try {
                const i = this.formatTarget(r);
                return typeof this.getExpiration(i) < "u"
            } catch {
                return !1
            }
        }, this.set = (r, i) => {
            this.isInitialized();
            const s = this.formatTarget(r),
                o = {
                    target: s,
                    expiry: i
                };
            this.expirations.set(s, o), this.checkExpiry(s, o), this.events.emit(ic.created, {
                target: s,
                expiration: o
            })
        }, this.get = r => {
            this.isInitialized();
            const i = this.formatTarget(r);
            return this.getExpiration(i)
        }, this.del = r => {
            if (this.isInitialized(), this.has(r)) {
                const i = this.formatTarget(r),
                    s = this.getExpiration(i);
                this.expirations.delete(i), this.events.emit(ic.deleted, {
                    target: i,
                    expiration: s
                })
            }
        }, this.on = (r, i) => {
            this.events.on(r, i)
        }, this.once = (r, i) => {
            this.events.once(r, i)
        }, this.off = (r, i) => {
            this.events.off(r, i)
        }, this.removeListener = (r, i) => {
            this.events.removeListener(r, i)
        }, this.logger = Ja(n, this.name)
    }
    get context() {
        return Qa(this.logger)
    }
    get storageKey() {
        return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name
    }
    get length() {
        return this.expirations.size
    }
    get keys() {
        return Array.from(this.expirations.keys())
    }
    get values() {
        return Array.from(this.expirations.values())
    }
    formatTarget(e) {
        if (typeof e == "string") return VSe(e);
        if (typeof e == "number") return GSe(e);
        const {
            message: n
        } = ut("UNKNOWN_TYPE", `Target type: ${typeof e}`);
        throw new Error(n)
    }
    async setExpirations(e) {
        await this.core.storage.setItem(this.storageKey, e)
    }
    async getExpirations() {
        return await this.core.storage.getItem(this.storageKey)
    }
    async persist() {
        await this.setExpirations(this.values), this.events.emit(ic.sync)
    }
    async restore() {
        try {
            const e = await this.getExpirations();
            if (typeof e > "u" || !e.length) return;
            if (this.expirations.size) {
                const {
                    message: n
                } = ut("RESTORE_WILL_OVERRIDE", this.name);
                throw this.logger.error(n), new Error(n)
            }
            this.cached = e, this.logger.debug(`Successfully Restored expirations for ${this.name}`), this.logger.trace({
                type: "method",
                method: "restore",
                expirations: this.values
            })
        } catch (e) {
            this.logger.debug(`Failed to Restore expirations for ${this.name}`), this.logger.error(e)
        }
    }
    getExpiration(e) {
        const n = this.expirations.get(e);
        if (!n) {
            const {
                message: r
            } = ut("NO_MATCHING_KEY", `${this.name}: ${e}`);
            throw this.logger.error(r), new Error(r)
        }
        return n
    }
    checkExpiry(e, n) {
        const {
            expiry: r
        } = n;
        Bt.toMiliseconds(r) - Date.now() <= 0 && this.expire(e, n)
    }
    expire(e, n) {
        this.expirations.delete(e), this.events.emit(ic.expired, {
            target: e,
            expiration: n
        })
    }
    checkExpirations() {
        this.core.relayer.connected && this.expirations.forEach((e, n) => this.checkExpiry(n, e))
    }
    registerEventListeners() {
        this.core.heartbeat.on(P2.HEARTBEAT_EVENTS.pulse, () => this.checkExpirations()), this.events.on(ic.created, e => {
            const n = ic.created;
            this.logger.info(`Emitting ${n}`), this.logger.debug({
                type: "event",
                event: n,
                data: e
            }), this.persist()
        }), this.events.on(ic.expired, e => {
            const n = ic.expired;
            this.logger.info(`Emitting ${n}`), this.logger.debug({
                type: "event",
                event: n,
                data: e
            }), this.persist()
        }), this.events.on(ic.deleted, e => {
            const n = ic.deleted;
            this.logger.info(`Emitting ${n}`), this.logger.debug({
                type: "event",
                event: n,
                data: e
            }), this.persist()
        })
    }
    isInitialized() {
        if (!this.initialized) {
            const {
                message: e
            } = ut("NOT_INITIALIZED", this.name);
            throw new Error(e)
        }
    }
}
class m7e extends tAe {
    constructor(e, n) {
        super(e, n), this.projectId = e, this.logger = n, this.name = oO, this.initialized = !1, this.queue = [], this.verifyDisabled = !1, this.init = async r => {
            if (this.verifyDisabled || R2() || !O2()) return;
            const i = this.getVerifyUrl(r == null ? void 0 : r.verifyUrl);
            this.verifyUrl !== i && this.removeIframe(), this.verifyUrl = i;
            try {
                await this.createIframe()
            } catch (s) {
                this.logger.info(`Verify iframe failed to load: ${this.verifyUrl}`), this.logger.info(s)
            }
            if (!this.initialized) {
                this.removeIframe(), this.verifyUrl = gk;
                try {
                    await this.createIframe()
                } catch (s) {
                    this.logger.info(`Verify iframe failed to load: ${this.verifyUrl}`), this.logger.info(s), this.verifyDisabled = !0
                }
            }
        }, this.register = async r => {
            this.initialized ? this.sendPost(r.attestationId) : (this.addToQueue(r.attestationId), await this.init())
        }, this.resolve = async r => {
            if (this.isDevEnv) return "";
            const i = this.getVerifyUrl(r == null ? void 0 : r.verifyUrl);
            let s;
            try {
                s = await this.fetchAttestation(r.attestationId, i)
            } catch (o) {
                this.logger.info(`failed to resolve attestation: ${r.attestationId} from url: ${i}`), this.logger.info(o), s = await this.fetchAttestation(r.attestationId, gk)
            }
            return s
        }, this.fetchAttestation = async (r, i) => {
            this.logger.info(`resolving attestation: ${r} from url: ${i}`);
            const s = this.startAbortTimer(Bt.ONE_SECOND * 2),
                o = await fetch(`${i}/attestation/${r}`, {
                    signal: this.abortController.signal
                });
            return clearTimeout(s), o.status === 200 ? await o.json() : void 0
        }, this.addToQueue = r => {
            this.queue.push(r)
        }, this.processQueue = () => {
            this.queue.length !== 0 && (this.queue.forEach(r => this.sendPost(r)), this.queue = [])
        }, this.sendPost = r => {
            var i;
            try {
                if (!this.iframe) return;
                (i = this.iframe.contentWindow) == null || i.postMessage(r, "*"), this.logger.info(`postMessage sent: ${r} ${this.verifyUrl}`)
            } catch {}
        }, this.createIframe = async () => {
            let r;
            const i = s => {
                s.data === "verify_ready" && (this.initialized = !0, this.processQueue(), window.removeEventListener("message", i), r())
            };
            await Promise.race([new Promise(s => {
                if (document.getElementById(oO)) return s();
                window.addEventListener("message", i);
                const o = document.createElement("iframe");
                o.id = oO, o.src = `${this.verifyUrl}/${this.projectId}`, o.style.display = "none", document.body.append(o), this.iframe = o, r = s
            }), new Promise((s, o) => setTimeout(() => {
                window.removeEventListener("message", i), o("verify iframe load timeout")
            }, Bt.toMiliseconds(Bt.FIVE_SECONDS)))])
        }, this.removeIframe = () => {
            this.iframe && (this.iframe.remove(), this.iframe = void 0, this.initialized = !1)
        }, this.getVerifyUrl = r => {
            let i = r || Iw;
            return V9e.includes(i) || (this.logger.info(`verify url: ${i}, not included in trusted list, assigning default: ${Iw}`), i = Iw), i
        }, this.logger = Ja(n, this.name), this.verifyUrl = Iw, this.abortController = new AbortController, this.isDevEnv = uL() && GAe.IS_VITEST
    }
    get context() {
        return Qa(this.logger)
    }
    startAbortTimer(e) {
        return this.abortController = new AbortController, setTimeout(() => this.abortController.abort(), Bt.toMiliseconds(e))
    }
}
class y7e extends nAe {
    constructor(e, n) {
        super(e, n), this.projectId = e, this.logger = n, this.context = G9e, this.registerDeviceToken = async r => {
            const {
                clientId: i,
                token: s,
                notificationType: o,
                enableEncrypted: a = !1
            } = r, l = `${q9e}/${this.projectId}/clients`;
            await VAe(l, {
                method: "POST",
                headers: {
                    "Content-Type": "application/json"
                },
                body: JSON.stringify({
                    client_id: i,
                    type: o,
                    token: s,
                    always_raw: a
                })
            })
        }, this.logger = Ja(n, this.context)
    }
}
var w7e = Object.defineProperty,
    MV = Object.getOwnPropertySymbols,
    v7e = Object.prototype.hasOwnProperty,
    b7e = Object.prototype.propertyIsEnumerable,
    DV = (t, e, n) => e in t ? w7e(t, e, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: n
    }) : t[e] = n,
    $V = (t, e) => {
        for (var n in e || (e = {})) v7e.call(e, n) && DV(t, n, e[n]);
        if (MV)
            for (var n of MV(e)) b7e.call(e, n) && DV(t, n, e[n]);
        return t
    };
let _7e = class Fne extends qCe {
    constructor(e) {
        super(e), this.protocol = $ne, this.version = y9e, this.name = wL, this.events = new uo.EventEmitter, this.initialized = !1, this.on = (r, i) => this.events.on(r, i), this.once = (r, i) => this.events.once(r, i), this.off = (r, i) => this.events.off(r, i), this.removeListener = (r, i) => this.events.removeListener(r, i), this.projectId = e == null ? void 0 : e.projectId, this.relayUrl = (e == null ? void 0 : e.relayUrl) || Bne, this.customStoragePrefix = e != null && e.customStoragePrefix ? `:${e.customStoragePrefix}` : "";
        const n = typeof(e == null ? void 0 : e.logger) < "u" && typeof(e == null ? void 0 : e.logger) != "string" ? e.logger : jT(HT({
            level: (e == null ? void 0 : e.logger) || w9e.logger
        }));
        this.logger = Ja(n, this.name), this.heartbeat = new P2.HeartBeat, this.crypto = new Y9e(this, this.logger, e == null ? void 0 : e.keychain), this.history = new p7e(this, this.logger), this.expirer = new g7e(this, this.logger), this.storage = e != null && e.storage ? e.storage : new mCe($V($V({}, v9e), e == null ? void 0 : e.storageOptions)), this.relayer = new c7e({
            core: this,
            logger: this.logger,
            relayUrl: this.relayUrl,
            projectId: this.projectId
        }), this.pairing = new h7e(this, this.logger), this.verify = new m7e(this.projectId || "", this.logger), this.echoClient = new y7e(this.projectId || "", this.logger)
    }
    static async init(e) {
        const n = new Fne(e);
        await n.initialize();
        const r = await n.crypto.getClientId();
        return await n.storage.setItem(D9e, r), n
    }
    get context() {
        return Qa(this.logger)
    }
    async start() {
        this.initialized || await this.initialize()
    }
    async initialize() {
        this.logger.trace("Initialized");
        try {
            await this.crypto.init(), await this.history.init(), await this.expirer.init(), await this.relayer.init(), await this.heartbeat.init(), await this.pairing.init(), this.initialized = !0, this.logger.info("Core Initialization Success")
        } catch (e) {
            throw this.logger.warn(`Core Initialization Failure at epoch ${Date.now()}`, e), this.logger.error(e.message), e
        }
    }
};
const E7e = _7e,
    Une = "wc",
    jne = 2,
    Hne = "client",
    vL = `${Une}@${jne}:${Hne}:`,
    lO = {
        name: Hne,
        logger: "error",
        controller: !1,
        relayUrl: "wss://relay.walletconnect.com"
    },
    LV = "WALLETCONNECT_DEEPLINK_CHOICE",
    x7e = "proposal",
    zne = "Proposal expired",
    S7e = "session",
    jx = Bt.SEVEN_DAYS,
    C7e = "engine",
    U5 = {
        wc_sessionPropose: {
            req: {
                ttl: Bt.FIVE_MINUTES,
                prompt: !0,
                tag: 1100
            },
            res: {
                ttl: Bt.FIVE_MINUTES,
                prompt: !1,
                tag: 1101
            }
        },
        wc_sessionSettle: {
            req: {
                ttl: Bt.FIVE_MINUTES,
                prompt: !1,
                tag: 1102
            },
            res: {
                ttl: Bt.FIVE_MINUTES,
                prompt: !1,
                tag: 1103
            }
        },
        wc_sessionUpdate: {
            req: {
                ttl: Bt.ONE_DAY,
                prompt: !1,
                tag: 1104
            },
            res: {
                ttl: Bt.ONE_DAY,
                prompt: !1,
                tag: 1105
            }
        },
        wc_sessionExtend: {
            req: {
                ttl: Bt.ONE_DAY,
                prompt: !1,
                tag: 1106
            },
            res: {
                ttl: Bt.ONE_DAY,
                prompt: !1,
                tag: 1107
            }
        },
        wc_sessionRequest: {
            req: {
                ttl: Bt.FIVE_MINUTES,
                prompt: !0,
                tag: 1108
            },
            res: {
                ttl: Bt.FIVE_MINUTES,
                prompt: !1,
                tag: 1109
            }
        },
        wc_sessionEvent: {
            req: {
                ttl: Bt.FIVE_MINUTES,
                prompt: !0,
                tag: 1110
            },
            res: {
                ttl: Bt.FIVE_MINUTES,
                prompt: !1,
                tag: 1111
            }
        },
        wc_sessionDelete: {
            req: {
                ttl: Bt.ONE_DAY,
                prompt: !1,
                tag: 1112
            },
            res: {
                ttl: Bt.ONE_DAY,
                prompt: !1,
                tag: 1113
            }
        },
        wc_sessionPing: {
            req: {
                ttl: Bt.THIRTY_SECONDS,
                prompt: !1,
                tag: 1114
            },
            res: {
                ttl: Bt.THIRTY_SECONDS,
                prompt: !1,
                tag: 1115
            }
        }
    },
    cO = {
        min: Bt.FIVE_MINUTES,
        max: Bt.SEVEN_DAYS
    },
    Nd = {
        idle: "IDLE",
        active: "ACTIVE"
    },
    A7e = "request",
    T7e = ["wc_sessionPropose", "wc_sessionRequest", "wc_authRequest"];
var I7e = Object.defineProperty,
    R7e = Object.defineProperties,
    O7e = Object.getOwnPropertyDescriptors,
    BV = Object.getOwnPropertySymbols,
    N7e = Object.prototype.hasOwnProperty,
    P7e = Object.prototype.propertyIsEnumerable,
    FV = (t, e, n) => e in t ? I7e(t, e, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: n
    }) : t[e] = n,
    Aa = (t, e) => {
        for (var n in e || (e = {})) N7e.call(e, n) && FV(t, n, e[n]);
        if (BV)
            for (var n of BV(e)) P7e.call(e, n) && FV(t, n, e[n]);
        return t
    },
    j5 = (t, e) => R7e(t, O7e(e));
class k7e extends iAe {
    constructor(e) {
        super(e), this.name = C7e, this.events = new eL, this.initialized = !1, this.ignoredPayloadTypes = [py], this.requestQueue = {
            state: Nd.idle,
            queue: []
        }, this.sessionRequestQueue = {
            state: Nd.idle,
            queue: []
        }, this.requestQueueDelay = Bt.ONE_SECOND, this.init = async () => {
            this.initialized || (await this.cleanup(), this.registerRelayerEvents(), this.registerExpirerEvents(), this.registerPairingEvents(), this.client.core.pairing.register({
                methods: Object.keys(U5)
            }), this.initialized = !0, setTimeout(() => {
                this.sessionRequestQueue.queue = this.getPendingSessionRequests(), this.processSessionRequestQueue()
            }, Bt.toMiliseconds(this.requestQueueDelay)))
        }, this.connect = async n => {
            await this.isInitialized();
            const r = j5(Aa({}, n), {
                requiredNamespaces: n.requiredNamespaces || {},
                optionalNamespaces: n.optionalNamespaces || {}
            });
            await this.isValidConnect(r);
            const {
                pairingTopic: i,
                requiredNamespaces: s,
                optionalNamespaces: o,
                sessionProperties: a,
                relays: l
            } = r;
            let c = i,
                u, f = !1;
            if (c && (f = this.client.core.pairing.pairings.get(c).active), !c || !f) {
                const {
                    topic: S,
                    uri: I
                } = await this.client.core.pairing.create();
                c = S, u = I
            }
            const h = await this.client.core.crypto.generateKeyPair(),
                g = Aa({
                    requiredNamespaces: s,
                    optionalNamespaces: o,
                    relays: l ? ? [{
                        protocol: Lne
                    }],
                    proposer: {
                        publicKey: h,
                        metadata: this.client.metadata
                    }
                }, a && {
                    sessionProperties: a
                }),
                {
                    reject: y,
                    resolve: _,
                    done: C
                } = bw(Bt.FIVE_MINUTES, zne);
            if (this.events.once(ws("session_connect"), async ({
                    error: S,
                    session: I
                }) => {
                    if (S) y(S);
                    else if (I) {
                        I.self.publicKey = h;
                        const P = j5(Aa({}, I), {
                            requiredNamespaces: I.requiredNamespaces,
                            optionalNamespaces: I.optionalNamespaces
                        });
                        await this.client.session.set(I.topic, P), await this.setExpiry(I.topic, I.expiry), c && await this.client.core.pairing.updateMetadata({
                            topic: c,
                            metadata: I.peer.metadata
                        }), _(P)
                    }
                }), !c) {
                const {
                    message: S
                } = ut("NO_MATCHING_KEY", `connect() pairing topic: ${c}`);
                throw new Error(S)
            }
            const b = await this.sendRequest({
                    topic: c,
                    method: "wc_sessionPropose",
                    params: g
                }),
                w = hu(Bt.FIVE_MINUTES);
            return await this.setProposal(b, Aa({
                id: b,
                expiry: w
            }, g)), {
                uri: u,
                approval: C
            }
        }, this.pair = async n => (await this.isInitialized(), await this.client.core.pairing.pair(n)), this.approve = async n => {
            await this.isInitialized(), await this.isValidApprove(n);
            const {
                id: r,
                relayProtocol: i,
                namespaces: s,
                sessionProperties: o
            } = n, a = this.client.proposal.get(r);
            let {
                pairingTopic: l,
                proposer: c,
                requiredNamespaces: u,
                optionalNamespaces: f
            } = a;
            l = l || "", rv(u) || (u = a8e(s, "approve()"));
            const h = await this.client.core.crypto.generateKeyPair(),
                g = c.publicKey,
                y = await this.client.core.crypto.generateSharedKey(h, g);
            l && r && (await this.client.core.pairing.updateMetadata({
                topic: l,
                metadata: c.metadata
            }), await this.sendResult({
                id: r,
                topic: l,
                result: {
                    relay: {
                        protocol: i ? ? "irn"
                    },
                    responderPublicKey: h
                }
            }), await this.client.proposal.delete(r, Vi("USER_DISCONNECTED")), await this.client.core.pairing.activate({
                topic: l
            }));
            const _ = Aa({
                relay: {
                    protocol: i ? ? "irn"
                },
                namespaces: s,
                requiredNamespaces: u,
                optionalNamespaces: f,
                pairingTopic: l,
                controller: {
                    publicKey: h,
                    metadata: this.client.metadata
                },
                expiry: hu(jx)
            }, o && {
                sessionProperties: o
            });
            await this.client.core.relayer.subscribe(y), await this.sendRequest({
                topic: y,
                method: "wc_sessionSettle",
                params: _,
                throwOnFailedPublish: !0
            });
            const C = j5(Aa({}, _), {
                topic: y,
                pairingTopic: l,
                acknowledged: !1,
                self: _.controller,
                peer: {
                    publicKey: c.publicKey,
                    metadata: c.metadata
                },
                controller: h
            });
            return await this.client.session.set(y, C), await this.setExpiry(y, hu(jx)), {
                topic: y,
                acknowledged: () => new Promise(b => setTimeout(() => b(this.client.session.get(y)), 500))
            }
        }, this.reject = async n => {
            await this.isInitialized(), await this.isValidReject(n);
            const {
                id: r,
                reason: i
            } = n, {
                pairingTopic: s
            } = this.client.proposal.get(r);
            s && (await this.sendError(r, s, i), await this.client.proposal.delete(r, Vi("USER_DISCONNECTED")))
        }, this.update = async n => {
            await this.isInitialized(), await this.isValidUpdate(n);
            const {
                topic: r,
                namespaces: i
            } = n, s = await this.sendRequest({
                topic: r,
                method: "wc_sessionUpdate",
                params: {
                    namespaces: i
                }
            }), {
                done: o,
                resolve: a,
                reject: l
            } = bw();
            return this.events.once(ws("session_update", s), ({
                error: c
            }) => {
                c ? l(c) : a()
            }), await this.client.session.update(r, {
                namespaces: i
            }), {
                acknowledged: o
            }
        }, this.extend = async n => {
            await this.isInitialized(), await this.isValidExtend(n);
            const {
                topic: r
            } = n, i = await this.sendRequest({
                topic: r,
                method: "wc_sessionExtend",
                params: {}
            }), {
                done: s,
                resolve: o,
                reject: a
            } = bw();
            return this.events.once(ws("session_extend", i), ({
                error: l
            }) => {
                l ? a(l) : o()
            }), await this.setExpiry(r, hu(jx)), {
                acknowledged: s
            }
        }, this.request = async n => {
            await this.isInitialized(), await this.isValidRequest(n);
            const {
                chainId: r,
                request: i,
                topic: s,
                expiry: o
            } = n, a = gL(), {
                done: l,
                resolve: c,
                reject: u
            } = bw(o, "Request expired. Please try again.");
            return this.events.once(ws("session_request", a), ({
                error: f,
                result: h
            }) => {
                f ? u(f) : c(h)
            }), await Promise.all([new Promise(async f => {
                await this.sendRequest({
                    clientRpcId: a,
                    topic: s,
                    method: "wc_sessionRequest",
                    params: {
                        request: i,
                        chainId: r
                    },
                    expiry: o,
                    throwOnFailedPublish: !0
                }).catch(h => u(h)), this.client.events.emit("session_request_sent", {
                    topic: s,
                    request: i,
                    chainId: r,
                    id: a
                }), f()
            }), new Promise(async f => {
                const h = await KSe(this.client.core.storage, LV);
                qSe({
                    id: a,
                    topic: s,
                    wcDeepLink: h
                }), f()
            }), l()]).then(f => f[2])
        }, this.respond = async n => {
            await this.isInitialized(), await this.isValidRespond(n);
            const {
                topic: r,
                response: i
            } = n, {
                id: s
            } = i;
            Bd(i) ? await this.sendResult({
                id: s,
                topic: r,
                result: i.result,
                throwOnFailedPublish: !0
            }) : pc(i) && await this.sendError(s, r, i.error), this.cleanupAfterResponse(n)
        }, this.ping = async n => {
            await this.isInitialized(), await this.isValidPing(n);
            const {
                topic: r
            } = n;
            if (this.client.session.keys.includes(r)) {
                const i = await this.sendRequest({
                        topic: r,
                        method: "wc_sessionPing",
                        params: {}
                    }),
                    {
                        done: s,
                        resolve: o,
                        reject: a
                    } = bw();
                this.events.once(ws("session_ping", i), ({
                    error: l
                }) => {
                    l ? a(l) : o()
                }), await s()
            } else this.client.core.pairing.pairings.keys.includes(r) && await this.client.core.pairing.ping({
                topic: r
            })
        }, this.emit = async n => {
            await this.isInitialized(), await this.isValidEmit(n);
            const {
                topic: r,
                event: i,
                chainId: s
            } = n;
            await this.sendRequest({
                topic: r,
                method: "wc_sessionEvent",
                params: {
                    event: i,
                    chainId: s
                }
            })
        }, this.disconnect = async n => {
            await this.isInitialized(), await this.isValidDisconnect(n);
            const {
                topic: r
            } = n;
            this.client.session.keys.includes(r) ? (await this.sendRequest({
                topic: r,
                method: "wc_sessionDelete",
                params: Vi("USER_DISCONNECTED"),
                throwOnFailedPublish: !0
            }), await this.deleteSession(r)) : await this.client.core.pairing.disconnect({
                topic: r
            })
        }, this.find = n => (this.isInitialized(), this.client.session.getAll().filter(r => u8e(r, n))), this.getPendingSessionRequests = () => (this.isInitialized(), this.client.pendingRequest.getAll()), this.cleanupDuplicatePairings = async n => {
            if (n.pairingTopic) try {
                const r = this.client.core.pairing.pairings.get(n.pairingTopic),
                    i = this.client.core.pairing.pairings.getAll().filter(s => {
                        var o, a;
                        return ((o = s.peerMetadata) == null ? void 0 : o.url) && ((a = s.peerMetadata) == null ? void 0 : a.url) === n.peer.metadata.url && s.topic && s.topic !== r.topic
                    });
                if (i.length === 0) return;
                this.client.logger.info(`Cleaning up ${i.length} duplicate pairing(s)`), await Promise.all(i.map(s => this.client.core.pairing.disconnect({
                    topic: s.topic
                }))), this.client.logger.info("Duplicate pairings clean up finished")
            } catch (r) {
                this.client.logger.error(r)
            }
        }, this.deleteSession = async (n, r) => {
            const {
                self: i
            } = this.client.session.get(n);
            await this.client.core.relayer.unsubscribe(n), this.client.session.delete(n, Vi("USER_DISCONNECTED")), this.client.core.crypto.keychain.has(i.publicKey) && await this.client.core.crypto.deleteKeyPair(i.publicKey), this.client.core.crypto.keychain.has(n) && await this.client.core.crypto.deleteSymKey(n), r || this.client.core.expirer.del(n), this.client.core.storage.removeItem(LV).catch(s => this.client.logger.warn(s)), this.getPendingSessionRequests().forEach(s => {
                s.topic === n && this.deletePendingSessionRequest(s.id, Vi("USER_DISCONNECTED"))
            })
        }, this.deleteProposal = async (n, r) => {
            await Promise.all([this.client.proposal.delete(n, Vi("USER_DISCONNECTED")), r ? Promise.resolve() : this.client.core.expirer.del(n)])
        }, this.deletePendingSessionRequest = async (n, r, i = !1) => {
            await Promise.all([this.client.pendingRequest.delete(n, r), i ? Promise.resolve() : this.client.core.expirer.del(n)]), this.sessionRequestQueue.queue = this.sessionRequestQueue.queue.filter(s => s.id !== n), i && (this.sessionRequestQueue.state = Nd.idle)
        }, this.setExpiry = async (n, r) => {
            this.client.session.keys.includes(n) && await this.client.session.update(n, {
                expiry: r
            }), this.client.core.expirer.set(n, r)
        }, this.setProposal = async (n, r) => {
            await this.client.proposal.set(n, r), this.client.core.expirer.set(n, r.expiry)
        }, this.setPendingSessionRequest = async n => {
            const r = U5.wc_sessionRequest.req.ttl,
                {
                    id: i,
                    topic: s,
                    params: o,
                    verifyContext: a
                } = n;
            await this.client.pendingRequest.set(i, {
                id: i,
                topic: s,
                params: o,
                verifyContext: a
            }), r && this.client.core.expirer.set(i, hu(r))
        }, this.sendRequest = async n => {
            const {
                topic: r,
                method: i,
                params: s,
                expiry: o,
                relayRpcId: a,
                clientRpcId: l,
                throwOnFailedPublish: c
            } = n, u = em(i, s, l);
            if (O2() && T7e.includes(i)) {
                const g = nv(JSON.stringify(u));
                this.client.core.verify.register({
                    attestationId: g
                })
            }
            const f = await this.client.core.crypto.encode(r, u),
                h = U5[i].req;
            return o && (h.ttl = o), a && (h.id = a), this.client.core.history.set(r, u), c ? (h.internal = j5(Aa({}, h.internal), {
                throwOnFailedPublish: !0
            }), await this.client.core.relayer.publish(r, f, h)) : this.client.core.relayer.publish(r, f, h).catch(g => this.client.logger.error(g)), u.id
        }, this.sendResult = async n => {
            const {
                id: r,
                topic: i,
                result: s,
                throwOnFailedPublish: o
            } = n, a = zT(r, s), l = await this.client.core.crypto.encode(i, a), c = await this.client.core.history.get(i, r), u = U5[c.request.method].res;
            o ? (u.internal = j5(Aa({}, u.internal), {
                throwOnFailedPublish: !0
            }), await this.client.core.relayer.publish(i, l, u)) : this.client.core.relayer.publish(i, l, u).catch(f => this.client.logger.error(f)), await this.client.core.history.resolve(a)
        }, this.sendError = async (n, r, i) => {
            const s = WT(n, i),
                o = await this.client.core.crypto.encode(r, s),
                a = await this.client.core.history.get(r, n),
                l = U5[a.request.method].res;
            this.client.core.relayer.publish(r, o, l), await this.client.core.history.resolve(s)
        }, this.cleanup = async () => {
            const n = [],
                r = [];
            this.client.session.getAll().forEach(i => {
                S0(i.expiry) && n.push(i.topic)
            }), this.client.proposal.getAll().forEach(i => {
                S0(i.expiry) && r.push(i.id)
            }), await Promise.all([...n.map(i => this.deleteSession(i)), ...r.map(i => this.deleteProposal(i))])
        }, this.onRelayEventRequest = async n => {
            this.requestQueue.queue.push(n), await this.processRequestsQueue()
        }, this.processRequestsQueue = async () => {
            if (this.requestQueue.state === Nd.active) {
                this.client.logger.info("Request queue already active, skipping...");
                return
            }
            for (this.client.logger.info(`Request queue starting with ${this.requestQueue.queue.length} requests`); this.requestQueue.queue.length > 0;) {
                this.requestQueue.state = Nd.active;
                const n = this.requestQueue.queue.shift();
                if (n) try {
                    this.processRequest(n), await new Promise(r => setTimeout(r, 300))
                } catch (r) {
                    this.client.logger.warn(r)
                }
            }
            this.requestQueue.state = Nd.idle
        }, this.processRequest = n => {
            const {
                topic: r,
                payload: i
            } = n, s = i.method;
            switch (s) {
                case "wc_sessionPropose":
                    return this.onSessionProposeRequest(r, i);
                case "wc_sessionSettle":
                    return this.onSessionSettleRequest(r, i);
                case "wc_sessionUpdate":
                    return this.onSessionUpdateRequest(r, i);
                case "wc_sessionExtend":
                    return this.onSessionExtendRequest(r, i);
                case "wc_sessionPing":
                    return this.onSessionPingRequest(r, i);
                case "wc_sessionDelete":
                    return this.onSessionDeleteRequest(r, i);
                case "wc_sessionRequest":
                    return this.onSessionRequest(r, i);
                case "wc_sessionEvent":
                    return this.onSessionEventRequest(r, i);
                default:
                    return this.client.logger.info(`Unsupported request method ${s}`)
            }
        }, this.onRelayEventResponse = async n => {
            const {
                topic: r,
                payload: i
            } = n, s = (await this.client.core.history.get(r, i.id)).request.method;
            switch (s) {
                case "wc_sessionPropose":
                    return this.onSessionProposeResponse(r, i);
                case "wc_sessionSettle":
                    return this.onSessionSettleResponse(r, i);
                case "wc_sessionUpdate":
                    return this.onSessionUpdateResponse(r, i);
                case "wc_sessionExtend":
                    return this.onSessionExtendResponse(r, i);
                case "wc_sessionPing":
                    return this.onSessionPingResponse(r, i);
                case "wc_sessionRequest":
                    return this.onSessionRequestResponse(r, i);
                default:
                    return this.client.logger.info(`Unsupported response method ${s}`)
            }
        }, this.onRelayEventUnknownPayload = n => {
            const {
                topic: r
            } = n, {
                message: i
            } = ut("MISSING_OR_INVALID", `Decoded payload on topic ${r} is not identifiable as a JSON-RPC request or a response.`);
            throw new Error(i)
        }, this.onSessionProposeRequest = async (n, r) => {
            const {
                params: i,
                id: s
            } = r;
            try {
                this.isValidConnect(Aa({}, r.params));
                const o = hu(Bt.FIVE_MINUTES),
                    a = Aa({
                        id: s,
                        pairingTopic: n,
                        expiry: o
                    }, i);
                await this.setProposal(s, a);
                const l = nv(JSON.stringify(r)),
                    c = await this.getVerifyContext(l, a.proposer.metadata);
                this.client.events.emit("session_proposal", {
                    id: s,
                    params: a,
                    verifyContext: c
                })
            } catch (o) {
                await this.sendError(s, n, o), this.client.logger.error(o)
            }
        }, this.onSessionProposeResponse = async (n, r) => {
            const {
                id: i
            } = r;
            if (Bd(r)) {
                const {
                    result: s
                } = r;
                this.client.logger.trace({
                    type: "method",
                    method: "onSessionProposeResponse",
                    result: s
                });
                const o = this.client.proposal.get(i);
                this.client.logger.trace({
                    type: "method",
                    method: "onSessionProposeResponse",
                    proposal: o
                });
                const a = o.proposer.publicKey;
                this.client.logger.trace({
                    type: "method",
                    method: "onSessionProposeResponse",
                    selfPublicKey: a
                });
                const l = s.responderPublicKey;
                this.client.logger.trace({
                    type: "method",
                    method: "onSessionProposeResponse",
                    peerPublicKey: l
                });
                const c = await this.client.core.crypto.generateSharedKey(a, l);
                this.client.logger.trace({
                    type: "method",
                    method: "onSessionProposeResponse",
                    sessionTopic: c
                });
                const u = await this.client.core.relayer.subscribe(c);
                this.client.logger.trace({
                    type: "method",
                    method: "onSessionProposeResponse",
                    subscriptionId: u
                }), await this.client.core.pairing.activate({
                    topic: n
                })
            } else pc(r) && (await this.client.proposal.delete(i, Vi("USER_DISCONNECTED")), this.events.emit(ws("session_connect"), {
                error: r.error
            }))
        }, this.onSessionSettleRequest = async (n, r) => {
            const {
                id: i,
                params: s
            } = r;
            try {
                this.isValidSessionSettleRequest(s);
                const {
                    relay: o,
                    controller: a,
                    expiry: l,
                    namespaces: c,
                    requiredNamespaces: u,
                    optionalNamespaces: f,
                    sessionProperties: h,
                    pairingTopic: g
                } = r.params, y = Aa({
                    topic: n,
                    relay: o,
                    expiry: l,
                    namespaces: c,
                    acknowledged: !0,
                    pairingTopic: g,
                    requiredNamespaces: u,
                    optionalNamespaces: f,
                    controller: a.publicKey,
                    self: {
                        publicKey: "",
                        metadata: this.client.metadata
                    },
                    peer: {
                        publicKey: a.publicKey,
                        metadata: a.metadata
                    }
                }, h && {
                    sessionProperties: h
                });
                await this.sendResult({
                    id: r.id,
                    topic: n,
                    result: !0
                }), this.events.emit(ws("session_connect"), {
                    session: y
                }), this.cleanupDuplicatePairings(y)
            } catch (o) {
                await this.sendError(i, n, o), this.client.logger.error(o)
            }
        }, this.onSessionSettleResponse = async (n, r) => {
            const {
                id: i
            } = r;
            Bd(r) ? (await this.client.session.update(n, {
                acknowledged: !0
            }), this.events.emit(ws("session_approve", i), {})) : pc(r) && (await this.client.session.delete(n, Vi("USER_DISCONNECTED")), this.events.emit(ws("session_approve", i), {
                error: r.error
            }))
        }, this.onSessionUpdateRequest = async (n, r) => {
            const {
                params: i,
                id: s
            } = r;
            try {
                const o = `${n}_session_update`,
                    a = Lx.get(o);
                if (a && this.isRequestOutOfSync(a, s)) {
                    this.client.logger.info(`Discarding out of sync request - ${s}`);
                    return
                }
                this.isValidUpdate(Aa({
                    topic: n
                }, i)), await this.client.session.update(n, {
                    namespaces: i.namespaces
                }), await this.sendResult({
                    id: s,
                    topic: n,
                    result: !0
                }), this.client.events.emit("session_update", {
                    id: s,
                    topic: n,
                    params: i
                }), Lx.set(o, s)
            } catch (o) {
                await this.sendError(s, n, o), this.client.logger.error(o)
            }
        }, this.isRequestOutOfSync = (n, r) => parseInt(r.toString().slice(0, -3)) <= parseInt(n.toString().slice(0, -3)), this.onSessionUpdateResponse = (n, r) => {
            const {
                id: i
            } = r;
            Bd(r) ? this.events.emit(ws("session_update", i), {}) : pc(r) && this.events.emit(ws("session_update", i), {
                error: r.error
            })
        }, this.onSessionExtendRequest = async (n, r) => {
            const {
                id: i
            } = r;
            try {
                this.isValidExtend({
                    topic: n
                }), await this.setExpiry(n, hu(jx)), await this.sendResult({
                    id: i,
                    topic: n,
                    result: !0
                }), this.client.events.emit("session_extend", {
                    id: i,
                    topic: n
                })
            } catch (s) {
                await this.sendError(i, n, s), this.client.logger.error(s)
            }
        }, this.onSessionExtendResponse = (n, r) => {
            const {
                id: i
            } = r;
            Bd(r) ? this.events.emit(ws("session_extend", i), {}) : pc(r) && this.events.emit(ws("session_extend", i), {
                error: r.error
            })
        }, this.onSessionPingRequest = async (n, r) => {
            const {
                id: i
            } = r;
            try {
                this.isValidPing({
                    topic: n
                }), await this.sendResult({
                    id: i,
                    topic: n,
                    result: !0
                }), this.client.events.emit("session_ping", {
                    id: i,
                    topic: n
                })
            } catch (s) {
                await this.sendError(i, n, s), this.client.logger.error(s)
            }
        }, this.onSessionPingResponse = (n, r) => {
            const {
                id: i
            } = r;
            setTimeout(() => {
                Bd(r) ? this.events.emit(ws("session_ping", i), {}) : pc(r) && this.events.emit(ws("session_ping", i), {
                    error: r.error
                })
            }, 500)
        }, this.onSessionDeleteRequest = async (n, r) => {
            const {
                id: i
            } = r;
            try {
                this.isValidDisconnect({
                    topic: n,
                    reason: r.params
                }), await Promise.all([new Promise(s => {
                    this.client.core.relayer.once(Ro.publish, async () => {
                        s(await this.deleteSession(n))
                    })
                }), this.sendResult({
                    id: i,
                    topic: n,
                    result: !0
                })]), this.client.events.emit("session_delete", {
                    id: i,
                    topic: n
                })
            } catch (s) {
                this.client.logger.error(s)
            }
        }, this.onSessionRequest = async (n, r) => {
            const {
                id: i,
                params: s
            } = r;
            try {
                this.isValidRequest(Aa({
                    topic: n
                }, s));
                const o = nv(JSON.stringify(em("wc_sessionRequest", s, i))),
                    a = this.client.session.get(n),
                    l = await this.getVerifyContext(o, a.peer.metadata),
                    c = {
                        id: i,
                        topic: n,
                        params: s,
                        verifyContext: l
                    };
                await this.setPendingSessionRequest(c), this.addSessionRequestToSessionRequestQueue(c), this.processSessionRequestQueue()
            } catch (o) {
                await this.sendError(i, n, o), this.client.logger.error(o)
            }
        }, this.onSessionRequestResponse = (n, r) => {
            const {
                id: i
            } = r;
            Bd(r) ? this.events.emit(ws("session_request", i), {
                result: r.result
            }) : pc(r) && this.events.emit(ws("session_request", i), {
                error: r.error
            })
        }, this.onSessionEventRequest = async (n, r) => {
            const {
                id: i,
                params: s
            } = r;
            try {
                const o = `${n}_session_event_${s.event.name}`,
                    a = Lx.get(o);
                if (a && this.isRequestOutOfSync(a, i)) {
                    this.client.logger.info(`Discarding out of sync request - ${i}`);
                    return
                }
                this.isValidEmit(Aa({
                    topic: n
                }, s)), this.client.events.emit("session_event", {
                    id: i,
                    topic: n,
                    params: s
                }), Lx.set(o, i)
            } catch (o) {
                await this.sendError(i, n, o), this.client.logger.error(o)
            }
        }, this.addSessionRequestToSessionRequestQueue = n => {
            this.sessionRequestQueue.queue.push(n)
        }, this.cleanupAfterResponse = n => {
            this.deletePendingSessionRequest(n.response.id, {
                message: "fulfilled",
                code: 0
            }), setTimeout(() => {
                this.sessionRequestQueue.state = Nd.idle, this.processSessionRequestQueue()
            }, Bt.toMiliseconds(this.requestQueueDelay))
        }, this.processSessionRequestQueue = () => {
            if (this.sessionRequestQueue.state === Nd.active) {
                this.client.logger.info("session request queue is already active.");
                return
            }
            const n = this.sessionRequestQueue.queue[0];
            if (!n) {
                this.client.logger.info("session request queue is empty.");
                return
            }
            try {
                this.sessionRequestQueue.state = Nd.active, this.client.events.emit("session_request", n)
            } catch (r) {
                this.client.logger.error(r)
            }
        }, this.onPairingCreated = n => {
            if (n.active) return;
            const r = this.client.proposal.getAll().find(i => i.pairingTopic === n.topic);
            r && this.onSessionProposeRequest(n.topic, em("wc_sessionPropose", {
                requiredNamespaces: r.requiredNamespaces,
                optionalNamespaces: r.optionalNamespaces,
                relays: r.relays,
                proposer: r.proposer,
                sessionProperties: r.sessionProperties
            }, r.id))
        }, this.isValidConnect = async n => {
            if (!Pa(n)) {
                const {
                    message: l
                } = ut("MISSING_OR_INVALID", `connect() params: ${JSON.stringify(n)}`);
                throw new Error(l)
            }
            const {
                pairingTopic: r,
                requiredNamespaces: i,
                optionalNamespaces: s,
                sessionProperties: o,
                relays: a
            } = n;
            if (Fa(r) || await this.isValidPairingTopic(r), !E8e(a)) {
                const {
                    message: l
                } = ut("MISSING_OR_INVALID", `connect() relays: ${a}`);
                throw new Error(l)
            }!Fa(i) && rv(i) !== 0 && this.validateNamespaces(i, "requiredNamespaces"), !Fa(s) && rv(s) !== 0 && this.validateNamespaces(s, "optionalNamespaces"), Fa(o) || this.validateSessionProps(o, "sessionProperties")
        }, this.validateNamespaces = (n, r) => {
            const i = _8e(n, "connect()", r);
            if (i) throw new Error(i.message)
        }, this.isValidApprove = async n => {
            if (!Pa(n)) throw new Error(ut("MISSING_OR_INVALID", `approve() params: ${n}`).message);
            const {
                id: r,
                namespaces: i,
                relayProtocol: s,
                sessionProperties: o
            } = n;
            await this.isValidProposalId(r);
            const a = this.client.proposal.get(r),
                l = JS(i, "approve()");
            if (l) throw new Error(l.message);
            const c = KW(a.requiredNamespaces, i, "approve()");
            if (c) throw new Error(c.message);
            if (!Ks(s, !0)) {
                const {
                    message: u
                } = ut("MISSING_OR_INVALID", `approve() relayProtocol: ${s}`);
                throw new Error(u)
            }
            Fa(o) || this.validateSessionProps(o, "sessionProperties")
        }, this.isValidReject = async n => {
            if (!Pa(n)) {
                const {
                    message: s
                } = ut("MISSING_OR_INVALID", `reject() params: ${n}`);
                throw new Error(s)
            }
            const {
                id: r,
                reason: i
            } = n;
            if (await this.isValidProposalId(r), !S8e(i)) {
                const {
                    message: s
                } = ut("MISSING_OR_INVALID", `reject() reason: ${JSON.stringify(i)}`);
                throw new Error(s)
            }
        }, this.isValidSessionSettleRequest = n => {
            if (!Pa(n)) {
                const {
                    message: c
                } = ut("MISSING_OR_INVALID", `onSessionSettleRequest() params: ${n}`);
                throw new Error(c)
            }
            const {
                relay: r,
                controller: i,
                namespaces: s,
                expiry: o
            } = n;
            if (!ane(r)) {
                const {
                    message: c
                } = ut("MISSING_OR_INVALID", "onSessionSettleRequest() relay protocol should be a string");
                throw new Error(c)
            }
            const a = g8e(i, "onSessionSettleRequest()");
            if (a) throw new Error(a.message);
            const l = JS(s, "onSessionSettleRequest()");
            if (l) throw new Error(l.message);
            if (S0(o)) {
                const {
                    message: c
                } = ut("EXPIRED", "onSessionSettleRequest()");
                throw new Error(c)
            }
        }, this.isValidUpdate = async n => {
            if (!Pa(n)) {
                const {
                    message: l
                } = ut("MISSING_OR_INVALID", `update() params: ${n}`);
                throw new Error(l)
            }
            const {
                topic: r,
                namespaces: i
            } = n;
            await this.isValidSessionTopic(r);
            const s = this.client.session.get(r),
                o = JS(i, "update()");
            if (o) throw new Error(o.message);
            const a = KW(s.requiredNamespaces, i, "update()");
            if (a) throw new Error(a.message)
        }, this.isValidExtend = async n => {
            if (!Pa(n)) {
                const {
                    message: i
                } = ut("MISSING_OR_INVALID", `extend() params: ${n}`);
                throw new Error(i)
            }
            const {
                topic: r
            } = n;
            await this.isValidSessionTopic(r)
        }, this.isValidRequest = async n => {
            if (!Pa(n)) {
                const {
                    message: l
                } = ut("MISSING_OR_INVALID", `request() params: ${n}`);
                throw new Error(l)
            }
            const {
                topic: r,
                request: i,
                chainId: s,
                expiry: o
            } = n;
            await this.isValidSessionTopic(r);
            const {
                namespaces: a
            } = this.client.session.get(r);
            if (!qW(a, s)) {
                const {
                    message: l
                } = ut("MISSING_OR_INVALID", `request() chainId: ${s}`);
                throw new Error(l)
            }
            if (!C8e(i)) {
                const {
                    message: l
                } = ut("MISSING_OR_INVALID", `request() ${JSON.stringify(i)}`);
                throw new Error(l)
            }
            if (!I8e(a, s, i.method)) {
                const {
                    message: l
                } = ut("MISSING_OR_INVALID", `request() method: ${i.method}`);
                throw new Error(l)
            }
            if (o && !P8e(o, cO)) {
                const {
                    message: l
                } = ut("MISSING_OR_INVALID", `request() expiry: ${o}. Expiry must be a number (in seconds) between ${cO.min} and ${cO.max}`);
                throw new Error(l)
            }
        }, this.isValidRespond = async n => {
            var r;
            if (!Pa(n)) {
                const {
                    message: o
                } = ut("MISSING_OR_INVALID", `respond() params: ${n}`);
                throw new Error(o)
            }
            const {
                topic: i,
                response: s
            } = n;
            try {
                await this.isValidSessionTopic(i)
            } catch (o) {
                throw (r = n == null ? void 0 : n.response) != null && r.id && this.cleanupAfterResponse(n), o
            }
            if (!A8e(s)) {
                const {
                    message: o
                } = ut("MISSING_OR_INVALID", `respond() response: ${JSON.stringify(s)}`);
                throw new Error(o)
            }
        }, this.isValidPing = async n => {
            if (!Pa(n)) {
                const {
                    message: i
                } = ut("MISSING_OR_INVALID", `ping() params: ${n}`);
                throw new Error(i)
            }
            const {
                topic: r
            } = n;
            await this.isValidSessionOrPairingTopic(r)
        }, this.isValidEmit = async n => {
            if (!Pa(n)) {
                const {
                    message: a
                } = ut("MISSING_OR_INVALID", `emit() params: ${n}`);
                throw new Error(a)
            }
            const {
                topic: r,
                event: i,
                chainId: s
            } = n;
            await this.isValidSessionTopic(r);
            const {
                namespaces: o
            } = this.client.session.get(r);
            if (!qW(o, s)) {
                const {
                    message: a
                } = ut("MISSING_OR_INVALID", `emit() chainId: ${s}`);
                throw new Error(a)
            }
            if (!T8e(i)) {
                const {
                    message: a
                } = ut("MISSING_OR_INVALID", `emit() event: ${JSON.stringify(i)}`);
                throw new Error(a)
            }
            if (!R8e(o, s, i.name)) {
                const {
                    message: a
                } = ut("MISSING_OR_INVALID", `emit() event: ${JSON.stringify(i)}`);
                throw new Error(a)
            }
        }, this.isValidDisconnect = async n => {
            if (!Pa(n)) {
                const {
                    message: i
                } = ut("MISSING_OR_INVALID", `disconnect() params: ${n}`);
                throw new Error(i)
            }
            const {
                topic: r
            } = n;
            await this.isValidSessionOrPairingTopic(r)
        }, this.getVerifyContext = async (n, r) => {
            const i = {
                verified: {
                    verifyUrl: r.verifyUrl || Iw,
                    validation: "UNKNOWN",
                    origin: r.url || ""
                }
            };
            try {
                const s = await this.client.core.verify.resolve({
                    attestationId: n,
                    verifyUrl: r.verifyUrl
                });
                s && (i.verified.origin = s.origin, i.verified.isScam = s.isScam, i.verified.validation = s.origin === new URL(r.url).origin ? "VALID" : "INVALID")
            } catch (s) {
                this.client.logger.info(s)
            }
            return this.client.logger.info(`Verify context: ${JSON.stringify(i)}`), i
        }, this.validateSessionProps = (n, r) => {
            Object.values(n).forEach(i => {
                if (!Ks(i, !1)) {
                    const {
                        message: s
                    } = ut("MISSING_OR_INVALID", `${r} must be in Record<string, string> format. Received: ${JSON.stringify(i)}`);
                    throw new Error(s)
                }
            })
        }
    }
    async isInitialized() {
        if (!this.initialized) {
            const {
                message: e
            } = ut("NOT_INITIALIZED", this.name);
            throw new Error(e)
        }
        await this.client.core.relayer.confirmOnlineStateOrThrow()
    }
    registerRelayerEvents() {
        this.client.core.relayer.on(Ro.message, async e => {
            const {
                topic: n,
                message: r
            } = e;
            if (this.ignoredPayloadTypes.includes(this.client.core.crypto.getPayloadType(r))) return;
            const i = await this.client.core.crypto.decode(n, r);
            try {
                yL(i) ? (this.client.core.history.set(n, i), this.onRelayEventRequest({
                    topic: n,
                    payload: i
                })) : AE(i) ? (await this.client.core.history.resolve(i), await this.onRelayEventResponse({
                    topic: n,
                    payload: i
                }), this.client.core.history.delete(n, i.id)) : this.onRelayEventUnknownPayload({
                    topic: n,
                    payload: i
                })
            } catch (s) {
                this.client.logger.error(s)
            }
        })
    }
    registerExpirerEvents() {
        this.client.core.expirer.on(ic.expired, async e => {
            const {
                topic: n,
                id: r
            } = sne(e.target);
            if (r && this.client.pendingRequest.keys.includes(r)) return await this.deletePendingSessionRequest(r, ut("EXPIRED"), !0);
            n ? this.client.session.keys.includes(n) && (await this.deleteSession(n, !0), this.client.events.emit("session_expire", {
                topic: n
            })) : r && (await this.deleteProposal(r, !0), this.client.events.emit("proposal_expire", {
                id: r
            }))
        })
    }
    registerPairingEvents() {
        this.client.core.pairing.events.on(_3.create, e => this.onPairingCreated(e))
    }
    isValidPairingTopic(e) {
        if (!Ks(e, !1)) {
            const {
                message: n
            } = ut("MISSING_OR_INVALID", `pairing topic should be a string: ${e}`);
            throw new Error(n)
        }
        if (!this.client.core.pairing.pairings.keys.includes(e)) {
            const {
                message: n
            } = ut("NO_MATCHING_KEY", `pairing topic doesn't exist: ${e}`);
            throw new Error(n)
        }
        if (S0(this.client.core.pairing.pairings.get(e).expiry)) {
            const {
                message: n
            } = ut("EXPIRED", `pairing topic: ${e}`);
            throw new Error(n)
        }
    }
    async isValidSessionTopic(e) {
        if (!Ks(e, !1)) {
            const {
                message: n
            } = ut("MISSING_OR_INVALID", `session topic should be a string: ${e}`);
            throw new Error(n)
        }
        if (!this.client.session.keys.includes(e)) {
            const {
                message: n
            } = ut("NO_MATCHING_KEY", `session topic doesn't exist: ${e}`);
            throw new Error(n)
        }
        if (S0(this.client.session.get(e).expiry)) {
            await this.deleteSession(e);
            const {
                message: n
            } = ut("EXPIRED", `session topic: ${e}`);
            throw new Error(n)
        }
    }
    async isValidSessionOrPairingTopic(e) {
        if (this.client.session.keys.includes(e)) await this.isValidSessionTopic(e);
        else if (this.client.core.pairing.pairings.keys.includes(e)) this.isValidPairingTopic(e);
        else if (Ks(e, !1)) {
            const {
                message: n
            } = ut("NO_MATCHING_KEY", `session or pairing topic doesn't exist: ${e}`);
            throw new Error(n)
        } else {
            const {
                message: n
            } = ut("MISSING_OR_INVALID", `session or pairing topic should be a string: ${e}`);
            throw new Error(n)
        }
    }
    async isValidProposalId(e) {
        if (!x8e(e)) {
            const {
                message: n
            } = ut("MISSING_OR_INVALID", `proposal id should be a number: ${e}`);
            throw new Error(n)
        }
        if (!this.client.proposal.keys.includes(e)) {
            const {
                message: n
            } = ut("NO_MATCHING_KEY", `proposal id doesn't exist: ${e}`);
            throw new Error(n)
        }
        if (S0(this.client.proposal.get(e).expiry)) {
            await this.deleteProposal(e);
            const {
                message: n
            } = ut("EXPIRED", `proposal id: ${e}`);
            throw new Error(n)
        }
    }
}
class M7e extends GT {
    constructor(e, n) {
        super(e, n, x7e, vL), this.core = e, this.logger = n
    }
}
let D7e = class extends GT {
    constructor(e, n) {
        super(e, n, S7e, vL), this.core = e, this.logger = n
    }
};
class $7e extends GT {
    constructor(e, n) {
        super(e, n, A7e, vL, r => r.id), this.core = e, this.logger = n
    }
}
let L7e = class Wne extends rAe {
    constructor(e) {
        super(e), this.protocol = Une, this.version = jne, this.name = lO.name, this.events = new uo.EventEmitter, this.on = (r, i) => this.events.on(r, i), this.once = (r, i) => this.events.once(r, i), this.off = (r, i) => this.events.off(r, i), this.removeListener = (r, i) => this.events.removeListener(r, i), this.removeAllListeners = r => this.events.removeAllListeners(r), this.connect = async r => {
            try {
                return await this.engine.connect(r)
            } catch (i) {
                throw this.logger.error(i.message), i
            }
        }, this.pair = async r => {
            try {
                return await this.engine.pair(r)
            } catch (i) {
                throw this.logger.error(i.message), i
            }
        }, this.approve = async r => {
            try {
                return await this.engine.approve(r)
            } catch (i) {
                throw this.logger.error(i.message), i
            }
        }, this.reject = async r => {
            try {
                return await this.engine.reject(r)
            } catch (i) {
                throw this.logger.error(i.message), i
            }
        }, this.update = async r => {
            try {
                return await this.engine.update(r)
            } catch (i) {
                throw this.logger.error(i.message), i
            }
        }, this.extend = async r => {
            try {
                return await this.engine.extend(r)
            } catch (i) {
                throw this.logger.error(i.message), i
            }
        }, this.request = async r => {
            try {
                return await this.engine.request(r)
            } catch (i) {
                throw this.logger.error(i.message), i
            }
        }, this.respond = async r => {
            try {
                return await this.engine.respond(r)
            } catch (i) {
                throw this.logger.error(i.message), i
            }
        }, this.ping = async r => {
            try {
                return await this.engine.ping(r)
            } catch (i) {
                throw this.logger.error(i.message), i
            }
        }, this.emit = async r => {
            try {
                return await this.engine.emit(r)
            } catch (i) {
                throw this.logger.error(i.message), i
            }
        }, this.disconnect = async r => {
            try {
                return await this.engine.disconnect(r)
            } catch (i) {
                throw this.logger.error(i.message), i
            }
        }, this.find = r => {
            try {
                return this.engine.find(r)
            } catch (i) {
                throw this.logger.error(i.message), i
            }
        }, this.getPendingSessionRequests = () => {
            try {
                return this.engine.getPendingSessionRequests()
            } catch (r) {
                throw this.logger.error(r.message), r
            }
        }, this.name = (e == null ? void 0 : e.name) || lO.name, this.metadata = (e == null ? void 0 : e.metadata) || USe();
        const n = typeof(e == null ? void 0 : e.logger) < "u" && typeof(e == null ? void 0 : e.logger) != "string" ? e.logger : jT(HT({
            level: (e == null ? void 0 : e.logger) || lO.logger
        }));
        this.core = (e == null ? void 0 : e.core) || new E7e(e), this.logger = Ja(n, this.name), this.session = new D7e(this.core, this.logger), this.proposal = new M7e(this.core, this.logger), this.pendingRequest = new $7e(this.core, this.logger), this.engine = new k7e(this)
    }
    static async init(e) {
        const n = new Wne(e);
        return await n.initialize(), n
    }
    get context() {
        return Qa(this.logger)
    }
    get pairing() {
        return this.core.pairing.pairings
    }
    async initialize() {
        this.logger.trace("Initialized");
        try {
            await this.core.start(), await this.session.init(), await this.proposal.init(), await this.pendingRequest.init(), await this.engine.init(), this.core.verify.init({
                verifyUrl: this.metadata.verifyUrl
            }), this.logger.info("SignClient Initialization Success")
        } catch (e) {
            throw this.logger.info("SignClient Initialization Failure"), this.logger.error(e.message), e
        }
    }
};
var mk = {
    exports: {}
};
(function(t, e) {
    var n = typeof self < "u" ? self : st,
        r = function() {
            function s() {
                this.fetch = !1, this.DOMException = n.DOMException
            }
            return s.prototype = n, new s
        }();
    (function(s) {
        (function(o) {
            var a = {
                searchParams: "URLSearchParams" in s,
                iterable: "Symbol" in s && "iterator" in Symbol,
                blob: "FileReader" in s && "Blob" in s && function() {
                    try {
                        return new Blob, !0
                    } catch {
                        return !1
                    }
                }(),
                formData: "FormData" in s,
                arrayBuffer: "ArrayBuffer" in s
            };

            function l(m) {
                return m && DataView.prototype.isPrototypeOf(m)
            }
            if (a.arrayBuffer) var c = ["[object Int8Array]", "[object Uint8Array]", "[object Uint8ClampedArray]", "[object Int16Array]", "[object Uint16Array]", "[object Int32Array]", "[object Uint32Array]", "[object Float32Array]", "[object Float64Array]"],
                u = ArrayBuffer.isView || function(m) {
                    return m && c.indexOf(Object.prototype.toString.call(m)) > -1
                };

            function f(m) {
                if (typeof m != "string" && (m = String(m)), /[^a-z0-9\-#$%&'*+.^_`|~]/i.test(m)) throw new TypeError("Invalid character in header field name");
                return m.toLowerCase()
            }

            function h(m) {
                return typeof m != "string" && (m = String(m)), m
            }

            function g(m) {
                var v = {
                    next: function() {
                        var T = m.shift();
                        return {
                            done: T === void 0,
                            value: T
                        }
                    }
                };
                return a.iterable && (v[Symbol.iterator] = function() {
                    return v
                }), v
            }

            function y(m) {
                this.map = {}, m instanceof y ? m.forEach(function(v, T) {
                    this.append(T, v)
                }, this) : Array.isArray(m) ? m.forEach(function(v) {
                    this.append(v[0], v[1])
                }, this) : m && Object.getOwnPropertyNames(m).forEach(function(v) {
                    this.append(v, m[v])
                }, this)
            }
            y.prototype.append = function(m, v) {
                m = f(m), v = h(v);
                var T = this.map[m];
                this.map[m] = T ? T + ", " + v : v
            }, y.prototype.delete = function(m) {
                delete this.map[f(m)]
            }, y.prototype.get = function(m) {
                return m = f(m), this.has(m) ? this.map[m] : null
            }, y.prototype.has = function(m) {
                return this.map.hasOwnProperty(f(m))
            }, y.prototype.set = function(m, v) {
                this.map[f(m)] = h(v)
            }, y.prototype.forEach = function(m, v) {
                for (var T in this.map) this.map.hasOwnProperty(T) && m.call(v, this.map[T], T, this)
            }, y.prototype.keys = function() {
                var m = [];
                return this.forEach(function(v, T) {
                    m.push(T)
                }), g(m)
            }, y.prototype.values = function() {
                var m = [];
                return this.forEach(function(v) {
                    m.push(v)
                }), g(m)
            }, y.prototype.entries = function() {
                var m = [];
                return this.forEach(function(v, T) {
                    m.push([T, v])
                }), g(m)
            }, a.iterable && (y.prototype[Symbol.iterator] = y.prototype.entries);

            function _(m) {
                if (m.bodyUsed) return Promise.reject(new TypeError("Already read"));
                m.bodyUsed = !0
            }

            function C(m) {
                return new Promise(function(v, T) {
                    m.onload = function() {
                        v(m.result)
                    }, m.onerror = function() {
                        T(m.error)
                    }
                })
            }

            function b(m) {
                var v = new FileReader,
                    T = C(v);
                return v.readAsArrayBuffer(m), T
            }

            function w(m) {
                var v = new FileReader,
                    T = C(v);
                return v.readAsText(m), T
            }

            function S(m) {
                for (var v = new Uint8Array(m), T = new Array(v.length), N = 0; N < v.length; N++) T[N] = String.fromCharCode(v[N]);
                return T.join("")
            }

            function I(m) {
                if (m.slice) return m.slice(0);
                var v = new Uint8Array(m.byteLength);
                return v.set(new Uint8Array(m)), v.buffer
            }

            function P() {
                return this.bodyUsed = !1, this._initBody = function(m) {
                    this._bodyInit = m, m ? typeof m == "string" ? this._bodyText = m : a.blob && Blob.prototype.isPrototypeOf(m) ? this._bodyBlob = m : a.formData && FormData.prototype.isPrototypeOf(m) ? this._bodyFormData = m : a.searchParams && URLSearchParams.prototype.isPrototypeOf(m) ? this._bodyText = m.toString() : a.arrayBuffer && a.blob && l(m) ? (this._bodyArrayBuffer = I(m.buffer), this._bodyInit = new Blob([this._bodyArrayBuffer])) : a.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(m) || u(m)) ? this._bodyArrayBuffer = I(m) : this._bodyText = m = Object.prototype.toString.call(m) : this._bodyText = "", this.headers.get("content-type") || (typeof m == "string" ? this.headers.set("content-type", "text/plain;charset=UTF-8") : this._bodyBlob && this._bodyBlob.type ? this.headers.set("content-type", this._bodyBlob.type) : a.searchParams && URLSearchParams.prototype.isPrototypeOf(m) && this.headers.set("content-type", "application/x-www-form-urlencoded;charset=UTF-8"))
                }, a.blob && (this.blob = function() {
                    var m = _(this);
                    if (m) return m;
                    if (this._bodyBlob) return Promise.resolve(this._bodyBlob);
                    if (this._bodyArrayBuffer) return Promise.resolve(new Blob([this._bodyArrayBuffer]));
                    if (this._bodyFormData) throw new Error("could not read FormData body as blob");
                    return Promise.resolve(new Blob([this._bodyText]))
                }, this.arrayBuffer = function() {
                    return this._bodyArrayBuffer ? _(this) || Promise.resolve(this._bodyArrayBuffer) : this.blob().then(b)
                }), this.text = function() {
                    var m = _(this);
                    if (m) return m;
                    if (this._bodyBlob) return w(this._bodyBlob);
                    if (this._bodyArrayBuffer) return Promise.resolve(S(this._bodyArrayBuffer));
                    if (this._bodyFormData) throw new Error("could not read FormData body as text");
                    return Promise.resolve(this._bodyText)
                }, a.formData && (this.formData = function() {
                    return this.text().then($)
                }), this.json = function() {
                    return this.text().then(JSON.parse)
                }, this
            }
            var M = ["DELETE", "GET", "HEAD", "OPTIONS", "POST", "PUT"];

            function A(m) {
                var v = m.toUpperCase();
                return M.indexOf(v) > -1 ? v : m
            }

            function E(m, v) {
                v = v || {};
                var T = v.body;
                if (m instanceof E) {
                    if (m.bodyUsed) throw new TypeError("Already read");
                    this.url = m.url, this.credentials = m.credentials, v.headers || (this.headers = new y(m.headers)), this.method = m.method, this.mode = m.mode, this.signal = m.signal, !T && m._bodyInit != null && (T = m._bodyInit, m.bodyUsed = !0)
                } else this.url = String(m);
                if (this.credentials = v.credentials || this.credentials || "same-origin", (v.headers || !this.headers) && (this.headers = new y(v.headers)), this.method = A(v.method || this.method || "GET"), this.mode = v.mode || this.mode || null, this.signal = v.signal || this.signal, this.referrer = null, (this.method === "GET" || this.method === "HEAD") && T) throw new TypeError("Body not allowed for GET or HEAD requests");
                this._initBody(T)
            }
            E.prototype.clone = function() {
                return new E(this, {
                    body: this._bodyInit
                })
            };

            function $(m) {
                var v = new FormData;
                return m.trim().split("&").forEach(function(T) {
                    if (T) {
                        var N = T.split("="),
                            O = N.shift().replace(/\+/g, " "),
                            L = N.join("=").replace(/\+/g, " ");
                        v.append(decodeURIComponent(O), decodeURIComponent(L))
                    }
                }), v
            }

            function H(m) {
                var v = new y,
                    T = m.replace(/\r?\n[\t ]+/g, " ");
                return T.split(/\r?\n/).forEach(function(N) {
                    var O = N.split(":"),
                        L = O.shift().trim();
                    if (L) {
                        var G = O.join(":").trim();
                        v.append(L, G)
                    }
                }), v
            }
            P.call(E.prototype);

            function K(m, v) {
                v || (v = {}), this.type = "default", this.status = v.status === void 0 ? 200 : v.status, this.ok = this.status >= 200 && this.status < 300, this.statusText = "statusText" in v ? v.statusText : "OK", this.headers = new y(v.headers), this.url = v.url || "", this._initBody(m)
            }
            P.call(K.prototype), K.prototype.clone = function() {
                return new K(this._bodyInit, {
                    status: this.status,
                    statusText: this.statusText,
                    headers: new y(this.headers),
                    url: this.url
                })
            }, K.error = function() {
                var m = new K(null, {
                    status: 0,
                    statusText: ""
                });
                return m.type = "error", m
            };
            var te = [301, 302, 303, 307, 308];
            K.redirect = function(m, v) {
                if (te.indexOf(v) === -1) throw new RangeError("Invalid status code");
                return new K(null, {
                    status: v,
                    headers: {
                        location: m
                    }
                })
            }, o.DOMException = s.DOMException;
            try {
                new o.DOMException
            } catch {
                o.DOMException = function(v, T) {
                    this.message = v, this.name = T;
                    var N = Error(v);
                    this.stack = N.stack
                }, o.DOMException.prototype = Object.create(Error.prototype), o.DOMException.prototype.constructor = o.DOMException
            }

            function U(m, v) {
                return new Promise(function(T, N) {
                    var O = new E(m, v);
                    if (O.signal && O.signal.aborted) return N(new o.DOMException("Aborted", "AbortError"));
                    var L = new XMLHttpRequest;

                    function G() {
                        L.abort()
                    }
                    L.onload = function() {
                        var j = {
                            status: L.status,
                            statusText: L.statusText,
                            headers: H(L.getAllResponseHeaders() || "")
                        };
                        j.url = "responseURL" in L ? L.responseURL : j.headers.get("X-Request-URL");
                        var R = "response" in L ? L.response : L.responseText;
                        T(new K(R, j))
                    }, L.onerror = function() {
                        N(new TypeError("Network request failed"))
                    }, L.ontimeout = function() {
                        N(new TypeError("Network request failed"))
                    }, L.onabort = function() {
                        N(new o.DOMException("Aborted", "AbortError"))
                    }, L.open(O.method, O.url, !0), O.credentials === "include" ? L.withCredentials = !0 : O.credentials === "omit" && (L.withCredentials = !1), "responseType" in L && a.blob && (L.responseType = "blob"), O.headers.forEach(function(j, R) {
                        L.setRequestHeader(R, j)
                    }), O.signal && (O.signal.addEventListener("abort", G), L.onreadystatechange = function() {
                        L.readyState === 4 && O.signal.removeEventListener("abort", G)
                    }), L.send(typeof O._bodyInit > "u" ? null : O._bodyInit)
                })
            }
            return U.polyfill = !0, s.fetch || (s.fetch = U, s.Headers = y, s.Request = E, s.Response = K), o.Headers = y, o.Request = E, o.Response = K, o.fetch = U, Object.defineProperty(o, "__esModule", {
                value: !0
            }), o
        })({})
    })(r), r.fetch.ponyfill = !0, delete r.fetch.polyfill;
    var i = r;
    e = i.fetch, e.default = i.fetch, e.fetch = i.fetch, e.Headers = i.Headers, e.Request = i.Request, e.Response = i.Response, t.exports = e
})(mk, mk.exports);
var B7e = mk.exports;
const UV = co(B7e);
var F7e = Object.defineProperty,
    U7e = Object.defineProperties,
    j7e = Object.getOwnPropertyDescriptors,
    jV = Object.getOwnPropertySymbols,
    H7e = Object.prototype.hasOwnProperty,
    z7e = Object.prototype.propertyIsEnumerable,
    HV = (t, e, n) => e in t ? F7e(t, e, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: n
    }) : t[e] = n,
    zV = (t, e) => {
        for (var n in e || (e = {})) H7e.call(e, n) && HV(t, n, e[n]);
        if (jV)
            for (var n of jV(e)) z7e.call(e, n) && HV(t, n, e[n]);
        return t
    },
    WV = (t, e) => U7e(t, j7e(e));
const W7e = {
        Accept: "application/json",
        "Content-Type": "application/json"
    },
    V7e = "POST",
    VV = {
        headers: W7e,
        method: V7e
    },
    GV = 10;
let og = class {
        constructor(e, n = !1) {
            if (this.url = e, this.disableProviderPing = n, this.events = new uo.EventEmitter, this.isAvailable = !1, this.registering = !1, !pV(e)) throw new Error(`Provided URL is not compatible with HTTP connection: ${e}`);
            this.url = e, this.disableProviderPing = n
        }
        get connected() {
            return this.isAvailable
        }
        get connecting() {
            return this.registering
        }
        on(e, n) {
            this.events.on(e, n)
        }
        once(e, n) {
            this.events.once(e, n)
        }
        off(e, n) {
            this.events.off(e, n)
        }
        removeListener(e, n) {
            this.events.removeListener(e, n)
        }
        async open(e = this.url) {
            await this.register(e)
        }
        async close() {
            if (!this.isAvailable) throw new Error("Connection already closed");
            this.onClose()
        }
        async send(e) {
            this.isAvailable || await this.register();
            try {
                const n = Pm(e),
                    r = await (await UV(this.url, WV(zV({}, VV), {
                        body: n
                    }))).json();
                this.onPayload({
                    data: r
                })
            } catch (n) {
                this.onError(e.id, n)
            }
        }
        async register(e = this.url) {
            if (!pV(e)) throw new Error(`Provided URL is not compatible with HTTP connection: ${e}`);
            if (this.registering) {
                const n = this.events.getMaxListeners();
                return (this.events.listenerCount("register_error") >= n || this.events.listenerCount("open") >= n) && this.events.setMaxListeners(n + 1), new Promise((r, i) => {
                    this.events.once("register_error", s => {
                        this.resetMaxListeners(), i(s)
                    }), this.events.once("open", () => {
                        if (this.resetMaxListeners(), typeof this.isAvailable > "u") return i(new Error("HTTP connection is missing or invalid"));
                        r()
                    })
                })
            }
            this.url = e, this.registering = !0;
            try {
                if (!this.disableProviderPing) {
                    const n = Pm({
                        id: 1,
                        jsonrpc: "2.0",
                        method: "test",
                        params: []
                    });
                    await UV(e, WV(zV({}, VV), {
                        body: n
                    }))
                }
                this.onOpen()
            } catch (n) {
                const r = this.parseError(n);
                throw this.events.emit("register_error", r), this.onClose(), r
            }
        }
        onOpen() {
            this.isAvailable = !0, this.registering = !1, this.events.emit("open")
        }
        onClose() {
            this.isAvailable = !1, this.registering = !1, this.events.emit("close")
        }
        onPayload(e) {
            if (typeof e.data > "u") return;
            const n = typeof e.data == "string" ? SE(e.data) : e.data;
            this.events.emit("payload", n)
        }
        onError(e, n) {
            const r = this.parseError(n),
                i = r.message || r.toString(),
                s = WT(e, i);
            this.events.emit("payload", s)
        }
        parseError(e, n = this.url) {
            return bne(e, n, "HTTP")
        }
        resetMaxListeners() {
            this.events.getMaxListeners() > GV && this.events.setMaxListeners(GV)
        }
    },
    ag = class extends Ene {
        constructor(e) {
            super(e), this.events = new uo.EventEmitter, this.hasRegisteredEventListeners = !1, this.connection = this.setConnection(e), this.connection.connected && this.registerEventListeners()
        }
        async connect(e = this.connection) {
            await this.open(e)
        }
        async disconnect() {
            await this.close()
        }
        on(e, n) {
            this.events.on(e, n)
        }
        once(e, n) {
            this.events.once(e, n)
        }
        off(e, n) {
            this.events.off(e, n)
        }
        removeListener(e, n) {
            this.events.removeListener(e, n)
        }
        async request(e, n) {
            return this.requestStrict(em(e.method, e.params || [], e.id || mL().toString()), n)
        }
        async requestStrict(e, n) {
            return new Promise(async (r, i) => {
                if (!this.connection.connected) try {
                    await this.open()
                } catch (s) {
                    i(s)
                }
                this.events.on(`${e.id}`, s => {
                    pc(s) ? i(s.error) : r(s.result)
                });
                try {
                    await this.connection.send(e, n)
                } catch (s) {
                    i(s)
                }
            })
        }
        setConnection(e = this.connection) {
            return e
        }
        onPayload(e) {
            this.events.emit("payload", e), AE(e) ? this.events.emit(`${e.id}`, e) : this.events.emit("message", {
                type: e.method,
                data: e.params
            })
        }
        onClose(e) {
            e && e.code === 3e3 && this.events.emit("error", new Error(`WebSocket connection closed abnormally with code: ${e.code} ${e.reason?`(${e.reason})`:""}`)), this.events.emit("disconnect")
        }
        async open(e = this.connection) {
            this.connection === e && this.connection.connected || (this.connection.connected && this.close(), typeof e == "string" && (await this.connection.open(e), e = this.connection), this.connection = this.setConnection(e), await this.connection.open(), this.registerEventListeners(), this.events.emit("connect"))
        }
        async close() {
            await this.connection.close()
        }
        registerEventListeners() {
            this.hasRegisteredEventListeners || (this.connection.on("payload", e => this.onPayload(e)), this.connection.on("close", e => this.onClose(e)), this.connection.on("error", e => this.events.emit("error", e)), this.connection.on("register_error", e => this.onClose()), this.hasRegisteredEventListeners = !0)
        }
    };
const qV = "error",
    G7e = "wss://relay.walletconnect.com",
    q7e = "wc",
    K7e = "universal_provider",
    KV = `${q7e}@2:${K7e}:`,
    Y7e = "https://rpc.walletconnect.com/v1/",
    jh = {
        DEFAULT_CHAIN_CHANGED: "default_chain_changed"
    };
var H5 = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {},
    yk = {
        exports: {}
    };
/**
 * @license
 * Lodash <https://lodash.com/>
 * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */
(function(t, e) {
    (function() {
        var n, r = "4.17.21",
            i = 200,
            s = "Unsupported core-js use. Try https://npms.io/search?q=ponyfill.",
            o = "Expected a function",
            a = "Invalid `variable` option passed into `_.template`",
            l = "__lodash_hash_undefined__",
            c = 500,
            u = "__lodash_placeholder__",
            f = 1,
            h = 2,
            g = 4,
            y = 1,
            _ = 2,
            C = 1,
            b = 2,
            w = 4,
            S = 8,
            I = 16,
            P = 32,
            M = 64,
            A = 128,
            E = 256,
            $ = 512,
            H = 30,
            K = "...",
            te = 800,
            U = 16,
            m = 1,
            v = 2,
            T = 3,
            N = 1 / 0,
            O = 9007199254740991,
            L = 17976931348623157e292,
            G = NaN,
            j = 4294967295,
            R = j - 1,
            Y = j >>> 1,
            ve = [
                ["ary", A],
                ["bind", C],
                ["bindKey", b],
                ["curry", S],
                ["curryRight", I],
                ["flip", $],
                ["partial", P],
                ["partialRight", M],
                ["rearg", E]
            ],
            V = "[object Arguments]",
            X = "[object Array]",
            q = "[object AsyncFunction]",
            ne = "[object Boolean]",
            ie = "[object Date]",
            k = "[object DOMException]",
            z = "[object Error]",
            Z = "[object Function]",
            ge = "[object GeneratorFunction]",
            me = "[object Map]",
            Re = "[object Number]",
            He = "[object Null]",
            Be = "[object Object]",
            bt = "[object Promise]",
            mn = "[object Proxy]",
            at = "[object RegExp]",
            tt = "[object Set]",
            _t = "[object String]",
            ot = "[object Symbol]",
            lt = "[object Undefined]",
            wt = "[object WeakMap]",
            Xe = "[object WeakSet]",
            Q = "[object ArrayBuffer]",
            D = "[object DataView]",
            B = "[object Float32Array]",
            se = "[object Float64Array]",
            de = "[object Int8Array]",
            ye = "[object Int16Array]",
            Se = "[object Int32Array]",
            nt = "[object Uint8Array]",
            Ke = "[object Uint8ClampedArray]",
            mt = "[object Uint16Array]",
            en = "[object Uint32Array]",
            vt = /\b__p \+= '';/g,
            hn = /\b(__p \+=) '' \+/g,
            ui = /(__e\(.*?\)|\b__t\)) \+\n'';/g,
            bn = /&(?:amp|lt|gt|quot|#39);/g,
            On = /[&<>"']/g,
            Un = RegExp(bn.source),
            Lt = RegExp(On.source),
            jt = /<%-([\s\S]+?)%>/g,
            qn = /<%([\s\S]+?)%>/g,
            Ht = /<%=([\s\S]+?)%>/g,
            zt = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
            Jn = /^\w*$/,
            Vt = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g,
            Ft = /[\\^$.*+?()[\]{}|]/g,
            Xn = RegExp(Ft.source),
            Kt = /^\s+/,
            Qt = /\s/,
            fe = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/,
            he = /\{\n\/\* \[wrapped with (.+)\] \*/,
            be = /,? & /,
            Pe = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g,
            qe = /[()=,{}\[\]\/\s]/,
            Je = /\\(\\)?/g,
            Mt = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g,
            Le = /\w*$/,
            rt = /^[-+]0x[0-9a-f]+$/i,
            ct = /^0b[01]+$/i,
            ft = /^\[object .+?Constructor\]$/,
            an = /^0o[0-7]+$/i,
            pn = /^(?:0|[1-9]\d*)$/,
            ln = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g,
            cn = /($^)/,
            Er = /['\n\r\u2028\u2029\\]/g,
            er = "\\ud800-\\udfff",
            Js = "\\u0300-\\u036f",
            Qi = "\\ufe20-\\ufe2f",
            Ji = "\\u20d0-\\u20ff",
            Xi = Js + Qi + Ji,
            Xs = "\\u2700-\\u27bf",
            Tr = "a-z\\xdf-\\xf6\\xf8-\\xff",
            Fl = "\\xac\\xb1\\xd7\\xf7",
            Ul = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf",
            jl = "\\u2000-\\u206f",
            un = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000",
            wr = "A-Z\\xc0-\\xd6\\xd8-\\xde",
            Ms = "\\ufe0e\\ufe0f",
            xr = Fl + Ul + jl + un,
            jo = "[']",
            Yu = "[" + er + "]",
            yg = "[" + xr + "]",
            wg = "[" + Xi + "]",
            R4 = "\\d+",
            dI = "[" + Xs + "]",
            O4 = "[" + Tr + "]",
            N4 = "[^" + er + xr + R4 + Xs + Tr + wr + "]",
            ky = "\\ud83c[\\udffb-\\udfff]",
            hI = "(?:" + wg + "|" + ky + ")",
            P4 = "[^" + er + "]",
            My = "(?:\\ud83c[\\udde6-\\uddff]){2}",
            Yh = "[\\ud800-\\udbff][\\udc00-\\udfff]",
            el = "[" + wr + "]",
            k4 = "\\u200d",
            M4 = "(?:" + O4 + "|" + N4 + ")",
            Zu = "(?:" + el + "|" + N4 + ")",
            D4 = "(?:" + jo + "(?:d|ll|m|re|s|t|ve))?",
            $4 = "(?:" + jo + "(?:D|LL|M|RE|S|T|VE))?",
            L4 = hI + "?",
            B4 = "[" + Ms + "]?",
            pI = "(?:" + k4 + "(?:" + [P4, My, Yh].join("|") + ")" + B4 + L4 + ")*",
            md = "\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])",
            F4 = "\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])",
            U4 = B4 + L4 + pI,
            Dy = "(?:" + [dI, My, Yh].join("|") + ")" + U4,
            gI = "(?:" + [P4 + wg + "?", wg, My, Yh, Yu].join("|") + ")",
            h5 = RegExp(jo, "g"),
            mI = RegExp(wg, "g"),
            $y = RegExp(ky + "(?=" + ky + ")|" + gI + U4, "g"),
            j4 = RegExp([el + "?" + O4 + "+" + D4 + "(?=" + [yg, el, "$"].join("|") + ")", Zu + "+" + $4 + "(?=" + [yg, el + M4, "$"].join("|") + ")", el + "?" + M4 + "+" + D4, el + "+" + $4, F4, md, R4, Dy].join("|"), "g"),
            H4 = RegExp("[" + k4 + er + Xi + Ms + "]"),
            vg = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/,
            z4 = ["Array", "Buffer", "DataView", "Date", "Error", "Float32Array", "Float64Array", "Function", "Int8Array", "Int16Array", "Int32Array", "Map", "Math", "Object", "Promise", "RegExp", "Set", "String", "Symbol", "TypeError", "Uint8Array", "Uint8ClampedArray", "Uint16Array", "Uint32Array", "WeakMap", "_", "clearTimeout", "isFinite", "parseInt", "setTimeout"],
            yI = -1,
            Br = {};
        Br[B] = Br[se] = Br[de] = Br[ye] = Br[Se] = Br[nt] = Br[Ke] = Br[mt] = Br[en] = !0, Br[V] = Br[X] = Br[Q] = Br[ne] = Br[D] = Br[ie] = Br[z] = Br[Z] = Br[me] = Br[Re] = Br[Be] = Br[at] = Br[tt] = Br[_t] = Br[wt] = !1;
        var Nr = {};
        Nr[V] = Nr[X] = Nr[Q] = Nr[D] = Nr[ne] = Nr[ie] = Nr[B] = Nr[se] = Nr[de] = Nr[ye] = Nr[Se] = Nr[me] = Nr[Re] = Nr[Be] = Nr[at] = Nr[tt] = Nr[_t] = Nr[ot] = Nr[nt] = Nr[Ke] = Nr[mt] = Nr[en] = !0, Nr[z] = Nr[Z] = Nr[wt] = !1;
        var ue = {
                : "A",
                : "A",
                : "A",
                : "A",
                : "A",
                : "A",
                : "a",
                : "a",
                : "a",
                : "a",
                : "a",
                : "a",
                : "C",
                : "c",
                : "D",
                : "d",
                : "E",
                : "E",
                : "E",
                : "E",
                : "e",
                : "e",
                : "e",
                : "e",
                : "I",
                : "I",
                : "I",
                : "I",
                : "i",
                : "i",
                : "i",
                : "i",
                : "N",
                : "n",
                : "O",
                : "O",
                : "O",
                : "O",
                : "O",
                : "O",
                : "o",
                : "o",
                : "o",
                : "o",
                : "o",
                : "o",
                : "U",
                : "U",
                : "U",
                : "U",
                : "u",
                : "u",
                : "u",
                : "u",
                : "Y",
                : "y",
                : "y",
                : "Ae",
                : "ae",
                : "Th",
                : "th",
                : "ss",
                : "A",
                : "A",
                : "A",
                : "a",
                : "a",
                : "a",
                : "C",
                : "C",
                : "C",
                : "C",
                : "c",
                : "c",
                : "c",
                : "c",
                : "D",
                : "D",
                : "d",
                : "d",
                : "E",
                : "E",
                : "E",
                : "E",
                : "E",
                : "e",
                : "e",
                : "e",
                : "e",
                : "e",
                : "G",
                : "G",
                : "G",
                : "G",
                : "g",
                : "g",
                : "g",
                : "g",
                : "H",
                : "H",
                : "h",
                : "h",
                : "I",
                : "I",
                : "I",
                : "I",
                : "I",
                : "i",
                : "i",
                : "i",
                : "i",
                : "i",
                : "J",
                : "j",
                : "K",
                : "k",
                : "k",
                : "L",
                : "L",
                : "L",
                : "L",
                : "L",
                : "l",
                : "l",
                : "l",
                : "l",
                : "l",
                : "N",
                : "N",
                : "N",
                : "N",
                : "n",
                : "n",
                : "n",
                : "n",
                : "O",
                : "O",
                : "O",
                : "o",
                : "o",
                : "o",
                : "R",
                : "R",
                : "R",
                : "r",
                : "r",
                : "r",
                : "S",
                : "S",
                : "S",
                : "S",
                : "s",
                : "s",
                : "s",
                : "s",
                : "T",
                : "T",
                : "T",
                : "t",
                : "t",
                : "t",
                : "U",
                : "U",
                : "U",
                : "U",
                : "U",
                : "U",
                : "u",
                : "u",
                : "u",
                : "u",
                : "u",
                : "u",
                : "W",
                : "w",
                : "Y",
                : "y",
                : "Y",
                : "Z",
                : "Z",
                : "Z",
                : "z",
                : "z",
                : "z",
                : "IJ",
                : "ij",
                : "Oe",
                : "oe",
                : "'n",
                : "s"
            },
            Ce = {
                "&": "&amp;",
                "<": "&lt;",
                ">": "&gt;",
                '"': "&quot;",
                "'": "&#39;"
            },
            ze = {
                "&amp;": "&",
                "&lt;": "<",
                "&gt;": ">",
                "&quot;": '"',
                "&#39;": "'"
            },
            xt = {
                "\\": "\\",
                "'": "'",
                "\n": "n",
                "\r": "r",
                "\u2028": "u2028",
                "\u2029": "u2029"
            },
            Fr = parseFloat,
            _n = parseInt,
            ei = typeof H5 == "object" && H5 && H5.Object === Object && H5,
            hs = typeof self == "object" && self && self.Object === Object && self,
            tr = ei || hs || Function("return this")(),
            Ur = e && !e.nodeType && e,
            es = Ur && !0 && t && !t.nodeType && t,
            _a = es && es.exports === Ur,
            ps = _a && ei.process,
            ti = function() {
                try {
                    var Ae = es && es.require && es.require("util").types;
                    return Ae || ps && ps.binding && ps.binding("util")
                } catch {}
            }(),
            Ho = ti && ti.isArrayBuffer,
            jc = ti && ti.isDate,
            Hl = ti && ti.isMap,
            Qu = ti && ti.isRegExp,
            p5 = ti && ti.isSet,
            bg = ti && ti.isTypedArray;

        function Ds(Ae, Me, Ne) {
            switch (Ne.length) {
                case 0:
                    return Ae.call(Me);
                case 1:
                    return Ae.call(Me, Ne[0]);
                case 2:
                    return Ae.call(Me, Ne[0], Ne[1]);
                case 3:
                    return Ae.call(Me, Ne[0], Ne[1], Ne[2])
            }
            return Ae.apply(Me, Ne)
        }

        function Uhe(Ae, Me, Ne, St) {
            for (var yn = -1, vr = Ae == null ? 0 : Ae.length; ++yn < vr;) {
                var Ss = Ae[yn];
                Me(St, Ss, Ne(Ss), Ae)
            }
            return St
        }

        function zl(Ae, Me) {
            for (var Ne = -1, St = Ae == null ? 0 : Ae.length; ++Ne < St && Me(Ae[Ne], Ne, Ae) !== !1;);
            return Ae
        }

        function jhe(Ae, Me) {
            for (var Ne = Ae == null ? 0 : Ae.length; Ne-- && Me(Ae[Ne], Ne, Ae) !== !1;);
            return Ae
        }

        function uj(Ae, Me) {
            for (var Ne = -1, St = Ae == null ? 0 : Ae.length; ++Ne < St;)
                if (!Me(Ae[Ne], Ne, Ae)) return !1;
            return !0
        }

        function Zh(Ae, Me) {
            for (var Ne = -1, St = Ae == null ? 0 : Ae.length, yn = 0, vr = []; ++Ne < St;) {
                var Ss = Ae[Ne];
                Me(Ss, Ne, Ae) && (vr[yn++] = Ss)
            }
            return vr
        }

        function W4(Ae, Me) {
            var Ne = Ae == null ? 0 : Ae.length;
            return !!Ne && Ly(Ae, Me, 0) > -1
        }

        function wI(Ae, Me, Ne) {
            for (var St = -1, yn = Ae == null ? 0 : Ae.length; ++St < yn;)
                if (Ne(Me, Ae[St])) return !0;
            return !1
        }

        function fi(Ae, Me) {
            for (var Ne = -1, St = Ae == null ? 0 : Ae.length, yn = Array(St); ++Ne < St;) yn[Ne] = Me(Ae[Ne], Ne, Ae);
            return yn
        }

        function Qh(Ae, Me) {
            for (var Ne = -1, St = Me.length, yn = Ae.length; ++Ne < St;) Ae[yn + Ne] = Me[Ne];
            return Ae
        }

        function vI(Ae, Me, Ne, St) {
            var yn = -1,
                vr = Ae == null ? 0 : Ae.length;
            for (St && vr && (Ne = Ae[++yn]); ++yn < vr;) Ne = Me(Ne, Ae[yn], yn, Ae);
            return Ne
        }

        function Hhe(Ae, Me, Ne, St) {
            var yn = Ae == null ? 0 : Ae.length;
            for (St && yn && (Ne = Ae[--yn]); yn--;) Ne = Me(Ne, Ae[yn], yn, Ae);
            return Ne
        }

        function bI(Ae, Me) {
            for (var Ne = -1, St = Ae == null ? 0 : Ae.length; ++Ne < St;)
                if (Me(Ae[Ne], Ne, Ae)) return !0;
            return !1
        }
        var zhe = _I("length");

        function Whe(Ae) {
            return Ae.split("")
        }

        function Vhe(Ae) {
            return Ae.match(Pe) || []
        }

        function fj(Ae, Me, Ne) {
            var St;
            return Ne(Ae, function(yn, vr, Ss) {
                if (Me(yn, vr, Ss)) return St = vr, !1
            }), St
        }

        function V4(Ae, Me, Ne, St) {
            for (var yn = Ae.length, vr = Ne + (St ? 1 : -1); St ? vr-- : ++vr < yn;)
                if (Me(Ae[vr], vr, Ae)) return vr;
            return -1
        }

        function Ly(Ae, Me, Ne) {
            return Me === Me ? r0e(Ae, Me, Ne) : V4(Ae, dj, Ne)
        }

        function Ghe(Ae, Me, Ne, St) {
            for (var yn = Ne - 1, vr = Ae.length; ++yn < vr;)
                if (St(Ae[yn], Me)) return yn;
            return -1
        }

        function dj(Ae) {
            return Ae !== Ae
        }

        function hj(Ae, Me) {
            var Ne = Ae == null ? 0 : Ae.length;
            return Ne ? xI(Ae, Me) / Ne : G
        }

        function _I(Ae) {
            return function(Me) {
                return Me == null ? n : Me[Ae]
            }
        }

        function EI(Ae) {
            return function(Me) {
                return Ae == null ? n : Ae[Me]
            }
        }

        function pj(Ae, Me, Ne, St, yn) {
            return yn(Ae, function(vr, Ss, jr) {
                Ne = St ? (St = !1, vr) : Me(Ne, vr, Ss, jr)
            }), Ne
        }

        function qhe(Ae, Me) {
            var Ne = Ae.length;
            for (Ae.sort(Me); Ne--;) Ae[Ne] = Ae[Ne].value;
            return Ae
        }

        function xI(Ae, Me) {
            for (var Ne, St = -1, yn = Ae.length; ++St < yn;) {
                var vr = Me(Ae[St]);
                vr !== n && (Ne = Ne === n ? vr : Ne + vr)
            }
            return Ne
        }

        function SI(Ae, Me) {
            for (var Ne = -1, St = Array(Ae); ++Ne < Ae;) St[Ne] = Me(Ne);
            return St
        }

        function Khe(Ae, Me) {
            return fi(Me, function(Ne) {
                return [Ne, Ae[Ne]]
            })
        }

        function gj(Ae) {
            return Ae && Ae.slice(0, vj(Ae) + 1).replace(Kt, "")
        }

        function tl(Ae) {
            return function(Me) {
                return Ae(Me)
            }
        }

        function CI(Ae, Me) {
            return fi(Me, function(Ne) {
                return Ae[Ne]
            })
        }

        function g5(Ae, Me) {
            return Ae.has(Me)
        }

        function mj(Ae, Me) {
            for (var Ne = -1, St = Ae.length; ++Ne < St && Ly(Me, Ae[Ne], 0) > -1;);
            return Ne
        }

        function yj(Ae, Me) {
            for (var Ne = Ae.length; Ne-- && Ly(Me, Ae[Ne], 0) > -1;);
            return Ne
        }

        function Yhe(Ae, Me) {
            for (var Ne = Ae.length, St = 0; Ne--;) Ae[Ne] === Me && ++St;
            return St
        }
        var Zhe = EI(ue),
            Qhe = EI(Ce);

        function Jhe(Ae) {
            return "\\" + xt[Ae]
        }

        function Xhe(Ae, Me) {
            return Ae == null ? n : Ae[Me]
        }

        function By(Ae) {
            return H4.test(Ae)
        }

        function e0e(Ae) {
            return vg.test(Ae)
        }

        function t0e(Ae) {
            for (var Me, Ne = []; !(Me = Ae.next()).done;) Ne.push(Me.value);
            return Ne
        }

        function AI(Ae) {
            var Me = -1,
                Ne = Array(Ae.size);
            return Ae.forEach(function(St, yn) {
                Ne[++Me] = [yn, St]
            }), Ne
        }

        function wj(Ae, Me) {
            return function(Ne) {
                return Ae(Me(Ne))
            }
        }

        function Jh(Ae, Me) {
            for (var Ne = -1, St = Ae.length, yn = 0, vr = []; ++Ne < St;) {
                var Ss = Ae[Ne];
                (Ss === Me || Ss === u) && (Ae[Ne] = u, vr[yn++] = Ne)
            }
            return vr
        }

        function G4(Ae) {
            var Me = -1,
                Ne = Array(Ae.size);
            return Ae.forEach(function(St) {
                Ne[++Me] = St
            }), Ne
        }

        function n0e(Ae) {
            var Me = -1,
                Ne = Array(Ae.size);
            return Ae.forEach(function(St) {
                Ne[++Me] = [St, St]
            }), Ne
        }

        function r0e(Ae, Me, Ne) {
            for (var St = Ne - 1, yn = Ae.length; ++St < yn;)
                if (Ae[St] === Me) return St;
            return -1
        }

        function i0e(Ae, Me, Ne) {
            for (var St = Ne + 1; St--;)
                if (Ae[St] === Me) return St;
            return St
        }

        function Fy(Ae) {
            return By(Ae) ? o0e(Ae) : zhe(Ae)
        }

        function Hc(Ae) {
            return By(Ae) ? a0e(Ae) : Whe(Ae)
        }

        function vj(Ae) {
            for (var Me = Ae.length; Me-- && Qt.test(Ae.charAt(Me)););
            return Me
        }
        var s0e = EI(ze);

        function o0e(Ae) {
            for (var Me = $y.lastIndex = 0; $y.test(Ae);) ++Me;
            return Me
        }

        function a0e(Ae) {
            return Ae.match($y) || []
        }

        function l0e(Ae) {
            return Ae.match(j4) || []
        }
        var c0e = function Ae(Me) {
                Me = Me == null ? tr : Uy.defaults(tr.Object(), Me, Uy.pick(tr, z4));
                var Ne = Me.Array,
                    St = Me.Date,
                    yn = Me.Error,
                    vr = Me.Function,
                    Ss = Me.Math,
                    jr = Me.Object,
                    TI = Me.RegExp,
                    u0e = Me.String,
                    Wl = Me.TypeError,
                    q4 = Ne.prototype,
                    f0e = vr.prototype,
                    jy = jr.prototype,
                    K4 = Me["__core-js_shared__"],
                    Y4 = f0e.toString,
                    Ir = jy.hasOwnProperty,
                    d0e = 0,
                    bj = function() {
                        var d = /[^.]+$/.exec(K4 && K4.keys && K4.keys.IE_PROTO || "");
                        return d ? "Symbol(src)_1." + d : ""
                    }(),
                    Z4 = jy.toString,
                    h0e = Y4.call(jr),
                    p0e = tr._,
                    g0e = TI("^" + Y4.call(Ir).replace(Ft, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"),
                    Q4 = _a ? Me.Buffer : n,
                    Xh = Me.Symbol,
                    J4 = Me.Uint8Array,
                    _j = Q4 ? Q4.allocUnsafe : n,
                    X4 = wj(jr.getPrototypeOf, jr),
                    Ej = jr.create,
                    xj = jy.propertyIsEnumerable,
                    ex = q4.splice,
                    Sj = Xh ? Xh.isConcatSpreadable : n,
                    m5 = Xh ? Xh.iterator : n,
                    _g = Xh ? Xh.toStringTag : n,
                    tx = function() {
                        try {
                            var d = Ag(jr, "defineProperty");
                            return d({}, "", {}), d
                        } catch {}
                    }(),
                    m0e = Me.clearTimeout !== tr.clearTimeout && Me.clearTimeout,
                    y0e = St && St.now !== tr.Date.now && St.now,
                    w0e = Me.setTimeout !== tr.setTimeout && Me.setTimeout,
                    nx = Ss.ceil,
                    rx = Ss.floor,
                    II = jr.getOwnPropertySymbols,
                    v0e = Q4 ? Q4.isBuffer : n,
                    Cj = Me.isFinite,
                    b0e = q4.join,
                    _0e = wj(jr.keys, jr),
                    Cs = Ss.max,
                    po = Ss.min,
                    E0e = St.now,
                    x0e = Me.parseInt,
                    Aj = Ss.random,
                    S0e = q4.reverse,
                    RI = Ag(Me, "DataView"),
                    y5 = Ag(Me, "Map"),
                    OI = Ag(Me, "Promise"),
                    Hy = Ag(Me, "Set"),
                    w5 = Ag(Me, "WeakMap"),
                    v5 = Ag(jr, "create"),
                    ix = w5 && new w5,
                    zy = {},
                    C0e = Tg(RI),
                    A0e = Tg(y5),
                    T0e = Tg(OI),
                    I0e = Tg(Hy),
                    R0e = Tg(w5),
                    sx = Xh ? Xh.prototype : n,
                    b5 = sx ? sx.valueOf : n,
                    Tj = sx ? sx.toString : n;

                function oe(d) {
                    if (Li(d) && !En(d) && !(d instanceof Kn)) {
                        if (d instanceof Vl) return d;
                        if (Ir.call(d, "__wrapped__")) return IH(d)
                    }
                    return new Vl(d)
                }
                var Wy = function() {
                    function d() {}
                    return function(p) {
                        if (!_i(p)) return {};
                        if (Ej) return Ej(p);
                        d.prototype = p;
                        var x = new d;
                        return d.prototype = n, x
                    }
                }();

                function ox() {}

                function Vl(d, p) {
                    this.__wrapped__ = d, this.__actions__ = [], this.__chain__ = !!p, this.__index__ = 0, this.__values__ = n
                }
                oe.templateSettings = {
                    escape: jt,
                    evaluate: qn,
                    interpolate: Ht,
                    variable: "",
                    imports: {
                        _: oe
                    }
                }, oe.prototype = ox.prototype, oe.prototype.constructor = oe, Vl.prototype = Wy(ox.prototype), Vl.prototype.constructor = Vl;

                function Kn(d) {
                    this.__wrapped__ = d, this.__actions__ = [], this.__dir__ = 1, this.__filtered__ = !1, this.__iteratees__ = [], this.__takeCount__ = j, this.__views__ = []
                }

                function O0e() {
                    var d = new Kn(this.__wrapped__);
                    return d.__actions__ = Ea(this.__actions__), d.__dir__ = this.__dir__, d.__filtered__ = this.__filtered__, d.__iteratees__ = Ea(this.__iteratees__), d.__takeCount__ = this.__takeCount__, d.__views__ = Ea(this.__views__), d
                }

                function N0e() {
                    if (this.__filtered__) {
                        var d = new Kn(this);
                        d.__dir__ = -1, d.__filtered__ = !0
                    } else d = this.clone(), d.__dir__ *= -1;
                    return d
                }

                function P0e() {
                    var d = this.__wrapped__.value(),
                        p = this.__dir__,
                        x = En(d),
                        F = p < 0,
                        ee = x ? d.length : 0,
                        ce = Wpe(0, ee, this.__views__),
                        pe = ce.start,
                        we = ce.end,
                        Te = we - pe,
                        Fe = F ? we : pe - 1,
                        Ue = this.__iteratees__,
                        Ge = Ue.length,
                        dt = 0,
                        $t = po(Te, this.__takeCount__);
                    if (!x || !F && ee == Te && $t == Te) return Qj(d, this.__actions__);
                    var nn = [];
                    e: for (; Te-- && dt < $t;) {
                        Fe += p;
                        for (var Nn = -1, rn = d[Fe]; ++Nn < Ge;) {
                            var Wn = Ue[Nn],
                                nr = Wn.iteratee,
                                il = Wn.type,
                                Vo = nr(rn);
                            if (il == v) rn = Vo;
                            else if (!Vo) {
                                if (il == m) continue e;
                                break e
                            }
                        }
                        nn[dt++] = rn
                    }
                    return nn
                }
                Kn.prototype = Wy(ox.prototype), Kn.prototype.constructor = Kn;

                function Eg(d) {
                    var p = -1,
                        x = d == null ? 0 : d.length;
                    for (this.clear(); ++p < x;) {
                        var F = d[p];
                        this.set(F[0], F[1])
                    }
                }

                function k0e() {
                    this.__data__ = v5 ? v5(null) : {}, this.size = 0
                }

                function M0e(d) {
                    var p = this.has(d) && delete this.__data__[d];
                    return this.size -= p ? 1 : 0, p
                }

                function D0e(d) {
                    var p = this.__data__;
                    if (v5) {
                        var x = p[d];
                        return x === l ? n : x
                    }
                    return Ir.call(p, d) ? p[d] : n
                }

                function $0e(d) {
                    var p = this.__data__;
                    return v5 ? p[d] !== n : Ir.call(p, d)
                }

                function L0e(d, p) {
                    var x = this.__data__;
                    return this.size += this.has(d) ? 0 : 1, x[d] = v5 && p === n ? l : p, this
                }
                Eg.prototype.clear = k0e, Eg.prototype.delete = M0e, Eg.prototype.get = D0e, Eg.prototype.has = $0e, Eg.prototype.set = L0e;

                function yd(d) {
                    var p = -1,
                        x = d == null ? 0 : d.length;
                    for (this.clear(); ++p < x;) {
                        var F = d[p];
                        this.set(F[0], F[1])
                    }
                }

                function B0e() {
                    this.__data__ = [], this.size = 0
                }

                function F0e(d) {
                    var p = this.__data__,
                        x = ax(p, d);
                    if (x < 0) return !1;
                    var F = p.length - 1;
                    return x == F ? p.pop() : ex.call(p, x, 1), --this.size, !0
                }

                function U0e(d) {
                    var p = this.__data__,
                        x = ax(p, d);
                    return x < 0 ? n : p[x][1]
                }

                function j0e(d) {
                    return ax(this.__data__, d) > -1
                }

                function H0e(d, p) {
                    var x = this.__data__,
                        F = ax(x, d);
                    return F < 0 ? (++this.size, x.push([d, p])) : x[F][1] = p, this
                }
                yd.prototype.clear = B0e, yd.prototype.delete = F0e, yd.prototype.get = U0e, yd.prototype.has = j0e, yd.prototype.set = H0e;

                function wd(d) {
                    var p = -1,
                        x = d == null ? 0 : d.length;
                    for (this.clear(); ++p < x;) {
                        var F = d[p];
                        this.set(F[0], F[1])
                    }
                }

                function z0e() {
                    this.size = 0, this.__data__ = {
                        hash: new Eg,
                        map: new(y5 || yd),
                        string: new Eg
                    }
                }

                function W0e(d) {
                    var p = vx(this, d).delete(d);
                    return this.size -= p ? 1 : 0, p
                }

                function V0e(d) {
                    return vx(this, d).get(d)
                }

                function G0e(d) {
                    return vx(this, d).has(d)
                }

                function q0e(d, p) {
                    var x = vx(this, d),
                        F = x.size;
                    return x.set(d, p), this.size += x.size == F ? 0 : 1, this
                }
                wd.prototype.clear = z0e, wd.prototype.delete = W0e, wd.prototype.get = V0e, wd.prototype.has = G0e, wd.prototype.set = q0e;

                function xg(d) {
                    var p = -1,
                        x = d == null ? 0 : d.length;
                    for (this.__data__ = new wd; ++p < x;) this.add(d[p])
                }

                function K0e(d) {
                    return this.__data__.set(d, l), this
                }

                function Y0e(d) {
                    return this.__data__.has(d)
                }
                xg.prototype.add = xg.prototype.push = K0e, xg.prototype.has = Y0e;

                function zc(d) {
                    var p = this.__data__ = new yd(d);
                    this.size = p.size
                }

                function Z0e() {
                    this.__data__ = new yd, this.size = 0
                }

                function Q0e(d) {
                    var p = this.__data__,
                        x = p.delete(d);
                    return this.size = p.size, x
                }

                function J0e(d) {
                    return this.__data__.get(d)
                }

                function X0e(d) {
                    return this.__data__.has(d)
                }

                function epe(d, p) {
                    var x = this.__data__;
                    if (x instanceof yd) {
                        var F = x.__data__;
                        if (!y5 || F.length < i - 1) return F.push([d, p]), this.size = ++x.size, this;
                        x = this.__data__ = new wd(F)
                    }
                    return x.set(d, p), this.size = x.size, this
                }
                zc.prototype.clear = Z0e, zc.prototype.delete = Q0e, zc.prototype.get = J0e, zc.prototype.has = X0e, zc.prototype.set = epe;

                function Ij(d, p) {
                    var x = En(d),
                        F = !x && Ig(d),
                        ee = !x && !F && i0(d),
                        ce = !x && !F && !ee && Ky(d),
                        pe = x || F || ee || ce,
                        we = pe ? SI(d.length, u0e) : [],
                        Te = we.length;
                    for (var Fe in d)(p || Ir.call(d, Fe)) && !(pe && (Fe == "length" || ee && (Fe == "offset" || Fe == "parent") || ce && (Fe == "buffer" || Fe == "byteLength" || Fe == "byteOffset") || Ed(Fe, Te))) && we.push(Fe);
                    return we
                }

                function Rj(d) {
                    var p = d.length;
                    return p ? d[jI(0, p - 1)] : n
                }

                function tpe(d, p) {
                    return bx(Ea(d), Sg(p, 0, d.length))
                }

                function npe(d) {
                    return bx(Ea(d))
                }

                function NI(d, p, x) {
                    (x !== n && !Wc(d[p], x) || x === n && !(p in d)) && vd(d, p, x)
                }

                function _5(d, p, x) {
                    var F = d[p];
                    (!(Ir.call(d, p) && Wc(F, x)) || x === n && !(p in d)) && vd(d, p, x)
                }

                function ax(d, p) {
                    for (var x = d.length; x--;)
                        if (Wc(d[x][0], p)) return x;
                    return -1
                }

                function rpe(d, p, x, F) {
                    return e0(d, function(ee, ce, pe) {
                        p(F, ee, x(ee), pe)
                    }), F
                }

                function Oj(d, p) {
                    return d && Xu(p, $s(p), d)
                }

                function ipe(d, p) {
                    return d && Xu(p, Sa(p), d)
                }

                function vd(d, p, x) {
                    p == "__proto__" && tx ? tx(d, p, {
                        configurable: !0,
                        enumerable: !0,
                        value: x,
                        writable: !0
                    }) : d[p] = x
                }

                function PI(d, p) {
                    for (var x = -1, F = p.length, ee = Ne(F), ce = d == null; ++x < F;) ee[x] = ce ? n : dR(d, p[x]);
                    return ee
                }

                function Sg(d, p, x) {
                    return d === d && (x !== n && (d = d <= x ? d : x), p !== n && (d = d >= p ? d : p)), d
                }

                function Gl(d, p, x, F, ee, ce) {
                    var pe, we = p & f,
                        Te = p & h,
                        Fe = p & g;
                    if (x && (pe = ee ? x(d, F, ee, ce) : x(d)), pe !== n) return pe;
                    if (!_i(d)) return d;
                    var Ue = En(d);
                    if (Ue) {
                        if (pe = Gpe(d), !we) return Ea(d, pe)
                    } else {
                        var Ge = go(d),
                            dt = Ge == Z || Ge == ge;
                        if (i0(d)) return eH(d, we);
                        if (Ge == Be || Ge == V || dt && !ee) {
                            if (pe = Te || dt ? {} : vH(d), !we) return Te ? Dpe(d, ipe(pe, d)) : Mpe(d, Oj(pe, d))
                        } else {
                            if (!Nr[Ge]) return ee ? d : {};
                            pe = qpe(d, Ge, we)
                        }
                    }
                    ce || (ce = new zc);
                    var $t = ce.get(d);
                    if ($t) return $t;
                    ce.set(d, pe), KH(d) ? d.forEach(function(rn) {
                        pe.add(Gl(rn, p, x, rn, d, ce))
                    }) : GH(d) && d.forEach(function(rn, Wn) {
                        pe.set(Wn, Gl(rn, p, x, Wn, d, ce))
                    });
                    var nn = Fe ? Te ? JI : QI : Te ? Sa : $s,
                        Nn = Ue ? n : nn(d);
                    return zl(Nn || d, function(rn, Wn) {
                        Nn && (Wn = rn, rn = d[Wn]), _5(pe, Wn, Gl(rn, p, x, Wn, d, ce))
                    }), pe
                }

                function spe(d) {
                    var p = $s(d);
                    return function(x) {
                        return Nj(x, d, p)
                    }
                }

                function Nj(d, p, x) {
                    var F = x.length;
                    if (d == null) return !F;
                    for (d = jr(d); F--;) {
                        var ee = x[F],
                            ce = p[ee],
                            pe = d[ee];
                        if (pe === n && !(ee in d) || !ce(pe)) return !1
                    }
                    return !0
                }

                function Pj(d, p, x) {
                    if (typeof d != "function") throw new Wl(o);
                    return I5(function() {
                        d.apply(n, x)
                    }, p)
                }

                function E5(d, p, x, F) {
                    var ee = -1,
                        ce = W4,
                        pe = !0,
                        we = d.length,
                        Te = [],
                        Fe = p.length;
                    if (!we) return Te;
                    x && (p = fi(p, tl(x))), F ? (ce = wI, pe = !1) : p.length >= i && (ce = g5, pe = !1, p = new xg(p));
                    e: for (; ++ee < we;) {
                        var Ue = d[ee],
                            Ge = x == null ? Ue : x(Ue);
                        if (Ue = F || Ue !== 0 ? Ue : 0, pe && Ge === Ge) {
                            for (var dt = Fe; dt--;)
                                if (p[dt] === Ge) continue e;
                            Te.push(Ue)
                        } else ce(p, Ge, F) || Te.push(Ue)
                    }
                    return Te
                }
                var e0 = sH(Ju),
                    kj = sH(MI, !0);

                function ope(d, p) {
                    var x = !0;
                    return e0(d, function(F, ee, ce) {
                        return x = !!p(F, ee, ce), x
                    }), x
                }

                function lx(d, p, x) {
                    for (var F = -1, ee = d.length; ++F < ee;) {
                        var ce = d[F],
                            pe = p(ce);
                        if (pe != null && (we === n ? pe === pe && !rl(pe) : x(pe, we))) var we = pe,
                            Te = ce
                    }
                    return Te
                }

                function ape(d, p, x, F) {
                    var ee = d.length;
                    for (x = Tn(x), x < 0 && (x = -x > ee ? 0 : ee + x), F = F === n || F > ee ? ee : Tn(F), F < 0 && (F += ee), F = x > F ? 0 : ZH(F); x < F;) d[x++] = p;
                    return d
                }

                function Mj(d, p) {
                    var x = [];
                    return e0(d, function(F, ee, ce) {
                        p(F, ee, ce) && x.push(F)
                    }), x
                }

                function eo(d, p, x, F, ee) {
                    var ce = -1,
                        pe = d.length;
                    for (x || (x = Ype), ee || (ee = []); ++ce < pe;) {
                        var we = d[ce];
                        p > 0 && x(we) ? p > 1 ? eo(we, p - 1, x, F, ee) : Qh(ee, we) : F || (ee[ee.length] = we)
                    }
                    return ee
                }
                var kI = oH(),
                    Dj = oH(!0);

                function Ju(d, p) {
                    return d && kI(d, p, $s)
                }

                function MI(d, p) {
                    return d && Dj(d, p, $s)
                }

                function cx(d, p) {
                    return Zh(p, function(x) {
                        return xd(d[x])
                    })
                }

                function Cg(d, p) {
                    p = n0(p, d);
                    for (var x = 0, F = p.length; d != null && x < F;) d = d[ef(p[x++])];
                    return x && x == F ? d : n
                }

                function $j(d, p, x) {
                    var F = p(d);
                    return En(d) ? F : Qh(F, x(d))
                }

                function zo(d) {
                    return d == null ? d === n ? lt : He : _g && _g in jr(d) ? zpe(d) : nge(d)
                }

                function DI(d, p) {
                    return d > p
                }

                function lpe(d, p) {
                    return d != null && Ir.call(d, p)
                }

                function cpe(d, p) {
                    return d != null && p in jr(d)
                }

                function upe(d, p, x) {
                    return d >= po(p, x) && d < Cs(p, x)
                }

                function $I(d, p, x) {
                    for (var F = x ? wI : W4, ee = d[0].length, ce = d.length, pe = ce, we = Ne(ce), Te = 1 / 0, Fe = []; pe--;) {
                        var Ue = d[pe];
                        pe && p && (Ue = fi(Ue, tl(p))), Te = po(Ue.length, Te), we[pe] = !x && (p || ee >= 120 && Ue.length >= 120) ? new xg(pe && Ue) : n
                    }
                    Ue = d[0];
                    var Ge = -1,
                        dt = we[0];
                    e: for (; ++Ge < ee && Fe.length < Te;) {
                        var $t = Ue[Ge],
                            nn = p ? p($t) : $t;
                        if ($t = x || $t !== 0 ? $t : 0, !(dt ? g5(dt, nn) : F(Fe, nn, x))) {
                            for (pe = ce; --pe;) {
                                var Nn = we[pe];
                                if (!(Nn ? g5(Nn, nn) : F(d[pe], nn, x))) continue e
                            }
                            dt && dt.push(nn), Fe.push($t)
                        }
                    }
                    return Fe
                }

                function fpe(d, p, x, F) {
                    return Ju(d, function(ee, ce, pe) {
                        p(F, x(ee), ce, pe)
                    }), F
                }

                function x5(d, p, x) {
                    p = n0(p, d), d = xH(d, p);
                    var F = d == null ? d : d[ef(Kl(p))];
                    return F == null ? n : Ds(F, d, x)
                }

                function Lj(d) {
                    return Li(d) && zo(d) == V
                }

                function dpe(d) {
                    return Li(d) && zo(d) == Q
                }

                function hpe(d) {
                    return Li(d) && zo(d) == ie
                }

                function S5(d, p, x, F, ee) {
                    return d === p ? !0 : d == null || p == null || !Li(d) && !Li(p) ? d !== d && p !== p : ppe(d, p, x, F, S5, ee)
                }

                function ppe(d, p, x, F, ee, ce) {
                    var pe = En(d),
                        we = En(p),
                        Te = pe ? X : go(d),
                        Fe = we ? X : go(p);
                    Te = Te == V ? Be : Te, Fe = Fe == V ? Be : Fe;
                    var Ue = Te == Be,
                        Ge = Fe == Be,
                        dt = Te == Fe;
                    if (dt && i0(d)) {
                        if (!i0(p)) return !1;
                        pe = !0, Ue = !1
                    }
                    if (dt && !Ue) return ce || (ce = new zc), pe || Ky(d) ? mH(d, p, x, F, ee, ce) : jpe(d, p, Te, x, F, ee, ce);
                    if (!(x & y)) {
                        var $t = Ue && Ir.call(d, "__wrapped__"),
                            nn = Ge && Ir.call(p, "__wrapped__");
                        if ($t || nn) {
                            var Nn = $t ? d.value() : d,
                                rn = nn ? p.value() : p;
                            return ce || (ce = new zc), ee(Nn, rn, x, F, ce)
                        }
                    }
                    return dt ? (ce || (ce = new zc), Hpe(d, p, x, F, ee, ce)) : !1
                }

                function gpe(d) {
                    return Li(d) && go(d) == me
                }

                function LI(d, p, x, F) {
                    var ee = x.length,
                        ce = ee,
                        pe = !F;
                    if (d == null) return !ce;
                    for (d = jr(d); ee--;) {
                        var we = x[ee];
                        if (pe && we[2] ? we[1] !== d[we[0]] : !(we[0] in d)) return !1
                    }
                    for (; ++ee < ce;) {
                        we = x[ee];
                        var Te = we[0],
                            Fe = d[Te],
                            Ue = we[1];
                        if (pe && we[2]) {
                            if (Fe === n && !(Te in d)) return !1
                        } else {
                            var Ge = new zc;
                            if (F) var dt = F(Fe, Ue, Te, d, p, Ge);
                            if (!(dt === n ? S5(Ue, Fe, y | _, F, Ge) : dt)) return !1
                        }
                    }
                    return !0
                }

                function Bj(d) {
                    if (!_i(d) || Qpe(d)) return !1;
                    var p = xd(d) ? g0e : ft;
                    return p.test(Tg(d))
                }

                function mpe(d) {
                    return Li(d) && zo(d) == at
                }

                function ype(d) {
                    return Li(d) && go(d) == tt
                }

                function wpe(d) {
                    return Li(d) && Ax(d.length) && !!Br[zo(d)]
                }

                function Fj(d) {
                    return typeof d == "function" ? d : d == null ? Ca : typeof d == "object" ? En(d) ? Hj(d[0], d[1]) : jj(d) : az(d)
                }

                function BI(d) {
                    if (!T5(d)) return _0e(d);
                    var p = [];
                    for (var x in jr(d)) Ir.call(d, x) && x != "constructor" && p.push(x);
                    return p
                }

                function vpe(d) {
                    if (!_i(d)) return tge(d);
                    var p = T5(d),
                        x = [];
                    for (var F in d) F == "constructor" && (p || !Ir.call(d, F)) || x.push(F);
                    return x
                }

                function FI(d, p) {
                    return d < p
                }

                function Uj(d, p) {
                    var x = -1,
                        F = xa(d) ? Ne(d.length) : [];
                    return e0(d, function(ee, ce, pe) {
                        F[++x] = p(ee, ce, pe)
                    }), F
                }

                function jj(d) {
                    var p = eR(d);
                    return p.length == 1 && p[0][2] ? _H(p[0][0], p[0][1]) : function(x) {
                        return x === d || LI(x, d, p)
                    }
                }

                function Hj(d, p) {
                    return nR(d) && bH(p) ? _H(ef(d), p) : function(x) {
                        var F = dR(x, d);
                        return F === n && F === p ? hR(x, d) : S5(p, F, y | _)
                    }
                }

                function ux(d, p, x, F, ee) {
                    d !== p && kI(p, function(ce, pe) {
                        if (ee || (ee = new zc), _i(ce)) bpe(d, p, pe, x, ux, F, ee);
                        else {
                            var we = F ? F(iR(d, pe), ce, pe + "", d, p, ee) : n;
                            we === n && (we = ce), NI(d, pe, we)
                        }
                    }, Sa)
                }

                function bpe(d, p, x, F, ee, ce, pe) {
                    var we = iR(d, x),
                        Te = iR(p, x),
                        Fe = pe.get(Te);
                    if (Fe) {
                        NI(d, x, Fe);
                        return
                    }
                    var Ue = ce ? ce(we, Te, x + "", d, p, pe) : n,
                        Ge = Ue === n;
                    if (Ge) {
                        var dt = En(Te),
                            $t = !dt && i0(Te),
                            nn = !dt && !$t && Ky(Te);
                        Ue = Te, dt || $t || nn ? En(we) ? Ue = we : ts(we) ? Ue = Ea(we) : $t ? (Ge = !1, Ue = eH(Te, !0)) : nn ? (Ge = !1, Ue = tH(Te, !0)) : Ue = [] : R5(Te) || Ig(Te) ? (Ue = we, Ig(we) ? Ue = QH(we) : (!_i(we) || xd(we)) && (Ue = vH(Te))) : Ge = !1
                    }
                    Ge && (pe.set(Te, Ue), ee(Ue, Te, F, ce, pe), pe.delete(Te)), NI(d, x, Ue)
                }

                function zj(d, p) {
                    var x = d.length;
                    if (x) return p += p < 0 ? x : 0, Ed(p, x) ? d[p] : n
                }

                function Wj(d, p, x) {
                    p.length ? p = fi(p, function(ce) {
                        return En(ce) ? function(pe) {
                            return Cg(pe, ce.length === 1 ? ce[0] : ce)
                        } : ce
                    }) : p = [Ca];
                    var F = -1;
                    p = fi(p, tl(tn()));
                    var ee = Uj(d, function(ce, pe, we) {
                        var Te = fi(p, function(Fe) {
                            return Fe(ce)
                        });
                        return {
                            criteria: Te,
                            index: ++F,
                            value: ce
                        }
                    });
                    return qhe(ee, function(ce, pe) {
                        return kpe(ce, pe, x)
                    })
                }

                function _pe(d, p) {
                    return Vj(d, p, function(x, F) {
                        return hR(d, F)
                    })
                }

                function Vj(d, p, x) {
                    for (var F = -1, ee = p.length, ce = {}; ++F < ee;) {
                        var pe = p[F],
                            we = Cg(d, pe);
                        x(we, pe) && C5(ce, n0(pe, d), we)
                    }
                    return ce
                }

                function Epe(d) {
                    return function(p) {
                        return Cg(p, d)
                    }
                }

                function UI(d, p, x, F) {
                    var ee = F ? Ghe : Ly,
                        ce = -1,
                        pe = p.length,
                        we = d;
                    for (d === p && (p = Ea(p)), x && (we = fi(d, tl(x))); ++ce < pe;)
                        for (var Te = 0, Fe = p[ce], Ue = x ? x(Fe) : Fe;
                            (Te = ee(we, Ue, Te, F)) > -1;) we !== d && ex.call(we, Te, 1), ex.call(d, Te, 1);
                    return d
                }

                function Gj(d, p) {
                    for (var x = d ? p.length : 0, F = x - 1; x--;) {
                        var ee = p[x];
                        if (x == F || ee !== ce) {
                            var ce = ee;
                            Ed(ee) ? ex.call(d, ee, 1) : WI(d, ee)
                        }
                    }
                    return d
                }

                function jI(d, p) {
                    return d + rx(Aj() * (p - d + 1))
                }

                function xpe(d, p, x, F) {
                    for (var ee = -1, ce = Cs(nx((p - d) / (x || 1)), 0), pe = Ne(ce); ce--;) pe[F ? ce : ++ee] = d, d += x;
                    return pe
                }

                function HI(d, p) {
                    var x = "";
                    if (!d || p < 1 || p > O) return x;
                    do p % 2 && (x += d), p = rx(p / 2), p && (d += d); while (p);
                    return x
                }

                function Ln(d, p) {
                    return sR(EH(d, p, Ca), d + "")
                }

                function Spe(d) {
                    return Rj(Yy(d))
                }

                function Cpe(d, p) {
                    var x = Yy(d);
                    return bx(x, Sg(p, 0, x.length))
                }

                function C5(d, p, x, F) {
                    if (!_i(d)) return d;
                    p = n0(p, d);
                    for (var ee = -1, ce = p.length, pe = ce - 1, we = d; we != null && ++ee < ce;) {
                        var Te = ef(p[ee]),
                            Fe = x;
                        if (Te === "__proto__" || Te === "constructor" || Te === "prototype") return d;
                        if (ee != pe) {
                            var Ue = we[Te];
                            Fe = F ? F(Ue, Te, we) : n, Fe === n && (Fe = _i(Ue) ? Ue : Ed(p[ee + 1]) ? [] : {})
                        }
                        _5(we, Te, Fe), we = we[Te]
                    }
                    return d
                }
                var qj = ix ? function(d, p) {
                        return ix.set(d, p), d
                    } : Ca,
                    Ape = tx ? function(d, p) {
                        return tx(d, "toString", {
                            configurable: !0,
                            enumerable: !1,
                            value: gR(p),
                            writable: !0
                        })
                    } : Ca;

                function Tpe(d) {
                    return bx(Yy(d))
                }

                function ql(d, p, x) {
                    var F = -1,
                        ee = d.length;
                    p < 0 && (p = -p > ee ? 0 : ee + p), x = x > ee ? ee : x, x < 0 && (x += ee), ee = p > x ? 0 : x - p >>> 0, p >>>= 0;
                    for (var ce = Ne(ee); ++F < ee;) ce[F] = d[F + p];
                    return ce
                }

                function Ipe(d, p) {
                    var x;
                    return e0(d, function(F, ee, ce) {
                        return x = p(F, ee, ce), !x
                    }), !!x
                }

                function fx(d, p, x) {
                    var F = 0,
                        ee = d == null ? F : d.length;
                    if (typeof p == "number" && p === p && ee <= Y) {
                        for (; F < ee;) {
                            var ce = F + ee >>> 1,
                                pe = d[ce];
                            pe !== null && !rl(pe) && (x ? pe <= p : pe < p) ? F = ce + 1 : ee = ce
                        }
                        return ee
                    }
                    return zI(d, p, Ca, x)
                }

                function zI(d, p, x, F) {
                    var ee = 0,
                        ce = d == null ? 0 : d.length;
                    if (ce === 0) return 0;
                    p = x(p);
                    for (var pe = p !== p, we = p === null, Te = rl(p), Fe = p === n; ee < ce;) {
                        var Ue = rx((ee + ce) / 2),
                            Ge = x(d[Ue]),
                            dt = Ge !== n,
                            $t = Ge === null,
                            nn = Ge === Ge,
                            Nn = rl(Ge);
                        if (pe) var rn = F || nn;
                        else Fe ? rn = nn && (F || dt) : we ? rn = nn && dt && (F || !$t) : Te ? rn = nn && dt && !$t && (F || !Nn) : $t || Nn ? rn = !1 : rn = F ? Ge <= p : Ge < p;
                        rn ? ee = Ue + 1 : ce = Ue
                    }
                    return po(ce, R)
                }

                function Kj(d, p) {
                    for (var x = -1, F = d.length, ee = 0, ce = []; ++x < F;) {
                        var pe = d[x],
                            we = p ? p(pe) : pe;
                        if (!x || !Wc(we, Te)) {
                            var Te = we;
                            ce[ee++] = pe === 0 ? 0 : pe
                        }
                    }
                    return ce
                }

                function Yj(d) {
                    return typeof d == "number" ? d : rl(d) ? G : +d
                }

                function nl(d) {
                    if (typeof d == "string") return d;
                    if (En(d)) return fi(d, nl) + "";
                    if (rl(d)) return Tj ? Tj.call(d) : "";
                    var p = d + "";
                    return p == "0" && 1 / d == -N ? "-0" : p
                }

                function t0(d, p, x) {
                    var F = -1,
                        ee = W4,
                        ce = d.length,
                        pe = !0,
                        we = [],
                        Te = we;
                    if (x) pe = !1, ee = wI;
                    else if (ce >= i) {
                        var Fe = p ? null : Fpe(d);
                        if (Fe) return G4(Fe);
                        pe = !1, ee = g5, Te = new xg
                    } else Te = p ? [] : we;
                    e: for (; ++F < ce;) {
                        var Ue = d[F],
                            Ge = p ? p(Ue) : Ue;
                        if (Ue = x || Ue !== 0 ? Ue : 0, pe && Ge === Ge) {
                            for (var dt = Te.length; dt--;)
                                if (Te[dt] === Ge) continue e;
                            p && Te.push(Ge), we.push(Ue)
                        } else ee(Te, Ge, x) || (Te !== we && Te.push(Ge), we.push(Ue))
                    }
                    return we
                }

                function WI(d, p) {
                    return p = n0(p, d), d = xH(d, p), d == null || delete d[ef(Kl(p))]
                }

                function Zj(d, p, x, F) {
                    return C5(d, p, x(Cg(d, p)), F)
                }

                function dx(d, p, x, F) {
                    for (var ee = d.length, ce = F ? ee : -1;
                        (F ? ce-- : ++ce < ee) && p(d[ce], ce, d););
                    return x ? ql(d, F ? 0 : ce, F ? ce + 1 : ee) : ql(d, F ? ce + 1 : 0, F ? ee : ce)
                }

                function Qj(d, p) {
                    var x = d;
                    return x instanceof Kn && (x = x.value()), vI(p, function(F, ee) {
                        return ee.func.apply(ee.thisArg, Qh([F], ee.args))
                    }, x)
                }

                function VI(d, p, x) {
                    var F = d.length;
                    if (F < 2) return F ? t0(d[0]) : [];
                    for (var ee = -1, ce = Ne(F); ++ee < F;)
                        for (var pe = d[ee], we = -1; ++we < F;) we != ee && (ce[ee] = E5(ce[ee] || pe, d[we], p, x));
                    return t0(eo(ce, 1), p, x)
                }

                function Jj(d, p, x) {
                    for (var F = -1, ee = d.length, ce = p.length, pe = {}; ++F < ee;) {
                        var we = F < ce ? p[F] : n;
                        x(pe, d[F], we)
                    }
                    return pe
                }

                function GI(d) {
                    return ts(d) ? d : []
                }

                function qI(d) {
                    return typeof d == "function" ? d : Ca
                }

                function n0(d, p) {
                    return En(d) ? d : nR(d, p) ? [d] : TH(Sr(d))
                }
                var Rpe = Ln;

                function r0(d, p, x) {
                    var F = d.length;
                    return x = x === n ? F : x, !p && x >= F ? d : ql(d, p, x)
                }
                var Xj = m0e || function(d) {
                    return tr.clearTimeout(d)
                };

                function eH(d, p) {
                    if (p) return d.slice();
                    var x = d.length,
                        F = _j ? _j(x) : new d.constructor(x);
                    return d.copy(F), F
                }

                function KI(d) {
                    var p = new d.constructor(d.byteLength);
                    return new J4(p).set(new J4(d)), p
                }

                function Ope(d, p) {
                    var x = p ? KI(d.buffer) : d.buffer;
                    return new d.constructor(x, d.byteOffset, d.byteLength)
                }

                function Npe(d) {
                    var p = new d.constructor(d.source, Le.exec(d));
                    return p.lastIndex = d.lastIndex, p
                }

                function Ppe(d) {
                    return b5 ? jr(b5.call(d)) : {}
                }

                function tH(d, p) {
                    var x = p ? KI(d.buffer) : d.buffer;
                    return new d.constructor(x, d.byteOffset, d.length)
                }

                function nH(d, p) {
                    if (d !== p) {
                        var x = d !== n,
                            F = d === null,
                            ee = d === d,
                            ce = rl(d),
                            pe = p !== n,
                            we = p === null,
                            Te = p === p,
                            Fe = rl(p);
                        if (!we && !Fe && !ce && d > p || ce && pe && Te && !we && !Fe || F && pe && Te || !x && Te || !ee) return 1;
                        if (!F && !ce && !Fe && d < p || Fe && x && ee && !F && !ce || we && x && ee || !pe && ee || !Te) return -1
                    }
                    return 0
                }

                function kpe(d, p, x) {
                    for (var F = -1, ee = d.criteria, ce = p.criteria, pe = ee.length, we = x.length; ++F < pe;) {
                        var Te = nH(ee[F], ce[F]);
                        if (Te) {
                            if (F >= we) return Te;
                            var Fe = x[F];
                            return Te * (Fe == "desc" ? -1 : 1)
                        }
                    }
                    return d.index - p.index
                }

                function rH(d, p, x, F) {
                    for (var ee = -1, ce = d.length, pe = x.length, we = -1, Te = p.length, Fe = Cs(ce - pe, 0), Ue = Ne(Te + Fe), Ge = !F; ++we < Te;) Ue[we] = p[we];
                    for (; ++ee < pe;)(Ge || ee < ce) && (Ue[x[ee]] = d[ee]);
                    for (; Fe--;) Ue[we++] = d[ee++];
                    return Ue
                }

                function iH(d, p, x, F) {
                    for (var ee = -1, ce = d.length, pe = -1, we = x.length, Te = -1, Fe = p.length, Ue = Cs(ce - we, 0), Ge = Ne(Ue + Fe), dt = !F; ++ee < Ue;) Ge[ee] = d[ee];
                    for (var $t = ee; ++Te < Fe;) Ge[$t + Te] = p[Te];
                    for (; ++pe < we;)(dt || ee < ce) && (Ge[$t + x[pe]] = d[ee++]);
                    return Ge
                }

                function Ea(d, p) {
                    var x = -1,
                        F = d.length;
                    for (p || (p = Ne(F)); ++x < F;) p[x] = d[x];
                    return p
                }

                function Xu(d, p, x, F) {
                    var ee = !x;
                    x || (x = {});
                    for (var ce = -1, pe = p.length; ++ce < pe;) {
                        var we = p[ce],
                            Te = F ? F(x[we], d[we], we, x, d) : n;
                        Te === n && (Te = d[we]), ee ? vd(x, we, Te) : _5(x, we, Te)
                    }
                    return x
                }

                function Mpe(d, p) {
                    return Xu(d, tR(d), p)
                }

                function Dpe(d, p) {
                    return Xu(d, yH(d), p)
                }

                function hx(d, p) {
                    return function(x, F) {
                        var ee = En(x) ? Uhe : rpe,
                            ce = p ? p() : {};
                        return ee(x, d, tn(F, 2), ce)
                    }
                }

                function Vy(d) {
                    return Ln(function(p, x) {
                        var F = -1,
                            ee = x.length,
                            ce = ee > 1 ? x[ee - 1] : n,
                            pe = ee > 2 ? x[2] : n;
                        for (ce = d.length > 3 && typeof ce == "function" ? (ee--, ce) : n, pe && Wo(x[0], x[1], pe) && (ce = ee < 3 ? n : ce, ee = 1), p = jr(p); ++F < ee;) {
                            var we = x[F];
                            we && d(p, we, F, ce)
                        }
                        return p
                    })
                }

                function sH(d, p) {
                    return function(x, F) {
                        if (x == null) return x;
                        if (!xa(x)) return d(x, F);
                        for (var ee = x.length, ce = p ? ee : -1, pe = jr(x);
                            (p ? ce-- : ++ce < ee) && F(pe[ce], ce, pe) !== !1;);
                        return x
                    }
                }

                function oH(d) {
                    return function(p, x, F) {
                        for (var ee = -1, ce = jr(p), pe = F(p), we = pe.length; we--;) {
                            var Te = pe[d ? we : ++ee];
                            if (x(ce[Te], Te, ce) === !1) break
                        }
                        return p
                    }
                }

                function $pe(d, p, x) {
                    var F = p & C,
                        ee = A5(d);

                    function ce() {
                        var pe = this && this !== tr && this instanceof ce ? ee : d;
                        return pe.apply(F ? x : this, arguments)
                    }
                    return ce
                }

                function aH(d) {
                    return function(p) {
                        p = Sr(p);
                        var x = By(p) ? Hc(p) : n,
                            F = x ? x[0] : p.charAt(0),
                            ee = x ? r0(x, 1).join("") : p.slice(1);
                        return F[d]() + ee
                    }
                }

                function Gy(d) {
                    return function(p) {
                        return vI(sz(iz(p).replace(h5, "")), d, "")
                    }
                }

                function A5(d) {
                    return function() {
                        var p = arguments;
                        switch (p.length) {
                            case 0:
                                return new d;
                            case 1:
                                return new d(p[0]);
                            case 2:
                                return new d(p[0], p[1]);
                            case 3:
                                return new d(p[0], p[1], p[2]);
                            case 4:
                                return new d(p[0], p[1], p[2], p[3]);
                            case 5:
                                return new d(p[0], p[1], p[2], p[3], p[4]);
                            case 6:
                                return new d(p[0], p[1], p[2], p[3], p[4], p[5]);
                            case 7:
                                return new d(p[0], p[1], p[2], p[3], p[4], p[5], p[6])
                        }
                        var x = Wy(d.prototype),
                            F = d.apply(x, p);
                        return _i(F) ? F : x
                    }
                }

                function Lpe(d, p, x) {
                    var F = A5(d);

                    function ee() {
                        for (var ce = arguments.length, pe = Ne(ce), we = ce, Te = qy(ee); we--;) pe[we] = arguments[we];
                        var Fe = ce < 3 && pe[0] !== Te && pe[ce - 1] !== Te ? [] : Jh(pe, Te);
                        if (ce -= Fe.length, ce < x) return dH(d, p, px, ee.placeholder, n, pe, Fe, n, n, x - ce);
                        var Ue = this && this !== tr && this instanceof ee ? F : d;
                        return Ds(Ue, this, pe)
                    }
                    return ee
                }

                function lH(d) {
                    return function(p, x, F) {
                        var ee = jr(p);
                        if (!xa(p)) {
                            var ce = tn(x, 3);
                            p = $s(p), x = function(we) {
                                return ce(ee[we], we, ee)
                            }
                        }
                        var pe = d(p, x, F);
                        return pe > -1 ? ee[ce ? p[pe] : pe] : n
                    }
                }

                function cH(d) {
                    return _d(function(p) {
                        var x = p.length,
                            F = x,
                            ee = Vl.prototype.thru;
                        for (d && p.reverse(); F--;) {
                            var ce = p[F];
                            if (typeof ce != "function") throw new Wl(o);
                            if (ee && !pe && wx(ce) == "wrapper") var pe = new Vl([], !0)
                        }
                        for (F = pe ? F : x; ++F < x;) {
                            ce = p[F];
                            var we = wx(ce),
                                Te = we == "wrapper" ? XI(ce) : n;
                            Te && rR(Te[0]) && Te[1] == (A | S | P | E) && !Te[4].length && Te[9] == 1 ? pe = pe[wx(Te[0])].apply(pe, Te[3]) : pe = ce.length == 1 && rR(ce) ? pe[we]() : pe.thru(ce)
                        }
                        return function() {
                            var Fe = arguments,
                                Ue = Fe[0];
                            if (pe && Fe.length == 1 && En(Ue)) return pe.plant(Ue).value();
                            for (var Ge = 0, dt = x ? p[Ge].apply(this, Fe) : Ue; ++Ge < x;) dt = p[Ge].call(this, dt);
                            return dt
                        }
                    })
                }

                function px(d, p, x, F, ee, ce, pe, we, Te, Fe) {
                    var Ue = p & A,
                        Ge = p & C,
                        dt = p & b,
                        $t = p & (S | I),
                        nn = p & $,
                        Nn = dt ? n : A5(d);

                    function rn() {
                        for (var Wn = arguments.length, nr = Ne(Wn), il = Wn; il--;) nr[il] = arguments[il];
                        if ($t) var Vo = qy(rn),
                            sl = Yhe(nr, Vo);
                        if (F && (nr = rH(nr, F, ee, $t)), ce && (nr = iH(nr, ce, pe, $t)), Wn -= sl, $t && Wn < Fe) {
                            var ns = Jh(nr, Vo);
                            return dH(d, p, px, rn.placeholder, x, nr, ns, we, Te, Fe - Wn)
                        }
                        var Vc = Ge ? x : this,
                            Cd = dt ? Vc[d] : d;
                        return Wn = nr.length, we ? nr = rge(nr, we) : nn && Wn > 1 && nr.reverse(), Ue && Te < Wn && (nr.length = Te), this && this !== tr && this instanceof rn && (Cd = Nn || A5(Cd)), Cd.apply(Vc, nr)
                    }
                    return rn
                }

                function uH(d, p) {
                    return function(x, F) {
                        return fpe(x, d, p(F), {})
                    }
                }

                function gx(d, p) {
                    return function(x, F) {
                        var ee;
                        if (x === n && F === n) return p;
                        if (x !== n && (ee = x), F !== n) {
                            if (ee === n) return F;
                            typeof x == "string" || typeof F == "string" ? (x = nl(x), F = nl(F)) : (x = Yj(x), F = Yj(F)), ee = d(x, F)
                        }
                        return ee
                    }
                }

                function YI(d) {
                    return _d(function(p) {
                        return p = fi(p, tl(tn())), Ln(function(x) {
                            var F = this;
                            return d(p, function(ee) {
                                return Ds(ee, F, x)
                            })
                        })
                    })
                }

                function mx(d, p) {
                    p = p === n ? " " : nl(p);
                    var x = p.length;
                    if (x < 2) return x ? HI(p, d) : p;
                    var F = HI(p, nx(d / Fy(p)));
                    return By(p) ? r0(Hc(F), 0, d).join("") : F.slice(0, d)
                }

                function Bpe(d, p, x, F) {
                    var ee = p & C,
                        ce = A5(d);

                    function pe() {
                        for (var we = -1, Te = arguments.length, Fe = -1, Ue = F.length, Ge = Ne(Ue + Te), dt = this && this !== tr && this instanceof pe ? ce : d; ++Fe < Ue;) Ge[Fe] = F[Fe];
                        for (; Te--;) Ge[Fe++] = arguments[++we];
                        return Ds(dt, ee ? x : this, Ge)
                    }
                    return pe
                }

                function fH(d) {
                    return function(p, x, F) {
                        return F && typeof F != "number" && Wo(p, x, F) && (x = F = n), p = Sd(p), x === n ? (x = p, p = 0) : x = Sd(x), F = F === n ? p < x ? 1 : -1 : Sd(F), xpe(p, x, F, d)
                    }
                }

                function yx(d) {
                    return function(p, x) {
                        return typeof p == "string" && typeof x == "string" || (p = Yl(p), x = Yl(x)), d(p, x)
                    }
                }

                function dH(d, p, x, F, ee, ce, pe, we, Te, Fe) {
                    var Ue = p & S,
                        Ge = Ue ? pe : n,
                        dt = Ue ? n : pe,
                        $t = Ue ? ce : n,
                        nn = Ue ? n : ce;
                    p |= Ue ? P : M, p &= ~(Ue ? M : P), p & w || (p &= ~(C | b));
                    var Nn = [d, p, ee, $t, Ge, nn, dt, we, Te, Fe],
                        rn = x.apply(n, Nn);
                    return rR(d) && SH(rn, Nn), rn.placeholder = F, CH(rn, d, p)
                }

                function ZI(d) {
                    var p = Ss[d];
                    return function(x, F) {
                        if (x = Yl(x), F = F == null ? 0 : po(Tn(F), 292), F && Cj(x)) {
                            var ee = (Sr(x) + "e").split("e"),
                                ce = p(ee[0] + "e" + (+ee[1] + F));
                            return ee = (Sr(ce) + "e").split("e"), +(ee[0] + "e" + (+ee[1] - F))
                        }
                        return p(x)
                    }
                }
                var Fpe = Hy && 1 / G4(new Hy([, -0]))[1] == N ? function(d) {
                    return new Hy(d)
                } : wR;

                function hH(d) {
                    return function(p) {
                        var x = go(p);
                        return x == me ? AI(p) : x == tt ? n0e(p) : Khe(p, d(p))
                    }
                }

                function bd(d, p, x, F, ee, ce, pe, we) {
                    var Te = p & b;
                    if (!Te && typeof d != "function") throw new Wl(o);
                    var Fe = F ? F.length : 0;
                    if (Fe || (p &= ~(P | M), F = ee = n), pe = pe === n ? pe : Cs(Tn(pe), 0), we = we === n ? we : Tn(we), Fe -= ee ? ee.length : 0, p & M) {
                        var Ue = F,
                            Ge = ee;
                        F = ee = n
                    }
                    var dt = Te ? n : XI(d),
                        $t = [d, p, x, F, ee, Ue, Ge, ce, pe, we];
                    if (dt && ege($t, dt), d = $t[0], p = $t[1], x = $t[2], F = $t[3], ee = $t[4], we = $t[9] = $t[9] === n ? Te ? 0 : d.length : Cs($t[9] - Fe, 0), !we && p & (S | I) && (p &= ~(S | I)), !p || p == C) var nn = $pe(d, p, x);
                    else p == S || p == I ? nn = Lpe(d, p, we) : (p == P || p == (C | P)) && !ee.length ? nn = Bpe(d, p, x, F) : nn = px.apply(n, $t);
                    var Nn = dt ? qj : SH;
                    return CH(Nn(nn, $t), d, p)
                }

                function pH(d, p, x, F) {
                    return d === n || Wc(d, jy[x]) && !Ir.call(F, x) ? p : d
                }

                function gH(d, p, x, F, ee, ce) {
                    return _i(d) && _i(p) && (ce.set(p, d), ux(d, p, n, gH, ce), ce.delete(p)), d
                }

                function Upe(d) {
                    return R5(d) ? n : d
                }

                function mH(d, p, x, F, ee, ce) {
                    var pe = x & y,
                        we = d.length,
                        Te = p.length;
                    if (we != Te && !(pe && Te > we)) return !1;
                    var Fe = ce.get(d),
                        Ue = ce.get(p);
                    if (Fe && Ue) return Fe == p && Ue == d;
                    var Ge = -1,
                        dt = !0,
                        $t = x & _ ? new xg : n;
                    for (ce.set(d, p), ce.set(p, d); ++Ge < we;) {
                        var nn = d[Ge],
                            Nn = p[Ge];
                        if (F) var rn = pe ? F(Nn, nn, Ge, p, d, ce) : F(nn, Nn, Ge, d, p, ce);
                        if (rn !== n) {
                            if (rn) continue;
                            dt = !1;
                            break
                        }
                        if ($t) {
                            if (!bI(p, function(Wn, nr) {
                                    if (!g5($t, nr) && (nn === Wn || ee(nn, Wn, x, F, ce))) return $t.push(nr)
                                })) {
                                dt = !1;
                                break
                            }
                        } else if (!(nn === Nn || ee(nn, Nn, x, F, ce))) {
                            dt = !1;
                            break
                        }
                    }
                    return ce.delete(d), ce.delete(p), dt
                }

                function jpe(d, p, x, F, ee, ce, pe) {
                    switch (x) {
                        case D:
                            if (d.byteLength != p.byteLength || d.byteOffset != p.byteOffset) return !1;
                            d = d.buffer, p = p.buffer;
                        case Q:
                            return !(d.byteLength != p.byteLength || !ce(new J4(d), new J4(p)));
                        case ne:
                        case ie:
                        case Re:
                            return Wc(+d, +p);
                        case z:
                            return d.name == p.name && d.message == p.message;
                        case at:
                        case _t:
                            return d == p + "";
                        case me:
                            var we = AI;
                        case tt:
                            var Te = F & y;
                            if (we || (we = G4), d.size != p.size && !Te) return !1;
                            var Fe = pe.get(d);
                            if (Fe) return Fe == p;
                            F |= _, pe.set(d, p);
                            var Ue = mH(we(d), we(p), F, ee, ce, pe);
                            return pe.delete(d), Ue;
                        case ot:
                            if (b5) return b5.call(d) == b5.call(p)
                    }
                    return !1
                }

                function Hpe(d, p, x, F, ee, ce) {
                    var pe = x & y,
                        we = QI(d),
                        Te = we.length,
                        Fe = QI(p),
                        Ue = Fe.length;
                    if (Te != Ue && !pe) return !1;
                    for (var Ge = Te; Ge--;) {
                        var dt = we[Ge];
                        if (!(pe ? dt in p : Ir.call(p, dt))) return !1
                    }
                    var $t = ce.get(d),
                        nn = ce.get(p);
                    if ($t && nn) return $t == p && nn == d;
                    var Nn = !0;
                    ce.set(d, p), ce.set(p, d);
                    for (var rn = pe; ++Ge < Te;) {
                        dt = we[Ge];
                        var Wn = d[dt],
                            nr = p[dt];
                        if (F) var il = pe ? F(nr, Wn, dt, p, d, ce) : F(Wn, nr, dt, d, p, ce);
                        if (!(il === n ? Wn === nr || ee(Wn, nr, x, F, ce) : il)) {
                            Nn = !1;
                            break
                        }
                        rn || (rn = dt == "constructor")
                    }
                    if (Nn && !rn) {
                        var Vo = d.constructor,
                            sl = p.constructor;
                        Vo != sl && "constructor" in d && "constructor" in p && !(typeof Vo == "function" && Vo instanceof Vo && typeof sl == "function" && sl instanceof sl) && (Nn = !1)
                    }
                    return ce.delete(d), ce.delete(p), Nn
                }

                function _d(d) {
                    return sR(EH(d, n, NH), d + "")
                }

                function QI(d) {
                    return $j(d, $s, tR)
                }

                function JI(d) {
                    return $j(d, Sa, yH)
                }
                var XI = ix ? function(d) {
                    return ix.get(d)
                } : wR;

                function wx(d) {
                    for (var p = d.name + "", x = zy[p], F = Ir.call(zy, p) ? x.length : 0; F--;) {
                        var ee = x[F],
                            ce = ee.func;
                        if (ce == null || ce == d) return ee.name
                    }
                    return p
                }

                function qy(d) {
                    var p = Ir.call(oe, "placeholder") ? oe : d;
                    return p.placeholder
                }

                function tn() {
                    var d = oe.iteratee || mR;
                    return d = d === mR ? Fj : d, arguments.length ? d(arguments[0], arguments[1]) : d
                }

                function vx(d, p) {
                    var x = d.__data__;
                    return Zpe(p) ? x[typeof p == "string" ? "string" : "hash"] : x.map
                }

                function eR(d) {
                    for (var p = $s(d), x = p.length; x--;) {
                        var F = p[x],
                            ee = d[F];
                        p[x] = [F, ee, bH(ee)]
                    }
                    return p
                }

                function Ag(d, p) {
                    var x = Xhe(d, p);
                    return Bj(x) ? x : n
                }

                function zpe(d) {
                    var p = Ir.call(d, _g),
                        x = d[_g];
                    try {
                        d[_g] = n;
                        var F = !0
                    } catch {}
                    var ee = Z4.call(d);
                    return F && (p ? d[_g] = x : delete d[_g]), ee
                }
                var tR = II ? function(d) {
                        return d == null ? [] : (d = jr(d), Zh(II(d), function(p) {
                            return xj.call(d, p)
                        }))
                    } : vR,
                    yH = II ? function(d) {
                        for (var p = []; d;) Qh(p, tR(d)), d = X4(d);
                        return p
                    } : vR,
                    go = zo;
                (RI && go(new RI(new ArrayBuffer(1))) != D || y5 && go(new y5) != me || OI && go(OI.resolve()) != bt || Hy && go(new Hy) != tt || w5 && go(new w5) != wt) && (go = function(d) {
                    var p = zo(d),
                        x = p == Be ? d.constructor : n,
                        F = x ? Tg(x) : "";
                    if (F) switch (F) {
                        case C0e:
                            return D;
                        case A0e:
                            return me;
                        case T0e:
                            return bt;
                        case I0e:
                            return tt;
                        case R0e:
                            return wt
                    }
                    return p
                });

                function Wpe(d, p, x) {
                    for (var F = -1, ee = x.length; ++F < ee;) {
                        var ce = x[F],
                            pe = ce.size;
                        switch (ce.type) {
                            case "drop":
                                d += pe;
                                break;
                            case "dropRight":
                                p -= pe;
                                break;
                            case "take":
                                p = po(p, d + pe);
                                break;
                            case "takeRight":
                                d = Cs(d, p - pe);
                                break
                        }
                    }
                    return {
                        start: d,
                        end: p
                    }
                }

                function Vpe(d) {
                    var p = d.match(he);
                    return p ? p[1].split(be) : []
                }

                function wH(d, p, x) {
                    p = n0(p, d);
                    for (var F = -1, ee = p.length, ce = !1; ++F < ee;) {
                        var pe = ef(p[F]);
                        if (!(ce = d != null && x(d, pe))) break;
                        d = d[pe]
                    }
                    return ce || ++F != ee ? ce : (ee = d == null ? 0 : d.length, !!ee && Ax(ee) && Ed(pe, ee) && (En(d) || Ig(d)))
                }

                function Gpe(d) {
                    var p = d.length,
                        x = new d.constructor(p);
                    return p && typeof d[0] == "string" && Ir.call(d, "index") && (x.index = d.index, x.input = d.input), x
                }

                function vH(d) {
                    return typeof d.constructor == "function" && !T5(d) ? Wy(X4(d)) : {}
                }

                function qpe(d, p, x) {
                    var F = d.constructor;
                    switch (p) {
                        case Q:
                            return KI(d);
                        case ne:
                        case ie:
                            return new F(+d);
                        case D:
                            return Ope(d, x);
                        case B:
                        case se:
                        case de:
                        case ye:
                        case Se:
                        case nt:
                        case Ke:
                        case mt:
                        case en:
                            return tH(d, x);
                        case me:
                            return new F;
                        case Re:
                        case _t:
                            return new F(d);
                        case at:
                            return Npe(d);
                        case tt:
                            return new F;
                        case ot:
                            return Ppe(d)
                    }
                }

                function Kpe(d, p) {
                    var x = p.length;
                    if (!x) return d;
                    var F = x - 1;
                    return p[F] = (x > 1 ? "& " : "") + p[F], p = p.join(x > 2 ? ", " : " "), d.replace(fe, `{
/* [wrapped with ` + p + `] */
`)
                }

                function Ype(d) {
                    return En(d) || Ig(d) || !!(Sj && d && d[Sj])
                }

                function Ed(d, p) {
                    var x = typeof d;
                    return p = p ? ? O, !!p && (x == "number" || x != "symbol" && pn.test(d)) && d > -1 && d % 1 == 0 && d < p
                }

                function Wo(d, p, x) {
                    if (!_i(x)) return !1;
                    var F = typeof p;
                    return (F == "number" ? xa(x) && Ed(p, x.length) : F == "string" && p in x) ? Wc(x[p], d) : !1
                }

                function nR(d, p) {
                    if (En(d)) return !1;
                    var x = typeof d;
                    return x == "number" || x == "symbol" || x == "boolean" || d == null || rl(d) ? !0 : Jn.test(d) || !zt.test(d) || p != null && d in jr(p)
                }

                function Zpe(d) {
                    var p = typeof d;
                    return p == "string" || p == "number" || p == "symbol" || p == "boolean" ? d !== "__proto__" : d === null
                }

                function rR(d) {
                    var p = wx(d),
                        x = oe[p];
                    if (typeof x != "function" || !(p in Kn.prototype)) return !1;
                    if (d === x) return !0;
                    var F = XI(x);
                    return !!F && d === F[0]
                }

                function Qpe(d) {
                    return !!bj && bj in d
                }
                var Jpe = K4 ? xd : bR;

                function T5(d) {
                    var p = d && d.constructor,
                        x = typeof p == "function" && p.prototype || jy;
                    return d === x
                }

                function bH(d) {
                    return d === d && !_i(d)
                }

                function _H(d, p) {
                    return function(x) {
                        return x == null ? !1 : x[d] === p && (p !== n || d in jr(x))
                    }
                }

                function Xpe(d) {
                    var p = Sx(d, function(F) {
                            return x.size === c && x.clear(), F
                        }),
                        x = p.cache;
                    return p
                }

                function ege(d, p) {
                    var x = d[1],
                        F = p[1],
                        ee = x | F,
                        ce = ee < (C | b | A),
                        pe = F == A && x == S || F == A && x == E && d[7].length <= p[8] || F == (A | E) && p[7].length <= p[8] && x == S;
                    if (!(ce || pe)) return d;
                    F & C && (d[2] = p[2], ee |= x & C ? 0 : w);
                    var we = p[3];
                    if (we) {
                        var Te = d[3];
                        d[3] = Te ? rH(Te, we, p[4]) : we, d[4] = Te ? Jh(d[3], u) : p[4]
                    }
                    return we = p[5], we && (Te = d[5], d[5] = Te ? iH(Te, we, p[6]) : we, d[6] = Te ? Jh(d[5], u) : p[6]), we = p[7], we && (d[7] = we), F & A && (d[8] = d[8] == null ? p[8] : po(d[8], p[8])), d[9] == null && (d[9] = p[9]), d[0] = p[0], d[1] = ee, d
                }

                function tge(d) {
                    var p = [];
                    if (d != null)
                        for (var x in jr(d)) p.push(x);
                    return p
                }

                function nge(d) {
                    return Z4.call(d)
                }

                function EH(d, p, x) {
                    return p = Cs(p === n ? d.length - 1 : p, 0),
                        function() {
                            for (var F = arguments, ee = -1, ce = Cs(F.length - p, 0), pe = Ne(ce); ++ee < ce;) pe[ee] = F[p + ee];
                            ee = -1;
                            for (var we = Ne(p + 1); ++ee < p;) we[ee] = F[ee];
                            return we[p] = x(pe), Ds(d, this, we)
                        }
                }

                function xH(d, p) {
                    return p.length < 2 ? d : Cg(d, ql(p, 0, -1))
                }

                function rge(d, p) {
                    for (var x = d.length, F = po(p.length, x), ee = Ea(d); F--;) {
                        var ce = p[F];
                        d[F] = Ed(ce, x) ? ee[ce] : n
                    }
                    return d
                }

                function iR(d, p) {
                    if (!(p === "constructor" && typeof d[p] == "function") && p != "__proto__") return d[p]
                }
                var SH = AH(qj),
                    I5 = w0e || function(d, p) {
                        return tr.setTimeout(d, p)
                    },
                    sR = AH(Ape);

                function CH(d, p, x) {
                    var F = p + "";
                    return sR(d, Kpe(F, ige(Vpe(F), x)))
                }

                function AH(d) {
                    var p = 0,
                        x = 0;
                    return function() {
                        var F = E0e(),
                            ee = U - (F - x);
                        if (x = F, ee > 0) {
                            if (++p >= te) return arguments[0]
                        } else p = 0;
                        return d.apply(n, arguments)
                    }
                }

                function bx(d, p) {
                    var x = -1,
                        F = d.length,
                        ee = F - 1;
                    for (p = p === n ? F : p; ++x < p;) {
                        var ce = jI(x, ee),
                            pe = d[ce];
                        d[ce] = d[x], d[x] = pe
                    }
                    return d.length = p, d
                }
                var TH = Xpe(function(d) {
                    var p = [];
                    return d.charCodeAt(0) === 46 && p.push(""), d.replace(Vt, function(x, F, ee, ce) {
                        p.push(ee ? ce.replace(Je, "$1") : F || x)
                    }), p
                });

                function ef(d) {
                    if (typeof d == "string" || rl(d)) return d;
                    var p = d + "";
                    return p == "0" && 1 / d == -N ? "-0" : p
                }

                function Tg(d) {
                    if (d != null) {
                        try {
                            return Y4.call(d)
                        } catch {}
                        try {
                            return d + ""
                        } catch {}
                    }
                    return ""
                }

                function ige(d, p) {
                    return zl(ve, function(x) {
                        var F = "_." + x[0];
                        p & x[1] && !W4(d, F) && d.push(F)
                    }), d.sort()
                }

                function IH(d) {
                    if (d instanceof Kn) return d.clone();
                    var p = new Vl(d.__wrapped__, d.__chain__);
                    return p.__actions__ = Ea(d.__actions__), p.__index__ = d.__index__, p.__values__ = d.__values__, p
                }

                function sge(d, p, x) {
                    (x ? Wo(d, p, x) : p === n) ? p = 1: p = Cs(Tn(p), 0);
                    var F = d == null ? 0 : d.length;
                    if (!F || p < 1) return [];
                    for (var ee = 0, ce = 0, pe = Ne(nx(F / p)); ee < F;) pe[ce++] = ql(d, ee, ee += p);
                    return pe
                }

                function oge(d) {
                    for (var p = -1, x = d == null ? 0 : d.length, F = 0, ee = []; ++p < x;) {
                        var ce = d[p];
                        ce && (ee[F++] = ce)
                    }
                    return ee
                }

                function age() {
                    var d = arguments.length;
                    if (!d) return [];
                    for (var p = Ne(d - 1), x = arguments[0], F = d; F--;) p[F - 1] = arguments[F];
                    return Qh(En(x) ? Ea(x) : [x], eo(p, 1))
                }
                var lge = Ln(function(d, p) {
                        return ts(d) ? E5(d, eo(p, 1, ts, !0)) : []
                    }),
                    cge = Ln(function(d, p) {
                        var x = Kl(p);
                        return ts(x) && (x = n), ts(d) ? E5(d, eo(p, 1, ts, !0), tn(x, 2)) : []
                    }),
                    uge = Ln(function(d, p) {
                        var x = Kl(p);
                        return ts(x) && (x = n), ts(d) ? E5(d, eo(p, 1, ts, !0), n, x) : []
                    });

                function fge(d, p, x) {
                    var F = d == null ? 0 : d.length;
                    return F ? (p = x || p === n ? 1 : Tn(p), ql(d, p < 0 ? 0 : p, F)) : []
                }

                function dge(d, p, x) {
                    var F = d == null ? 0 : d.length;
                    return F ? (p = x || p === n ? 1 : Tn(p), p = F - p, ql(d, 0, p < 0 ? 0 : p)) : []
                }

                function hge(d, p) {
                    return d && d.length ? dx(d, tn(p, 3), !0, !0) : []
                }

                function pge(d, p) {
                    return d && d.length ? dx(d, tn(p, 3), !0) : []
                }

                function gge(d, p, x, F) {
                    var ee = d == null ? 0 : d.length;
                    return ee ? (x && typeof x != "number" && Wo(d, p, x) && (x = 0, F = ee), ape(d, p, x, F)) : []
                }

                function RH(d, p, x) {
                    var F = d == null ? 0 : d.length;
                    if (!F) return -1;
                    var ee = x == null ? 0 : Tn(x);
                    return ee < 0 && (ee = Cs(F + ee, 0)), V4(d, tn(p, 3), ee)
                }

                function OH(d, p, x) {
                    var F = d == null ? 0 : d.length;
                    if (!F) return -1;
                    var ee = F - 1;
                    return x !== n && (ee = Tn(x), ee = x < 0 ? Cs(F + ee, 0) : po(ee, F - 1)), V4(d, tn(p, 3), ee, !0)
                }

                function NH(d) {
                    var p = d == null ? 0 : d.length;
                    return p ? eo(d, 1) : []
                }

                function mge(d) {
                    var p = d == null ? 0 : d.length;
                    return p ? eo(d, N) : []
                }

                function yge(d, p) {
                    var x = d == null ? 0 : d.length;
                    return x ? (p = p === n ? 1 : Tn(p), eo(d, p)) : []
                }

                function wge(d) {
                    for (var p = -1, x = d == null ? 0 : d.length, F = {}; ++p < x;) {
                        var ee = d[p];
                        F[ee[0]] = ee[1]
                    }
                    return F
                }

                function PH(d) {
                    return d && d.length ? d[0] : n
                }

                function vge(d, p, x) {
                    var F = d == null ? 0 : d.length;
                    if (!F) return -1;
                    var ee = x == null ? 0 : Tn(x);
                    return ee < 0 && (ee = Cs(F + ee, 0)), Ly(d, p, ee)
                }

                function bge(d) {
                    var p = d == null ? 0 : d.length;
                    return p ? ql(d, 0, -1) : []
                }
                var _ge = Ln(function(d) {
                        var p = fi(d, GI);
                        return p.length && p[0] === d[0] ? $I(p) : []
                    }),
                    Ege = Ln(function(d) {
                        var p = Kl(d),
                            x = fi(d, GI);
                        return p === Kl(x) ? p = n : x.pop(), x.length && x[0] === d[0] ? $I(x, tn(p, 2)) : []
                    }),
                    xge = Ln(function(d) {
                        var p = Kl(d),
                            x = fi(d, GI);
                        return p = typeof p == "function" ? p : n, p && x.pop(), x.length && x[0] === d[0] ? $I(x, n, p) : []
                    });

                function Sge(d, p) {
                    return d == null ? "" : b0e.call(d, p)
                }

                function Kl(d) {
                    var p = d == null ? 0 : d.length;
                    return p ? d[p - 1] : n
                }

                function Cge(d, p, x) {
                    var F = d == null ? 0 : d.length;
                    if (!F) return -1;
                    var ee = F;
                    return x !== n && (ee = Tn(x), ee = ee < 0 ? Cs(F + ee, 0) : po(ee, F - 1)), p === p ? i0e(d, p, ee) : V4(d, dj, ee, !0)
                }

                function Age(d, p) {
                    return d && d.length ? zj(d, Tn(p)) : n
                }
                var Tge = Ln(kH);

                function kH(d, p) {
                    return d && d.length && p && p.length ? UI(d, p) : d
                }

                function Ige(d, p, x) {
                    return d && d.length && p && p.length ? UI(d, p, tn(x, 2)) : d
                }

                function Rge(d, p, x) {
                    return d && d.length && p && p.length ? UI(d, p, n, x) : d
                }
                var Oge = _d(function(d, p) {
                    var x = d == null ? 0 : d.length,
                        F = PI(d, p);
                    return Gj(d, fi(p, function(ee) {
                        return Ed(ee, x) ? +ee : ee
                    }).sort(nH)), F
                });

                function Nge(d, p) {
                    var x = [];
                    if (!(d && d.length)) return x;
                    var F = -1,
                        ee = [],
                        ce = d.length;
                    for (p = tn(p, 3); ++F < ce;) {
                        var pe = d[F];
                        p(pe, F, d) && (x.push(pe), ee.push(F))
                    }
                    return Gj(d, ee), x
                }

                function oR(d) {
                    return d == null ? d : S0e.call(d)
                }

                function Pge(d, p, x) {
                    var F = d == null ? 0 : d.length;
                    return F ? (x && typeof x != "number" && Wo(d, p, x) ? (p = 0, x = F) : (p = p == null ? 0 : Tn(p), x = x === n ? F : Tn(x)), ql(d, p, x)) : []
                }

                function kge(d, p) {
                    return fx(d, p)
                }

                function Mge(d, p, x) {
                    return zI(d, p, tn(x, 2))
                }

                function Dge(d, p) {
                    var x = d == null ? 0 : d.length;
                    if (x) {
                        var F = fx(d, p);
                        if (F < x && Wc(d[F], p)) return F
                    }
                    return -1
                }

                function $ge(d, p) {
                    return fx(d, p, !0)
                }

                function Lge(d, p, x) {
                    return zI(d, p, tn(x, 2), !0)
                }

                function Bge(d, p) {
                    var x = d == null ? 0 : d.length;
                    if (x) {
                        var F = fx(d, p, !0) - 1;
                        if (Wc(d[F], p)) return F
                    }
                    return -1
                }

                function Fge(d) {
                    return d && d.length ? Kj(d) : []
                }

                function Uge(d, p) {
                    return d && d.length ? Kj(d, tn(p, 2)) : []
                }

                function jge(d) {
                    var p = d == null ? 0 : d.length;
                    return p ? ql(d, 1, p) : []
                }

                function Hge(d, p, x) {
                    return d && d.length ? (p = x || p === n ? 1 : Tn(p), ql(d, 0, p < 0 ? 0 : p)) : []
                }

                function zge(d, p, x) {
                    var F = d == null ? 0 : d.length;
                    return F ? (p = x || p === n ? 1 : Tn(p), p = F - p, ql(d, p < 0 ? 0 : p, F)) : []
                }

                function Wge(d, p) {
                    return d && d.length ? dx(d, tn(p, 3), !1, !0) : []
                }

                function Vge(d, p) {
                    return d && d.length ? dx(d, tn(p, 3)) : []
                }
                var Gge = Ln(function(d) {
                        return t0(eo(d, 1, ts, !0))
                    }),
                    qge = Ln(function(d) {
                        var p = Kl(d);
                        return ts(p) && (p = n), t0(eo(d, 1, ts, !0), tn(p, 2))
                    }),
                    Kge = Ln(function(d) {
                        var p = Kl(d);
                        return p = typeof p == "function" ? p : n, t0(eo(d, 1, ts, !0), n, p)
                    });

                function Yge(d) {
                    return d && d.length ? t0(d) : []
                }

                function Zge(d, p) {
                    return d && d.length ? t0(d, tn(p, 2)) : []
                }

                function Qge(d, p) {
                    return p = typeof p == "function" ? p : n, d && d.length ? t0(d, n, p) : []
                }

                function aR(d) {
                    if (!(d && d.length)) return [];
                    var p = 0;
                    return d = Zh(d, function(x) {
                        if (ts(x)) return p = Cs(x.length, p), !0
                    }), SI(p, function(x) {
                        return fi(d, _I(x))
                    })
                }

                function MH(d, p) {
                    if (!(d && d.length)) return [];
                    var x = aR(d);
                    return p == null ? x : fi(x, function(F) {
                        return Ds(p, n, F)
                    })
                }
                var Jge = Ln(function(d, p) {
                        return ts(d) ? E5(d, p) : []
                    }),
                    Xge = Ln(function(d) {
                        return VI(Zh(d, ts))
                    }),
                    e1e = Ln(function(d) {
                        var p = Kl(d);
                        return ts(p) && (p = n), VI(Zh(d, ts), tn(p, 2))
                    }),
                    t1e = Ln(function(d) {
                        var p = Kl(d);
                        return p = typeof p == "function" ? p : n, VI(Zh(d, ts), n, p)
                    }),
                    n1e = Ln(aR);

                function r1e(d, p) {
                    return Jj(d || [], p || [], _5)
                }

                function i1e(d, p) {
                    return Jj(d || [], p || [], C5)
                }
                var s1e = Ln(function(d) {
                    var p = d.length,
                        x = p > 1 ? d[p - 1] : n;
                    return x = typeof x == "function" ? (d.pop(), x) : n, MH(d, x)
                });

                function DH(d) {
                    var p = oe(d);
                    return p.__chain__ = !0, p
                }

                function o1e(d, p) {
                    return p(d), d
                }

                function _x(d, p) {
                    return p(d)
                }
                var a1e = _d(function(d) {
                    var p = d.length,
                        x = p ? d[0] : 0,
                        F = this.__wrapped__,
                        ee = function(ce) {
                            return PI(ce, d)
                        };
                    return p > 1 || this.__actions__.length || !(F instanceof Kn) || !Ed(x) ? this.thru(ee) : (F = F.slice(x, +x + (p ? 1 : 0)), F.__actions__.push({
                        func: _x,
                        args: [ee],
                        thisArg: n
                    }), new Vl(F, this.__chain__).thru(function(ce) {
                        return p && !ce.length && ce.push(n), ce
                    }))
                });

                function l1e() {
                    return DH(this)
                }

                function c1e() {
                    return new Vl(this.value(), this.__chain__)
                }

                function u1e() {
                    this.__values__ === n && (this.__values__ = YH(this.value()));
                    var d = this.__index__ >= this.__values__.length,
                        p = d ? n : this.__values__[this.__index__++];
                    return {
                        done: d,
                        value: p
                    }
                }

                function f1e() {
                    return this
                }

                function d1e(d) {
                    for (var p, x = this; x instanceof ox;) {
                        var F = IH(x);
                        F.__index__ = 0, F.__values__ = n, p ? ee.__wrapped__ = F : p = F;
                        var ee = F;
                        x = x.__wrapped__
                    }
                    return ee.__wrapped__ = d, p
                }

                function h1e() {
                    var d = this.__wrapped__;
                    if (d instanceof Kn) {
                        var p = d;
                        return this.__actions__.length && (p = new Kn(this)), p = p.reverse(), p.__actions__.push({
                            func: _x,
                            args: [oR],
                            thisArg: n
                        }), new Vl(p, this.__chain__)
                    }
                    return this.thru(oR)
                }

                function p1e() {
                    return Qj(this.__wrapped__, this.__actions__)
                }
                var g1e = hx(function(d, p, x) {
                    Ir.call(d, x) ? ++d[x] : vd(d, x, 1)
                });

                function m1e(d, p, x) {
                    var F = En(d) ? uj : ope;
                    return x && Wo(d, p, x) && (p = n), F(d, tn(p, 3))
                }

                function y1e(d, p) {
                    var x = En(d) ? Zh : Mj;
                    return x(d, tn(p, 3))
                }
                var w1e = lH(RH),
                    v1e = lH(OH);

                function b1e(d, p) {
                    return eo(Ex(d, p), 1)
                }

                function _1e(d, p) {
                    return eo(Ex(d, p), N)
                }

                function E1e(d, p, x) {
                    return x = x === n ? 1 : Tn(x), eo(Ex(d, p), x)
                }

                function $H(d, p) {
                    var x = En(d) ? zl : e0;
                    return x(d, tn(p, 3))
                }

                function LH(d, p) {
                    var x = En(d) ? jhe : kj;
                    return x(d, tn(p, 3))
                }
                var x1e = hx(function(d, p, x) {
                    Ir.call(d, x) ? d[x].push(p) : vd(d, x, [p])
                });

                function S1e(d, p, x, F) {
                    d = xa(d) ? d : Yy(d), x = x && !F ? Tn(x) : 0;
                    var ee = d.length;
                    return x < 0 && (x = Cs(ee + x, 0)), Tx(d) ? x <= ee && d.indexOf(p, x) > -1 : !!ee && Ly(d, p, x) > -1
                }
                var C1e = Ln(function(d, p, x) {
                        var F = -1,
                            ee = typeof p == "function",
                            ce = xa(d) ? Ne(d.length) : [];
                        return e0(d, function(pe) {
                            ce[++F] = ee ? Ds(p, pe, x) : x5(pe, p, x)
                        }), ce
                    }),
                    A1e = hx(function(d, p, x) {
                        vd(d, x, p)
                    });

                function Ex(d, p) {
                    var x = En(d) ? fi : Uj;
                    return x(d, tn(p, 3))
                }

                function T1e(d, p, x, F) {
                    return d == null ? [] : (En(p) || (p = p == null ? [] : [p]), x = F ? n : x, En(x) || (x = x == null ? [] : [x]), Wj(d, p, x))
                }
                var I1e = hx(function(d, p, x) {
                    d[x ? 0 : 1].push(p)
                }, function() {
                    return [
                        [],
                        []
                    ]
                });

                function R1e(d, p, x) {
                    var F = En(d) ? vI : pj,
                        ee = arguments.length < 3;
                    return F(d, tn(p, 4), x, ee, e0)
                }

                function O1e(d, p, x) {
                    var F = En(d) ? Hhe : pj,
                        ee = arguments.length < 3;
                    return F(d, tn(p, 4), x, ee, kj)
                }

                function N1e(d, p) {
                    var x = En(d) ? Zh : Mj;
                    return x(d, Cx(tn(p, 3)))
                }

                function P1e(d) {
                    var p = En(d) ? Rj : Spe;
                    return p(d)
                }

                function k1e(d, p, x) {
                    (x ? Wo(d, p, x) : p === n) ? p = 1: p = Tn(p);
                    var F = En(d) ? tpe : Cpe;
                    return F(d, p)
                }

                function M1e(d) {
                    var p = En(d) ? npe : Tpe;
                    return p(d)
                }

                function D1e(d) {
                    if (d == null) return 0;
                    if (xa(d)) return Tx(d) ? Fy(d) : d.length;
                    var p = go(d);
                    return p == me || p == tt ? d.size : BI(d).length
                }

                function $1e(d, p, x) {
                    var F = En(d) ? bI : Ipe;
                    return x && Wo(d, p, x) && (p = n), F(d, tn(p, 3))
                }
                var L1e = Ln(function(d, p) {
                        if (d == null) return [];
                        var x = p.length;
                        return x > 1 && Wo(d, p[0], p[1]) ? p = [] : x > 2 && Wo(p[0], p[1], p[2]) && (p = [p[0]]), Wj(d, eo(p, 1), [])
                    }),
                    xx = y0e || function() {
                        return tr.Date.now()
                    };

                function B1e(d, p) {
                    if (typeof p != "function") throw new Wl(o);
                    return d = Tn(d),
                        function() {
                            if (--d < 1) return p.apply(this, arguments)
                        }
                }

                function BH(d, p, x) {
                    return p = x ? n : p, p = d && p == null ? d.length : p, bd(d, A, n, n, n, n, p)
                }

                function FH(d, p) {
                    var x;
                    if (typeof p != "function") throw new Wl(o);
                    return d = Tn(d),
                        function() {
                            return --d > 0 && (x = p.apply(this, arguments)), d <= 1 && (p = n), x
                        }
                }
                var lR = Ln(function(d, p, x) {
                        var F = C;
                        if (x.length) {
                            var ee = Jh(x, qy(lR));
                            F |= P
                        }
                        return bd(d, F, p, x, ee)
                    }),
                    UH = Ln(function(d, p, x) {
                        var F = C | b;
                        if (x.length) {
                            var ee = Jh(x, qy(UH));
                            F |= P
                        }
                        return bd(p, F, d, x, ee)
                    });

                function jH(d, p, x) {
                    p = x ? n : p;
                    var F = bd(d, S, n, n, n, n, n, p);
                    return F.placeholder = jH.placeholder, F
                }

                function HH(d, p, x) {
                    p = x ? n : p;
                    var F = bd(d, I, n, n, n, n, n, p);
                    return F.placeholder = HH.placeholder, F
                }

                function zH(d, p, x) {
                    var F, ee, ce, pe, we, Te, Fe = 0,
                        Ue = !1,
                        Ge = !1,
                        dt = !0;
                    if (typeof d != "function") throw new Wl(o);
                    p = Yl(p) || 0, _i(x) && (Ue = !!x.leading, Ge = "maxWait" in x, ce = Ge ? Cs(Yl(x.maxWait) || 0, p) : ce, dt = "trailing" in x ? !!x.trailing : dt);

                    function $t(ns) {
                        var Vc = F,
                            Cd = ee;
                        return F = ee = n, Fe = ns, pe = d.apply(Cd, Vc), pe
                    }

                    function nn(ns) {
                        return Fe = ns, we = I5(Wn, p), Ue ? $t(ns) : pe
                    }

                    function Nn(ns) {
                        var Vc = ns - Te,
                            Cd = ns - Fe,
                            lz = p - Vc;
                        return Ge ? po(lz, ce - Cd) : lz
                    }

                    function rn(ns) {
                        var Vc = ns - Te,
                            Cd = ns - Fe;
                        return Te === n || Vc >= p || Vc < 0 || Ge && Cd >= ce
                    }

                    function Wn() {
                        var ns = xx();
                        if (rn(ns)) return nr(ns);
                        we = I5(Wn, Nn(ns))
                    }

                    function nr(ns) {
                        return we = n, dt && F ? $t(ns) : (F = ee = n, pe)
                    }

                    function il() {
                        we !== n && Xj(we), Fe = 0, F = Te = ee = we = n
                    }

                    function Vo() {
                        return we === n ? pe : nr(xx())
                    }

                    function sl() {
                        var ns = xx(),
                            Vc = rn(ns);
                        if (F = arguments, ee = this, Te = ns, Vc) {
                            if (we === n) return nn(Te);
                            if (Ge) return Xj(we), we = I5(Wn, p), $t(Te)
                        }
                        return we === n && (we = I5(Wn, p)), pe
                    }
                    return sl.cancel = il, sl.flush = Vo, sl
                }
                var F1e = Ln(function(d, p) {
                        return Pj(d, 1, p)
                    }),
                    U1e = Ln(function(d, p, x) {
                        return Pj(d, Yl(p) || 0, x)
                    });

                function j1e(d) {
                    return bd(d, $)
                }

                function Sx(d, p) {
                    if (typeof d != "function" || p != null && typeof p != "function") throw new Wl(o);
                    var x = function() {
                        var F = arguments,
                            ee = p ? p.apply(this, F) : F[0],
                            ce = x.cache;
                        if (ce.has(ee)) return ce.get(ee);
                        var pe = d.apply(this, F);
                        return x.cache = ce.set(ee, pe) || ce, pe
                    };
                    return x.cache = new(Sx.Cache || wd), x
                }
                Sx.Cache = wd;

                function Cx(d) {
                    if (typeof d != "function") throw new Wl(o);
                    return function() {
                        var p = arguments;
                        switch (p.length) {
                            case 0:
                                return !d.call(this);
                            case 1:
                                return !d.call(this, p[0]);
                            case 2:
                                return !d.call(this, p[0], p[1]);
                            case 3:
                                return !d.call(this, p[0], p[1], p[2])
                        }
                        return !d.apply(this, p)
                    }
                }

                function H1e(d) {
                    return FH(2, d)
                }
                var z1e = Rpe(function(d, p) {
                        p = p.length == 1 && En(p[0]) ? fi(p[0], tl(tn())) : fi(eo(p, 1), tl(tn()));
                        var x = p.length;
                        return Ln(function(F) {
                            for (var ee = -1, ce = po(F.length, x); ++ee < ce;) F[ee] = p[ee].call(this, F[ee]);
                            return Ds(d, this, F)
                        })
                    }),
                    cR = Ln(function(d, p) {
                        var x = Jh(p, qy(cR));
                        return bd(d, P, n, p, x)
                    }),
                    WH = Ln(function(d, p) {
                        var x = Jh(p, qy(WH));
                        return bd(d, M, n, p, x)
                    }),
                    W1e = _d(function(d, p) {
                        return bd(d, E, n, n, n, p)
                    });

                function V1e(d, p) {
                    if (typeof d != "function") throw new Wl(o);
                    return p = p === n ? p : Tn(p), Ln(d, p)
                }

                function G1e(d, p) {
                    if (typeof d != "function") throw new Wl(o);
                    return p = p == null ? 0 : Cs(Tn(p), 0), Ln(function(x) {
                        var F = x[p],
                            ee = r0(x, 0, p);
                        return F && Qh(ee, F), Ds(d, this, ee)
                    })
                }

                function q1e(d, p, x) {
                    var F = !0,
                        ee = !0;
                    if (typeof d != "function") throw new Wl(o);
                    return _i(x) && (F = "leading" in x ? !!x.leading : F, ee = "trailing" in x ? !!x.trailing : ee), zH(d, p, {
                        leading: F,
                        maxWait: p,
                        trailing: ee
                    })
                }

                function K1e(d) {
                    return BH(d, 1)
                }

                function Y1e(d, p) {
                    return cR(qI(p), d)
                }

                function Z1e() {
                    if (!arguments.length) return [];
                    var d = arguments[0];
                    return En(d) ? d : [d]
                }

                function Q1e(d) {
                    return Gl(d, g)
                }

                function J1e(d, p) {
                    return p = typeof p == "function" ? p : n, Gl(d, g, p)
                }

                function X1e(d) {
                    return Gl(d, f | g)
                }

                function eme(d, p) {
                    return p = typeof p == "function" ? p : n, Gl(d, f | g, p)
                }

                function tme(d, p) {
                    return p == null || Nj(d, p, $s(p))
                }

                function Wc(d, p) {
                    return d === p || d !== d && p !== p
                }
                var nme = yx(DI),
                    rme = yx(function(d, p) {
                        return d >= p
                    }),
                    Ig = Lj(function() {
                        return arguments
                    }()) ? Lj : function(d) {
                        return Li(d) && Ir.call(d, "callee") && !xj.call(d, "callee")
                    },
                    En = Ne.isArray,
                    ime = Ho ? tl(Ho) : dpe;

                function xa(d) {
                    return d != null && Ax(d.length) && !xd(d)
                }

                function ts(d) {
                    return Li(d) && xa(d)
                }

                function sme(d) {
                    return d === !0 || d === !1 || Li(d) && zo(d) == ne
                }
                var i0 = v0e || bR,
                    ome = jc ? tl(jc) : hpe;

                function ame(d) {
                    return Li(d) && d.nodeType === 1 && !R5(d)
                }

                function lme(d) {
                    if (d == null) return !0;
                    if (xa(d) && (En(d) || typeof d == "string" || typeof d.splice == "function" || i0(d) || Ky(d) || Ig(d))) return !d.length;
                    var p = go(d);
                    if (p == me || p == tt) return !d.size;
                    if (T5(d)) return !BI(d).length;
                    for (var x in d)
                        if (Ir.call(d, x)) return !1;
                    return !0
                }

                function cme(d, p) {
                    return S5(d, p)
                }

                function ume(d, p, x) {
                    x = typeof x == "function" ? x : n;
                    var F = x ? x(d, p) : n;
                    return F === n ? S5(d, p, n, x) : !!F
                }

                function uR(d) {
                    if (!Li(d)) return !1;
                    var p = zo(d);
                    return p == z || p == k || typeof d.message == "string" && typeof d.name == "string" && !R5(d)
                }

                function fme(d) {
                    return typeof d == "number" && Cj(d)
                }

                function xd(d) {
                    if (!_i(d)) return !1;
                    var p = zo(d);
                    return p == Z || p == ge || p == q || p == mn
                }

                function VH(d) {
                    return typeof d == "number" && d == Tn(d)
                }

                function Ax(d) {
                    return typeof d == "number" && d > -1 && d % 1 == 0 && d <= O
                }

                function _i(d) {
                    var p = typeof d;
                    return d != null && (p == "object" || p == "function")
                }

                function Li(d) {
                    return d != null && typeof d == "object"
                }
                var GH = Hl ? tl(Hl) : gpe;

                function dme(d, p) {
                    return d === p || LI(d, p, eR(p))
                }

                function hme(d, p, x) {
                    return x = typeof x == "function" ? x : n, LI(d, p, eR(p), x)
                }

                function pme(d) {
                    return qH(d) && d != +d
                }

                function gme(d) {
                    if (Jpe(d)) throw new yn(s);
                    return Bj(d)
                }

                function mme(d) {
                    return d === null
                }

                function yme(d) {
                    return d == null
                }

                function qH(d) {
                    return typeof d == "number" || Li(d) && zo(d) == Re
                }

                function R5(d) {
                    if (!Li(d) || zo(d) != Be) return !1;
                    var p = X4(d);
                    if (p === null) return !0;
                    var x = Ir.call(p, "constructor") && p.constructor;
                    return typeof x == "function" && x instanceof x && Y4.call(x) == h0e
                }
                var fR = Qu ? tl(Qu) : mpe;

                function wme(d) {
                    return VH(d) && d >= -O && d <= O
                }
                var KH = p5 ? tl(p5) : ype;

                function Tx(d) {
                    return typeof d == "string" || !En(d) && Li(d) && zo(d) == _t
                }

                function rl(d) {
                    return typeof d == "symbol" || Li(d) && zo(d) == ot
                }
                var Ky = bg ? tl(bg) : wpe;

                function vme(d) {
                    return d === n
                }

                function bme(d) {
                    return Li(d) && go(d) == wt
                }

                function _me(d) {
                    return Li(d) && zo(d) == Xe
                }
                var Eme = yx(FI),
                    xme = yx(function(d, p) {
                        return d <= p
                    });

                function YH(d) {
                    if (!d) return [];
                    if (xa(d)) return Tx(d) ? Hc(d) : Ea(d);
                    if (m5 && d[m5]) return t0e(d[m5]());
                    var p = go(d),
                        x = p == me ? AI : p == tt ? G4 : Yy;
                    return x(d)
                }

                function Sd(d) {
                    if (!d) return d === 0 ? d : 0;
                    if (d = Yl(d), d === N || d === -N) {
                        var p = d < 0 ? -1 : 1;
                        return p * L
                    }
                    return d === d ? d : 0
                }

                function Tn(d) {
                    var p = Sd(d),
                        x = p % 1;
                    return p === p ? x ? p - x : p : 0
                }

                function ZH(d) {
                    return d ? Sg(Tn(d), 0, j) : 0
                }

                function Yl(d) {
                    if (typeof d == "number") return d;
                    if (rl(d)) return G;
                    if (_i(d)) {
                        var p = typeof d.valueOf == "function" ? d.valueOf() : d;
                        d = _i(p) ? p + "" : p
                    }
                    if (typeof d != "string") return d === 0 ? d : +d;
                    d = gj(d);
                    var x = ct.test(d);
                    return x || an.test(d) ? _n(d.slice(2), x ? 2 : 8) : rt.test(d) ? G : +d
                }

                function QH(d) {
                    return Xu(d, Sa(d))
                }

                function Sme(d) {
                    return d ? Sg(Tn(d), -O, O) : d === 0 ? d : 0
                }

                function Sr(d) {
                    return d == null ? "" : nl(d)
                }
                var Cme = Vy(function(d, p) {
                        if (T5(p) || xa(p)) {
                            Xu(p, $s(p), d);
                            return
                        }
                        for (var x in p) Ir.call(p, x) && _5(d, x, p[x])
                    }),
                    JH = Vy(function(d, p) {
                        Xu(p, Sa(p), d)
                    }),
                    Ix = Vy(function(d, p, x, F) {
                        Xu(p, Sa(p), d, F)
                    }),
                    Ame = Vy(function(d, p, x, F) {
                        Xu(p, $s(p), d, F)
                    }),
                    Tme = _d(PI);

                function Ime(d, p) {
                    var x = Wy(d);
                    return p == null ? x : Oj(x, p)
                }
                var Rme = Ln(function(d, p) {
                        d = jr(d);
                        var x = -1,
                            F = p.length,
                            ee = F > 2 ? p[2] : n;
                        for (ee && Wo(p[0], p[1], ee) && (F = 1); ++x < F;)
                            for (var ce = p[x], pe = Sa(ce), we = -1, Te = pe.length; ++we < Te;) {
                                var Fe = pe[we],
                                    Ue = d[Fe];
                                (Ue === n || Wc(Ue, jy[Fe]) && !Ir.call(d, Fe)) && (d[Fe] = ce[Fe])
                            }
                        return d
                    }),
                    Ome = Ln(function(d) {
                        return d.push(n, gH), Ds(XH, n, d)
                    });

                function Nme(d, p) {
                    return fj(d, tn(p, 3), Ju)
                }

                function Pme(d, p) {
                    return fj(d, tn(p, 3), MI)
                }

                function kme(d, p) {
                    return d == null ? d : kI(d, tn(p, 3), Sa)
                }

                function Mme(d, p) {
                    return d == null ? d : Dj(d, tn(p, 3), Sa)
                }

                function Dme(d, p) {
                    return d && Ju(d, tn(p, 3))
                }

                function $me(d, p) {
                    return d && MI(d, tn(p, 3))
                }

                function Lme(d) {
                    return d == null ? [] : cx(d, $s(d))
                }

                function Bme(d) {
                    return d == null ? [] : cx(d, Sa(d))
                }

                function dR(d, p, x) {
                    var F = d == null ? n : Cg(d, p);
                    return F === n ? x : F
                }

                function Fme(d, p) {
                    return d != null && wH(d, p, lpe)
                }

                function hR(d, p) {
                    return d != null && wH(d, p, cpe)
                }
                var Ume = uH(function(d, p, x) {
                        p != null && typeof p.toString != "function" && (p = Z4.call(p)), d[p] = x
                    }, gR(Ca)),
                    jme = uH(function(d, p, x) {
                        p != null && typeof p.toString != "function" && (p = Z4.call(p)), Ir.call(d, p) ? d[p].push(x) : d[p] = [x]
                    }, tn),
                    Hme = Ln(x5);

                function $s(d) {
                    return xa(d) ? Ij(d) : BI(d)
                }

                function Sa(d) {
                    return xa(d) ? Ij(d, !0) : vpe(d)
                }

                function zme(d, p) {
                    var x = {};
                    return p = tn(p, 3), Ju(d, function(F, ee, ce) {
                        vd(x, p(F, ee, ce), F)
                    }), x
                }

                function Wme(d, p) {
                    var x = {};
                    return p = tn(p, 3), Ju(d, function(F, ee, ce) {
                        vd(x, ee, p(F, ee, ce))
                    }), x
                }
                var Vme = Vy(function(d, p, x) {
                        ux(d, p, x)
                    }),
                    XH = Vy(function(d, p, x, F) {
                        ux(d, p, x, F)
                    }),
                    Gme = _d(function(d, p) {
                        var x = {};
                        if (d == null) return x;
                        var F = !1;
                        p = fi(p, function(ce) {
                            return ce = n0(ce, d), F || (F = ce.length > 1), ce
                        }), Xu(d, JI(d), x), F && (x = Gl(x, f | h | g, Upe));
                        for (var ee = p.length; ee--;) WI(x, p[ee]);
                        return x
                    });

                function qme(d, p) {
                    return ez(d, Cx(tn(p)))
                }
                var Kme = _d(function(d, p) {
                    return d == null ? {} : _pe(d, p)
                });

                function ez(d, p) {
                    if (d == null) return {};
                    var x = fi(JI(d), function(F) {
                        return [F]
                    });
                    return p = tn(p), Vj(d, x, function(F, ee) {
                        return p(F, ee[0])
                    })
                }

                function Yme(d, p, x) {
                    p = n0(p, d);
                    var F = -1,
                        ee = p.length;
                    for (ee || (ee = 1, d = n); ++F < ee;) {
                        var ce = d == null ? n : d[ef(p[F])];
                        ce === n && (F = ee, ce = x), d = xd(ce) ? ce.call(d) : ce
                    }
                    return d
                }

                function Zme(d, p, x) {
                    return d == null ? d : C5(d, p, x)
                }

                function Qme(d, p, x, F) {
                    return F = typeof F == "function" ? F : n, d == null ? d : C5(d, p, x, F)
                }
                var tz = hH($s),
                    nz = hH(Sa);

                function Jme(d, p, x) {
                    var F = En(d),
                        ee = F || i0(d) || Ky(d);
                    if (p = tn(p, 4), x == null) {
                        var ce = d && d.constructor;
                        ee ? x = F ? new ce : [] : _i(d) ? x = xd(ce) ? Wy(X4(d)) : {} : x = {}
                    }
                    return (ee ? zl : Ju)(d, function(pe, we, Te) {
                        return p(x, pe, we, Te)
                    }), x
                }

                function Xme(d, p) {
                    return d == null ? !0 : WI(d, p)
                }

                function eye(d, p, x) {
                    return d == null ? d : Zj(d, p, qI(x))
                }

                function tye(d, p, x, F) {
                    return F = typeof F == "function" ? F : n, d == null ? d : Zj(d, p, qI(x), F)
                }

                function Yy(d) {
                    return d == null ? [] : CI(d, $s(d))
                }

                function nye(d) {
                    return d == null ? [] : CI(d, Sa(d))
                }

                function rye(d, p, x) {
                    return x === n && (x = p, p = n), x !== n && (x = Yl(x), x = x === x ? x : 0), p !== n && (p = Yl(p), p = p === p ? p : 0), Sg(Yl(d), p, x)
                }

                function iye(d, p, x) {
                    return p = Sd(p), x === n ? (x = p, p = 0) : x = Sd(x), d = Yl(d), upe(d, p, x)
                }

                function sye(d, p, x) {
                    if (x && typeof x != "boolean" && Wo(d, p, x) && (p = x = n), x === n && (typeof p == "boolean" ? (x = p, p = n) : typeof d == "boolean" && (x = d, d = n)), d === n && p === n ? (d = 0, p = 1) : (d = Sd(d), p === n ? (p = d, d = 0) : p = Sd(p)), d > p) {
                        var F = d;
                        d = p, p = F
                    }
                    if (x || d % 1 || p % 1) {
                        var ee = Aj();
                        return po(d + ee * (p - d + Fr("1e-" + ((ee + "").length - 1))), p)
                    }
                    return jI(d, p)
                }
                var oye = Gy(function(d, p, x) {
                    return p = p.toLowerCase(), d + (x ? rz(p) : p)
                });

                function rz(d) {
                    return pR(Sr(d).toLowerCase())
                }

                function iz(d) {
                    return d = Sr(d), d && d.replace(ln, Zhe).replace(mI, "")
                }

                function aye(d, p, x) {
                    d = Sr(d), p = nl(p);
                    var F = d.length;
                    x = x === n ? F : Sg(Tn(x), 0, F);
                    var ee = x;
                    return x -= p.length, x >= 0 && d.slice(x, ee) == p
                }

                function lye(d) {
                    return d = Sr(d), d && Lt.test(d) ? d.replace(On, Qhe) : d
                }

                function cye(d) {
                    return d = Sr(d), d && Xn.test(d) ? d.replace(Ft, "\\$&") : d
                }
                var uye = Gy(function(d, p, x) {
                        return d + (x ? "-" : "") + p.toLowerCase()
                    }),
                    fye = Gy(function(d, p, x) {
                        return d + (x ? " " : "") + p.toLowerCase()
                    }),
                    dye = aH("toLowerCase");

                function hye(d, p, x) {
                    d = Sr(d), p = Tn(p);
                    var F = p ? Fy(d) : 0;
                    if (!p || F >= p) return d;
                    var ee = (p - F) / 2;
                    return mx(rx(ee), x) + d + mx(nx(ee), x)
                }

                function pye(d, p, x) {
                    d = Sr(d), p = Tn(p);
                    var F = p ? Fy(d) : 0;
                    return p && F < p ? d + mx(p - F, x) : d
                }

                function gye(d, p, x) {
                    d = Sr(d), p = Tn(p);
                    var F = p ? Fy(d) : 0;
                    return p && F < p ? mx(p - F, x) + d : d
                }

                function mye(d, p, x) {
                    return x || p == null ? p = 0 : p && (p = +p), x0e(Sr(d).replace(Kt, ""), p || 0)
                }

                function yye(d, p, x) {
                    return (x ? Wo(d, p, x) : p === n) ? p = 1 : p = Tn(p), HI(Sr(d), p)
                }

                function wye() {
                    var d = arguments,
                        p = Sr(d[0]);
                    return d.length < 3 ? p : p.replace(d[1], d[2])
                }
                var vye = Gy(function(d, p, x) {
                    return d + (x ? "_" : "") + p.toLowerCase()
                });

                function bye(d, p, x) {
                    return x && typeof x != "number" && Wo(d, p, x) && (p = x = n), x = x === n ? j : x >>> 0, x ? (d = Sr(d), d && (typeof p == "string" || p != null && !fR(p)) && (p = nl(p), !p && By(d)) ? r0(Hc(d), 0, x) : d.split(p, x)) : []
                }
                var _ye = Gy(function(d, p, x) {
                    return d + (x ? " " : "") + pR(p)
                });

                function Eye(d, p, x) {
                    return d = Sr(d), x = x == null ? 0 : Sg(Tn(x), 0, d.length), p = nl(p), d.slice(x, x + p.length) == p
                }

                function xye(d, p, x) {
                    var F = oe.templateSettings;
                    x && Wo(d, p, x) && (p = n), d = Sr(d), p = Ix({}, p, F, pH);
                    var ee = Ix({}, p.imports, F.imports, pH),
                        ce = $s(ee),
                        pe = CI(ee, ce),
                        we, Te, Fe = 0,
                        Ue = p.interpolate || cn,
                        Ge = "__p += '",
                        dt = TI((p.escape || cn).source + "|" + Ue.source + "|" + (Ue === Ht ? Mt : cn).source + "|" + (p.evaluate || cn).source + "|$", "g"),
                        $t = "//# sourceURL=" + (Ir.call(p, "sourceURL") ? (p.sourceURL + "").replace(/\s/g, " ") : "lodash.templateSources[" + ++yI + "]") + `
`;
                    d.replace(dt, function(rn, Wn, nr, il, Vo, sl) {
                        return nr || (nr = il), Ge += d.slice(Fe, sl).replace(Er, Jhe), Wn && (we = !0, Ge += `' +
__e(` + Wn + `) +
'`), Vo && (Te = !0, Ge += `';
` + Vo + `;
__p += '`), nr && (Ge += `' +
((__t = (` + nr + `)) == null ? '' : __t) +
'`), Fe = sl + rn.length, rn
                    }), Ge += `';
`;
                    var nn = Ir.call(p, "variable") && p.variable;
                    if (!nn) Ge = `with (obj) {
` + Ge + `
}
`;
                    else if (qe.test(nn)) throw new yn(a);
                    Ge = (Te ? Ge.replace(vt, "") : Ge).replace(hn, "$1").replace(ui, "$1;"), Ge = "function(" + (nn || "obj") + `) {
` + (nn ? "" : `obj || (obj = {});
`) + "var __t, __p = ''" + (we ? ", __e = _.escape" : "") + (Te ? `, __j = Array.prototype.join;
function print() { __p += __j.call(arguments, '') }
` : `;
`) + Ge + `return __p
}`;
                    var Nn = oz(function() {
                        return vr(ce, $t + "return " + Ge).apply(n, pe)
                    });
                    if (Nn.source = Ge, uR(Nn)) throw Nn;
                    return Nn
                }

                function Sye(d) {
                    return Sr(d).toLowerCase()
                }

                function Cye(d) {
                    return Sr(d).toUpperCase()
                }

                function Aye(d, p, x) {
                    if (d = Sr(d), d && (x || p === n)) return gj(d);
                    if (!d || !(p = nl(p))) return d;
                    var F = Hc(d),
                        ee = Hc(p),
                        ce = mj(F, ee),
                        pe = yj(F, ee) + 1;
                    return r0(F, ce, pe).join("")
                }

                function Tye(d, p, x) {
                    if (d = Sr(d), d && (x || p === n)) return d.slice(0, vj(d) + 1);
                    if (!d || !(p = nl(p))) return d;
                    var F = Hc(d),
                        ee = yj(F, Hc(p)) + 1;
                    return r0(F, 0, ee).join("")
                }

                function Iye(d, p, x) {
                    if (d = Sr(d), d && (x || p === n)) return d.replace(Kt, "");
                    if (!d || !(p = nl(p))) return d;
                    var F = Hc(d),
                        ee = mj(F, Hc(p));
                    return r0(F, ee).join("")
                }

                function Rye(d, p) {
                    var x = H,
                        F = K;
                    if (_i(p)) {
                        var ee = "separator" in p ? p.separator : ee;
                        x = "length" in p ? Tn(p.length) : x, F = "omission" in p ? nl(p.omission) : F
                    }
                    d = Sr(d);
                    var ce = d.length;
                    if (By(d)) {
                        var pe = Hc(d);
                        ce = pe.length
                    }
                    if (x >= ce) return d;
                    var we = x - Fy(F);
                    if (we < 1) return F;
                    var Te = pe ? r0(pe, 0, we).join("") : d.slice(0, we);
                    if (ee === n) return Te + F;
                    if (pe && (we += Te.length - we), fR(ee)) {
                        if (d.slice(we).search(ee)) {
                            var Fe, Ue = Te;
                            for (ee.global || (ee = TI(ee.source, Sr(Le.exec(ee)) + "g")), ee.lastIndex = 0; Fe = ee.exec(Ue);) var Ge = Fe.index;
                            Te = Te.slice(0, Ge === n ? we : Ge)
                        }
                    } else if (d.indexOf(nl(ee), we) != we) {
                        var dt = Te.lastIndexOf(ee);
                        dt > -1 && (Te = Te.slice(0, dt))
                    }
                    return Te + F
                }

                function Oye(d) {
                    return d = Sr(d), d && Un.test(d) ? d.replace(bn, s0e) : d
                }
                var Nye = Gy(function(d, p, x) {
                        return d + (x ? " " : "") + p.toUpperCase()
                    }),
                    pR = aH("toUpperCase");

                function sz(d, p, x) {
                    return d = Sr(d), p = x ? n : p, p === n ? e0e(d) ? l0e(d) : Vhe(d) : d.match(p) || []
                }
                var oz = Ln(function(d, p) {
                        try {
                            return Ds(d, n, p)
                        } catch (x) {
                            return uR(x) ? x : new yn(x)
                        }
                    }),
                    Pye = _d(function(d, p) {
                        return zl(p, function(x) {
                            x = ef(x), vd(d, x, lR(d[x], d))
                        }), d
                    });

                function kye(d) {
                    var p = d == null ? 0 : d.length,
                        x = tn();
                    return d = p ? fi(d, function(F) {
                        if (typeof F[1] != "function") throw new Wl(o);
                        return [x(F[0]), F[1]]
                    }) : [], Ln(function(F) {
                        for (var ee = -1; ++ee < p;) {
                            var ce = d[ee];
                            if (Ds(ce[0], this, F)) return Ds(ce[1], this, F)
                        }
                    })
                }

                function Mye(d) {
                    return spe(Gl(d, f))
                }

                function gR(d) {
                    return function() {
                        return d
                    }
                }

                function Dye(d, p) {
                    return d == null || d !== d ? p : d
                }
                var $ye = cH(),
                    Lye = cH(!0);

                function Ca(d) {
                    return d
                }

                function mR(d) {
                    return Fj(typeof d == "function" ? d : Gl(d, f))
                }

                function Bye(d) {
                    return jj(Gl(d, f))
                }

                function Fye(d, p) {
                    return Hj(d, Gl(p, f))
                }
                var Uye = Ln(function(d, p) {
                        return function(x) {
                            return x5(x, d, p)
                        }
                    }),
                    jye = Ln(function(d, p) {
                        return function(x) {
                            return x5(d, x, p)
                        }
                    });

                function yR(d, p, x) {
                    var F = $s(p),
                        ee = cx(p, F);
                    x == null && !(_i(p) && (ee.length || !F.length)) && (x = p, p = d, d = this, ee = cx(p, $s(p)));
                    var ce = !(_i(x) && "chain" in x) || !!x.chain,
                        pe = xd(d);
                    return zl(ee, function(we) {
                        var Te = p[we];
                        d[we] = Te, pe && (d.prototype[we] = function() {
                            var Fe = this.__chain__;
                            if (ce || Fe) {
                                var Ue = d(this.__wrapped__),
                                    Ge = Ue.__actions__ = Ea(this.__actions__);
                                return Ge.push({
                                    func: Te,
                                    args: arguments,
                                    thisArg: d
                                }), Ue.__chain__ = Fe, Ue
                            }
                            return Te.apply(d, Qh([this.value()], arguments))
                        })
                    }), d
                }

                function Hye() {
                    return tr._ === this && (tr._ = p0e), this
                }

                function wR() {}

                function zye(d) {
                    return d = Tn(d), Ln(function(p) {
                        return zj(p, d)
                    })
                }
                var Wye = YI(fi),
                    Vye = YI(uj),
                    Gye = YI(bI);

                function az(d) {
                    return nR(d) ? _I(ef(d)) : Epe(d)
                }

                function qye(d) {
                    return function(p) {
                        return d == null ? n : Cg(d, p)
                    }
                }
                var Kye = fH(),
                    Yye = fH(!0);

                function vR() {
                    return []
                }

                function bR() {
                    return !1
                }

                function Zye() {
                    return {}
                }

                function Qye() {
                    return ""
                }

                function Jye() {
                    return !0
                }

                function Xye(d, p) {
                    if (d = Tn(d), d < 1 || d > O) return [];
                    var x = j,
                        F = po(d, j);
                    p = tn(p), d -= j;
                    for (var ee = SI(F, p); ++x < d;) p(x);
                    return ee
                }

                function ewe(d) {
                    return En(d) ? fi(d, ef) : rl(d) ? [d] : Ea(TH(Sr(d)))
                }

                function twe(d) {
                    var p = ++d0e;
                    return Sr(d) + p
                }
                var nwe = gx(function(d, p) {
                        return d + p
                    }, 0),
                    rwe = ZI("ceil"),
                    iwe = gx(function(d, p) {
                        return d / p
                    }, 1),
                    swe = ZI("floor");

                function owe(d) {
                    return d && d.length ? lx(d, Ca, DI) : n
                }

                function awe(d, p) {
                    return d && d.length ? lx(d, tn(p, 2), DI) : n
                }

                function lwe(d) {
                    return hj(d, Ca)
                }

                function cwe(d, p) {
                    return hj(d, tn(p, 2))
                }

                function uwe(d) {
                    return d && d.length ? lx(d, Ca, FI) : n
                }

                function fwe(d, p) {
                    return d && d.length ? lx(d, tn(p, 2), FI) : n
                }
                var dwe = gx(function(d, p) {
                        return d * p
                    }, 1),
                    hwe = ZI("round"),
                    pwe = gx(function(d, p) {
                        return d - p
                    }, 0);

                function gwe(d) {
                    return d && d.length ? xI(d, Ca) : 0
                }

                function mwe(d, p) {
                    return d && d.length ? xI(d, tn(p, 2)) : 0
                }
                return oe.after = B1e, oe.ary = BH, oe.assign = Cme, oe.assignIn = JH, oe.assignInWith = Ix, oe.assignWith = Ame, oe.at = Tme, oe.before = FH, oe.bind = lR, oe.bindAll = Pye, oe.bindKey = UH, oe.castArray = Z1e, oe.chain = DH, oe.chunk = sge, oe.compact = oge, oe.concat = age, oe.cond = kye, oe.conforms = Mye, oe.constant = gR, oe.countBy = g1e, oe.create = Ime, oe.curry = jH, oe.curryRight = HH, oe.debounce = zH, oe.defaults = Rme, oe.defaultsDeep = Ome, oe.defer = F1e, oe.delay = U1e, oe.difference = lge, oe.differenceBy = cge, oe.differenceWith = uge, oe.drop = fge, oe.dropRight = dge, oe.dropRightWhile = hge, oe.dropWhile = pge, oe.fill = gge, oe.filter = y1e, oe.flatMap = b1e, oe.flatMapDeep = _1e, oe.flatMapDepth = E1e, oe.flatten = NH, oe.flattenDeep = mge, oe.flattenDepth = yge, oe.flip = j1e, oe.flow = $ye, oe.flowRight = Lye, oe.fromPairs = wge, oe.functions = Lme, oe.functionsIn = Bme, oe.groupBy = x1e, oe.initial = bge, oe.intersection = _ge, oe.intersectionBy = Ege, oe.intersectionWith = xge, oe.invert = Ume, oe.invertBy = jme, oe.invokeMap = C1e, oe.iteratee = mR, oe.keyBy = A1e, oe.keys = $s, oe.keysIn = Sa, oe.map = Ex, oe.mapKeys = zme, oe.mapValues = Wme, oe.matches = Bye, oe.matchesProperty = Fye, oe.memoize = Sx, oe.merge = Vme, oe.mergeWith = XH, oe.method = Uye, oe.methodOf = jye, oe.mixin = yR, oe.negate = Cx, oe.nthArg = zye, oe.omit = Gme, oe.omitBy = qme, oe.once = H1e, oe.orderBy = T1e, oe.over = Wye, oe.overArgs = z1e, oe.overEvery = Vye, oe.overSome = Gye, oe.partial = cR, oe.partialRight = WH, oe.partition = I1e, oe.pick = Kme, oe.pickBy = ez, oe.property = az, oe.propertyOf = qye, oe.pull = Tge, oe.pullAll = kH, oe.pullAllBy = Ige, oe.pullAllWith = Rge, oe.pullAt = Oge, oe.range = Kye, oe.rangeRight = Yye, oe.rearg = W1e, oe.reject = N1e, oe.remove = Nge, oe.rest = V1e, oe.reverse = oR, oe.sampleSize = k1e, oe.set = Zme, oe.setWith = Qme, oe.shuffle = M1e, oe.slice = Pge, oe.sortBy = L1e, oe.sortedUniq = Fge, oe.sortedUniqBy = Uge, oe.split = bye, oe.spread = G1e, oe.tail = jge, oe.take = Hge, oe.takeRight = zge, oe.takeRightWhile = Wge, oe.takeWhile = Vge, oe.tap = o1e, oe.throttle = q1e, oe.thru = _x, oe.toArray = YH, oe.toPairs = tz, oe.toPairsIn = nz, oe.toPath = ewe, oe.toPlainObject = QH, oe.transform = Jme, oe.unary = K1e, oe.union = Gge, oe.unionBy = qge, oe.unionWith = Kge, oe.uniq = Yge, oe.uniqBy = Zge, oe.uniqWith = Qge, oe.unset = Xme, oe.unzip = aR, oe.unzipWith = MH, oe.update = eye, oe.updateWith = tye, oe.values = Yy, oe.valuesIn = nye, oe.without = Jge, oe.words = sz, oe.wrap = Y1e, oe.xor = Xge, oe.xorBy = e1e, oe.xorWith = t1e, oe.zip = n1e, oe.zipObject = r1e, oe.zipObjectDeep = i1e, oe.zipWith = s1e, oe.entries = tz, oe.entriesIn = nz, oe.extend = JH, oe.extendWith = Ix, yR(oe, oe), oe.add = nwe, oe.attempt = oz, oe.camelCase = oye, oe.capitalize = rz, oe.ceil = rwe, oe.clamp = rye, oe.clone = Q1e, oe.cloneDeep = X1e, oe.cloneDeepWith = eme, oe.cloneWith = J1e, oe.conformsTo = tme, oe.deburr = iz, oe.defaultTo = Dye, oe.divide = iwe, oe.endsWith = aye, oe.eq = Wc, oe.escape = lye, oe.escapeRegExp = cye, oe.every = m1e, oe.find = w1e, oe.findIndex = RH, oe.findKey = Nme, oe.findLast = v1e, oe.findLastIndex = OH, oe.findLastKey = Pme, oe.floor = swe, oe.forEach = $H, oe.forEachRight = LH, oe.forIn = kme, oe.forInRight = Mme, oe.forOwn = Dme, oe.forOwnRight = $me, oe.get = dR, oe.gt = nme, oe.gte = rme, oe.has = Fme, oe.hasIn = hR, oe.head = PH, oe.identity = Ca, oe.includes = S1e, oe.indexOf = vge, oe.inRange = iye, oe.invoke = Hme, oe.isArguments = Ig, oe.isArray = En, oe.isArrayBuffer = ime, oe.isArrayLike = xa, oe.isArrayLikeObject = ts, oe.isBoolean = sme, oe.isBuffer = i0, oe.isDate = ome, oe.isElement = ame, oe.isEmpty = lme, oe.isEqual = cme, oe.isEqualWith = ume, oe.isError = uR, oe.isFinite = fme, oe.isFunction = xd, oe.isInteger = VH, oe.isLength = Ax, oe.isMap = GH, oe.isMatch = dme, oe.isMatchWith = hme, oe.isNaN = pme, oe.isNative = gme, oe.isNil = yme, oe.isNull = mme, oe.isNumber = qH, oe.isObject = _i, oe.isObjectLike = Li, oe.isPlainObject = R5, oe.isRegExp = fR, oe.isSafeInteger = wme, oe.isSet = KH, oe.isString = Tx, oe.isSymbol = rl, oe.isTypedArray = Ky, oe.isUndefined = vme, oe.isWeakMap = bme, oe.isWeakSet = _me, oe.join = Sge, oe.kebabCase = uye, oe.last = Kl, oe.lastIndexOf = Cge, oe.lowerCase = fye, oe.lowerFirst = dye, oe.lt = Eme, oe.lte = xme, oe.max = owe, oe.maxBy = awe, oe.mean = lwe, oe.meanBy = cwe, oe.min = uwe, oe.minBy = fwe, oe.stubArray = vR, oe.stubFalse = bR, oe.stubObject = Zye, oe.stubString = Qye, oe.stubTrue = Jye, oe.multiply = dwe, oe.nth = Age, oe.noConflict = Hye, oe.noop = wR, oe.now = xx, oe.pad = hye, oe.padEnd = pye, oe.padStart = gye, oe.parseInt = mye, oe.random = sye, oe.reduce = R1e, oe.reduceRight = O1e, oe.repeat = yye, oe.replace = wye, oe.result = Yme, oe.round = hwe, oe.runInContext = Ae, oe.sample = P1e, oe.size = D1e, oe.snakeCase = vye, oe.some = $1e, oe.sortedIndex = kge, oe.sortedIndexBy = Mge, oe.sortedIndexOf = Dge, oe.sortedLastIndex = $ge, oe.sortedLastIndexBy = Lge, oe.sortedLastIndexOf = Bge, oe.startCase = _ye, oe.startsWith = Eye, oe.subtract = pwe, oe.sum = gwe, oe.sumBy = mwe, oe.template = xye, oe.times = Xye, oe.toFinite = Sd, oe.toInteger = Tn, oe.toLength = ZH, oe.toLower = Sye, oe.toNumber = Yl, oe.toSafeInteger = Sme, oe.toString = Sr, oe.toUpper = Cye, oe.trim = Aye, oe.trimEnd = Tye, oe.trimStart = Iye, oe.truncate = Rye, oe.unescape = Oye, oe.uniqueId = twe, oe.upperCase = Nye, oe.upperFirst = pR, oe.each = $H, oe.eachRight = LH, oe.first = PH, yR(oe, function() {
                    var d = {};
                    return Ju(oe, function(p, x) {
                        Ir.call(oe.prototype, x) || (d[x] = p)
                    }), d
                }(), {
                    chain: !1
                }), oe.VERSION = r, zl(["bind", "bindKey", "curry", "curryRight", "partial", "partialRight"], function(d) {
                    oe[d].placeholder = oe
                }), zl(["drop", "take"], function(d, p) {
                    Kn.prototype[d] = function(x) {
                        x = x === n ? 1 : Cs(Tn(x), 0);
                        var F = this.__filtered__ && !p ? new Kn(this) : this.clone();
                        return F.__filtered__ ? F.__takeCount__ = po(x, F.__takeCount__) : F.__views__.push({
                            size: po(x, j),
                            type: d + (F.__dir__ < 0 ? "Right" : "")
                        }), F
                    }, Kn.prototype[d + "Right"] = function(x) {
                        return this.reverse()[d](x).reverse()
                    }
                }), zl(["filter", "map", "takeWhile"], function(d, p) {
                    var x = p + 1,
                        F = x == m || x == T;
                    Kn.prototype[d] = function(ee) {
                        var ce = this.clone();
                        return ce.__iteratees__.push({
                            iteratee: tn(ee, 3),
                            type: x
                        }), ce.__filtered__ = ce.__filtered__ || F, ce
                    }
                }), zl(["head", "last"], function(d, p) {
                    var x = "take" + (p ? "Right" : "");
                    Kn.prototype[d] = function() {
                        return this[x](1).value()[0]
                    }
                }), zl(["initial", "tail"], function(d, p) {
                    var x = "drop" + (p ? "" : "Right");
                    Kn.prototype[d] = function() {
                        return this.__filtered__ ? new Kn(this) : this[x](1)
                    }
                }), Kn.prototype.compact = function() {
                    return this.filter(Ca)
                }, Kn.prototype.find = function(d) {
                    return this.filter(d).head()
                }, Kn.prototype.findLast = function(d) {
                    return this.reverse().find(d)
                }, Kn.prototype.invokeMap = Ln(function(d, p) {
                    return typeof d == "function" ? new Kn(this) : this.map(function(x) {
                        return x5(x, d, p)
                    })
                }), Kn.prototype.reject = function(d) {
                    return this.filter(Cx(tn(d)))
                }, Kn.prototype.slice = function(d, p) {
                    d = Tn(d);
                    var x = this;
                    return x.__filtered__ && (d > 0 || p < 0) ? new Kn(x) : (d < 0 ? x = x.takeRight(-d) : d && (x = x.drop(d)), p !== n && (p = Tn(p), x = p < 0 ? x.dropRight(-p) : x.take(p - d)), x)
                }, Kn.prototype.takeRightWhile = function(d) {
                    return this.reverse().takeWhile(d).reverse()
                }, Kn.prototype.toArray = function() {
                    return this.take(j)
                }, Ju(Kn.prototype, function(d, p) {
                    var x = /^(?:filter|find|map|reject)|While$/.test(p),
                        F = /^(?:head|last)$/.test(p),
                        ee = oe[F ? "take" + (p == "last" ? "Right" : "") : p],
                        ce = F || /^find/.test(p);
                    ee && (oe.prototype[p] = function() {
                        var pe = this.__wrapped__,
                            we = F ? [1] : arguments,
                            Te = pe instanceof Kn,
                            Fe = we[0],
                            Ue = Te || En(pe),
                            Ge = function(Wn) {
                                var nr = ee.apply(oe, Qh([Wn], we));
                                return F && dt ? nr[0] : nr
                            };
                        Ue && x && typeof Fe == "function" && Fe.length != 1 && (Te = Ue = !1);
                        var dt = this.__chain__,
                            $t = !!this.__actions__.length,
                            nn = ce && !dt,
                            Nn = Te && !$t;
                        if (!ce && Ue) {
                            pe = Nn ? pe : new Kn(this);
                            var rn = d.apply(pe, we);
                            return rn.__actions__.push({
                                func: _x,
                                args: [Ge],
                                thisArg: n
                            }), new Vl(rn, dt)
                        }
                        return nn && Nn ? d.apply(this, we) : (rn = this.thru(Ge), nn ? F ? rn.value()[0] : rn.value() : rn)
                    })
                }), zl(["pop", "push", "shift", "sort", "splice", "unshift"], function(d) {
                    var p = q4[d],
                        x = /^(?:push|sort|unshift)$/.test(d) ? "tap" : "thru",
                        F = /^(?:pop|shift)$/.test(d);
                    oe.prototype[d] = function() {
                        var ee = arguments;
                        if (F && !this.__chain__) {
                            var ce = this.value();
                            return p.apply(En(ce) ? ce : [], ee)
                        }
                        return this[x](function(pe) {
                            return p.apply(En(pe) ? pe : [], ee)
                        })
                    }
                }), Ju(Kn.prototype, function(d, p) {
                    var x = oe[p];
                    if (x) {
                        var F = x.name + "";
                        Ir.call(zy, F) || (zy[F] = []), zy[F].push({
                            name: p,
                            func: x
                        })
                    }
                }), zy[px(n, b).name] = [{
                    name: "wrapper",
                    func: n
                }], Kn.prototype.clone = O0e, Kn.prototype.reverse = N0e, Kn.prototype.value = P0e, oe.prototype.at = a1e, oe.prototype.chain = l1e, oe.prototype.commit = c1e, oe.prototype.next = u1e, oe.prototype.plant = d1e, oe.prototype.reverse = h1e, oe.prototype.toJSON = oe.prototype.valueOf = oe.prototype.value = p1e, oe.prototype.first = oe.prototype.head, m5 && (oe.prototype[m5] = f1e), oe
            },
            Uy = c0e();
        es ? ((es.exports = Uy)._ = Uy, Ur._ = Uy) : tr._ = Uy
    }).call(H5)
})(yk, yk.exports);
var Z7e = Object.defineProperty,
    Q7e = Object.defineProperties,
    J7e = Object.getOwnPropertyDescriptors,
    YV = Object.getOwnPropertySymbols,
    X7e = Object.prototype.hasOwnProperty,
    eIe = Object.prototype.propertyIsEnumerable,
    ZV = (t, e, n) => e in t ? Z7e(t, e, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: n
    }) : t[e] = n,
    Hx = (t, e) => {
        for (var n in e || (e = {})) X7e.call(e, n) && ZV(t, n, e[n]);
        if (YV)
            for (var n of YV(e)) eIe.call(e, n) && ZV(t, n, e[n]);
        return t
    },
    tIe = (t, e) => Q7e(t, J7e(e));

function Hp(t, e, n) {
    var r;
    const i = ESe(t);
    return ((r = e.rpcMap) == null ? void 0 : r[i.reference]) || `${Y7e}?chainId=${i.namespace}:${i.reference}&projectId=${n}`
}

function yy(t) {
    return t.includes(":") ? t.split(":")[1] : t
}

function Vne(t) {
    return t.map(e => `${e.split(":")[0]}:${e.split(":")[1]}`)
}

function nIe(t, e) {
    const n = Object.keys(e.namespaces).filter(i => i.includes(t));
    if (!n.length) return [];
    const r = [];
    return n.forEach(i => {
        const s = e.namespaces[i].accounts;
        r.push(...s)
    }), r
}

function rIe(t = {}, e = {}) {
    const n = QV(t),
        r = QV(e);
    return yk.exports.merge(n, r)
}

function QV(t) {
    var e, n, r, i;
    const s = {};
    if (!rv(t)) return s;
    for (const [o, a] of Object.entries(t)) {
        const l = fL(o) ? [o] : a.chains,
            c = a.methods || [],
            u = a.events || [],
            f = a.rpcMap || {},
            h = b3(o);
        s[h] = tIe(Hx(Hx({}, s[h]), a), {
            chains: JR(l, (e = s[h]) == null ? void 0 : e.chains),
            methods: JR(c, (n = s[h]) == null ? void 0 : n.methods),
            events: JR(u, (r = s[h]) == null ? void 0 : r.events),
            rpcMap: Hx(Hx({}, f), (i = s[h]) == null ? void 0 : i.rpcMap)
        })
    }
    return s
}

function iIe(t) {
    return t.includes(":") ? t.split(":")[2] : t
}

function sIe(t) {
    const e = {};
    for (const [n, r] of Object.entries(t)) {
        const i = r.methods || [],
            s = r.events || [],
            o = r.accounts || [],
            a = fL(n) ? [n] : r.chains ? r.chains : Vne(r.accounts);
        e[n] = {
            chains: a,
            methods: i,
            events: s,
            accounts: o
        }
    }
    return e
}

function uO(t) {
    return typeof t == "number" ? t : t.includes("0x") ? parseInt(t, 16) : t.includes(":") ? Number(t.split(":")[1]) : Number(t)
}
const Gne = {},
    wi = t => Gne[t],
    fO = (t, e) => {
        Gne[t] = e
    };
let oIe = class {
        constructor(e) {
            this.name = "polkadot", this.namespace = e.namespace, this.events = wi("events"), this.client = wi("client"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders()
        }
        updateNamespace(e) {
            this.namespace = Object.assign(this.namespace, e)
        }
        requestAccounts() {
            return this.getAccounts()
        }
        getDefaultChain() {
            if (this.chainId) return this.chainId;
            if (this.namespace.defaultChain) return this.namespace.defaultChain;
            const e = this.namespace.chains[0];
            if (!e) throw new Error("ChainId not found");
            return e.split(":")[1]
        }
        request(e) {
            return this.namespace.methods.includes(e.request.method) ? this.client.request(e) : this.getHttpProvider().request(e.request)
        }
        setDefaultChain(e, n) {
            this.httpProviders[e] || this.setHttpProvider(e, n), this.chainId = e, this.events.emit(jh.DEFAULT_CHAIN_CHANGED, `${this.name}:${e}`)
        }
        getAccounts() {
            const e = this.namespace.accounts;
            return e ? e.filter(n => n.split(":")[1] === this.chainId.toString()).map(n => n.split(":")[2]) || [] : []
        }
        createHttpProviders() {
            const e = {};
            return this.namespace.chains.forEach(n => {
                var r;
                const i = yy(n);
                e[i] = this.createHttpProvider(i, (r = this.namespace.rpcMap) == null ? void 0 : r[n])
            }), e
        }
        getHttpProvider() {
            const e = `${this.name}:${this.chainId}`,
                n = this.httpProviders[e];
            if (typeof n > "u") throw new Error(`JSON-RPC provider for ${e} not found`);
            return n
        }
        setHttpProvider(e, n) {
            const r = this.createHttpProvider(e, n);
            r && (this.httpProviders[e] = r)
        }
        createHttpProvider(e, n) {
            const r = n || Hp(e, this.namespace, this.client.core.projectId);
            if (!r) throw new Error(`No RPC url provided for chainId: ${e}`);
            return new ag(new og(r, wi("disableProviderPing")))
        }
    },
    aIe = class {
        constructor(e) {
            this.name = "eip155", this.namespace = e.namespace, this.events = wi("events"), this.client = wi("client"), this.httpProviders = this.createHttpProviders(), this.chainId = parseInt(this.getDefaultChain())
        }
        async request(e) {
            switch (e.request.method) {
                case "eth_requestAccounts":
                    return this.getAccounts();
                case "eth_accounts":
                    return this.getAccounts();
                case "wallet_switchEthereumChain":
                    return await this.handleSwitchChain(e);
                case "eth_chainId":
                    return parseInt(this.getDefaultChain())
            }
            return this.namespace.methods.includes(e.request.method) ? await this.client.request(e) : this.getHttpProvider().request(e.request)
        }
        updateNamespace(e) {
            this.namespace = Object.assign(this.namespace, e)
        }
        setDefaultChain(e, n) {
            this.httpProviders[e] || this.setHttpProvider(parseInt(e), n), this.chainId = parseInt(e), this.events.emit(jh.DEFAULT_CHAIN_CHANGED, `${this.name}:${e}`)
        }
        requestAccounts() {
            return this.getAccounts()
        }
        getDefaultChain() {
            if (this.chainId) return this.chainId.toString();
            if (this.namespace.defaultChain) return this.namespace.defaultChain;
            const e = this.namespace.chains[0];
            if (!e) throw new Error("ChainId not found");
            return e.split(":")[1]
        }
        createHttpProvider(e, n) {
            const r = n || Hp(`${this.name}:${e}`, this.namespace, this.client.core.projectId);
            if (!r) throw new Error(`No RPC url provided for chainId: ${e}`);
            return new ag(new og(r, wi("disableProviderPing")))
        }
        setHttpProvider(e, n) {
            const r = this.createHttpProvider(e, n);
            r && (this.httpProviders[e] = r)
        }
        createHttpProviders() {
            const e = {};
            return this.namespace.chains.forEach(n => {
                var r;
                const i = parseInt(yy(n));
                e[i] = this.createHttpProvider(i, (r = this.namespace.rpcMap) == null ? void 0 : r[n])
            }), e
        }
        getAccounts() {
            const e = this.namespace.accounts;
            return e ? [...new Set(e.filter(n => n.split(":")[1] === this.chainId.toString()).map(n => n.split(":")[2]))] : []
        }
        getHttpProvider() {
            const e = this.chainId,
                n = this.httpProviders[e];
            if (typeof n > "u") throw new Error(`JSON-RPC provider for ${e} not found`);
            return n
        }
        async handleSwitchChain(e) {
            var n, r;
            let i = e.request.params ? (n = e.request.params[0]) == null ? void 0 : n.chainId : "0x0";
            i = i.startsWith("0x") ? i : `0x${i}`;
            const s = parseInt(i, 16);
            if (this.isChainApproved(s)) this.setDefaultChain(`${s}`);
            else if (this.namespace.methods.includes("wallet_switchEthereumChain")) await this.client.request({
                topic: e.topic,
                request: {
                    method: e.request.method,
                    params: [{
                        chainId: i
                    }]
                },
                chainId: (r = this.namespace.chains) == null ? void 0 : r[0]
            }), this.setDefaultChain(`${s}`);
            else throw new Error(`Failed to switch to chain 'eip155:${s}'. The chain is not approved or the wallet does not support 'wallet_switchEthereumChain' method.`);
            return null
        }
        isChainApproved(e) {
            return this.namespace.chains.includes(`${this.name}:${e}`)
        }
    };
class lIe {
    constructor(e) {
        this.name = "solana", this.namespace = e.namespace, this.events = wi("events"), this.client = wi("client"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders()
    }
    updateNamespace(e) {
        this.namespace = Object.assign(this.namespace, e)
    }
    requestAccounts() {
        return this.getAccounts()
    }
    request(e) {
        return this.namespace.methods.includes(e.request.method) ? this.client.request(e) : this.getHttpProvider().request(e.request)
    }
    setDefaultChain(e, n) {
        this.httpProviders[e] || this.setHttpProvider(e, n), this.chainId = e, this.events.emit(jh.DEFAULT_CHAIN_CHANGED, `${this.name}:${e}`)
    }
    getDefaultChain() {
        if (this.chainId) return this.chainId;
        if (this.namespace.defaultChain) return this.namespace.defaultChain;
        const e = this.namespace.chains[0];
        if (!e) throw new Error("ChainId not found");
        return e.split(":")[1]
    }
    getAccounts() {
        const e = this.namespace.accounts;
        return e ? [...new Set(e.filter(n => n.split(":")[1] === this.chainId.toString()).map(n => n.split(":")[2]))] : []
    }
    createHttpProviders() {
        const e = {};
        return this.namespace.chains.forEach(n => {
            var r;
            const i = yy(n);
            e[i] = this.createHttpProvider(i, (r = this.namespace.rpcMap) == null ? void 0 : r[n])
        }), e
    }
    getHttpProvider() {
        const e = `${this.name}:${this.chainId}`,
            n = this.httpProviders[e];
        if (typeof n > "u") throw new Error(`JSON-RPC provider for ${e} not found`);
        return n
    }
    setHttpProvider(e, n) {
        const r = this.createHttpProvider(e, n);
        r && (this.httpProviders[e] = r)
    }
    createHttpProvider(e, n) {
        const r = n || Hp(e, this.namespace, this.client.core.projectId);
        if (!r) throw new Error(`No RPC url provided for chainId: ${e}`);
        return new ag(new og(r, wi("disableProviderPing")))
    }
}
class cIe {
    constructor(e) {
        this.name = "cosmos", this.namespace = e.namespace, this.events = wi("events"), this.client = wi("client"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders()
    }
    updateNamespace(e) {
        this.namespace = Object.assign(this.namespace, e)
    }
    requestAccounts() {
        return this.getAccounts()
    }
    getDefaultChain() {
        if (this.chainId) return this.chainId;
        if (this.namespace.defaultChain) return this.namespace.defaultChain;
        const e = this.namespace.chains[0];
        if (!e) throw new Error("ChainId not found");
        return e.split(":")[1]
    }
    request(e) {
        return this.namespace.methods.includes(e.request.method) ? this.client.request(e) : this.getHttpProvider().request(e.request)
    }
    setDefaultChain(e, n) {
        this.httpProviders[e] || this.setHttpProvider(e, n), this.chainId = e, this.events.emit(jh.DEFAULT_CHAIN_CHANGED, `${this.name}:${this.chainId}`)
    }
    getAccounts() {
        const e = this.namespace.accounts;
        return e ? [...new Set(e.filter(n => n.split(":")[1] === this.chainId.toString()).map(n => n.split(":")[2]))] : []
    }
    createHttpProviders() {
        const e = {};
        return this.namespace.chains.forEach(n => {
            var r;
            const i = yy(n);
            e[i] = this.createHttpProvider(i, (r = this.namespace.rpcMap) == null ? void 0 : r[n])
        }), e
    }
    getHttpProvider() {
        const e = `${this.name}:${this.chainId}`,
            n = this.httpProviders[e];
        if (typeof n > "u") throw new Error(`JSON-RPC provider for ${e} not found`);
        return n
    }
    setHttpProvider(e, n) {
        const r = this.createHttpProvider(e, n);
        r && (this.httpProviders[e] = r)
    }
    createHttpProvider(e, n) {
        const r = n || Hp(e, this.namespace, this.client.core.projectId);
        if (!r) throw new Error(`No RPC url provided for chainId: ${e}`);
        return new ag(new og(r, wi("disableProviderPing")))
    }
}
class uIe {
    constructor(e) {
        this.name = "cip34", this.namespace = e.namespace, this.events = wi("events"), this.client = wi("client"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders()
    }
    updateNamespace(e) {
        this.namespace = Object.assign(this.namespace, e)
    }
    requestAccounts() {
        return this.getAccounts()
    }
    getDefaultChain() {
        if (this.chainId) return this.chainId;
        if (this.namespace.defaultChain) return this.namespace.defaultChain;
        const e = this.namespace.chains[0];
        if (!e) throw new Error("ChainId not found");
        return e.split(":")[1]
    }
    request(e) {
        return this.namespace.methods.includes(e.request.method) ? this.client.request(e) : this.getHttpProvider().request(e.request)
    }
    setDefaultChain(e, n) {
        this.httpProviders[e] || this.setHttpProvider(e, n), this.chainId = e, this.events.emit(jh.DEFAULT_CHAIN_CHANGED, `${this.name}:${this.chainId}`)
    }
    getAccounts() {
        const e = this.namespace.accounts;
        return e ? [...new Set(e.filter(n => n.split(":")[1] === this.chainId.toString()).map(n => n.split(":")[2]))] : []
    }
    createHttpProviders() {
        const e = {};
        return this.namespace.chains.forEach(n => {
            const r = this.getCardanoRPCUrl(n),
                i = yy(n);
            e[i] = this.createHttpProvider(i, r)
        }), e
    }
    getHttpProvider() {
        const e = `${this.name}:${this.chainId}`,
            n = this.httpProviders[e];
        if (typeof n > "u") throw new Error(`JSON-RPC provider for ${e} not found`);
        return n
    }
    getCardanoRPCUrl(e) {
        const n = this.namespace.rpcMap;
        if (n) return n[e]
    }
    setHttpProvider(e, n) {
        const r = this.createHttpProvider(e, n);
        r && (this.httpProviders[e] = r)
    }
    createHttpProvider(e, n) {
        const r = n || this.getCardanoRPCUrl(e);
        if (!r) throw new Error(`No RPC url provided for chainId: ${e}`);
        return new ag(new og(r, wi("disableProviderPing")))
    }
}
class fIe {
    constructor(e) {
        this.name = "elrond", this.namespace = e.namespace, this.events = wi("events"), this.client = wi("client"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders()
    }
    updateNamespace(e) {
        this.namespace = Object.assign(this.namespace, e)
    }
    requestAccounts() {
        return this.getAccounts()
    }
    request(e) {
        return this.namespace.methods.includes(e.request.method) ? this.client.request(e) : this.getHttpProvider().request(e.request)
    }
    setDefaultChain(e, n) {
        this.httpProviders[e] || this.setHttpProvider(e, n), this.chainId = e, this.events.emit(jh.DEFAULT_CHAIN_CHANGED, `${this.name}:${e}`)
    }
    getDefaultChain() {
        if (this.chainId) return this.chainId;
        if (this.namespace.defaultChain) return this.namespace.defaultChain;
        const e = this.namespace.chains[0];
        if (!e) throw new Error("ChainId not found");
        return e.split(":")[1]
    }
    getAccounts() {
        const e = this.namespace.accounts;
        return e ? [...new Set(e.filter(n => n.split(":")[1] === this.chainId.toString()).map(n => n.split(":")[2]))] : []
    }
    createHttpProviders() {
        const e = {};
        return this.namespace.chains.forEach(n => {
            var r;
            const i = yy(n);
            e[i] = this.createHttpProvider(i, (r = this.namespace.rpcMap) == null ? void 0 : r[n])
        }), e
    }
    getHttpProvider() {
        const e = `${this.name}:${this.chainId}`,
            n = this.httpProviders[e];
        if (typeof n > "u") throw new Error(`JSON-RPC provider for ${e} not found`);
        return n
    }
    setHttpProvider(e, n) {
        const r = this.createHttpProvider(e, n);
        r && (this.httpProviders[e] = r)
    }
    createHttpProvider(e, n) {
        const r = n || Hp(e, this.namespace, this.client.core.projectId);
        if (!r) throw new Error(`No RPC url provided for chainId: ${e}`);
        return new ag(new og(r, wi("disableProviderPing")))
    }
}
class dIe {
    constructor(e) {
        this.name = "multiversx", this.namespace = e.namespace, this.events = wi("events"), this.client = wi("client"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders()
    }
    updateNamespace(e) {
        this.namespace = Object.assign(this.namespace, e)
    }
    requestAccounts() {
        return this.getAccounts()
    }
    request(e) {
        return this.namespace.methods.includes(e.request.method) ? this.client.request(e) : this.getHttpProvider().request(e.request)
    }
    setDefaultChain(e, n) {
        this.httpProviders[e] || this.setHttpProvider(e, n), this.chainId = e, this.events.emit(jh.DEFAULT_CHAIN_CHANGED, `${this.name}:${e}`)
    }
    getDefaultChain() {
        if (this.chainId) return this.chainId;
        if (this.namespace.defaultChain) return this.namespace.defaultChain;
        const e = this.namespace.chains[0];
        if (!e) throw new Error("ChainId not found");
        return e.split(":")[1]
    }
    getAccounts() {
        const e = this.namespace.accounts;
        return e ? [...new Set(e.filter(n => n.split(":")[1] === this.chainId.toString()).map(n => n.split(":")[2]))] : []
    }
    createHttpProviders() {
        const e = {};
        return this.namespace.chains.forEach(n => {
            var r;
            const i = yy(n);
            e[i] = this.createHttpProvider(i, (r = this.namespace.rpcMap) == null ? void 0 : r[n])
        }), e
    }
    getHttpProvider() {
        const e = `${this.name}:${this.chainId}`,
            n = this.httpProviders[e];
        if (typeof n > "u") throw new Error(`JSON-RPC provider for ${e} not found`);
        return n
    }
    setHttpProvider(e, n) {
        const r = this.createHttpProvider(e, n);
        r && (this.httpProviders[e] = r)
    }
    createHttpProvider(e, n) {
        const r = n || Hp(e, this.namespace, this.client.core.projectId);
        if (!r) throw new Error(`No RPC url provided for chainId: ${e}`);
        return new ag(new og(r, wi("disableProviderPing")))
    }
}
class hIe {
    constructor(e) {
        this.name = "near", this.namespace = e.namespace, this.events = wi("events"), this.client = wi("client"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders()
    }
    updateNamespace(e) {
        this.namespace = Object.assign(this.namespace, e)
    }
    requestAccounts() {
        return this.getAccounts()
    }
    getDefaultChain() {
        if (this.chainId) return this.chainId;
        if (this.namespace.defaultChain) return this.namespace.defaultChain;
        const e = this.namespace.chains[0];
        if (!e) throw new Error("ChainId not found");
        return e.split(":")[1]
    }
    request(e) {
        return this.namespace.methods.includes(e.request.method) ? this.client.request(e) : this.getHttpProvider().request(e.request)
    }
    setDefaultChain(e, n) {
        if (this.chainId = e, !this.httpProviders[e]) {
            const r = n || Hp(`${this.name}:${e}`, this.namespace);
            if (!r) throw new Error(`No RPC url provided for chainId: ${e}`);
            this.setHttpProvider(e, r)
        }
        this.events.emit(jh.DEFAULT_CHAIN_CHANGED, `${this.name}:${this.chainId}`)
    }
    getAccounts() {
        const e = this.namespace.accounts;
        return e ? e.filter(n => n.split(":")[1] === this.chainId.toString()).map(n => n.split(":")[2]) || [] : []
    }
    createHttpProviders() {
        const e = {};
        return this.namespace.chains.forEach(n => {
            var r;
            e[n] = this.createHttpProvider(n, (r = this.namespace.rpcMap) == null ? void 0 : r[n])
        }), e
    }
    getHttpProvider() {
        const e = `${this.name}:${this.chainId}`,
            n = this.httpProviders[e];
        if (typeof n > "u") throw new Error(`JSON-RPC provider for ${e} not found`);
        return n
    }
    setHttpProvider(e, n) {
        const r = this.createHttpProvider(e, n);
        r && (this.httpProviders[e] = r)
    }
    createHttpProvider(e, n) {
        const r = n || Hp(e, this.namespace);
        return typeof r > "u" ? void 0 : new ag(new og(r, wi("disableProviderPing")))
    }
}
var pIe = Object.defineProperty,
    gIe = Object.defineProperties,
    mIe = Object.getOwnPropertyDescriptors,
    JV = Object.getOwnPropertySymbols,
    yIe = Object.prototype.hasOwnProperty,
    wIe = Object.prototype.propertyIsEnumerable,
    XV = (t, e, n) => e in t ? pIe(t, e, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: n
    }) : t[e] = n,
    zx = (t, e) => {
        for (var n in e || (e = {})) yIe.call(e, n) && XV(t, n, e[n]);
        if (JV)
            for (var n of JV(e)) wIe.call(e, n) && XV(t, n, e[n]);
        return t
    },
    dO = (t, e) => gIe(t, mIe(e));
class bL {
    constructor(e) {
        this.events = new eL, this.rpcProviders = {}, this.shouldAbortPairingAttempt = !1, this.maxPairingAttempts = 10, this.disableProviderPing = !1, this.providerOpts = e, this.logger = typeof(e == null ? void 0 : e.logger) < "u" && typeof(e == null ? void 0 : e.logger) != "string" ? e.logger : jT(HT({
            level: (e == null ? void 0 : e.logger) || qV
        })), this.disableProviderPing = (e == null ? void 0 : e.disableProviderPing) || !1
    }
    static async init(e) {
        const n = new bL(e);
        return await n.initialize(), n
    }
    async request(e, n) {
        const [r, i] = this.validateChain(n);
        if (!this.session) throw new Error("Please call connect() before request()");
        return await this.getProvider(r).request({
            request: zx({}, e),
            chainId: `${r}:${i}`,
            topic: this.session.topic
        })
    }
    sendAsync(e, n, r) {
        const i = new Date().getTime();
        this.request(e, r).then(s => n(null, zT(i, s))).catch(s => n(s, void 0))
    }
    async enable() {
        if (!this.client) throw new Error("Sign Client not initialized");
        return this.session || await this.connect({
            namespaces: this.namespaces,
            optionalNamespaces: this.optionalNamespaces,
            sessionProperties: this.sessionProperties
        }), await this.requestAccounts()
    }
    async disconnect() {
        var e;
        if (!this.session) throw new Error("Please call connect() before enable()");
        await this.client.disconnect({
            topic: (e = this.session) == null ? void 0 : e.topic,
            reason: Vi("USER_DISCONNECTED")
        }), await this.cleanup()
    }
    async connect(e) {
        if (!this.client) throw new Error("Sign Client not initialized");
        if (this.setNamespaces(e), await this.cleanupPendingPairings(), !e.skipPairing) return await this.pair(e.pairingTopic)
    }
    on(e, n) {
        this.events.on(e, n)
    }
    once(e, n) {
        this.events.once(e, n)
    }
    removeListener(e, n) {
        this.events.removeListener(e, n)
    }
    off(e, n) {
        this.events.off(e, n)
    }
    get isWalletConnect() {
        return !0
    }
    async pair(e) {
        this.shouldAbortPairingAttempt = !1;
        let n = 0;
        do {
            if (this.shouldAbortPairingAttempt) throw new Error("Pairing aborted");
            if (n >= this.maxPairingAttempts) throw new Error("Max auto pairing attempts reached");
            const {
                uri: r,
                approval: i
            } = await this.client.connect({
                pairingTopic: e,
                requiredNamespaces: this.namespaces,
                optionalNamespaces: this.optionalNamespaces,
                sessionProperties: this.sessionProperties
            });
            r && (this.uri = r, this.events.emit("display_uri", r)), await i().then(s => {
                this.session = s, this.namespaces || (this.namespaces = sIe(s.namespaces), this.persist("namespaces", this.namespaces))
            }).catch(s => {
                if (s.message !== zne) throw s;
                n++
            })
        } while (!this.session);
        return this.onConnect(), this.session
    }
    setDefaultChain(e, n) {
        try {
            if (!this.session) return;
            const [r, i] = this.validateChain(e);
            this.getProvider(r).setDefaultChain(i, n)
        } catch (r) {
            if (!/Please call connect/.test(r.message)) throw r
        }
    }
    async cleanupPendingPairings(e = {}) {
        this.logger.info("Cleaning up inactive pairings...");
        const n = this.client.pairing.getAll();
        if (sd(n)) {
            for (const r of n) e.deletePairings ? this.client.core.expirer.set(r.topic, 0) : await this.client.core.relayer.subscriber.unsubscribe(r.topic);
            this.logger.info(`Inactive pairings cleared: ${n.length}`)
        }
    }
    abortPairingAttempt() {
        this.shouldAbortPairingAttempt = !0
    }
    async checkStorage() {
        if (this.namespaces = await this.getFromStore("namespaces"), this.optionalNamespaces = await this.getFromStore("optionalNamespaces") || {}, this.client.session.length) {
            const e = this.client.session.keys.length - 1;
            this.session = this.client.session.get(this.client.session.keys[e]), this.createProviders()
        }
    }
    async initialize() {
        this.logger.trace("Initialized"), await this.createClient(), await this.checkStorage(), this.registerEventListeners()
    }
    async createClient() {
        this.client = this.providerOpts.client || await L7e.init({
            logger: this.providerOpts.logger || qV,
            relayUrl: this.providerOpts.relayUrl || G7e,
            projectId: this.providerOpts.projectId,
            metadata: this.providerOpts.metadata,
            storageOptions: this.providerOpts.storageOptions,
            storage: this.providerOpts.storage,
            name: this.providerOpts.name
        }), this.logger.trace("SignClient Initialized")
    }
    createProviders() {
        if (!this.client) throw new Error("Sign Client not initialized");
        if (!this.session) throw new Error("Session not initialized. Please call connect() before enable()");
        const e = [...new Set(Object.keys(this.session.namespaces).map(n => b3(n)))];
        fO("client", this.client), fO("events", this.events), fO("disableProviderPing", this.disableProviderPing), e.forEach(n => {
            if (!this.session) return;
            const r = nIe(n, this.session),
                i = Vne(r),
                s = rIe(this.namespaces, this.optionalNamespaces),
                o = dO(zx({}, s[n]), {
                    accounts: r,
                    chains: i
                });
            switch (n) {
                case "eip155":
                    this.rpcProviders[n] = new aIe({
                        namespace: o
                    });
                    break;
                case "solana":
                    this.rpcProviders[n] = new lIe({
                        namespace: o
                    });
                    break;
                case "cosmos":
                    this.rpcProviders[n] = new cIe({
                        namespace: o
                    });
                    break;
                case "polkadot":
                    this.rpcProviders[n] = new oIe({
                        namespace: o
                    });
                    break;
                case "cip34":
                    this.rpcProviders[n] = new uIe({
                        namespace: o
                    });
                    break;
                case "elrond":
                    this.rpcProviders[n] = new fIe({
                        namespace: o
                    });
                    break;
                case "multiversx":
                    this.rpcProviders[n] = new dIe({
                        namespace: o
                    });
                    break;
                case "near":
                    this.rpcProviders[n] = new hIe({
                        namespace: o
                    });
                    break
            }
        })
    }
    registerEventListeners() {
        if (typeof this.client > "u") throw new Error("Sign Client is not initialized");
        this.client.on("session_ping", e => {
            this.events.emit("session_ping", e)
        }), this.client.on("session_event", e => {
            const {
                params: n
            } = e, {
                event: r
            } = n;
            if (r.name === "accountsChanged") {
                const i = r.data;
                i && sd(i) && this.events.emit("accountsChanged", i.map(iIe))
            } else if (r.name === "chainChanged") {
                const i = n.chainId,
                    s = n.event.data,
                    o = b3(i),
                    a = uO(i) !== uO(s) ? `${o}:${uO(s)}` : i;
                this.onChainChanged(a)
            } else this.events.emit(r.name, r.data);
            this.events.emit("session_event", e)
        }), this.client.on("session_update", ({
            topic: e,
            params: n
        }) => {
            var r;
            const {
                namespaces: i
            } = n, s = (r = this.client) == null ? void 0 : r.session.get(e);
            this.session = dO(zx({}, s), {
                namespaces: i
            }), this.onSessionUpdate(), this.events.emit("session_update", {
                topic: e,
                params: n
            })
        }), this.client.on("session_delete", async e => {
            await this.cleanup(), this.events.emit("session_delete", e), this.events.emit("disconnect", dO(zx({}, Vi("USER_DISCONNECTED")), {
                data: e.topic
            }))
        }), this.on(jh.DEFAULT_CHAIN_CHANGED, e => {
            this.onChainChanged(e, !0)
        })
    }
    getProvider(e) {
        if (!this.rpcProviders[e]) throw new Error(`Provider not found: ${e}`);
        return this.rpcProviders[e]
    }
    onSessionUpdate() {
        Object.keys(this.rpcProviders).forEach(e => {
            var n;
            this.getProvider(e).updateNamespace((n = this.session) == null ? void 0 : n.namespaces[e])
        })
    }
    setNamespaces(e) {
        const {
            namespaces: n,
            optionalNamespaces: r,
            sessionProperties: i
        } = e;
        n && Object.keys(n).length && (this.namespaces = n), r && Object.keys(r).length && (this.optionalNamespaces = r), this.sessionProperties = i, this.persist("namespaces", n), this.persist("optionalNamespaces", r)
    }
    validateChain(e) {
        const [n, r] = (e == null ? void 0 : e.split(":")) || ["", ""];
        if (!this.namespaces || !Object.keys(this.namespaces).length) return [n, r];
        if (n && !Object.keys(this.namespaces || {}).map(o => b3(o)).includes(n)) throw new Error(`Namespace '${n}' is not configured. Please call connect() first with namespace config.`);
        if (n && r) return [n, r];
        const i = b3(Object.keys(this.namespaces)[0]),
            s = this.rpcProviders[i].getDefaultChain();
        return [i, s]
    }
    async requestAccounts() {
        const [e] = this.validateChain();
        return await this.getProvider(e).requestAccounts()
    }
    onChainChanged(e, n = !1) {
        var r;
        if (!this.namespaces) return;
        const [i, s] = this.validateChain(e);
        n || this.getProvider(i).setDefaultChain(s), ((r = this.namespaces[i]) != null ? r : this.namespaces[`${i}:${s}`]).defaultChain = s, this.persist("namespaces", this.namespaces), this.events.emit("chainChanged", s)
    }
    onConnect() {
        this.createProviders(), this.events.emit("connect", {
            session: this.session
        })
    }
    async cleanup() {
        this.session = void 0, this.namespaces = void 0, this.optionalNamespaces = void 0, this.sessionProperties = void 0, this.persist("namespaces", void 0), this.persist("optionalNamespaces", void 0), this.persist("sessionProperties", void 0), await this.cleanupPendingPairings({
            deletePairings: !0
        })
    }
    persist(e, n) {
        this.client.core.storage.setItem(`${KV}/${e}`, n)
    }
    async getFromStore(e) {
        return await this.client.core.storage.getItem(`${KV}/${e}`)
    }
}
const vIe = bL,
    bIe = "wc",
    _Ie = "ethereum_provider",
    EIe = `${bIe}@2:${_Ie}:`,
    xIe = "https://rpc.walletconnect.com/v1/",
    wk = ["eth_sendTransaction", "personal_sign"],
    SIe = ["eth_accounts", "eth_requestAccounts", "eth_sendRawTransaction", "eth_sign", "eth_signTransaction", "eth_signTypedData", "eth_signTypedData_v3", "eth_signTypedData_v4", "eth_sendTransaction", "personal_sign", "wallet_switchEthereumChain", "wallet_addEthereumChain", "wallet_getPermissions", "wallet_requestPermissions", "wallet_registerOnboarding", "wallet_watchAsset", "wallet_scanQRCode"],
    vk = ["chainChanged", "accountsChanged"],
    CIe = ["chainChanged", "accountsChanged", "message", "disconnect", "connect"];
var AIe = Object.defineProperty,
    TIe = Object.defineProperties,
    IIe = Object.getOwnPropertyDescriptors,
    eG = Object.getOwnPropertySymbols,
    RIe = Object.prototype.hasOwnProperty,
    OIe = Object.prototype.propertyIsEnumerable,
    tG = (t, e, n) => e in t ? AIe(t, e, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: n
    }) : t[e] = n,
    E3 = (t, e) => {
        for (var n in e || (e = {})) RIe.call(e, n) && tG(t, n, e[n]);
        if (eG)
            for (var n of eG(e)) OIe.call(e, n) && tG(t, n, e[n]);
        return t
    },
    nG = (t, e) => TIe(t, IIe(e));

function OC(t) {
    return Number(t[0].split(":")[1])
}

function hO(t) {
    return `0x${t.toString(16)}`
}

function NIe(t) {
    const {
        chains: e,
        optionalChains: n,
        methods: r,
        optionalMethods: i,
        events: s,
        optionalEvents: o,
        rpcMap: a
    } = t;
    if (!sd(e)) throw new Error("Invalid chains");
    const l = {
            chains: e,
            methods: r || wk,
            events: s || vk,
            rpcMap: E3({}, e.length ? {
                [OC(e)]: a[OC(e)]
            } : {})
        },
        c = s == null ? void 0 : s.filter(g => !vk.includes(g)),
        u = r == null ? void 0 : r.filter(g => !wk.includes(g));
    if (!n && !o && !i && !(c != null && c.length) && !(u != null && u.length)) return {
        required: e.length ? l : void 0
    };
    const f = (c == null ? void 0 : c.length) && (u == null ? void 0 : u.length) || !n,
        h = {
            chains: [...new Set(f ? l.chains.concat(n || []) : n)],
            methods: [...new Set(l.methods.concat(i != null && i.length ? i : SIe))],
            events: [...new Set(l.events.concat(o != null && o.length ? o : CIe))],
            rpcMap: a
        };
    return {
        required: e.length ? l : void 0,
        optional: n.length ? h : void 0
    }
}
let PIe = class qne {
    constructor() {
        this.events = new uo.EventEmitter, this.namespace = "eip155", this.accounts = [], this.chainId = 1, this.STORAGE_KEY = EIe, this.on = (e, n) => (this.events.on(e, n), this), this.once = (e, n) => (this.events.once(e, n), this), this.removeListener = (e, n) => (this.events.removeListener(e, n), this), this.off = (e, n) => (this.events.off(e, n), this), this.parseAccount = e => this.isCompatibleChainId(e) ? this.parseAccountId(e).address : e, this.signer = {}, this.rpc = {}
    }
    static async init(e) {
        const n = new qne;
        return await n.initialize(e), n
    }
    async request(e) {
        return await this.signer.request(e, this.formatChainId(this.chainId))
    }
    sendAsync(e, n) {
        this.signer.sendAsync(e, n, this.formatChainId(this.chainId))
    }
    get connected() {
        return this.signer.client ? this.signer.client.core.relayer.connected : !1
    }
    get connecting() {
        return this.signer.client ? this.signer.client.core.relayer.connecting : !1
    }
    async enable() {
        return this.session || await this.connect(), await this.request({
            method: "eth_requestAccounts"
        })
    }
    async connect(e) {
        if (!this.signer.client) throw new Error("Provider not initialized. Call init() first");
        this.loadConnectOpts(e);
        const {
            required: n,
            optional: r
        } = NIe(this.rpc);
        try {
            const i = await new Promise(async (o, a) => {
                var l;
                this.rpc.showQrModal && ((l = this.modal) == null || l.subscribeModal(c => {
                    !c.open && !this.signer.session && (this.signer.abortPairingAttempt(), a(new Error("Connection request reset. Please try again.")))
                })), await this.signer.connect(nG(E3({
                    namespaces: E3({}, n && {
                        [this.namespace]: n
                    })
                }, r && {
                    optionalNamespaces: {
                        [this.namespace]: r
                    }
                }), {
                    pairingTopic: e == null ? void 0 : e.pairingTopic
                })).then(c => {
                    o(c)
                }).catch(c => {
                    a(new Error(c.message))
                })
            });
            if (!i) return;
            const s = xSe(i.namespaces, [this.namespace]);
            this.setChainIds(this.rpc.chains.length ? this.rpc.chains : s), this.setAccounts(s), this.events.emit("connect", {
                chainId: hO(this.chainId)
            })
        } catch (i) {
            throw this.signer.logger.error(i), i
        } finally {
            this.modal && this.modal.closeModal()
        }
    }
    async disconnect() {
        this.session && await this.signer.disconnect(), this.reset()
    }
    get isWalletConnect() {
        return !0
    }
    get session() {
        return this.signer.session
    }
    registerEventListeners() {
        this.signer.on("session_event", e => {
            const {
                params: n
            } = e, {
                event: r
            } = n;
            r.name === "accountsChanged" ? (this.accounts = this.parseAccounts(r.data), this.events.emit("accountsChanged", this.accounts)) : r.name === "chainChanged" ? this.setChainId(this.formatChainId(r.data)) : this.events.emit(r.name, r.data), this.events.emit("session_event", e)
        }), this.signer.on("chainChanged", e => {
            const n = parseInt(e);
            this.chainId = n, this.events.emit("chainChanged", hO(this.chainId)), this.persist()
        }), this.signer.on("session_update", e => {
            this.events.emit("session_update", e)
        }), this.signer.on("session_delete", e => {
            this.reset(), this.events.emit("session_delete", e), this.events.emit("disconnect", nG(E3({}, Vi("USER_DISCONNECTED")), {
                data: e.topic,
                name: "USER_DISCONNECTED"
            }))
        }), this.signer.on("display_uri", e => {
            var n, r;
            this.rpc.showQrModal && ((n = this.modal) == null || n.closeModal(), (r = this.modal) == null || r.openModal({
                uri: e
            })), this.events.emit("display_uri", e)
        })
    }
    switchEthereumChain(e) {
        this.request({
            method: "wallet_switchEthereumChain",
            params: [{
                chainId: e.toString(16)
            }]
        })
    }
    isCompatibleChainId(e) {
        return typeof e == "string" ? e.startsWith(`${this.namespace}:`) : !1
    }
    formatChainId(e) {
        return `${this.namespace}:${e}`
    }
    parseChainId(e) {
        return Number(e.split(":")[1])
    }
    setChainIds(e) {
        const n = e.filter(r => this.isCompatibleChainId(r)).map(r => this.parseChainId(r));
        n.length && (this.chainId = n[0], this.events.emit("chainChanged", hO(this.chainId)), this.persist())
    }
    setChainId(e) {
        if (this.isCompatibleChainId(e)) {
            const n = this.parseChainId(e);
            this.chainId = n, this.switchEthereumChain(n)
        }
    }
    parseAccountId(e) {
        const [n, r, i] = e.split(":");
        return {
            chainId: `${n}:${r}`,
            address: i
        }
    }
    setAccounts(e) {
        this.accounts = e.filter(n => this.parseChainId(this.parseAccountId(n).chainId) === this.chainId).map(n => this.parseAccountId(n).address), this.events.emit("accountsChanged", this.accounts)
    }
    getRpcConfig(e) {
        var n, r;
        const i = (n = e == null ? void 0 : e.chains) != null ? n : [],
            s = (r = e == null ? void 0 : e.optionalChains) != null ? r : [],
            o = i.concat(s);
        if (!o.length) throw new Error("No chains specified in either `chains` or `optionalChains`");
        const a = i.length ? (e == null ? void 0 : e.methods) || wk : [],
            l = i.length ? (e == null ? void 0 : e.events) || vk : [],
            c = (e == null ? void 0 : e.optionalMethods) || [],
            u = (e == null ? void 0 : e.optionalEvents) || [],
            f = (e == null ? void 0 : e.rpcMap) || this.buildRpcMap(o, e.projectId),
            h = (e == null ? void 0 : e.qrModalOptions) || void 0;
        return {
            chains: i == null ? void 0 : i.map(g => this.formatChainId(g)),
            optionalChains: s.map(g => this.formatChainId(g)),
            methods: a,
            events: l,
            optionalMethods: c,
            optionalEvents: u,
            rpcMap: f,
            showQrModal: !!(e != null && e.showQrModal),
            qrModalOptions: h,
            projectId: e.projectId,
            metadata: e.metadata
        }
    }
    buildRpcMap(e, n) {
        const r = {};
        return e.forEach(i => {
            r[i] = this.getRpcUrl(i, n)
        }), r
    }
    async initialize(e) {
        if (this.rpc = this.getRpcConfig(e), this.chainId = this.rpc.chains.length ? OC(this.rpc.chains) : OC(this.rpc.optionalChains), this.signer = await vIe.init({
                projectId: this.rpc.projectId,
                metadata: this.rpc.metadata,
                disableProviderPing: e.disableProviderPing,
                relayUrl: e.relayUrl,
                storageOptions: e.storageOptions
            }), this.registerEventListeners(), await this.loadPersistedSession(), this.rpc.showQrModal) {
            let n;
            try {
                const {
                    WalletConnectModal: r
                } = await Pi(() =>
                    import ("./index-spuQw5rE.js").then(i => i.i), []);
                n = r
            } catch {
                throw new Error("To use QR modal, please install @walletconnect/modal package")
            }
            if (n) try {
                this.modal = new n(E3({
                    projectId: this.rpc.projectId
                }, this.rpc.qrModalOptions))
            } catch (r) {
                throw this.signer.logger.error(r), new Error("Could not generate WalletConnectModal Instance")
            }
        }
    }
    loadConnectOpts(e) {
        if (!e) return;
        const {
            chains: n,
            optionalChains: r,
            rpcMap: i
        } = e;
        n && sd(n) && (this.rpc.chains = n.map(s => this.formatChainId(s)), n.forEach(s => {
            this.rpc.rpcMap[s] = (i == null ? void 0 : i[s]) || this.getRpcUrl(s)
        })), r && sd(r) && (this.rpc.optionalChains = [], this.rpc.optionalChains = r == null ? void 0 : r.map(s => this.formatChainId(s)), r.forEach(s => {
            this.rpc.rpcMap[s] = (i == null ? void 0 : i[s]) || this.getRpcUrl(s)
        }))
    }
    getRpcUrl(e, n) {
        var r;
        return ((r = this.rpc.rpcMap) == null ? void 0 : r[e]) || `${xIe}?chainId=eip155:${e}&projectId=${n||this.rpc.projectId}`
    }
    async loadPersistedSession() {
        if (!this.session) return;
        const e = await this.signer.client.core.storage.getItem(`${this.STORAGE_KEY}/chainId`),
            n = this.session.namespaces[`${this.namespace}:${e}`] ? this.session.namespaces[`${this.namespace}:${e}`] : this.session.namespaces[this.namespace];
        this.setChainIds(e ? [this.formatChainId(e)] : n == null ? void 0 : n.accounts), this.setAccounts(n == null ? void 0 : n.accounts)
    }
    reset() {
        this.chainId = 1, this.accounts = []
    }
    persist() {
        this.session && this.signer.client.core.storage.setItem(`${this.STORAGE_KEY}/chainId`, this.chainId)
    }
    parseAccounts(e) {
        return typeof e == "string" || e instanceof String ? [this.parseAccount(e)] : e.map(n => this.parseAccount(n))
    }
};
const kIe = "6.13.2";

function MIe(t, e, n) {
    const r = e.split("|").map(s => s.trim());
    for (let s = 0; s < r.length; s++) switch (e) {
        case "any":
            return;
        case "bigint":
        case "boolean":
        case "number":
        case "string":
            if (typeof t === e) return
    }
    const i = new Error(`invalid value for type ${e}`);
    throw i.code = "INVALID_ARGUMENT", i.argument = `value.${n}`, i.value = t, i
}
async function Xo(t) {
    const e = Object.keys(t);
    return (await Promise.all(e.map(r => Promise.resolve(t[r])))).reduce((r, i, s) => (r[e[s]] = i, r), {})
}

function Xt(t, e, n) {
    for (let r in e) {
        let i = e[r];
        const s = n ? n[r] : null;
        s && MIe(i, s, r), Object.defineProperty(t, r, {
            enumerable: !0,
            value: i,
            writable: !1
        })
    }
}

function Rw(t) {
    if (t == null) return "null";
    if (Array.isArray(t)) return "[ " + t.map(Rw).join(", ") + " ]";
    if (t instanceof Uint8Array) {
        const e = "0123456789abcdef";
        let n = "0x";
        for (let r = 0; r < t.length; r++) n += e[t[r] >> 4], n += e[t[r] & 15];
        return n
    }
    if (typeof t == "object" && typeof t.toJSON == "function") return Rw(t.toJSON());
    switch (typeof t) {
        case "boolean":
        case "symbol":
            return t.toString();
        case "bigint":
            return BigInt(t).toString();
        case "number":
            return t.toString();
        case "string":
            return JSON.stringify(t);
        case "object":
            {
                const e = Object.keys(t);
                return e.sort(),
                "{ " + e.map(n => `${Rw(n)}: ${Rw(t[n])}`).join(", ") + " }"
            }
    }
    return "[ COULD NOT SERIALIZE ]"
}

function No(t, e) {
    return t && t.code === e
}

function _L(t) {
    return No(t, "CALL_EXCEPTION")
}

function pi(t, e, n) {
    let r = t; {
        const s = [];
        if (n) {
            if ("message" in n || "code" in n || "name" in n) throw new Error(`value will overwrite populated values: ${Rw(n)}`);
            for (const o in n) {
                if (o === "shortMessage") continue;
                const a = n[o];
                s.push(o + "=" + Rw(a))
            }
        }
        s.push(`code=${e}`), s.push(`version=${kIe}`), s.length && (t += " (" + s.join(", ") + ")")
    }
    let i;
    switch (e) {
        case "INVALID_ARGUMENT":
            i = new TypeError(t);
            break;
        case "NUMERIC_FAULT":
        case "BUFFER_OVERRUN":
            i = new RangeError(t);
            break;
        default:
            i = new Error(t)
    }
    return Xt(i, {
        code: e
    }), n && Object.assign(i, n), i.shortMessage == null && Xt(i, {
        shortMessage: r
    }), i
}

function je(t, e, n, r) {
    if (!t) throw pi(e, n, r)
}

function Ee(t, e, n, r) {
    je(t, e, "INVALID_ARGUMENT", {
        argument: n,
        value: r
    })
}

function Kne(t, e, n) {
    n == null && (n = ""), n && (n = ": " + n), je(t >= e, "missing arguemnt" + n, "MISSING_ARGUMENT", {
        count: t,
        expectedCount: e
    }), je(t <= e, "too many arguments" + n, "UNEXPECTED_ARGUMENT", {
        count: t,
        expectedCount: e
    })
}["NFD", "NFC", "NFKD", "NFKC"].reduce((t, e) => {
    try {
        if ("test".normalize(e) !== "test") throw new Error("bad");
        if (e === "NFD" && "".normalize("NFD") !== "e") throw new Error("broken");
        t.push(e)
    } catch {}
    return t
}, []);

function IE(t, e, n) {
    if (n == null && (n = ""), t !== e) {
        let r = n,
            i = "new";
        n && (r += ".", i += " " + n), je(!1, `private constructor; use ${r}from* methods`, "UNSUPPORTED_OPERATION", {
            operation: i
        })
    }
}

function Yne(t, e, n) {
    if (t instanceof Uint8Array) return n ? new Uint8Array(t) : t;
    if (typeof t == "string" && t.match(/^0x(?:[0-9a-f][0-9a-f])*$/i)) {
        const r = new Uint8Array((t.length - 2) / 2);
        let i = 2;
        for (let s = 0; s < r.length; s++) r[s] = parseInt(t.substring(i, i + 2), 16), i += 2;
        return r
    }
    Ee(!1, "invalid BytesLike value", e || "value", t)
}

function or(t, e) {
    return Yne(t, e, !1)
}

function ra(t, e) {
    return Yne(t, e, !0)
}

function Zr(t, e) {
    return !(typeof t != "string" || !t.match(/^0x[0-9A-Fa-f]*$/) || typeof e == "number" && t.length !== 2 + 2 * e || e === !0 && t.length % 2 !== 0)
}

function EL(t) {
    return Zr(t, !0) || t instanceof Uint8Array
}
const rG = "0123456789abcdef";

function Ot(t) {
    const e = or(t);
    let n = "0x";
    for (let r = 0; r < e.length; r++) {
        const i = e[r];
        n += rG[(i & 240) >> 4] + rG[i & 15]
    }
    return n
}

function vi(t) {
    return "0x" + t.map(e => Ot(e).substring(2)).join("")
}

function iv(t) {
    return Zr(t, !0) ? (t.length - 2) / 2 : or(t).length
}

function ji(t, e, n) {
    const r = or(t);
    return n != null && n > r.length && je(!1, "cannot slice beyond data bounds", "BUFFER_OVERRUN", {
        buffer: r,
        length: r.length,
        offset: n
    }), Ot(r.slice(e ? ? 0, n ? ? r.length))
}

function Zne(t, e, n) {
    const r = or(t);
    je(e >= r.length, "padding exceeds data length", "BUFFER_OVERRUN", {
        buffer: new Uint8Array(r),
        length: e,
        offset: e + 1
    });
    const i = new Uint8Array(e);
    return i.fill(0), n ? i.set(r, e - r.length) : i.set(r, 0), Ot(i)
}

function km(t, e) {
    return Zne(t, e, !0)
}

function DIe(t, e) {
    return Zne(t, e, !1)
}
const qT = BigInt(0),
    wu = BigInt(1),
    Ow = 9007199254740991;

function NC(t, e) {
    const n = KT(t, "value"),
        r = BigInt(Mn(e, "width"));
    if (je(n >> r === qT, "overflow", "NUMERIC_FAULT", {
            operation: "fromTwos",
            fault: "overflow",
            value: t
        }), n >> r - wu) {
        const i = (wu << r) - wu;
        return -((~n & i) + wu)
    }
    return n
}

function Qne(t, e) {
    let n = kt(t, "value");
    const r = BigInt(Mn(e, "width")),
        i = wu << r - wu;
    if (n < qT) {
        n = -n, je(n <= i, "too low", "NUMERIC_FAULT", {
            operation: "toTwos",
            fault: "overflow",
            value: t
        });
        const s = (wu << r) - wu;
        return (~n & s) + wu
    } else je(n < i, "too high", "NUMERIC_FAULT", {
        operation: "toTwos",
        fault: "overflow",
        value: t
    });
    return n
}

function c1(t, e) {
    const n = KT(t, "value"),
        r = BigInt(Mn(e, "bits"));
    return n & (wu << r) - wu
}

function kt(t, e) {
    switch (typeof t) {
        case "bigint":
            return t;
        case "number":
            return Ee(Number.isInteger(t), "underflow", e || "value", t), Ee(t >= -Ow && t <= Ow, "overflow", e || "value", t), BigInt(t);
        case "string":
            try {
                if (t === "") throw new Error("empty string");
                return t[0] === "-" && t[1] !== "-" ? -BigInt(t.substring(1)) : BigInt(t)
            } catch (n) {
                Ee(!1, `invalid BigNumberish string: ${n.message}`, e || "value", t)
            }
    }
    Ee(!1, "invalid BigNumberish value", e || "value", t)
}

function KT(t, e) {
    const n = kt(t, e);
    return je(n >= qT, "unsigned value cannot be negative", "NUMERIC_FAULT", {
        fault: "overflow",
        operation: "getUint",
        value: t
    }), n
}
const iG = "0123456789abcdef";

function YT(t) {
    if (t instanceof Uint8Array) {
        let e = "0x0";
        for (const n of t) e += iG[n >> 4], e += iG[n & 15];
        return BigInt(e)
    }
    return kt(t)
}

function Mn(t, e) {
    switch (typeof t) {
        case "bigint":
            return Ee(t >= -Ow && t <= Ow, "overflow", e || "value", t), Number(t);
        case "number":
            return Ee(Number.isInteger(t), "underflow", e || "value", t), Ee(t >= -Ow && t <= Ow, "overflow", e || "value", t), t;
        case "string":
            try {
                if (t === "") throw new Error("empty string");
                return Mn(BigInt(t), e)
            } catch (n) {
                Ee(!1, `invalid numeric string: ${n.message}`, e || "value", t)
            }
    }
    Ee(!1, "invalid numeric value", e || "value", t)
}

function $Ie(t) {
    return Mn(YT(t))
}

function zp(t, e) {
    let r = KT(t, "value").toString(16);
    if (e == null) r.length % 2 && (r = "0" + r);
    else {
        const i = Mn(e, "width");
        for (je(i * 2 >= r.length, `value exceeds width (${i} bytes)`, "NUMERIC_FAULT", {
                operation: "toBeHex",
                fault: "overflow",
                value: t
            }); r.length < i * 2;) r = "0" + r
    }
    return "0x" + r
}

function sa(t) {
    const e = KT(t, "value");
    if (e === qT) return new Uint8Array([]);
    let n = e.toString(16);
    n.length % 2 && (n = "0" + n);
    const r = new Uint8Array(n.length / 2);
    for (let i = 0; i < r.length; i++) {
        const s = i * 2;
        r[i] = parseInt(n.substring(s, s + 2), 16)
    }
    return r
}

function u1(t) {
    let e = Ot(EL(t) ? t : sa(t)).substring(2);
    for (; e.startsWith("0");) e = e.substring(1);
    return e === "" && (e = "0"), "0x" + e
}
const sG = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
BigInt(0);
const oG = BigInt(58);

function LIe(t) {
    const e = or(t);
    let n = YT(e),
        r = "";
    for (; n;) r = sG[Number(n % oG)] + r, n /= oG;
    for (let i = 0; i < e.length && !e[i]; i++) r = sG[0] + r;
    return r
}

function BIe(t) {
    t = atob(t);
    const e = new Uint8Array(t.length);
    for (let n = 0; n < t.length; n++) e[n] = t.charCodeAt(n);
    return or(e)
}

function FIe(t) {
    const e = or(t);
    let n = "";
    for (let r = 0; r < e.length; r++) n += String.fromCharCode(e[r]);
    return btoa(n)
}
var Mv;
class Jne {
    constructor(e, n, r) {
        Ie(this, "filter");
        Ie(this, "emitter");
        _e(this, Mv);
        le(this, Mv, n), Xt(this, {
            emitter: e,
            filter: r
        })
    }
    async removeListener() {
        W(this, Mv) != null && await this.emitter.off(this.filter, W(this, Mv))
    }
}
Mv = new WeakMap;

function UIe(t, e, n, r, i) {
    Ee(!1, `invalid codepoint at offset ${e}; ${t}`, "bytes", n)
}

function Xne(t, e, n, r, i) {
    if (t === "BAD_PREFIX" || t === "UNEXPECTED_CONTINUE") {
        let s = 0;
        for (let o = e + 1; o < n.length && n[o] >> 6 === 2; o++) s++;
        return s
    }
    return t === "OVERRUN" ? n.length - e - 1 : 0
}

function jIe(t, e, n, r, i) {
    return t === "OVERLONG" ? (Ee(typeof i == "number", "invalid bad code point for replacement", "badCodepoint", i), r.push(i), 0) : (r.push(65533), Xne(t, e, n))
}
const HIe = Object.freeze({
    error: UIe,
    ignore: Xne,
    replace: jIe
});

function zIe(t, e) {
    e == null && (e = HIe.error);
    const n = or(t, "bytes"),
        r = [];
    let i = 0;
    for (; i < n.length;) {
        const s = n[i++];
        if (!(s >> 7)) {
            r.push(s);
            continue
        }
        let o = null,
            a = null;
        if ((s & 224) === 192) o = 1, a = 127;
        else if ((s & 240) === 224) o = 2, a = 2047;
        else if ((s & 248) === 240) o = 3, a = 65535;
        else {
            (s & 192) === 128 ? i += e("UNEXPECTED_CONTINUE", i - 1, n, r) : i += e("BAD_PREFIX", i - 1, n, r);
            continue
        }
        if (i - 1 + o >= n.length) {
            i += e("OVERRUN", i - 1, n, r);
            continue
        }
        let l = s & (1 << 8 - o - 1) - 1;
        for (let c = 0; c < o; c++) {
            let u = n[i];
            if ((u & 192) != 128) {
                i += e("MISSING_CONTINUE", i, n, r), l = null;
                break
            }
            l = l << 6 | u & 63, i++
        }
        if (l !== null) {
            if (l > 1114111) {
                i += e("OUT_OF_RANGE", i - 1 - o, n, r, l);
                continue
            }
            if (l >= 55296 && l <= 57343) {
                i += e("UTF16_SURROGATE", i - 1 - o, n, r, l);
                continue
            }
            if (l <= a) {
                i += e("OVERLONG", i - 1 - o, n, r, l);
                continue
            }
            r.push(l)
        }
    }
    return r
}

function qf(t, e) {
    Ee(typeof t == "string", "invalid string value", "str", t);
    let n = [];
    for (let r = 0; r < t.length; r++) {
        const i = t.charCodeAt(r);
        if (i < 128) n.push(i);
        else if (i < 2048) n.push(i >> 6 | 192), n.push(i & 63 | 128);
        else if ((i & 64512) == 55296) {
            r++;
            const s = t.charCodeAt(r);
            Ee(r < t.length && (s & 64512) === 56320, "invalid surrogate pair", "str", t);
            const o = 65536 + ((i & 1023) << 10) + (s & 1023);
            n.push(o >> 18 | 240), n.push(o >> 12 & 63 | 128), n.push(o >> 6 & 63 | 128), n.push(o & 63 | 128)
        } else n.push(i >> 12 | 224), n.push(i >> 6 & 63 | 128), n.push(i & 63 | 128)
    }
    return new Uint8Array(n)
}

function WIe(t) {
    return t.map(e => e <= 65535 ? String.fromCharCode(e) : (e -= 65536, String.fromCharCode((e >> 10 & 1023) + 55296, (e & 1023) + 56320))).join("")
}

function PC(t, e) {
    return WIe(zIe(t, e))
}

function ere(t) {
    async function e(n, r) {
        je(r == null || !r.cancelled, "request cancelled before sending", "CANCELLED");
        const i = n.url.split(":")[0].toLowerCase();
        je(i === "http" || i === "https", `unsupported protocol ${i}`, "UNSUPPORTED_OPERATION", {
            info: {
                protocol: i
            },
            operation: "request"
        }), je(i === "https" || !n.credentials || n.allowInsecureAuthentication, "insecure authorized connections unsupported", "UNSUPPORTED_OPERATION", {
            operation: "request"
        });
        let s = null;
        const o = new AbortController,
            a = setTimeout(() => {
                s = pi("request timeout", "TIMEOUT"), o.abort()
            }, n.timeout);
        r && r.addListener(() => {
            s = pi("request cancelled", "CANCELLED"), o.abort()
        });
        const l = {
            method: n.method,
            headers: new Headers(Array.from(n)),
            body: n.body || void 0,
            signal: o.signal
        };
        let c;
        try {
            c = await fetch(n.url, l)
        } catch (g) {
            throw clearTimeout(a), s || g
        }
        clearTimeout(a);
        const u = {};
        c.headers.forEach((g, y) => {
            u[y.toLowerCase()] = g
        });
        const f = await c.arrayBuffer(),
            h = f == null ? null : new Uint8Array(f);
        return {
            statusCode: c.status,
            statusMessage: c.statusText,
            headers: u,
            body: h
        }
    }
    return e
}
const VIe = 12,
    GIe = 250;
let aG = ere();
const qIe = new RegExp("^data:([^;:]*)?(;base64)?,(.*)$", "i"),
    KIe = new RegExp("^ipfs://(ipfs/)?(.*)$", "i");
let pO = !1;
async function tre(t, e) {
    try {
        const n = t.match(qIe);
        if (!n) throw new Error("invalid data");
        return new Ep(200, "OK", {
            "content-type": n[1] || "text/plain"
        }, n[2] ? BIe(n[3]) : ZIe(n[3]))
    } catch {
        return new Ep(599, "BAD REQUEST (invalid data: URI)", {}, null, new od(t))
    }
}

function nre(t) {
    async function e(n, r) {
        try {
            const i = n.match(KIe);
            if (!i) throw new Error("invalid link");
            return new od(`${t}${i[2]}`)
        } catch {
            return new Ep(599, "BAD REQUEST (invalid IPFS URI)", {}, null, new od(n))
        }
    }
    return e
}
const Wx = {
        data: tre,
        ipfs: nre("https://gateway.ipfs.io/ipfs/")
    },
    rre = new WeakMap;
var T1, W0;
class YIe {
    constructor(e) {
        _e(this, T1);
        _e(this, W0);
        le(this, T1, []), le(this, W0, !1), rre.set(e, () => {
            if (!W(this, W0)) {
                le(this, W0, !0);
                for (const n of W(this, T1)) setTimeout(() => {
                    n()
                }, 0);
                le(this, T1, [])
            }
        })
    }
    addListener(e) {
        je(!W(this, W0), "singal already cancelled", "UNSUPPORTED_OPERATION", {
            operation: "fetchCancelSignal.addCancelListener"
        }), W(this, T1).push(e)
    }
    get cancelled() {
        return W(this, W0)
    }
    checkSignal() {
        je(!this.cancelled, "cancelled", "CANCELLED", {})
    }
}
T1 = new WeakMap, W0 = new WeakMap;

function Vx(t) {
    if (t == null) throw new Error("missing signal; should not happen");
    return t.checkSignal(), t
}
var Dv, $v, au, Kd, Lv, Bv, Hs, gl, Yd, I1, R1, O1, bf, lu, V0, N1, x3;
const eT = class eT {
    constructor(e) {
        _e(this, N1);
        _e(this, Dv);
        _e(this, $v);
        _e(this, au);
        _e(this, Kd);
        _e(this, Lv);
        _e(this, Bv);
        _e(this, Hs);
        _e(this, gl);
        _e(this, Yd);
        _e(this, I1);
        _e(this, R1);
        _e(this, O1);
        _e(this, bf);
        _e(this, lu);
        _e(this, V0);
        le(this, Bv, String(e)), le(this, Dv, !1), le(this, $v, !0), le(this, au, {}), le(this, Kd, ""), le(this, Lv, 3e5), le(this, lu, {
            slotInterval: GIe,
            maxAttempts: VIe
        }), le(this, V0, null)
    }
    get url() {
        return W(this, Bv)
    }
    set url(e) {
        le(this, Bv, String(e))
    }
    get body() {
        return W(this, Hs) == null ? null : new Uint8Array(W(this, Hs))
    }
    set body(e) {
        if (e == null) le(this, Hs, void 0), le(this, gl, void 0);
        else if (typeof e == "string") le(this, Hs, qf(e)), le(this, gl, "text/plain");
        else if (e instanceof Uint8Array) le(this, Hs, e), le(this, gl, "application/octet-stream");
        else if (typeof e == "object") le(this, Hs, qf(JSON.stringify(e))), le(this, gl, "application/json");
        else throw new Error("invalid body")
    }
    hasBody() {
        return W(this, Hs) != null
    }
    get method() {
        return W(this, Kd) ? W(this, Kd) : this.hasBody() ? "POST" : "GET"
    }
    set method(e) {
        e == null && (e = ""), le(this, Kd, String(e).toUpperCase())
    }
    get headers() {
        const e = Object.assign({}, W(this, au));
        return W(this, Yd) && (e.authorization = `Basic ${FIe(qf(W(this,Yd)))}`), this.allowGzip && (e["accept-encoding"] = "gzip"), e["content-type"] == null && W(this, gl) && (e["content-type"] = W(this, gl)), this.body && (e["content-length"] = String(this.body.length)), e
    }
    getHeader(e) {
        return this.headers[e.toLowerCase()]
    }
    setHeader(e, n) {
        W(this, au)[String(e).toLowerCase()] = String(n)
    }
    clearHeaders() {
        le(this, au, {})
    }[Symbol.iterator]() {
        const e = this.headers,
            n = Object.keys(e);
        let r = 0;
        return {
            next: () => {
                if (r < n.length) {
                    const i = n[r++];
                    return {
                        value: [i, e[i]],
                        done: !1
                    }
                }
                return {
                    value: void 0,
                    done: !0
                }
            }
        }
    }
    get credentials() {
        return W(this, Yd) || null
    }
    setCredentials(e, n) {
        Ee(!e.match(/:/), "invalid basic authentication username", "username", "[REDACTED]"), le(this, Yd, `${e}:${n}`)
    }
    get allowGzip() {
        return W(this, $v)
    }
    set allowGzip(e) {
        le(this, $v, !!e)
    }
    get allowInsecureAuthentication() {
        return !!W(this, Dv)
    }
    set allowInsecureAuthentication(e) {
        le(this, Dv, !!e)
    }
    get timeout() {
        return W(this, Lv)
    }
    set timeout(e) {
        Ee(e >= 0, "timeout must be non-zero", "timeout", e), le(this, Lv, e)
    }
    get preflightFunc() {
        return W(this, I1) || null
    }
    set preflightFunc(e) {
        le(this, I1, e)
    }
    get processFunc() {
        return W(this, R1) || null
    }
    set processFunc(e) {
        le(this, R1, e)
    }
    get retryFunc() {
        return W(this, O1) || null
    }
    set retryFunc(e) {
        le(this, O1, e)
    }
    get getUrlFunc() {
        return W(this, V0) || aG
    }
    set getUrlFunc(e) {
        le(this, V0, e)
    }
    toString() {
        return `<FetchRequest method=${JSON.stringify(this.method)} url=${JSON.stringify(this.url)} headers=${JSON.stringify(this.headers)} body=${W(this,Hs)?Ot(W(this,Hs)):"null"}>`
    }
    setThrottleParams(e) {
        e.slotInterval != null && (W(this, lu).slotInterval = e.slotInterval), e.maxAttempts != null && (W(this, lu).maxAttempts = e.maxAttempts)
    }
    send() {
        return je(W(this, bf) == null, "request already sent", "UNSUPPORTED_OPERATION", {
            operation: "fetchRequest.send"
        }), le(this, bf, new YIe(this)), De(this, N1, x3).call(this, 0, lG() + this.timeout, 0, this, new Ep(0, "", {}, null, this))
    }
    cancel() {
        je(W(this, bf) != null, "request has not been sent", "UNSUPPORTED_OPERATION", {
            operation: "fetchRequest.cancel"
        });
        const e = rre.get(this);
        if (!e) throw new Error("missing signal; should not happen");
        e()
    }
    redirect(e) {
        const n = this.url.split(":")[0].toLowerCase(),
            r = e.split(":")[0].toLowerCase();
        je(this.method === "GET" && (n !== "https" || r !== "http") && e.match(/^https?:/), "unsupported redirect", "UNSUPPORTED_OPERATION", {
            operation: `redirect(${this.method} ${JSON.stringify(this.url)} => ${JSON.stringify(e)})`
        });
        const i = new eT(e);
        return i.method = "GET", i.allowGzip = this.allowGzip, i.timeout = this.timeout, le(i, au, Object.assign({}, W(this, au))), W(this, Hs) && le(i, Hs, new Uint8Array(W(this, Hs))), le(i, gl, W(this, gl)), i
    }
    clone() {
        const e = new eT(this.url);
        return le(e, Kd, W(this, Kd)), W(this, Hs) && le(e, Hs, W(this, Hs)), le(e, gl, W(this, gl)), le(e, au, Object.assign({}, W(this, au))), le(e, Yd, W(this, Yd)), this.allowGzip && (e.allowGzip = !0), e.timeout = this.timeout, this.allowInsecureAuthentication && (e.allowInsecureAuthentication = !0), le(e, I1, W(this, I1)), le(e, R1, W(this, R1)), le(e, O1, W(this, O1)), le(e, lu, Object.assign({}, W(this, lu))), le(e, V0, W(this, V0)), e
    }
    static lockConfig() {
        pO = !0
    }
    static getGateway(e) {
        return Wx[e.toLowerCase()] || null
    }
    static registerGateway(e, n) {
        if (e = e.toLowerCase(), e === "http" || e === "https") throw new Error(`cannot intercept ${e}; use registerGetUrl`);
        if (pO) throw new Error("gateways locked");
        Wx[e] = n
    }
    static registerGetUrl(e) {
        if (pO) throw new Error("gateways locked");
        aG = e
    }
    static createGetUrlFunc(e) {
        return ere()
    }
    static createDataGateway() {
        return tre
    }
    static createIpfsGatewayFunc(e) {
        return nre(e)
    }
};
Dv = new WeakMap, $v = new WeakMap, au = new WeakMap, Kd = new WeakMap, Lv = new WeakMap, Bv = new WeakMap, Hs = new WeakMap, gl = new WeakMap, Yd = new WeakMap, I1 = new WeakMap, R1 = new WeakMap, O1 = new WeakMap, bf = new WeakMap, lu = new WeakMap, V0 = new WeakMap, N1 = new WeakSet, x3 = async function(e, n, r, i, s) {
    var u, f, h;
    if (e >= W(this, lu).maxAttempts) return s.makeServerError("exceeded maximum retry limit");
    je(lG() <= n, "timeout", "TIMEOUT", {
        operation: "request.send",
        reason: "timeout",
        request: i
    }), r > 0 && await QIe(r);
    let o = this.clone();
    const a = (o.url.split(":")[0] || "").toLowerCase();
    if (a in Wx) {
        const g = await Wx[a](o.url, Vx(W(i, bf)));
        if (g instanceof Ep) {
            let y = g;
            if (this.processFunc) {
                Vx(W(i, bf));
                try {
                    y = await this.processFunc(o, y)
                } catch (_) {
                    (_.throttle == null || typeof _.stall != "number") && y.makeServerError("error in post-processing function", _).assertOk()
                }
            }
            return y
        }
        o = g
    }
    this.preflightFunc && (o = await this.preflightFunc(o));
    const l = await this.getUrlFunc(o, Vx(W(i, bf)));
    let c = new Ep(l.statusCode, l.statusMessage, l.headers, l.body, i);
    if (c.statusCode === 301 || c.statusCode === 302) {
        try {
            const g = c.headers.location || "";
            return De(u = o.redirect(g), N1, x3).call(u, e + 1, n, 0, i, c)
        } catch {}
        return c
    } else if (c.statusCode === 429 && (this.retryFunc == null || await this.retryFunc(o, c, e))) {
        const g = c.headers["retry-after"];
        let y = W(this, lu).slotInterval * Math.trunc(Math.random() * Math.pow(2, e));
        return typeof g == "string" && g.match(/^[1-9][0-9]*$/) && (y = parseInt(g)), De(f = o.clone(), N1, x3).call(f, e + 1, n, y, i, c)
    }
    if (this.processFunc) {
        Vx(W(i, bf));
        try {
            c = await this.processFunc(o, c)
        } catch (g) {
            (g.throttle == null || typeof g.stall != "number") && c.makeServerError("error in post-processing function", g).assertOk();
            let y = W(this, lu).slotInterval * Math.trunc(Math.random() * Math.pow(2, e));
            return g.stall >= 0 && (y = g.stall), De(h = o.clone(), N1, x3).call(h, e + 1, n, y, i, c)
        }
    }
    return c
};
let od = eT;
var V6, G6, q6, ml, Fv, P1;
const aj = class aj {
    constructor(e, n, r, i, s) {
        _e(this, V6);
        _e(this, G6);
        _e(this, q6);
        _e(this, ml);
        _e(this, Fv);
        _e(this, P1);
        le(this, V6, e), le(this, G6, n), le(this, q6, Object.keys(r).reduce((o, a) => (o[a.toLowerCase()] = String(r[a]), o), {})), le(this, ml, i == null ? null : new Uint8Array(i)), le(this, Fv, s || null), le(this, P1, {
            message: ""
        })
    }
    toString() {
        return `<FetchResponse status=${this.statusCode} body=${W(this,ml)?Ot(W(this,ml)):"null"}>`
    }
    get statusCode() {
        return W(this, V6)
    }
    get statusMessage() {
        return W(this, G6)
    }
    get headers() {
        return Object.assign({}, W(this, q6))
    }
    get body() {
        return W(this, ml) == null ? null : new Uint8Array(W(this, ml))
    }
    get bodyText() {
        try {
            return W(this, ml) == null ? "" : PC(W(this, ml))
        } catch {
            je(!1, "response body is not valid UTF-8 data", "UNSUPPORTED_OPERATION", {
                operation: "bodyText",
                info: {
                    response: this
                }
            })
        }
    }
    get bodyJson() {
        try {
            return JSON.parse(this.bodyText)
        } catch {
            je(!1, "response body is not valid JSON", "UNSUPPORTED_OPERATION", {
                operation: "bodyJson",
                info: {
                    response: this
                }
            })
        }
    }[Symbol.iterator]() {
        const e = this.headers,
            n = Object.keys(e);
        let r = 0;
        return {
            next: () => {
                if (r < n.length) {
                    const i = n[r++];
                    return {
                        value: [i, e[i]],
                        done: !1
                    }
                }
                return {
                    value: void 0,
                    done: !0
                }
            }
        }
    }
    makeServerError(e, n) {
        let r;
        e ? r = `CLIENT ESCALATED SERVER ERROR (${this.statusCode} ${this.statusMessage}; ${e})` : (e = `${this.statusCode} ${this.statusMessage}`, r = `CLIENT ESCALATED SERVER ERROR (${e})`);
        const i = new aj(599, r, this.headers, this.body, W(this, Fv) || void 0);
        return le(i, P1, {
            message: e,
            error: n
        }), i
    }
    throwThrottleError(e, n) {
        n == null ? n = -1 : Ee(Number.isInteger(n) && n >= 0, "invalid stall timeout", "stall", n);
        const r = new Error(e || "throttling requests");
        throw Xt(r, {
            stall: n,
            throttle: !0
        }), r
    }
    getHeader(e) {
        return this.headers[e.toLowerCase()]
    }
    hasBody() {
        return W(this, ml) != null
    }
    get request() {
        return W(this, Fv)
    }
    ok() {
        return W(this, P1).message === "" && this.statusCode >= 200 && this.statusCode < 300
    }
    assertOk() {
        if (this.ok()) return;
        let {
            message: e,
            error: n
        } = W(this, P1);
        e === "" && (e = `server response ${this.statusCode} ${this.statusMessage}`);
        let r = null;
        this.request && (r = this.request.url);
        let i = null;
        try {
            W(this, ml) && (i = PC(W(this, ml)))
        } catch {}
        je(!1, e, "SERVER_ERROR", {
            request: this.request || "unknown request",
            response: this,
            error: n,
            info: {
                requestUrl: r,
                responseBody: i,
                responseStatus: `${this.statusCode} ${this.statusMessage}`
            }
        })
    }
};
V6 = new WeakMap, G6 = new WeakMap, q6 = new WeakMap, ml = new WeakMap, Fv = new WeakMap, P1 = new WeakMap;
let Ep = aj;

function lG() {
    return new Date().getTime()
}

function ZIe(t) {
    return qf(t.replace(/%([0-9a-f][0-9a-f])/gi, (e, n) => String.fromCharCode(parseInt(n, 16))))
}

function QIe(t) {
    return new Promise(e => setTimeout(e, t))
}
const JIe = BigInt(-1),
    Xc = BigInt(0),
    Nw = BigInt(1),
    XIe = BigInt(5),
    ew = {};
let sv = "0000";
for (; sv.length < 80;) sv += sv;

function Lg(t) {
    let e = sv;
    for (; e.length < t;) e += e;
    return BigInt("1" + e.substring(0, t))
}

function z5(t, e, n) {
    const r = BigInt(e.width);
    if (e.signed) {
        const i = Nw << r - Nw;
        je(n == null || t >= -i && t < i, "overflow", "NUMERIC_FAULT", {
            operation: n,
            fault: "overflow",
            value: t
        }), t > Xc ? t = NC(c1(t, r), r) : t = -NC(c1(-t, r), r)
    } else {
        const i = Nw << r;
        je(n == null || t >= 0 && t < i, "overflow", "NUMERIC_FAULT", {
            operation: n,
            fault: "overflow",
            value: t
        }), t = (t % i + i) % i & i - Nw
    }
    return t
}

function gO(t) {
    typeof t == "number" && (t = `fixed128x${t}`);
    let e = !0,
        n = 128,
        r = 18;
    if (typeof t == "string") {
        if (t !== "fixed")
            if (t === "ufixed") e = !1;
            else {
                const s = t.match(/^(u?)fixed([0-9]+)x([0-9]+)$/);
                Ee(s, "invalid fixed format", "format", t), e = s[1] !== "u", n = parseInt(s[2]), r = parseInt(s[3])
            }
    } else if (t) {
        const s = t,
            o = (a, l, c) => s[a] == null ? c : (Ee(typeof s[a] === l, "invalid fixed format (" + a + " not " + l + ")", "format." + a, s[a]), s[a]);
        e = o("signed", "boolean", e), n = o("width", "number", n), r = o("decimals", "number", r)
    }
    Ee(n % 8 === 0, "invalid FixedNumber width (not byte aligned)", "format.width", n), Ee(r <= 80, "invalid FixedNumber decimals (too large)", "format.decimals", r);
    const i = (e ? "" : "u") + "fixed" + String(n) + "x" + String(r);
    return {
        signed: e,
        width: n,
        decimals: r,
        name: i
    }
}

function eRe(t, e) {
    let n = "";
    t < Xc && (n = "-", t *= JIe);
    let r = t.toString();
    if (e === 0) return n + r;
    for (; r.length <= e;) r = sv + r;
    const i = r.length - e;
    for (r = r.substring(0, i) + "." + r.substring(i); r[0] === "0" && r[1] !== ".";) r = r.substring(1);
    for (; r[r.length - 1] === "0" && r[r.length - 2] !== ".";) r = r.substring(0, r.length - 1);
    return n + r
}
var cu, Pr, Yo, Ar, Wg, Ld, _k, Ek, xk, Sk;
const R0 = class R0 {
    constructor(e, n, r) {
        _e(this, Ar);
        Ie(this, "format");
        _e(this, cu);
        _e(this, Pr);
        _e(this, Yo);
        Ie(this, "_value");
        IE(e, ew, "FixedNumber"), le(this, Pr, n), le(this, cu, r);
        const i = eRe(n, r.decimals);
        Xt(this, {
            format: r.name,
            _value: i
        }), le(this, Yo, Lg(r.decimals))
    }
    get signed() {
        return W(this, cu).signed
    }
    get width() {
        return W(this, cu).width
    }
    get decimals() {
        return W(this, cu).decimals
    }
    get value() {
        return W(this, Pr)
    }
    addUnsafe(e) {
        return De(this, Ar, _k).call(this, e)
    }
    add(e) {
        return De(this, Ar, _k).call(this, e, "add")
    }
    subUnsafe(e) {
        return De(this, Ar, Ek).call(this, e)
    }
    sub(e) {
        return De(this, Ar, Ek).call(this, e, "sub")
    }
    mulUnsafe(e) {
        return De(this, Ar, xk).call(this, e)
    }
    mul(e) {
        return De(this, Ar, xk).call(this, e, "mul")
    }
    mulSignal(e) {
        De(this, Ar, Wg).call(this, e);
        const n = W(this, Pr) * W(e, Pr);
        return je(n % W(this, Yo) === Xc, "precision lost during signalling mul", "NUMERIC_FAULT", {
            operation: "mulSignal",
            fault: "underflow",
            value: this
        }), De(this, Ar, Ld).call(this, n / W(this, Yo), "mulSignal")
    }
    divUnsafe(e) {
        return De(this, Ar, Sk).call(this, e)
    }
    div(e) {
        return De(this, Ar, Sk).call(this, e, "div")
    }
    divSignal(e) {
        je(W(e, Pr) !== Xc, "division by zero", "NUMERIC_FAULT", {
            operation: "div",
            fault: "divide-by-zero",
            value: this
        }), De(this, Ar, Wg).call(this, e);
        const n = W(this, Pr) * W(this, Yo);
        return je(n % W(e, Pr) === Xc, "precision lost during signalling div", "NUMERIC_FAULT", {
            operation: "divSignal",
            fault: "underflow",
            value: this
        }), De(this, Ar, Ld).call(this, n / W(e, Pr), "divSignal")
    }
    cmp(e) {
        let n = this.value,
            r = e.value;
        const i = this.decimals - e.decimals;
        return i > 0 ? r *= Lg(i) : i < 0 && (n *= Lg(-i)), n < r ? -1 : n > r ? 1 : 0
    }
    eq(e) {
        return this.cmp(e) === 0
    }
    lt(e) {
        return this.cmp(e) < 0
    }
    lte(e) {
        return this.cmp(e) <= 0
    }
    gt(e) {
        return this.cmp(e) > 0
    }
    gte(e) {
        return this.cmp(e) >= 0
    }
    floor() {
        let e = W(this, Pr);
        return W(this, Pr) < Xc && (e -= W(this, Yo) - Nw), e = W(this, Pr) / W(this, Yo) * W(this, Yo), De(this, Ar, Ld).call(this, e, "floor")
    }
    ceiling() {
        let e = W(this, Pr);
        return W(this, Pr) > Xc && (e += W(this, Yo) - Nw), e = W(this, Pr) / W(this, Yo) * W(this, Yo), De(this, Ar, Ld).call(this, e, "ceiling")
    }
    round(e) {
        if (e == null && (e = 0), e >= this.decimals) return this;
        const n = this.decimals - e,
            r = XIe * Lg(n - 1);
        let i = this.value + r;
        const s = Lg(n);
        return i = i / s * s, z5(i, W(this, cu), "round"), new R0(ew, i, W(this, cu))
    }
    isZero() {
        return W(this, Pr) === Xc
    }
    isNegative() {
        return W(this, Pr) < Xc
    }
    toString() {
        return this._value
    }
    toUnsafeFloat() {
        return parseFloat(this.toString())
    }
    toFormat(e) {
        return R0.fromString(this.toString(), e)
    }
    static fromValue(e, n, r) {
        const i = n == null ? 0 : Mn(n),
            s = gO(r);
        let o = kt(e, "value");
        const a = i - s.decimals;
        if (a > 0) {
            const l = Lg(a);
            je(o % l === Xc, "value loses precision for format", "NUMERIC_FAULT", {
                operation: "fromValue",
                fault: "underflow",
                value: e
            }), o /= l
        } else a < 0 && (o *= Lg(-a));
        return z5(o, s, "fromValue"), new R0(ew, o, s)
    }
    static fromString(e, n) {
        const r = e.match(/^(-?)([0-9]*)\.?([0-9]*)$/);
        Ee(r && r[2].length + r[3].length > 0, "invalid FixedNumber string value", "value", e);
        const i = gO(n);
        let s = r[2] || "0",
            o = r[3] || "";
        for (; o.length < i.decimals;) o += sv;
        je(o.substring(i.decimals).match(/^0*$/), "too many decimals for format", "NUMERIC_FAULT", {
            operation: "fromString",
            fault: "underflow",
            value: e
        }), o = o.substring(0, i.decimals);
        const a = BigInt(r[1] + s + o);
        return z5(a, i, "fromString"), new R0(ew, a, i)
    }
    static fromBytes(e, n) {
        let r = YT(or(e, "value"));
        const i = gO(n);
        return i.signed && (r = NC(r, i.width)), z5(r, i, "fromBytes"), new R0(ew, r, i)
    }
};
cu = new WeakMap, Pr = new WeakMap, Yo = new WeakMap, Ar = new WeakSet, Wg = function(e) {
    Ee(this.format === e.format, "incompatible format; use fixedNumber.toFormat", "other", e)
}, Ld = function(e, n) {
    return e = z5(e, W(this, cu), n), new R0(ew, e, W(this, cu))
}, _k = function(e, n) {
    return De(this, Ar, Wg).call(this, e), De(this, Ar, Ld).call(this, W(this, Pr) + W(e, Pr), n)
}, Ek = function(e, n) {
    return De(this, Ar, Wg).call(this, e), De(this, Ar, Ld).call(this, W(this, Pr) - W(e, Pr), n)
}, xk = function(e, n) {
    return De(this, Ar, Wg).call(this, e), De(this, Ar, Ld).call(this, W(this, Pr) * W(e, Pr) / W(this, Yo), n)
}, Sk = function(e, n) {
    return je(W(e, Pr) !== Xc, "division by zero", "NUMERIC_FAULT", {
        operation: "div",
        fault: "divide-by-zero",
        value: this
    }), De(this, Ar, Wg).call(this, e), De(this, Ar, Ld).call(this, W(this, Pr) * W(this, Yo) / W(e, Pr), n)
};
let bk = R0;

function tRe(t) {
    let e = t.toString(16);
    for (; e.length < 2;) e = "0" + e;
    return "0x" + e
}

function cG(t, e, n) {
    let r = 0;
    for (let i = 0; i < n; i++) r = r * 256 + t[e + i];
    return r
}

function uG(t, e, n, r) {
    const i = [];
    for (; n < e + 1 + r;) {
        const s = ire(t, n);
        i.push(s.result), n += s.consumed, je(n <= e + 1 + r, "child data too short", "BUFFER_OVERRUN", {
            buffer: t,
            length: r,
            offset: e
        })
    }
    return {
        consumed: 1 + r,
        result: i
    }
}

function ire(t, e) {
    je(t.length !== 0, "data too short", "BUFFER_OVERRUN", {
        buffer: t,
        length: 0,
        offset: 1
    });
    const n = r => {
        je(r <= t.length, "data short segment too short", "BUFFER_OVERRUN", {
            buffer: t,
            length: t.length,
            offset: r
        })
    };
    if (t[e] >= 248) {
        const r = t[e] - 247;
        n(e + 1 + r);
        const i = cG(t, e + 1, r);
        return n(e + 1 + r + i), uG(t, e, e + 1 + r, r + i)
    } else if (t[e] >= 192) {
        const r = t[e] - 192;
        return n(e + 1 + r), uG(t, e, e + 1, r)
    } else if (t[e] >= 184) {
        const r = t[e] - 183;
        n(e + 1 + r);
        const i = cG(t, e + 1, r);
        n(e + 1 + r + i);
        const s = Ot(t.slice(e + 1 + r, e + 1 + r + i));
        return {
            consumed: 1 + r + i,
            result: s
        }
    } else if (t[e] >= 128) {
        const r = t[e] - 128;
        n(e + 1 + r);
        const i = Ot(t.slice(e + 1, e + 1 + r));
        return {
            consumed: 1 + r,
            result: i
        }
    }
    return {
        consumed: 1,
        result: tRe(t[e])
    }
}

function ZT(t) {
    const e = or(t, "data"),
        n = ire(e, 0);
    return Ee(n.consumed === e.length, "unexpected junk after rlp payload", "data", t), n.result
}

function fG(t) {
    const e = [];
    for (; t;) e.unshift(t & 255), t >>= 8;
    return e
}

function sre(t) {
    if (Array.isArray(t)) {
        let r = [];
        if (t.forEach(function(s) {
                r = r.concat(sre(s))
            }), r.length <= 55) return r.unshift(192 + r.length), r;
        const i = fG(r.length);
        return i.unshift(247 + i.length), i.concat(r)
    }
    const e = Array.prototype.slice.call(or(t, "object"));
    if (e.length === 1 && e[0] <= 127) return e;
    if (e.length <= 55) return e.unshift(128 + e.length), e;
    const n = fG(e.length);
    return n.unshift(183 + n.length), n.concat(e)
}
const dG = "0123456789abcdef";

function Mm(t) {
    let e = "0x";
    for (const n of sre(t)) e += dG[n >> 4], e += dG[n & 15];
    return e
}

function nRe(t, e) {
    let n = 18;
    return n = Mn(e, "unit"), bk.fromValue(t, n, {
        decimals: n,
        width: 512
    }).toString()
}

function rRe(t) {
    return nRe(t, 18)
}
const oa = 32,
    Ck = new Uint8Array(oa),
    iRe = ["then"],
    Gx = {},
    ore = new WeakMap;

function Zg(t) {
    return ore.get(t)
}

function hG(t, e) {
    ore.set(t, e)
}

function W5(t, e) {
    const n = new Error(`deferred error during ABI decoding triggered accessing ${t}`);
    throw n.error = e, n
}

function Ak(t, e, n) {
    return t.indexOf(null) >= 0 ? e.map((r, i) => r instanceof Wp ? Ak(Zg(r), r, n) : r) : t.reduce((r, i, s) => {
        let o = e.getValue(i);
        return i in r || (n && o instanceof Wp && (o = Ak(Zg(o), o, n)), r[i] = o), r
    }, {})
}
var Uv;
const Kw = class Kw extends Array {
    constructor(...n) {
        const r = n[0];
        let i = n[1],
            s = (n[2] || []).slice(),
            o = !0;
        r !== Gx && (i = n, s = [], o = !1);
        super(i.length);
        _e(this, Uv);
        i.forEach((c, u) => {
            this[u] = c
        });
        const a = s.reduce((c, u) => (typeof u == "string" && c.set(u, (c.get(u) || 0) + 1), c), new Map);
        if (hG(this, Object.freeze(i.map((c, u) => {
                const f = s[u];
                return f != null && a.get(f) === 1 ? f : null
            }))), le(this, Uv, []), W(this, Uv) == null && W(this, Uv), !o) return;
        Object.freeze(this);
        const l = new Proxy(this, {
            get: (c, u, f) => {
                if (typeof u == "string") {
                    if (u.match(/^[0-9]+$/)) {
                        const g = Mn(u, "%index");
                        if (g < 0 || g >= this.length) throw new RangeError("out of result range");
                        const y = c[g];
                        return y instanceof Error && W5(`index ${g}`, y), y
                    }
                    if (iRe.indexOf(u) >= 0) return Reflect.get(c, u, f);
                    const h = c[u];
                    if (h instanceof Function) return function(...g) {
                        return h.apply(this === f ? c : this, g)
                    };
                    if (!(u in c)) return c.getValue.apply(this === f ? c : this, [u])
                }
                return Reflect.get(c, u, f)
            }
        });
        return hG(l, Zg(this)), l
    }
    toArray(n) {
        const r = [];
        return this.forEach((i, s) => {
            i instanceof Error && W5(`index ${s}`, i), n && i instanceof Kw && (i = i.toArray(n)), r.push(i)
        }), r
    }
    toObject(n) {
        const r = Zg(this);
        return r.reduce((i, s, o) => (je(s != null, `value at index ${o} unnamed`, "UNSUPPORTED_OPERATION", {
            operation: "toObject()"
        }), Ak(r, this, n)), {})
    }
    slice(n, r) {
        n == null && (n = 0), n < 0 && (n += this.length, n < 0 && (n = 0)), r == null && (r = this.length), r < 0 && (r += this.length, r < 0 && (r = 0)), r > this.length && (r = this.length);
        const i = Zg(this),
            s = [],
            o = [];
        for (let a = n; a < r; a++) s.push(this[a]), o.push(i[a]);
        return new Kw(Gx, s, o)
    }
    filter(n, r) {
        const i = Zg(this),
            s = [],
            o = [];
        for (let a = 0; a < this.length; a++) {
            const l = this[a];
            l instanceof Error && W5(`index ${a}`, l), n.call(r, l, a, this) && (s.push(l), o.push(i[a]))
        }
        return new Kw(Gx, s, o)
    }
    map(n, r) {
        const i = [];
        for (let s = 0; s < this.length; s++) {
            const o = this[s];
            o instanceof Error && W5(`index ${s}`, o), i.push(n.call(r, o, s, this))
        }
        return i
    }
    getValue(n) {
        const r = Zg(this).indexOf(n);
        if (r === -1) return;
        const i = this[r];
        return i instanceof Error && W5(`property ${JSON.stringify(n)}`, i.error), i
    }
    static fromItems(n, r) {
        return new Kw(Gx, n, r)
    }
};
Uv = new WeakMap;
let Wp = Kw;

function pG(t) {
    let e = sa(t);
    return je(e.length <= oa, "value out-of-bounds", "BUFFER_OVERRUN", {
        buffer: e,
        length: oa,
        offset: e.length
    }), e.length !== oa && (e = ra(vi([Ck.slice(e.length % oa), e]))), e
}
let Hh = class {
    constructor(e, n, r, i) {
        Ie(this, "name");
        Ie(this, "type");
        Ie(this, "localName");
        Ie(this, "dynamic");
        Xt(this, {
            name: e,
            type: n,
            localName: r,
            dynamic: i
        }, {
            name: "string",
            type: "string",
            localName: "string",
            dynamic: "boolean"
        })
    }
    _throwError(e, n) {
        Ee(!1, e, this.localName, n)
    }
};
var Zd, k1, jv, t8;
class Tk {
    constructor() {
        _e(this, jv);
        _e(this, Zd);
        _e(this, k1);
        le(this, Zd, []), le(this, k1, 0)
    }
    get data() {
        return vi(W(this, Zd))
    }
    get length() {
        return W(this, k1)
    }
    appendWriter(e) {
        return De(this, jv, t8).call(this, ra(e.data))
    }
    writeBytes(e) {
        let n = ra(e);
        const r = n.length % oa;
        return r && (n = ra(vi([n, Ck.slice(r)]))), De(this, jv, t8).call(this, n)
    }
    writeValue(e) {
        return De(this, jv, t8).call(this, pG(e))
    }
    writeUpdatableValue() {
        const e = W(this, Zd).length;
        return W(this, Zd).push(Ck), le(this, k1, W(this, k1) + oa), n => {
            W(this, Zd)[e] = pG(n)
        }
    }
}
Zd = new WeakMap, k1 = new WeakMap, jv = new WeakSet, t8 = function(e) {
    return W(this, Zd).push(e), le(this, k1, W(this, k1) + e.length), e.length
};
var Ma, yl, M1, D1, G0, oy, Rk, are;
const lj = class lj {
    constructor(e, n, r) {
        _e(this, oy);
        Ie(this, "allowLoose");
        _e(this, Ma);
        _e(this, yl);
        _e(this, M1);
        _e(this, D1);
        _e(this, G0);
        Xt(this, {
            allowLoose: !!n
        }), le(this, Ma, ra(e)), le(this, M1, 0), le(this, D1, null), le(this, G0, r ? ? 1024), le(this, yl, 0)
    }
    get data() {
        return Ot(W(this, Ma))
    }
    get dataLength() {
        return W(this, Ma).length
    }
    get consumed() {
        return W(this, yl)
    }
    get bytes() {
        return new Uint8Array(W(this, Ma))
    }
    subReader(e) {
        const n = new lj(W(this, Ma).slice(W(this, yl) + e), this.allowLoose, W(this, G0));
        return le(n, D1, this), n
    }
    readBytes(e, n) {
        let r = De(this, oy, are).call(this, 0, e, !!n);
        return De(this, oy, Rk).call(this, e), le(this, yl, W(this, yl) + r.length), r.slice(0, e)
    }
    readValue() {
        return YT(this.readBytes(oa))
    }
    readIndex() {
        return $Ie(this.readBytes(oa))
    }
};
Ma = new WeakMap, yl = new WeakMap, M1 = new WeakMap, D1 = new WeakMap, G0 = new WeakMap, oy = new WeakSet, Rk = function(e) {
    var n;
    if (W(this, D1)) return De(n = W(this, D1), oy, Rk).call(n, e);
    le(this, M1, W(this, M1) + e), je(W(this, G0) < 1 || W(this, M1) <= W(this, G0) * this.dataLength, `compressed ABI data exceeds inflation ratio of ${W(this,G0)} ( see: https://github.com/ethers-io/ethers.js/issues/4537 )`, "BUFFER_OVERRUN", {
        buffer: ra(W(this, Ma)),
        offset: W(this, yl),
        length: e,
        info: {
            bytesRead: W(this, M1),
            dataLength: this.dataLength
        }
    })
}, are = function(e, n, r) {
    let i = Math.ceil(n / oa) * oa;
    return W(this, yl) + i > W(this, Ma).length && (this.allowLoose && r && W(this, yl) + n <= W(this, Ma).length ? i = n : je(!1, "data out-of-bounds", "BUFFER_OVERRUN", {
        buffer: ra(W(this, Ma)),
        length: W(this, Ma).length,
        offset: W(this, yl) + i
    })), W(this, Ma).slice(W(this, yl), W(this, yl) + i)
};
let Ik = lj;

function kC(t) {
    if (!Number.isSafeInteger(t) || t < 0) throw new Error(`Wrong positive integer: ${t}`)
}

function xL(t, ...e) {
    if (!(t instanceof Uint8Array)) throw new Error("Expected Uint8Array");
    if (e.length > 0 && !e.includes(t.length)) throw new Error(`Expected Uint8Array of length ${e}, not of length=${t.length}`)
}

function sRe(t) {
    if (typeof t != "function" || typeof t.create != "function") throw new Error("Hash should be wrapped by utils.wrapConstructor");
    kC(t.outputLen), kC(t.blockLen)
}

function Vb(t, e = !0) {
    if (t.destroyed) throw new Error("Hash instance has been destroyed");
    if (e && t.finished) throw new Error("Hash#digest() has already been called")
}

function lre(t, e) {
    xL(t);
    const n = e.outputLen;
    if (t.length < n) throw new Error(`digestInto() expects output buffer of length at least ${n}`)
}
const mO = typeof globalThis == "object" && "crypto" in globalThis ? globalThis.crypto : void 0; /*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const cre = t => t instanceof Uint8Array,
    oRe = t => new Uint32Array(t.buffer, t.byteOffset, Math.floor(t.byteLength / 4)),
    yO = t => new DataView(t.buffer, t.byteOffset, t.byteLength),
    sf = (t, e) => t << 32 - e | t >>> e,
    aRe = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
if (!aRe) throw new Error("Non little-endian hardware is not supported");

function lRe(t) {
    if (typeof t != "string") throw new Error(`utf8ToBytes expected string, got ${typeof t}`);
    return new Uint8Array(new TextEncoder().encode(t))
}

function QT(t) {
    if (typeof t == "string" && (t = lRe(t)), !cre(t)) throw new Error(`expected Uint8Array, got ${typeof t}`);
    return t
}

function cRe(...t) {
    const e = new Uint8Array(t.reduce((r, i) => r + i.length, 0));
    let n = 0;
    return t.forEach(r => {
        if (!cre(r)) throw new Error("Uint8Array expected");
        e.set(r, n), n += r.length
    }), e
}
let SL = class {
    clone() {
        return this._cloneInto()
    }
};

function CL(t) {
    const e = r => t().update(QT(r)).digest(),
        n = t();
    return e.outputLen = n.outputLen, e.blockLen = n.blockLen, e.create = () => t(), e
}

function uRe(t = 32) {
    if (mO && typeof mO.getRandomValues == "function") return mO.getRandomValues(new Uint8Array(t));
    throw new Error("crypto.getRandomValues must be defined")
}
class ure extends SL {
    constructor(e, n) {
        super(), this.finished = !1, this.destroyed = !1, sRe(e);
        const r = QT(n);
        if (this.iHash = e.create(), typeof this.iHash.update != "function") throw new Error("Expected instance of class which extends utils.Hash");
        this.blockLen = this.iHash.blockLen, this.outputLen = this.iHash.outputLen;
        const i = this.blockLen,
            s = new Uint8Array(i);
        s.set(r.length > i ? e.create().update(r).digest() : r);
        for (let o = 0; o < s.length; o++) s[o] ^= 54;
        this.iHash.update(s), this.oHash = e.create();
        for (let o = 0; o < s.length; o++) s[o] ^= 106;
        this.oHash.update(s), s.fill(0)
    }
    update(e) {
        return Vb(this), this.iHash.update(e), this
    }
    digestInto(e) {
        Vb(this), xL(e, this.outputLen), this.finished = !0, this.iHash.digestInto(e), this.oHash.update(e), this.oHash.digestInto(e), this.destroy()
    }
    digest() {
        const e = new Uint8Array(this.oHash.outputLen);
        return this.digestInto(e), e
    }
    _cloneInto(e) {
        e || (e = Object.create(Object.getPrototypeOf(this), {}));
        const {
            oHash: n,
            iHash: r,
            finished: i,
            destroyed: s,
            blockLen: o,
            outputLen: a
        } = this;
        return e = e, e.finished = i, e.destroyed = s, e.blockLen = o, e.outputLen = a, e.oHash = n._cloneInto(e.oHash), e.iHash = r._cloneInto(e.iHash), e
    }
    destroy() {
        this.destroyed = !0, this.oHash.destroy(), this.iHash.destroy()
    }
}
const fre = (t, e, n) => new ure(t, e).update(n).digest();
fre.create = (t, e) => new ure(t, e);

function fRe(t, e, n, r) {
    if (typeof t.setBigUint64 == "function") return t.setBigUint64(e, n, r);
    const i = BigInt(32),
        s = BigInt(4294967295),
        o = Number(n >> i & s),
        a = Number(n & s),
        l = r ? 4 : 0,
        c = r ? 0 : 4;
    t.setUint32(e + l, o, r), t.setUint32(e + c, a, r)
}
class dre extends SL {
    constructor(e, n, r, i) {
        super(), this.blockLen = e, this.outputLen = n, this.padOffset = r, this.isLE = i, this.finished = !1, this.length = 0, this.pos = 0, this.destroyed = !1, this.buffer = new Uint8Array(e), this.view = yO(this.buffer)
    }
    update(e) {
        Vb(this);
        const {
            view: n,
            buffer: r,
            blockLen: i
        } = this;
        e = QT(e);
        const s = e.length;
        for (let o = 0; o < s;) {
            const a = Math.min(i - this.pos, s - o);
            if (a === i) {
                const l = yO(e);
                for (; i <= s - o; o += i) this.process(l, o);
                continue
            }
            r.set(e.subarray(o, o + a), this.pos), this.pos += a, o += a, this.pos === i && (this.process(n, 0), this.pos = 0)
        }
        return this.length += e.length, this.roundClean(), this
    }
    digestInto(e) {
        Vb(this), lre(e, this), this.finished = !0;
        const {
            buffer: n,
            view: r,
            blockLen: i,
            isLE: s
        } = this;
        let {
            pos: o
        } = this;
        n[o++] = 128, this.buffer.subarray(o).fill(0), this.padOffset > i - o && (this.process(r, 0), o = 0);
        for (let f = o; f < i; f++) n[f] = 0;
        fRe(r, i - 8, BigInt(this.length * 8), s), this.process(r, 0);
        const a = yO(e),
            l = this.outputLen;
        if (l % 4) throw new Error("_sha2: outputLen should be aligned to 32bit");
        const c = l / 4,
            u = this.get();
        if (c > u.length) throw new Error("_sha2: outputLen bigger than state");
        for (let f = 0; f < c; f++) a.setUint32(4 * f, u[f], s)
    }
    digest() {
        const {
            buffer: e,
            outputLen: n
        } = this;
        this.digestInto(e);
        const r = e.slice(0, n);
        return this.destroy(), r
    }
    _cloneInto(e) {
        e || (e = new this.constructor), e.set(...this.get());
        const {
            blockLen: n,
            buffer: r,
            length: i,
            finished: s,
            destroyed: o,
            pos: a
        } = this;
        return e.length = i, e.pos = a, e.finished = s, e.destroyed = o, i % n && e.buffer.set(r), e
    }
}
const dRe = (t, e, n) => t & e ^ ~t & n,
    hRe = (t, e, n) => t & e ^ t & n ^ e & n,
    pRe = new Uint32Array([1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298]),
    a0 = new Uint32Array([1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635, 1541459225]),
    l0 = new Uint32Array(64);
class gRe extends dre {
    constructor() {
        super(64, 32, 8, !1), this.A = a0[0] | 0, this.B = a0[1] | 0, this.C = a0[2] | 0, this.D = a0[3] | 0, this.E = a0[4] | 0, this.F = a0[5] | 0, this.G = a0[6] | 0, this.H = a0[7] | 0
    }
    get() {
        const {
            A: e,
            B: n,
            C: r,
            D: i,
            E: s,
            F: o,
            G: a,
            H: l
        } = this;
        return [e, n, r, i, s, o, a, l]
    }
    set(e, n, r, i, s, o, a, l) {
        this.A = e | 0, this.B = n | 0, this.C = r | 0, this.D = i | 0, this.E = s | 0, this.F = o | 0, this.G = a | 0, this.H = l | 0
    }
    process(e, n) {
        for (let f = 0; f < 16; f++, n += 4) l0[f] = e.getUint32(n, !1);
        for (let f = 16; f < 64; f++) {
            const h = l0[f - 15],
                g = l0[f - 2],
                y = sf(h, 7) ^ sf(h, 18) ^ h >>> 3,
                _ = sf(g, 17) ^ sf(g, 19) ^ g >>> 10;
            l0[f] = _ + l0[f - 7] + y + l0[f - 16] | 0
        }
        let {
            A: r,
            B: i,
            C: s,
            D: o,
            E: a,
            F: l,
            G: c,
            H: u
        } = this;
        for (let f = 0; f < 64; f++) {
            const h = sf(a, 6) ^ sf(a, 11) ^ sf(a, 25),
                g = u + h + dRe(a, l, c) + pRe[f] + l0[f] | 0,
                _ = (sf(r, 2) ^ sf(r, 13) ^ sf(r, 22)) + hRe(r, i, s) | 0;
            u = c, c = l, l = a, a = o + g | 0, o = s, s = i, i = r, r = g + _ | 0
        }
        r = r + this.A | 0, i = i + this.B | 0, s = s + this.C | 0, o = o + this.D | 0, a = a + this.E | 0, l = l + this.F | 0, c = c + this.G | 0, u = u + this.H | 0, this.set(r, i, s, o, a, l, c, u)
    }
    roundClean() {
        l0.fill(0)
    }
    destroy() {
        this.set(0, 0, 0, 0, 0, 0, 0, 0), this.buffer.fill(0)
    }
}
const hre = CL(() => new gRe),
    qx = BigInt(2 ** 32 - 1),
    Ok = BigInt(32);

function pre(t, e = !1) {
    return e ? {
        h: Number(t & qx),
        l: Number(t >> Ok & qx)
    } : {
        h: Number(t >> Ok & qx) | 0,
        l: Number(t & qx) | 0
    }
}

function gre(t, e = !1) {
    let n = new Uint32Array(t.length),
        r = new Uint32Array(t.length);
    for (let i = 0; i < t.length; i++) {
        const {
            h: s,
            l: o
        } = pre(t[i], e);
        [n[i], r[i]] = [s, o]
    }
    return [n, r]
}
const mRe = (t, e) => BigInt(t >>> 0) << Ok | BigInt(e >>> 0),
    yRe = (t, e, n) => t >>> n,
    wRe = (t, e, n) => t << 32 - n | e >>> n,
    vRe = (t, e, n) => t >>> n | e << 32 - n,
    bRe = (t, e, n) => t << 32 - n | e >>> n,
    _Re = (t, e, n) => t << 64 - n | e >>> n - 32,
    ERe = (t, e, n) => t >>> n - 32 | e << 64 - n,
    xRe = (t, e) => e,
    SRe = (t, e) => t,
    mre = (t, e, n) => t << n | e >>> 32 - n,
    yre = (t, e, n) => e << n | t >>> 32 - n,
    wre = (t, e, n) => e << n - 32 | t >>> 64 - n,
    vre = (t, e, n) => t << n - 32 | e >>> 64 - n;

function CRe(t, e, n, r) {
    const i = (e >>> 0) + (r >>> 0);
    return {
        h: t + n + (i / 2 ** 32 | 0) | 0,
        l: i | 0
    }
}
const ARe = (t, e, n) => (t >>> 0) + (e >>> 0) + (n >>> 0),
    TRe = (t, e, n, r) => e + n + r + (t / 2 ** 32 | 0) | 0,
    IRe = (t, e, n, r) => (t >>> 0) + (e >>> 0) + (n >>> 0) + (r >>> 0),
    RRe = (t, e, n, r, i) => e + n + r + i + (t / 2 ** 32 | 0) | 0,
    ORe = (t, e, n, r, i) => (t >>> 0) + (e >>> 0) + (n >>> 0) + (r >>> 0) + (i >>> 0),
    NRe = (t, e, n, r, i, s) => e + n + r + i + s + (t / 2 ** 32 | 0) | 0,
    kn = {
        fromBig: pre,
        split: gre,
        toBig: mRe,
        shrSH: yRe,
        shrSL: wRe,
        rotrSH: vRe,
        rotrSL: bRe,
        rotrBH: _Re,
        rotrBL: ERe,
        rotr32H: xRe,
        rotr32L: SRe,
        rotlSH: mre,
        rotlSL: yre,
        rotlBH: wre,
        rotlBL: vre,
        add: CRe,
        add3L: ARe,
        add3H: TRe,
        add4L: IRe,
        add4H: RRe,
        add5H: NRe,
        add5L: ORe
    },
    [PRe, kRe] = kn.split(["0x428a2f98d728ae22", "0x7137449123ef65cd", "0xb5c0fbcfec4d3b2f", "0xe9b5dba58189dbbc", "0x3956c25bf348b538", "0x59f111f1b605d019", "0x923f82a4af194f9b", "0xab1c5ed5da6d8118", "0xd807aa98a3030242", "0x12835b0145706fbe", "0x243185be4ee4b28c", "0x550c7dc3d5ffb4e2", "0x72be5d74f27b896f", "0x80deb1fe3b1696b1", "0x9bdc06a725c71235", "0xc19bf174cf692694", "0xe49b69c19ef14ad2", "0xefbe4786384f25e3", "0x0fc19dc68b8cd5b5", "0x240ca1cc77ac9c65", "0x2de92c6f592b0275", "0x4a7484aa6ea6e483", "0x5cb0a9dcbd41fbd4", "0x76f988da831153b5", "0x983e5152ee66dfab", "0xa831c66d2db43210", "0xb00327c898fb213f", "0xbf597fc7beef0ee4", "0xc6e00bf33da88fc2", "0xd5a79147930aa725", "0x06ca6351e003826f", "0x142929670a0e6e70", "0x27b70a8546d22ffc", "0x2e1b21385c26c926", "0x4d2c6dfc5ac42aed", "0x53380d139d95b3df", "0x650a73548baf63de", "0x766a0abb3c77b2a8", "0x81c2c92e47edaee6", "0x92722c851482353b", "0xa2bfe8a14cf10364", "0xa81a664bbc423001", "0xc24b8b70d0f89791", "0xc76c51a30654be30", "0xd192e819d6ef5218", "0xd69906245565a910", "0xf40e35855771202a", "0x106aa07032bbd1b8", "0x19a4c116b8d2d0c8", "0x1e376c085141ab53", "0x2748774cdf8eeb99", "0x34b0bcb5e19b48a8", "0x391c0cb3c5c95a63", "0x4ed8aa4ae3418acb", "0x5b9cca4f7763e373", "0x682e6ff3d6b2b8a3", "0x748f82ee5defb2fc", "0x78a5636f43172f60", "0x84c87814a1f0ab72", "0x8cc702081a6439ec", "0x90befffa23631e28", "0xa4506cebde82bde9", "0xbef9a3f7b2c67915", "0xc67178f2e372532b", "0xca273eceea26619c", "0xd186b8c721c0c207", "0xeada7dd6cde0eb1e", "0xf57d4f7fee6ed178", "0x06f067aa72176fba", "0x0a637dc5a2c898a6", "0x113f9804bef90dae", "0x1b710b35131c471b", "0x28db77f523047d84", "0x32caab7b40c72493", "0x3c9ebe0a15c9bebc", "0x431d67c49c100d4c", "0x4cc5d4becb3e42b6", "0x597f299cfc657e2a", "0x5fcb6fab3ad6faec", "0x6c44198c4a475817"].map(t => BigInt(t))),
    c0 = new Uint32Array(80),
    u0 = new Uint32Array(80);
let MRe = class extends dre {
    constructor() {
        super(128, 64, 16, !1), this.Ah = 1779033703, this.Al = -205731576, this.Bh = -1150833019, this.Bl = -2067093701, this.Ch = 1013904242, this.Cl = -23791573, this.Dh = -1521486534, this.Dl = 1595750129, this.Eh = 1359893119, this.El = -1377402159, this.Fh = -1694144372, this.Fl = 725511199, this.Gh = 528734635, this.Gl = -79577749, this.Hh = 1541459225, this.Hl = 327033209
    }
    get() {
        const {
            Ah: e,
            Al: n,
            Bh: r,
            Bl: i,
            Ch: s,
            Cl: o,
            Dh: a,
            Dl: l,
            Eh: c,
            El: u,
            Fh: f,
            Fl: h,
            Gh: g,
            Gl: y,
            Hh: _,
            Hl: C
        } = this;
        return [e, n, r, i, s, o, a, l, c, u, f, h, g, y, _, C]
    }
    set(e, n, r, i, s, o, a, l, c, u, f, h, g, y, _, C) {
        this.Ah = e | 0, this.Al = n | 0, this.Bh = r | 0, this.Bl = i | 0, this.Ch = s | 0, this.Cl = o | 0, this.Dh = a | 0, this.Dl = l | 0, this.Eh = c | 0, this.El = u | 0, this.Fh = f | 0, this.Fl = h | 0, this.Gh = g | 0, this.Gl = y | 0, this.Hh = _ | 0, this.Hl = C | 0
    }
    process(e, n) {
        for (let S = 0; S < 16; S++, n += 4) c0[S] = e.getUint32(n), u0[S] = e.getUint32(n += 4);
        for (let S = 16; S < 80; S++) {
            const I = c0[S - 15] | 0,
                P = u0[S - 15] | 0,
                M = kn.rotrSH(I, P, 1) ^ kn.rotrSH(I, P, 8) ^ kn.shrSH(I, P, 7),
                A = kn.rotrSL(I, P, 1) ^ kn.rotrSL(I, P, 8) ^ kn.shrSL(I, P, 7),
                E = c0[S - 2] | 0,
                $ = u0[S - 2] | 0,
                H = kn.rotrSH(E, $, 19) ^ kn.rotrBH(E, $, 61) ^ kn.shrSH(E, $, 6),
                K = kn.rotrSL(E, $, 19) ^ kn.rotrBL(E, $, 61) ^ kn.shrSL(E, $, 6),
                te = kn.add4L(A, K, u0[S - 7], u0[S - 16]),
                U = kn.add4H(te, M, H, c0[S - 7], c0[S - 16]);
            c0[S] = U | 0, u0[S] = te | 0
        }
        let {
            Ah: r,
            Al: i,
            Bh: s,
            Bl: o,
            Ch: a,
            Cl: l,
            Dh: c,
            Dl: u,
            Eh: f,
            El: h,
            Fh: g,
            Fl: y,
            Gh: _,
            Gl: C,
            Hh: b,
            Hl: w
        } = this;
        for (let S = 0; S < 80; S++) {
            const I = kn.rotrSH(f, h, 14) ^ kn.rotrSH(f, h, 18) ^ kn.rotrBH(f, h, 41),
                P = kn.rotrSL(f, h, 14) ^ kn.rotrSL(f, h, 18) ^ kn.rotrBL(f, h, 41),
                M = f & g ^ ~f & _,
                A = h & y ^ ~h & C,
                E = kn.add5L(w, P, A, kRe[S], u0[S]),
                $ = kn.add5H(E, b, I, M, PRe[S], c0[S]),
                H = E | 0,
                K = kn.rotrSH(r, i, 28) ^ kn.rotrBH(r, i, 34) ^ kn.rotrBH(r, i, 39),
                te = kn.rotrSL(r, i, 28) ^ kn.rotrBL(r, i, 34) ^ kn.rotrBL(r, i, 39),
                U = r & s ^ r & a ^ s & a,
                m = i & o ^ i & l ^ o & l;
            b = _ | 0, w = C | 0, _ = g | 0, C = y | 0, g = f | 0, y = h | 0, {
                h: f,
                l: h
            } = kn.add(c | 0, u | 0, $ | 0, H | 0), c = a | 0, u = l | 0, a = s | 0, l = o | 0, s = r | 0, o = i | 0;
            const v = kn.add3L(H, te, m);
            r = kn.add3H(v, $, K, U), i = v | 0
        }({
            h: r,
            l: i
        } = kn.add(this.Ah | 0, this.Al | 0, r | 0, i | 0)), {
            h: s,
            l: o
        } = kn.add(this.Bh | 0, this.Bl | 0, s | 0, o | 0), {
            h: a,
            l
        } = kn.add(this.Ch | 0, this.Cl | 0, a | 0, l | 0), {
            h: c,
            l: u
        } = kn.add(this.Dh | 0, this.Dl | 0, c | 0, u | 0), {
            h: f,
            l: h
        } = kn.add(this.Eh | 0, this.El | 0, f | 0, h | 0), {
            h: g,
            l: y
        } = kn.add(this.Fh | 0, this.Fl | 0, g | 0, y | 0), {
            h: _,
            l: C
        } = kn.add(this.Gh | 0, this.Gl | 0, _ | 0, C | 0), {
            h: b,
            l: w
        } = kn.add(this.Hh | 0, this.Hl | 0, b | 0, w | 0), this.set(r, i, s, o, a, l, c, u, f, h, g, y, _, C, b, w)
    }
    roundClean() {
        c0.fill(0), u0.fill(0)
    }
    destroy() {
        this.buffer.fill(0), this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0)
    }
};
const DRe = CL(() => new MRe);

function $Re() {
    if (typeof self < "u") return self;
    if (typeof window < "u") return window;
    if (typeof global < "u") return global;
    throw new Error("unable to locate global object")
}
const gG = $Re();
gG.crypto || gG.msCrypto;

function LRe(t) {
    switch (t) {
        case "sha256":
            return hre.create();
        case "sha512":
            return DRe.create()
    }
    Ee(!1, "invalid hashing algorithm name", "algorithm", t)
}
const [bre, _re, Ere] = [
    [],
    [],
    []
], BRe = BigInt(0), V5 = BigInt(1), FRe = BigInt(2), URe = BigInt(7), jRe = BigInt(256), HRe = BigInt(113);
for (let t = 0, e = V5, n = 1, r = 0; t < 24; t++) {
    [n, r] = [r, (2 * n + 3 * r) % 5], bre.push(2 * (5 * r + n)), _re.push((t + 1) * (t + 2) / 2 % 64);
    let i = BRe;
    for (let s = 0; s < 7; s++) e = (e << V5 ^ (e >> URe) * HRe) % jRe, e & FRe && (i ^= V5 << (V5 << BigInt(s)) - V5);
    Ere.push(i)
}
const [zRe, WRe] = gre(Ere, !0), mG = (t, e, n) => n > 32 ? wre(t, e, n) : mre(t, e, n), yG = (t, e, n) => n > 32 ? vre(t, e, n) : yre(t, e, n);

function VRe(t, e = 24) {
    const n = new Uint32Array(10);
    for (let r = 24 - e; r < 24; r++) {
        for (let o = 0; o < 10; o++) n[o] = t[o] ^ t[o + 10] ^ t[o + 20] ^ t[o + 30] ^ t[o + 40];
        for (let o = 0; o < 10; o += 2) {
            const a = (o + 8) % 10,
                l = (o + 2) % 10,
                c = n[l],
                u = n[l + 1],
                f = mG(c, u, 1) ^ n[a],
                h = yG(c, u, 1) ^ n[a + 1];
            for (let g = 0; g < 50; g += 10) t[o + g] ^= f, t[o + g + 1] ^= h
        }
        let i = t[2],
            s = t[3];
        for (let o = 0; o < 24; o++) {
            const a = _re[o],
                l = mG(i, s, a),
                c = yG(i, s, a),
                u = bre[o];
            i = t[u], s = t[u + 1], t[u] = l, t[u + 1] = c
        }
        for (let o = 0; o < 50; o += 10) {
            for (let a = 0; a < 10; a++) n[a] = t[o + a];
            for (let a = 0; a < 10; a++) t[o + a] ^= ~n[(a + 2) % 10] & n[(a + 4) % 10]
        }
        t[0] ^= zRe[r], t[1] ^= WRe[r]
    }
    n.fill(0)
}
let GRe = class xre extends SL {
    constructor(e, n, r, i = !1, s = 24) {
        if (super(), this.blockLen = e, this.suffix = n, this.outputLen = r, this.enableXOF = i, this.rounds = s, this.pos = 0, this.posOut = 0, this.finished = !1, this.destroyed = !1, kC(r), 0 >= this.blockLen || this.blockLen >= 200) throw new Error("Sha3 supports only keccak-f1600 function");
        this.state = new Uint8Array(200), this.state32 = oRe(this.state)
    }
    keccak() {
        VRe(this.state32, this.rounds), this.posOut = 0, this.pos = 0
    }
    update(e) {
        Vb(this);
        const {
            blockLen: n,
            state: r
        } = this;
        e = QT(e);
        const i = e.length;
        for (let s = 0; s < i;) {
            const o = Math.min(n - this.pos, i - s);
            for (let a = 0; a < o; a++) r[this.pos++] ^= e[s++];
            this.pos === n && this.keccak()
        }
        return this
    }
    finish() {
        if (this.finished) return;
        this.finished = !0;
        const {
            state: e,
            suffix: n,
            pos: r,
            blockLen: i
        } = this;
        e[r] ^= n, n & 128 && r === i - 1 && this.keccak(), e[i - 1] ^= 128, this.keccak()
    }
    writeInto(e) {
        Vb(this, !1), xL(e), this.finish();
        const n = this.state,
            {
                blockLen: r
            } = this;
        for (let i = 0, s = e.length; i < s;) {
            this.posOut >= r && this.keccak();
            const o = Math.min(r - this.posOut, s - i);
            e.set(n.subarray(this.posOut, this.posOut + o), i), this.posOut += o, i += o
        }
        return e
    }
    xofInto(e) {
        if (!this.enableXOF) throw new Error("XOF is not possible for this instance");
        return this.writeInto(e)
    }
    xof(e) {
        return kC(e), this.xofInto(new Uint8Array(e))
    }
    digestInto(e) {
        if (lre(e, this), this.finished) throw new Error("digest() was already called");
        return this.writeInto(e), this.destroy(), e
    }
    digest() {
        return this.digestInto(new Uint8Array(this.outputLen))
    }
    destroy() {
        this.destroyed = !0, this.state.fill(0)
    }
    _cloneInto(e) {
        const {
            blockLen: n,
            suffix: r,
            outputLen: i,
            rounds: s,
            enableXOF: o
        } = this;
        return e || (e = new xre(n, r, i, o, s)), e.state32.set(this.state32), e.pos = this.pos, e.posOut = this.posOut, e.finished = this.finished, e.rounds = s, e.suffix = r, e.outputLen = i, e.enableXOF = o, e.destroyed = this.destroyed, e
    }
};
const qRe = (t, e, n) => CL(() => new GRe(e, t, n)),
    KRe = qRe(1, 136, 256 / 8);
let Sre = !1;
const Cre = function(t) {
    return KRe(t)
};
let Are = Cre;

function fs(t) {
    const e = or(t, "data");
    return Ot(Are(e))
}
fs._ = Cre;
fs.lock = function() {
    Sre = !0
};
fs.register = function(t) {
    if (Sre) throw new TypeError("keccak256 is locked");
    Are = t
};
Object.freeze(fs);
const Tre = function(t) {
    return LRe("sha256").update(t).digest()
};
let Ire = Tre,
    Rre = !1;

function k2(t) {
    const e = or(t, "data");
    return Ot(Ire(e))
}
k2._ = Tre;
k2.lock = function() {
    Rre = !0
};
k2.register = function(t) {
    if (Rre) throw new Error("sha256 is locked");
    Ire = t
};
Object.freeze(k2);
Object.freeze(k2); /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const Ore = BigInt(0),
    JT = BigInt(1),
    YRe = BigInt(2),
    XT = t => t instanceof Uint8Array,
    ZRe = Array.from({
        length: 256
    }, (t, e) => e.toString(16).padStart(2, "0"));

function Gb(t) {
    if (!XT(t)) throw new Error("Uint8Array expected");
    let e = "";
    for (let n = 0; n < t.length; n++) e += ZRe[t[n]];
    return e
}

function Nre(t) {
    const e = t.toString(16);
    return e.length & 1 ? `0${e}` : e
}

function AL(t) {
    if (typeof t != "string") throw new Error("hex string expected, got " + typeof t);
    return BigInt(t === "" ? "0" : `0x${t}`)
}

function qb(t) {
    if (typeof t != "string") throw new Error("hex string expected, got " + typeof t);
    const e = t.length;
    if (e % 2) throw new Error("padded hex string expected, got unpadded hex of length " + e);
    const n = new Uint8Array(e / 2);
    for (let r = 0; r < n.length; r++) {
        const i = r * 2,
            s = t.slice(i, i + 2),
            o = Number.parseInt(s, 16);
        if (Number.isNaN(o) || o < 0) throw new Error("Invalid byte sequence");
        n[r] = o
    }
    return n
}

function tm(t) {
    return AL(Gb(t))
}

function TL(t) {
    if (!XT(t)) throw new Error("Uint8Array expected");
    return AL(Gb(Uint8Array.from(t).reverse()))
}

function Kb(t, e) {
    return qb(t.toString(16).padStart(e * 2, "0"))
}

function IL(t, e) {
    return Kb(t, e).reverse()
}

function QRe(t) {
    return qb(Nre(t))
}

function ru(t, e, n) {
    let r;
    if (typeof e == "string") try {
            r = qb(e)
        } catch (s) {
            throw new Error(`${t} must be valid hex string, got "${e}". Cause: ${s}`)
        } else if (XT(e)) r = Uint8Array.from(e);
        else throw new Error(`${t} must be hex string or Uint8Array`);
    const i = r.length;
    if (typeof n == "number" && i !== n) throw new Error(`${t} expected ${n} bytes, got ${i}`);
    return r
}

function Y_(...t) {
    const e = new Uint8Array(t.reduce((r, i) => r + i.length, 0));
    let n = 0;
    return t.forEach(r => {
        if (!XT(r)) throw new Error("Uint8Array expected");
        e.set(r, n), n += r.length
    }), e
}

function JRe(t, e) {
    if (t.length !== e.length) return !1;
    for (let n = 0; n < t.length; n++)
        if (t[n] !== e[n]) return !1;
    return !0
}

function XRe(t) {
    if (typeof t != "string") throw new Error(`utf8ToBytes expected string, got ${typeof t}`);
    return new Uint8Array(new TextEncoder().encode(t))
}

function eOe(t) {
    let e;
    for (e = 0; t > Ore; t >>= JT, e += 1);
    return e
}

function tOe(t, e) {
    return t >> BigInt(e) & JT
}
const nOe = (t, e, n) => t | (n ? JT : Ore) << BigInt(e),
    RL = t => (YRe << BigInt(t - 1)) - JT,
    wO = t => new Uint8Array(t),
    wG = t => Uint8Array.from(t);

function Pre(t, e, n) {
    if (typeof t != "number" || t < 2) throw new Error("hashLen must be a number");
    if (typeof e != "number" || e < 2) throw new Error("qByteLen must be a number");
    if (typeof n != "function") throw new Error("hmacFn must be a function");
    let r = wO(t),
        i = wO(t),
        s = 0;
    const o = () => {
            r.fill(1), i.fill(0), s = 0
        },
        a = (...f) => n(i, r, ...f),
        l = (f = wO()) => {
            i = a(wG([0]), f), r = a(), f.length !== 0 && (i = a(wG([1]), f), r = a())
        },
        c = () => {
            if (s++ >= 1e3) throw new Error("drbg: tried 1000 values");
            let f = 0;
            const h = [];
            for (; f < e;) {
                r = a();
                const g = r.slice();
                h.push(g), f += r.length
            }
            return Y_(...h)
        };
    return (f, h) => {
        o(), l(f);
        let g;
        for (; !(g = h(c()));) l();
        return o(), g
    }
}
const rOe = {
    bigint: t => typeof t == "bigint",
    function: t => typeof t == "function",
    boolean: t => typeof t == "boolean",
    string: t => typeof t == "string",
    stringOrUint8Array: t => typeof t == "string" || t instanceof Uint8Array,
    isSafeInteger: t => Number.isSafeInteger(t),
    array: t => Array.isArray(t),
    field: (t, e) => e.Fp.isValid(t),
    hash: t => typeof t == "function" && Number.isSafeInteger(t.outputLen)
};

function RE(t, e, n = {}) {
    const r = (i, s, o) => {
        const a = rOe[s];
        if (typeof a != "function") throw new Error(`Invalid validator "${s}", expected function`);
        const l = t[i];
        if (!(o && l === void 0) && !a(l, t)) throw new Error(`Invalid param ${String(i)}=${l} (${typeof l}), expected ${s}`)
    };
    for (const [i, s] of Object.entries(e)) r(i, s, !1);
    for (const [i, s] of Object.entries(n)) r(i, s, !0);
    return t
}
const iOe = Object.freeze(Object.defineProperty({
    __proto__: null,
    bitGet: tOe,
    bitLen: eOe,
    bitMask: RL,
    bitSet: nOe,
    bytesToHex: Gb,
    bytesToNumberBE: tm,
    bytesToNumberLE: TL,
    concatBytes: Y_,
    createHmacDrbg: Pre,
    ensureBytes: ru,
    equalBytes: JRe,
    hexToBytes: qb,
    hexToNumber: AL,
    numberToBytesBE: Kb,
    numberToBytesLE: IL,
    numberToHexUnpadded: Nre,
    numberToVarBytesBE: QRe,
    utf8ToBytes: XRe,
    validateObject: RE
}, Symbol.toStringTag, {
    value: "Module"
})); /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const Ys = BigInt(0),
    ls = BigInt(1),
    Qg = BigInt(2),
    sOe = BigInt(3),
    Nk = BigInt(4),
    vG = BigInt(5),
    bG = BigInt(8);
BigInt(9);
BigInt(16);

function $a(t, e) {
    const n = t % e;
    return n >= Ys ? n : e + n
}

function oOe(t, e, n) {
    if (n <= Ys || e < Ys) throw new Error("Expected power/modulo > 0");
    if (n === ls) return Ys;
    let r = ls;
    for (; e > Ys;) e & ls && (r = r * t % n), t = t * t % n, e >>= ls;
    return r
}

function Zl(t, e, n) {
    let r = t;
    for (; e-- > Ys;) r *= r, r %= n;
    return r
}

function Pk(t, e) {
    if (t === Ys || e <= Ys) throw new Error(`invert: expected positive integers, got n=${t} mod=${e}`);
    let n = $a(t, e),
        r = e,
        i = Ys,
        s = ls;
    for (; n !== Ys;) {
        const a = r / n,
            l = r % n,
            c = i - s * a;
        r = n, n = l, i = s, s = c
    }
    if (r !== ls) throw new Error("invert: does not exist");
    return $a(i, e)
}

function aOe(t) {
    const e = (t - ls) / Qg;
    let n, r, i;
    for (n = t - ls, r = 0; n % Qg === Ys; n /= Qg, r++);
    for (i = Qg; i < t && oOe(i, e, t) !== t - ls; i++);
    if (r === 1) {
        const o = (t + ls) / Nk;
        return function(l, c) {
            const u = l.pow(c, o);
            if (!l.eql(l.sqr(u), c)) throw new Error("Cannot find square root");
            return u
        }
    }
    const s = (n + ls) / Qg;
    return function(a, l) {
        if (a.pow(l, e) === a.neg(a.ONE)) throw new Error("Cannot find square root");
        let c = r,
            u = a.pow(a.mul(a.ONE, i), n),
            f = a.pow(l, s),
            h = a.pow(l, n);
        for (; !a.eql(h, a.ONE);) {
            if (a.eql(h, a.ZERO)) return a.ZERO;
            let g = 1;
            for (let _ = a.sqr(h); g < c && !a.eql(_, a.ONE); g++) _ = a.sqr(_);
            const y = a.pow(u, ls << BigInt(c - g - 1));
            u = a.sqr(y), f = a.mul(f, y), h = a.mul(h, u), c = g
        }
        return f
    }
}

function lOe(t) {
    if (t % Nk === sOe) {
        const e = (t + ls) / Nk;
        return function(r, i) {
            const s = r.pow(i, e);
            if (!r.eql(r.sqr(s), i)) throw new Error("Cannot find square root");
            return s
        }
    }
    if (t % bG === vG) {
        const e = (t - vG) / bG;
        return function(r, i) {
            const s = r.mul(i, Qg),
                o = r.pow(s, e),
                a = r.mul(i, o),
                l = r.mul(r.mul(a, Qg), o),
                c = r.mul(a, r.sub(l, r.ONE));
            if (!r.eql(r.sqr(c), i)) throw new Error("Cannot find square root");
            return c
        }
    }
    return aOe(t)
}
const cOe = ["create", "isValid", "is0", "neg", "inv", "sqrt", "sqr", "eql", "add", "sub", "mul", "pow", "div", "addN", "subN", "mulN", "sqrN"];

function uOe(t) {
    const e = {
            ORDER: "bigint",
            MASK: "bigint",
            BYTES: "isSafeInteger",
            BITS: "isSafeInteger"
        },
        n = cOe.reduce((r, i) => (r[i] = "function", r), e);
    return RE(t, n)
}

function fOe(t, e, n) {
    if (n < Ys) throw new Error("Expected power > 0");
    if (n === Ys) return t.ONE;
    if (n === ls) return e;
    let r = t.ONE,
        i = e;
    for (; n > Ys;) n & ls && (r = t.mul(r, i)), i = t.sqr(i), n >>= ls;
    return r
}

function dOe(t, e) {
    const n = new Array(e.length),
        r = e.reduce((s, o, a) => t.is0(o) ? s : (n[a] = s, t.mul(s, o)), t.ONE),
        i = t.inv(r);
    return e.reduceRight((s, o, a) => t.is0(o) ? s : (n[a] = t.mul(s, n[a]), t.mul(s, o)), i), n
}

function kre(t, e) {
    const n = e !== void 0 ? e : t.toString(2).length,
        r = Math.ceil(n / 8);
    return {
        nBitLength: n,
        nByteLength: r
    }
}

function hOe(t, e, n = !1, r = {}) {
    if (t <= Ys) throw new Error(`Expected Field ORDER > 0, got ${t}`);
    const {
        nBitLength: i,
        nByteLength: s
    } = kre(t, e);
    if (s > 2048) throw new Error("Field lengths over 2048 bytes are not supported");
    const o = lOe(t),
        a = Object.freeze({
            ORDER: t,
            BITS: i,
            BYTES: s,
            MASK: RL(i),
            ZERO: Ys,
            ONE: ls,
            create: l => $a(l, t),
            isValid: l => {
                if (typeof l != "bigint") throw new Error(`Invalid field element: expected bigint, got ${typeof l}`);
                return Ys <= l && l < t
            },
            is0: l => l === Ys,
            isOdd: l => (l & ls) === ls,
            neg: l => $a(-l, t),
            eql: (l, c) => l === c,
            sqr: l => $a(l * l, t),
            add: (l, c) => $a(l + c, t),
            sub: (l, c) => $a(l - c, t),
            mul: (l, c) => $a(l * c, t),
            pow: (l, c) => fOe(a, l, c),
            div: (l, c) => $a(l * Pk(c, t), t),
            sqrN: l => l * l,
            addN: (l, c) => l + c,
            subN: (l, c) => l - c,
            mulN: (l, c) => l * c,
            inv: l => Pk(l, t),
            sqrt: r.sqrt || (l => o(a, l)),
            invertBatch: l => dOe(a, l),
            cmov: (l, c, u) => u ? c : l,
            toBytes: l => n ? IL(l, s) : Kb(l, s),
            fromBytes: l => {
                if (l.length !== s) throw new Error(`Fp.fromBytes: expected ${s}, got ${l.length}`);
                return n ? TL(l) : tm(l)
            }
        });
    return Object.freeze(a)
}

function Mre(t) {
    if (typeof t != "bigint") throw new Error("field order must be bigint");
    const e = t.toString(2).length;
    return Math.ceil(e / 8)
}

function Dre(t) {
    const e = Mre(t);
    return e + Math.ceil(e / 2)
}

function pOe(t, e, n = !1) {
    const r = t.length,
        i = Mre(e),
        s = Dre(e);
    if (r < 16 || r < s || r > 1024) throw new Error(`expected ${s}-1024 bytes of input, got ${r}`);
    const o = n ? tm(t) : TL(t),
        a = $a(o, e - ls) + ls;
    return n ? IL(a, i) : Kb(a, i)
} /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const gOe = BigInt(0),
    vO = BigInt(1);

function mOe(t, e) {
    const n = (i, s) => {
            const o = s.negate();
            return i ? o : s
        },
        r = i => {
            const s = Math.ceil(e / i) + 1,
                o = 2 ** (i - 1);
            return {
                windows: s,
                windowSize: o
            }
        };
    return {
        constTimeNegate: n,
        unsafeLadder(i, s) {
            let o = t.ZERO,
                a = i;
            for (; s > gOe;) s & vO && (o = o.add(a)), a = a.double(), s >>= vO;
            return o
        },
        precomputeWindow(i, s) {
            const {
                windows: o,
                windowSize: a
            } = r(s), l = [];
            let c = i,
                u = c;
            for (let f = 0; f < o; f++) {
                u = c, l.push(u);
                for (let h = 1; h < a; h++) u = u.add(c), l.push(u);
                c = u.double()
            }
            return l
        },
        wNAF(i, s, o) {
            const {
                windows: a,
                windowSize: l
            } = r(i);
            let c = t.ZERO,
                u = t.BASE;
            const f = BigInt(2 ** i - 1),
                h = 2 ** i,
                g = BigInt(i);
            for (let y = 0; y < a; y++) {
                const _ = y * l;
                let C = Number(o & f);
                o >>= g, C > l && (C -= h, o += vO);
                const b = _,
                    w = _ + Math.abs(C) - 1,
                    S = y % 2 !== 0,
                    I = C < 0;
                C === 0 ? u = u.add(n(S, s[b])) : c = c.add(n(I, s[w]))
            }
            return {
                p: c,
                f: u
            }
        },
        wNAFCached(i, s, o, a) {
            const l = i._WINDOW_SIZE || 1;
            let c = s.get(i);
            return c || (c = this.precomputeWindow(i, l), l !== 1 && s.set(i, a(c))), this.wNAF(l, c, o)
        }
    }
}

function $re(t) {
    return uOe(t.Fp), RE(t, {
        n: "bigint",
        h: "bigint",
        Gx: "field",
        Gy: "field"
    }, {
        nBitLength: "isSafeInteger",
        nByteLength: "isSafeInteger"
    }), Object.freeze({ ...kre(t.n, t.nBitLength),
        ...t,
        p: t.Fp.ORDER
    })
} /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
function yOe(t) {
    const e = $re(t);
    RE(e, {
        a: "field",
        b: "field"
    }, {
        allowedPrivateKeyLengths: "array",
        wrapPrivateKey: "boolean",
        isTorsionFree: "function",
        clearCofactor: "function",
        allowInfinityPoint: "boolean",
        fromBytes: "function",
        toBytes: "function"
    });
    const {
        endo: n,
        Fp: r,
        a: i
    } = e;
    if (n) {
        if (!r.eql(i, r.ZERO)) throw new Error("Endomorphism can only be defined for Koblitz curves that have a=0");
        if (typeof n != "object" || typeof n.beta != "bigint" || typeof n.splitScalar != "function") throw new Error("Expected endomorphism with beta: bigint and splitScalar: function")
    }
    return Object.freeze({ ...e
    })
}
const {
    bytesToNumberBE: wOe,
    hexToBytes: vOe
} = iOe, f1 = {
    Err: class extends Error {
        constructor(e = "") {
            super(e)
        }
    },
    _parseInt(t) {
        const {
            Err: e
        } = f1;
        if (t.length < 2 || t[0] !== 2) throw new e("Invalid signature integer tag");
        const n = t[1],
            r = t.subarray(2, n + 2);
        if (!n || r.length !== n) throw new e("Invalid signature integer: wrong length");
        if (r[0] & 128) throw new e("Invalid signature integer: negative");
        if (r[0] === 0 && !(r[1] & 128)) throw new e("Invalid signature integer: unnecessary leading zero");
        return {
            d: wOe(r),
            l: t.subarray(n + 2)
        }
    },
    toSig(t) {
        const {
            Err: e
        } = f1, n = typeof t == "string" ? vOe(t) : t;
        if (!(n instanceof Uint8Array)) throw new Error("ui8a expected");
        let r = n.length;
        if (r < 2 || n[0] != 48) throw new e("Invalid signature tag");
        if (n[1] !== r - 2) throw new e("Invalid signature: incorrect length");
        const {
            d: i,
            l: s
        } = f1._parseInt(n.subarray(2)), {
            d: o,
            l: a
        } = f1._parseInt(s);
        if (a.length) throw new e("Invalid signature: left bytes after parsing");
        return {
            r: i,
            s: o
        }
    },
    hexFromSig(t) {
        const e = c => Number.parseInt(c[0], 16) & 8 ? "00" + c : c,
            n = c => {
                const u = c.toString(16);
                return u.length & 1 ? `0${u}` : u
            },
            r = e(n(t.s)),
            i = e(n(t.r)),
            s = r.length / 2,
            o = i.length / 2,
            a = n(s),
            l = n(o);
        return `30${n(o+s+4)}02${l}${i}02${a}${r}`
    }
}, oh = BigInt(0), hc = BigInt(1);
BigInt(2);
const _G = BigInt(3);
BigInt(4);

function bOe(t) {
    const e = yOe(t),
        {
            Fp: n
        } = e,
        r = e.toBytes || ((y, _, C) => {
            const b = _.toAffine();
            return Y_(Uint8Array.from([4]), n.toBytes(b.x), n.toBytes(b.y))
        }),
        i = e.fromBytes || (y => {
            const _ = y.subarray(1),
                C = n.fromBytes(_.subarray(0, n.BYTES)),
                b = n.fromBytes(_.subarray(n.BYTES, 2 * n.BYTES));
            return {
                x: C,
                y: b
            }
        });

    function s(y) {
        const {
            a: _,
            b: C
        } = e, b = n.sqr(y), w = n.mul(b, y);
        return n.add(n.add(w, n.mul(y, _)), C)
    }
    if (!n.eql(n.sqr(e.Gy), s(e.Gx))) throw new Error("bad generator point: equation left != right");

    function o(y) {
        return typeof y == "bigint" && oh < y && y < e.n
    }

    function a(y) {
        if (!o(y)) throw new Error("Expected valid bigint: 0 < bigint < curve.n")
    }

    function l(y) {
        const {
            allowedPrivateKeyLengths: _,
            nByteLength: C,
            wrapPrivateKey: b,
            n: w
        } = e;
        if (_ && typeof y != "bigint") {
            if (y instanceof Uint8Array && (y = Gb(y)), typeof y != "string" || !_.includes(y.length)) throw new Error("Invalid key");
            y = y.padStart(C * 2, "0")
        }
        let S;
        try {
            S = typeof y == "bigint" ? y : tm(ru("private key", y, C))
        } catch {
            throw new Error(`private key must be ${C} bytes, hex or bigint, not ${typeof y}`)
        }
        return b && (S = $a(S, w)), a(S), S
    }
    const c = new Map;

    function u(y) {
        if (!(y instanceof f)) throw new Error("ProjectivePoint expected")
    }
    class f {
        constructor(_, C, b) {
            if (this.px = _, this.py = C, this.pz = b, _ == null || !n.isValid(_)) throw new Error("x required");
            if (C == null || !n.isValid(C)) throw new Error("y required");
            if (b == null || !n.isValid(b)) throw new Error("z required")
        }
        static fromAffine(_) {
            const {
                x: C,
                y: b
            } = _ || {};
            if (!_ || !n.isValid(C) || !n.isValid(b)) throw new Error("invalid affine point");
            if (_ instanceof f) throw new Error("projective point not allowed");
            const w = S => n.eql(S, n.ZERO);
            return w(C) && w(b) ? f.ZERO : new f(C, b, n.ONE)
        }
        get x() {
            return this.toAffine().x
        }
        get y() {
            return this.toAffine().y
        }
        static normalizeZ(_) {
            const C = n.invertBatch(_.map(b => b.pz));
            return _.map((b, w) => b.toAffine(C[w])).map(f.fromAffine)
        }
        static fromHex(_) {
            const C = f.fromAffine(i(ru("pointHex", _)));
            return C.assertValidity(), C
        }
        static fromPrivateKey(_) {
            return f.BASE.multiply(l(_))
        }
        _setWindowSize(_) {
            this._WINDOW_SIZE = _, c.delete(this)
        }
        assertValidity() {
            if (this.is0()) {
                if (e.allowInfinityPoint && !n.is0(this.py)) return;
                throw new Error("bad point: ZERO")
            }
            const {
                x: _,
                y: C
            } = this.toAffine();
            if (!n.isValid(_) || !n.isValid(C)) throw new Error("bad point: x or y not FE");
            const b = n.sqr(C),
                w = s(_);
            if (!n.eql(b, w)) throw new Error("bad point: equation left != right");
            if (!this.isTorsionFree()) throw new Error("bad point: not in prime-order subgroup")
        }
        hasEvenY() {
            const {
                y: _
            } = this.toAffine();
            if (n.isOdd) return !n.isOdd(_);
            throw new Error("Field doesn't support isOdd")
        }
        equals(_) {
            u(_);
            const {
                px: C,
                py: b,
                pz: w
            } = this, {
                px: S,
                py: I,
                pz: P
            } = _, M = n.eql(n.mul(C, P), n.mul(S, w)), A = n.eql(n.mul(b, P), n.mul(I, w));
            return M && A
        }
        negate() {
            return new f(this.px, n.neg(this.py), this.pz)
        }
        double() {
            const {
                a: _,
                b: C
            } = e, b = n.mul(C, _G), {
                px: w,
                py: S,
                pz: I
            } = this;
            let P = n.ZERO,
                M = n.ZERO,
                A = n.ZERO,
                E = n.mul(w, w),
                $ = n.mul(S, S),
                H = n.mul(I, I),
                K = n.mul(w, S);
            return K = n.add(K, K), A = n.mul(w, I), A = n.add(A, A), P = n.mul(_, A), M = n.mul(b, H), M = n.add(P, M), P = n.sub($, M), M = n.add($, M), M = n.mul(P, M), P = n.mul(K, P), A = n.mul(b, A), H = n.mul(_, H), K = n.sub(E, H), K = n.mul(_, K), K = n.add(K, A), A = n.add(E, E), E = n.add(A, E), E = n.add(E, H), E = n.mul(E, K), M = n.add(M, E), H = n.mul(S, I), H = n.add(H, H), E = n.mul(H, K), P = n.sub(P, E), A = n.mul(H, $), A = n.add(A, A), A = n.add(A, A), new f(P, M, A)
        }
        add(_) {
            u(_);
            const {
                px: C,
                py: b,
                pz: w
            } = this, {
                px: S,
                py: I,
                pz: P
            } = _;
            let M = n.ZERO,
                A = n.ZERO,
                E = n.ZERO;
            const $ = e.a,
                H = n.mul(e.b, _G);
            let K = n.mul(C, S),
                te = n.mul(b, I),
                U = n.mul(w, P),
                m = n.add(C, b),
                v = n.add(S, I);
            m = n.mul(m, v), v = n.add(K, te), m = n.sub(m, v), v = n.add(C, w);
            let T = n.add(S, P);
            return v = n.mul(v, T), T = n.add(K, U), v = n.sub(v, T), T = n.add(b, w), M = n.add(I, P), T = n.mul(T, M), M = n.add(te, U), T = n.sub(T, M), E = n.mul($, v), M = n.mul(H, U), E = n.add(M, E), M = n.sub(te, E), E = n.add(te, E), A = n.mul(M, E), te = n.add(K, K), te = n.add(te, K), U = n.mul($, U), v = n.mul(H, v), te = n.add(te, U), U = n.sub(K, U), U = n.mul($, U), v = n.add(v, U), K = n.mul(te, v), A = n.add(A, K), K = n.mul(T, v), M = n.mul(m, M), M = n.sub(M, K), K = n.mul(m, te), E = n.mul(T, E), E = n.add(E, K), new f(M, A, E)
        }
        subtract(_) {
            return this.add(_.negate())
        }
        is0() {
            return this.equals(f.ZERO)
        }
        wNAF(_) {
            return g.wNAFCached(this, c, _, C => {
                const b = n.invertBatch(C.map(w => w.pz));
                return C.map((w, S) => w.toAffine(b[S])).map(f.fromAffine)
            })
        }
        multiplyUnsafe(_) {
            const C = f.ZERO;
            if (_ === oh) return C;
            if (a(_), _ === hc) return this;
            const {
                endo: b
            } = e;
            if (!b) return g.unsafeLadder(this, _);
            let {
                k1neg: w,
                k1: S,
                k2neg: I,
                k2: P
            } = b.splitScalar(_), M = C, A = C, E = this;
            for (; S > oh || P > oh;) S & hc && (M = M.add(E)), P & hc && (A = A.add(E)), E = E.double(), S >>= hc, P >>= hc;
            return w && (M = M.negate()), I && (A = A.negate()), A = new f(n.mul(A.px, b.beta), A.py, A.pz), M.add(A)
        }
        multiply(_) {
            a(_);
            let C = _,
                b, w;
            const {
                endo: S
            } = e;
            if (S) {
                const {
                    k1neg: I,
                    k1: P,
                    k2neg: M,
                    k2: A
                } = S.splitScalar(C);
                let {
                    p: E,
                    f: $
                } = this.wNAF(P), {
                    p: H,
                    f: K
                } = this.wNAF(A);
                E = g.constTimeNegate(I, E), H = g.constTimeNegate(M, H), H = new f(n.mul(H.px, S.beta), H.py, H.pz), b = E.add(H), w = $.add(K)
            } else {
                const {
                    p: I,
                    f: P
                } = this.wNAF(C);
                b = I, w = P
            }
            return f.normalizeZ([b, w])[0]
        }
        multiplyAndAddUnsafe(_, C, b) {
            const w = f.BASE,
                S = (P, M) => M === oh || M === hc || !P.equals(w) ? P.multiplyUnsafe(M) : P.multiply(M),
                I = S(this, C).add(S(_, b));
            return I.is0() ? void 0 : I
        }
        toAffine(_) {
            const {
                px: C,
                py: b,
                pz: w
            } = this, S = this.is0();
            _ == null && (_ = S ? n.ONE : n.inv(w));
            const I = n.mul(C, _),
                P = n.mul(b, _),
                M = n.mul(w, _);
            if (S) return {
                x: n.ZERO,
                y: n.ZERO
            };
            if (!n.eql(M, n.ONE)) throw new Error("invZ was invalid");
            return {
                x: I,
                y: P
            }
        }
        isTorsionFree() {
            const {
                h: _,
                isTorsionFree: C
            } = e;
            if (_ === hc) return !0;
            if (C) return C(f, this);
            throw new Error("isTorsionFree() has not been declared for the elliptic curve")
        }
        clearCofactor() {
            const {
                h: _,
                clearCofactor: C
            } = e;
            return _ === hc ? this : C ? C(f, this) : this.multiplyUnsafe(e.h)
        }
        toRawBytes(_ = !0) {
            return this.assertValidity(), r(f, this, _)
        }
        toHex(_ = !0) {
            return Gb(this.toRawBytes(_))
        }
    }
    f.BASE = new f(e.Gx, e.Gy, n.ONE), f.ZERO = new f(n.ZERO, n.ONE, n.ZERO);
    const h = e.nBitLength,
        g = mOe(f, e.endo ? Math.ceil(h / 2) : h);
    return {
        CURVE: e,
        ProjectivePoint: f,
        normPrivateKeyToScalar: l,
        weierstrassEquation: s,
        isWithinCurveOrder: o
    }
}

function _Oe(t) {
    const e = $re(t);
    return RE(e, {
        hash: "hash",
        hmac: "function",
        randomBytes: "function"
    }, {
        bits2int: "function",
        bits2int_modN: "function",
        lowS: "boolean"
    }), Object.freeze({
        lowS: !0,
        ...e
    })
}

function EOe(t) {
    const e = _Oe(t),
        {
            Fp: n,
            n: r
        } = e,
        i = n.BYTES + 1,
        s = 2 * n.BYTES + 1;

    function o(v) {
        return oh < v && v < n.ORDER
    }

    function a(v) {
        return $a(v, r)
    }

    function l(v) {
        return Pk(v, r)
    }
    const {
        ProjectivePoint: c,
        normPrivateKeyToScalar: u,
        weierstrassEquation: f,
        isWithinCurveOrder: h
    } = bOe({ ...e,
        toBytes(v, T, N) {
            const O = T.toAffine(),
                L = n.toBytes(O.x),
                G = Y_;
            return N ? G(Uint8Array.from([T.hasEvenY() ? 2 : 3]), L) : G(Uint8Array.from([4]), L, n.toBytes(O.y))
        },
        fromBytes(v) {
            const T = v.length,
                N = v[0],
                O = v.subarray(1);
            if (T === i && (N === 2 || N === 3)) {
                const L = tm(O);
                if (!o(L)) throw new Error("Point is not on curve");
                const G = f(L);
                let j = n.sqrt(G);
                const R = (j & hc) === hc;
                return (N & 1) === 1 !== R && (j = n.neg(j)), {
                    x: L,
                    y: j
                }
            } else if (T === s && N === 4) {
                const L = n.fromBytes(O.subarray(0, n.BYTES)),
                    G = n.fromBytes(O.subarray(n.BYTES, 2 * n.BYTES));
                return {
                    x: L,
                    y: G
                }
            } else throw new Error(`Point of length ${T} was invalid. Expected ${i} compressed bytes or ${s} uncompressed bytes`)
        }
    }), g = v => Gb(Kb(v, e.nByteLength));

    function y(v) {
        const T = r >> hc;
        return v > T
    }

    function _(v) {
        return y(v) ? a(-v) : v
    }
    const C = (v, T, N) => tm(v.slice(T, N));
    class b {
        constructor(T, N, O) {
            this.r = T, this.s = N, this.recovery = O, this.assertValidity()
        }
        static fromCompact(T) {
            const N = e.nByteLength;
            return T = ru("compactSignature", T, N * 2), new b(C(T, 0, N), C(T, N, 2 * N))
        }
        static fromDER(T) {
            const {
                r: N,
                s: O
            } = f1.toSig(ru("DER", T));
            return new b(N, O)
        }
        assertValidity() {
            if (!h(this.r)) throw new Error("r must be 0 < r < CURVE.n");
            if (!h(this.s)) throw new Error("s must be 0 < s < CURVE.n")
        }
        addRecoveryBit(T) {
            return new b(this.r, this.s, T)
        }
        recoverPublicKey(T) {
            const {
                r: N,
                s: O,
                recovery: L
            } = this, G = A(ru("msgHash", T));
            if (L == null || ![0, 1, 2, 3].includes(L)) throw new Error("recovery id invalid");
            const j = L === 2 || L === 3 ? N + e.n : N;
            if (j >= n.ORDER) throw new Error("recovery id 2 or 3 invalid");
            const R = L & 1 ? "03" : "02",
                Y = c.fromHex(R + g(j)),
                ve = l(j),
                V = a(-G * ve),
                X = a(O * ve),
                q = c.BASE.multiplyAndAddUnsafe(Y, V, X);
            if (!q) throw new Error("point at infinify");
            return q.assertValidity(), q
        }
        hasHighS() {
            return y(this.s)
        }
        normalizeS() {
            return this.hasHighS() ? new b(this.r, a(-this.s), this.recovery) : this
        }
        toDERRawBytes() {
            return qb(this.toDERHex())
        }
        toDERHex() {
            return f1.hexFromSig({
                r: this.r,
                s: this.s
            })
        }
        toCompactRawBytes() {
            return qb(this.toCompactHex())
        }
        toCompactHex() {
            return g(this.r) + g(this.s)
        }
    }
    const w = {
        isValidPrivateKey(v) {
            try {
                return u(v), !0
            } catch {
                return !1
            }
        },
        normPrivateKeyToScalar: u,
        randomPrivateKey: () => {
            const v = Dre(e.n);
            return pOe(e.randomBytes(v), e.n)
        },
        precompute(v = 8, T = c.BASE) {
            return T._setWindowSize(v), T.multiply(BigInt(3)), T
        }
    };

    function S(v, T = !0) {
        return c.fromPrivateKey(v).toRawBytes(T)
    }

    function I(v) {
        const T = v instanceof Uint8Array,
            N = typeof v == "string",
            O = (T || N) && v.length;
        return T ? O === i || O === s : N ? O === 2 * i || O === 2 * s : v instanceof c
    }

    function P(v, T, N = !0) {
        if (I(v)) throw new Error("first arg must be private key");
        if (!I(T)) throw new Error("second arg must be public key");
        return c.fromHex(T).multiply(u(v)).toRawBytes(N)
    }
    const M = e.bits2int || function(v) {
            const T = tm(v),
                N = v.length * 8 - e.nBitLength;
            return N > 0 ? T >> BigInt(N) : T
        },
        A = e.bits2int_modN || function(v) {
            return a(M(v))
        },
        E = RL(e.nBitLength);

    function $(v) {
        if (typeof v != "bigint") throw new Error("bigint expected");
        if (!(oh <= v && v < E)) throw new Error(`bigint expected < 2^${e.nBitLength}`);
        return Kb(v, e.nByteLength)
    }

    function H(v, T, N = K) {
        if (["recovered", "canonical"].some(ie => ie in N)) throw new Error("sign() legacy options not supported");
        const {
            hash: O,
            randomBytes: L
        } = e;
        let {
            lowS: G,
            prehash: j,
            extraEntropy: R
        } = N;
        G == null && (G = !0), v = ru("msgHash", v), j && (v = ru("prehashed msgHash", O(v)));
        const Y = A(v),
            ve = u(T),
            V = [$(ve), $(Y)];
        if (R != null) {
            const ie = R === !0 ? L(n.BYTES) : R;
            V.push(ru("extraEntropy", ie))
        }
        const X = Y_(...V),
            q = Y;

        function ne(ie) {
            const k = M(ie);
            if (!h(k)) return;
            const z = l(k),
                Z = c.BASE.multiply(k).toAffine(),
                ge = a(Z.x);
            if (ge === oh) return;
            const me = a(z * a(q + ge * ve));
            if (me === oh) return;
            let Re = (Z.x === ge ? 0 : 2) | Number(Z.y & hc),
                He = me;
            return G && y(me) && (He = _(me), Re ^= 1), new b(ge, He, Re)
        }
        return {
            seed: X,
            k2sig: ne
        }
    }
    const K = {
            lowS: e.lowS,
            prehash: !1
        },
        te = {
            lowS: e.lowS,
            prehash: !1
        };

    function U(v, T, N = K) {
        const {
            seed: O,
            k2sig: L
        } = H(v, T, N), G = e;
        return Pre(G.hash.outputLen, G.nByteLength, G.hmac)(O, L)
    }
    c.BASE._setWindowSize(8);

    function m(v, T, N, O = te) {
        var Z;
        const L = v;
        if (T = ru("msgHash", T), N = ru("publicKey", N), "strict" in O) throw new Error("options.strict was renamed to lowS");
        const {
            lowS: G,
            prehash: j
        } = O;
        let R, Y;
        try {
            if (typeof L == "string" || L instanceof Uint8Array) try {
                R = b.fromDER(L)
            } catch (ge) {
                if (!(ge instanceof f1.Err)) throw ge;
                R = b.fromCompact(L)
            } else if (typeof L == "object" && typeof L.r == "bigint" && typeof L.s == "bigint") {
                const {
                    r: ge,
                    s: me
                } = L;
                R = new b(ge, me)
            } else throw new Error("PARSE");
            Y = c.fromHex(N)
        } catch (ge) {
            if (ge.message === "PARSE") throw new Error("signature must be Signature instance, Uint8Array or hex string");
            return !1
        }
        if (G && R.hasHighS()) return !1;
        j && (T = e.hash(T));
        const {
            r: ve,
            s: V
        } = R, X = A(T), q = l(V), ne = a(X * q), ie = a(ve * q), k = (Z = c.BASE.multiplyAndAddUnsafe(Y, ne, ie)) == null ? void 0 : Z.toAffine();
        return k ? a(k.x) === ve : !1
    }
    return {
        CURVE: e,
        getPublicKey: S,
        getSharedSecret: P,
        sign: U,
        verify: m,
        ProjectivePoint: c,
        Signature: b,
        utils: w
    }
} /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
function xOe(t) {
    return {
        hash: t,
        hmac: (e, ...n) => fre(t, e, cRe(...n)),
        randomBytes: uRe
    }
}

function SOe(t, e) {
    const n = r => EOe({ ...t,
        ...xOe(r)
    });
    return Object.freeze({ ...n(e),
        create: n
    })
} /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const Lre = BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),
    EG = BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),
    COe = BigInt(1),
    kk = BigInt(2),
    xG = (t, e) => (t + e / kk) / e;

function AOe(t) {
    const e = Lre,
        n = BigInt(3),
        r = BigInt(6),
        i = BigInt(11),
        s = BigInt(22),
        o = BigInt(23),
        a = BigInt(44),
        l = BigInt(88),
        c = t * t * t % e,
        u = c * c * t % e,
        f = Zl(u, n, e) * u % e,
        h = Zl(f, n, e) * u % e,
        g = Zl(h, kk, e) * c % e,
        y = Zl(g, i, e) * g % e,
        _ = Zl(y, s, e) * y % e,
        C = Zl(_, a, e) * _ % e,
        b = Zl(C, l, e) * C % e,
        w = Zl(b, a, e) * _ % e,
        S = Zl(w, n, e) * u % e,
        I = Zl(S, o, e) * y % e,
        P = Zl(I, r, e) * c % e,
        M = Zl(P, kk, e);
    if (!Mk.eql(Mk.sqr(M), t)) throw new Error("Cannot find square root");
    return M
}
const Mk = hOe(Lre, void 0, void 0, {
        sqrt: AOe
    }),
    v0 = SOe({
        a: BigInt(0),
        b: BigInt(7),
        Fp: Mk,
        n: EG,
        Gx: BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),
        Gy: BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),
        h: BigInt(1),
        lowS: !0,
        endo: {
            beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),
            splitScalar: t => {
                const e = EG,
                    n = BigInt("0x3086d221a7d46bcde86c90e49284eb15"),
                    r = -COe * BigInt("0xe4437ed6010e88286f547fa90abfe4c3"),
                    i = BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),
                    s = n,
                    o = BigInt("0x100000000000000000000000000000000"),
                    a = xG(s * t, e),
                    l = xG(-r * t, e);
                let c = $a(t - a * n - l * i, e),
                    u = $a(-a * r - l * s, e);
                const f = c > o,
                    h = u > o;
                if (f && (c = e - c), h && (u = e - u), c > o || u > o) throw new Error("splitScalar: Endomorphism failed, k=" + t);
                return {
                    k1neg: f,
                    k1: c,
                    k2neg: h,
                    k2: u
                }
            }
        }
    }, hre);
BigInt(0);
v0.ProjectivePoint;
const Z_ = "0x0000000000000000000000000000000000000000",
    SG = "0x0000000000000000000000000000000000000000000000000000000000000000",
    CG = BigInt(0),
    AG = BigInt(1),
    TG = BigInt(2),
    IG = BigInt(27),
    RG = BigInt(28),
    Kx = BigInt(35),
    tw = {};

function OG(t) {
    return km(sa(t), 32)
}
var Hv, zv, Wv, $1;
const eu = class eu {
    constructor(e, n, r, i) {
        _e(this, Hv);
        _e(this, zv);
        _e(this, Wv);
        _e(this, $1);
        IE(e, tw, "Signature"), le(this, Hv, n), le(this, zv, r), le(this, Wv, i), le(this, $1, null)
    }
    get r() {
        return W(this, Hv)
    }
    set r(e) {
        Ee(iv(e) === 32, "invalid r", "value", e), le(this, Hv, Ot(e))
    }
    get s() {
        return W(this, zv)
    }
    set s(e) {
        Ee(iv(e) === 32, "invalid s", "value", e);
        const n = Ot(e);
        Ee(parseInt(n.substring(0, 3)) < 8, "non-canonical s", "value", n), le(this, zv, n)
    }
    get v() {
        return W(this, Wv)
    }
    set v(e) {
        const n = Mn(e, "value");
        Ee(n === 27 || n === 28, "invalid v", "v", e), le(this, Wv, n)
    }
    get networkV() {
        return W(this, $1)
    }
    get legacyChainId() {
        const e = this.networkV;
        return e == null ? null : eu.getChainId(e)
    }
    get yParity() {
        return this.v === 27 ? 0 : 1
    }
    get yParityAndS() {
        const e = or(this.s);
        return this.yParity && (e[0] |= 128), Ot(e)
    }
    get compactSerialized() {
        return vi([this.r, this.yParityAndS])
    }
    get serialized() {
        return vi([this.r, this.s, this.yParity ? "0x1c" : "0x1b"])
    }[Symbol.for("nodejs.util.inspect.custom")]() {
        return `Signature { r: "${this.r}", s: "${this.s}", yParity: ${this.yParity}, networkV: ${this.networkV} }`
    }
    clone() {
        const e = new eu(tw, this.r, this.s, this.v);
        return this.networkV && le(e, $1, this.networkV), e
    }
    toJSON() {
        const e = this.networkV;
        return {
            _type: "signature",
            networkV: e != null ? e.toString() : null,
            r: this.r,
            s: this.s,
            v: this.v
        }
    }
    static getChainId(e) {
        const n = kt(e, "v");
        return n == IG || n == RG ? CG : (Ee(n >= Kx, "invalid EIP-155 v", "v", e), (n - Kx) / TG)
    }
    static getChainIdV(e, n) {
        return kt(e) * TG + BigInt(35 + n - 27)
    }
    static getNormalizedV(e) {
        const n = kt(e);
        return n === CG || n === IG ? 27 : n === AG || n === RG ? 28 : (Ee(n >= Kx, "invalid v", "v", e), n & AG ? 27 : 28)
    }
    static from(e) {
        function n(c, u) {
            Ee(c, u, "signature", e)
        }
        if (e == null) return new eu(tw, SG, SG, 27);
        if (typeof e == "string") {
            const c = or(e, "signature");
            if (c.length === 64) {
                const u = Ot(c.slice(0, 32)),
                    f = c.slice(32, 64),
                    h = f[0] & 128 ? 28 : 27;
                return f[0] &= 127, new eu(tw, u, Ot(f), h)
            }
            if (c.length === 65) {
                const u = Ot(c.slice(0, 32)),
                    f = c.slice(32, 64);
                n((f[0] & 128) === 0, "non-canonical s");
                const h = eu.getNormalizedV(c[64]);
                return new eu(tw, u, Ot(f), h)
            }
            n(!1, "invalid raw signature length")
        }
        if (e instanceof eu) return e.clone();
        const r = e.r;
        n(r != null, "missing r");
        const i = OG(r),
            s = function(c, u) {
                if (c != null) return OG(c);
                if (u != null) {
                    n(Zr(u, 32), "invalid yParityAndS");
                    const f = or(u);
                    return f[0] &= 127, Ot(f)
                }
                n(!1, "missing s")
            }(e.s, e.yParityAndS);
        n((or(s)[0] & 128) == 0, "non-canonical s");
        const {
            networkV: o,
            v: a
        } = function(c, u, f) {
            if (c != null) {
                const h = kt(c);
                return {
                    networkV: h >= Kx ? h : void 0,
                    v: eu.getNormalizedV(h)
                }
            }
            if (u != null) return n(Zr(u, 32), "invalid yParityAndS"), {
                v: or(u)[0] & 128 ? 28 : 27
            };
            if (f != null) {
                switch (Mn(f, "sig.yParity")) {
                    case 0:
                        return {
                            v: 27
                        };
                    case 1:
                        return {
                            v: 28
                        }
                }
                n(!1, "invalid yParity")
            }
            n(!1, "missing v")
        }(e.v, e.yParityAndS, e.yParity), l = new eu(tw, i, s, a);
        return o && le(l, $1, o), n(e.yParity == null || Mn(e.yParity, "sig.yParity") === l.yParity, "yParity mismatch"), n(e.yParityAndS == null || e.yParityAndS === l.yParityAndS, "yParityAndS mismatch"), l
    }
};
Hv = new WeakMap, zv = new WeakMap, Wv = new WeakMap, $1 = new WeakMap;
let Mu = eu;
var Qd;
const r1 = class r1 {
    constructor(e) {
        _e(this, Qd);
        Ee(iv(e) === 32, "invalid private key", "privateKey", "[REDACTED]"), le(this, Qd, Ot(e))
    }
    get privateKey() {
        return W(this, Qd)
    }
    get publicKey() {
        return r1.computePublicKey(W(this, Qd))
    }
    get compressedPublicKey() {
        return r1.computePublicKey(W(this, Qd), !0)
    }
    sign(e) {
        Ee(iv(e) === 32, "invalid digest length", "digest", e);
        const n = v0.sign(ra(e), ra(W(this, Qd)), {
            lowS: !0
        });
        return Mu.from({
            r: zp(n.r, 32),
            s: zp(n.s, 32),
            v: n.recovery ? 28 : 27
        })
    }
    computeSharedSecret(e) {
        const n = r1.computePublicKey(e);
        return Ot(v0.getSharedSecret(ra(W(this, Qd)), or(n), !1))
    }
    static computePublicKey(e, n) {
        let r = or(e, "key");
        if (r.length === 32) {
            const s = v0.getPublicKey(r, !!n);
            return Ot(s)
        }
        if (r.length === 64) {
            const s = new Uint8Array(65);
            s[0] = 4, s.set(r, 1), r = s
        }
        const i = v0.ProjectivePoint.fromHex(r);
        return Ot(i.toRawBytes(n))
    }
    static recoverPublicKey(e, n) {
        Ee(iv(e) === 32, "invalid digest length", "digest", e);
        const r = Mu.from(n);
        let i = v0.Signature.fromCompact(ra(vi([r.r, r.s])));
        i = i.addRecoveryBit(r.yParity);
        const s = i.recoverPublicKey(ra(e));
        return Ee(s != null, "invalid signautre for digest", "signature", n), "0x" + s.toHex(!1)
    }
    static addPoints(e, n, r) {
        const i = v0.ProjectivePoint.fromHex(r1.computePublicKey(e).substring(2)),
            s = v0.ProjectivePoint.fromHex(r1.computePublicKey(n).substring(2));
        return "0x" + i.add(s).toHex(!!r)
    }
};
Qd = new WeakMap;
let Q_ = r1;
const TOe = BigInt(0),
    IOe = BigInt(36);

function NG(t) {
    t = t.toLowerCase();
    const e = t.substring(2).split(""),
        n = new Uint8Array(40);
    for (let i = 0; i < 40; i++) n[i] = e[i].charCodeAt(0);
    const r = or(fs(n));
    for (let i = 0; i < 40; i += 2) r[i >> 1] >> 4 >= 8 && (e[i] = e[i].toUpperCase()), (r[i >> 1] & 15) >= 8 && (e[i + 1] = e[i + 1].toUpperCase());
    return "0x" + e.join("")
}
const OL = {};
for (let t = 0; t < 10; t++) OL[String(t)] = String(t);
for (let t = 0; t < 26; t++) OL[String.fromCharCode(65 + t)] = String(10 + t);
const PG = 15;

function ROe(t) {
    t = t.toUpperCase(), t = t.substring(4) + t.substring(0, 2) + "00";
    let e = t.split("").map(r => OL[r]).join("");
    for (; e.length >= PG;) {
        let r = e.substring(0, PG);
        e = parseInt(r, 10) % 97 + e.substring(r.length)
    }
    let n = String(98 - parseInt(e, 10) % 97);
    for (; n.length < 2;) n = "0" + n;
    return n
}
const OOe = function() {
    const t = {};
    for (let e = 0; e < 36; e++) {
        const n = "0123456789abcdefghijklmnopqrstuvwxyz" [e];
        t[n] = BigInt(e)
    }
    return t
}();

function NOe(t) {
    t = t.toLowerCase();
    let e = TOe;
    for (let n = 0; n < t.length; n++) e = e * IOe + OOe[t[n]];
    return e
}

function Hn(t) {
    if (Ee(typeof t == "string", "invalid address", "address", t), t.match(/^(0x)?[0-9a-fA-F]{40}$/)) {
        t.startsWith("0x") || (t = "0x" + t);
        const e = NG(t);
        return Ee(!t.match(/([A-F].*[a-f])|([a-f].*[A-F])/) || e === t, "bad address checksum", "address", t), e
    }
    if (t.match(/^XE[0-9]{2}[0-9A-Za-z]{30,31}$/)) {
        Ee(t.substring(2, 4) === ROe(t), "bad icap checksum", "address", t);
        let e = NOe(t.substring(4)).toString(16);
        for (; e.length < 40;) e = "0" + e;
        return NG("0x" + e)
    }
    Ee(!1, "invalid address", "address", t)
}

function POe(t) {
    const e = Hn(t.from);
    let r = kt(t.nonce, "tx.nonce").toString(16);
    return r === "0" ? r = "0x" : r.length % 2 ? r = "0x0" + r : r = "0x" + r, Hn(ji(fs(Mm([e, r])), 12))
}

function Bre(t) {
    return t && typeof t.getAddress == "function"
}

function kOe(t) {
    try {
        return Hn(t), !0
    } catch {}
    return !1
}
async function bO(t, e) {
    const n = await e;
    return (n == null || n === "0x0000000000000000000000000000000000000000") && (je(typeof t != "string", "unconfigured name", "UNCONFIGURED_NAME", {
        value: t
    }), Ee(!1, "invalid AddressLike value; did not resolve to a value address", "target", t)), Hn(n)
}

function aa(t, e) {
    if (typeof t == "string") return t.match(/^0x[0-9a-f]{40}$/i) ? Hn(t) : (je(e != null, "ENS resolution requires a provider", "UNSUPPORTED_OPERATION", {
        operation: "resolveName"
    }), bO(t, e.resolveName(t)));
    if (Bre(t)) return bO(t, t.getAddress());
    if (t && typeof t.then == "function") return bO(t, t);
    Ee(!1, "unsupported addressable value", "target", t)
}
const Fd = {};

function Tt(t, e) {
    let n = !1;
    return e < 0 && (n = !0, e *= -1), new Po(Fd, `${n?"":"u"}int${e}`, t, {
        signed: n,
        width: e
    })
}

function dr(t, e) {
    return new Po(Fd, `bytes${e||""}`, t, {
        size: e
    })
}
const kG = Symbol.for("_ethers_typed");
var L1;
const Wd = class Wd {
    constructor(e, n, r, i) {
        Ie(this, "type");
        Ie(this, "value");
        _e(this, L1);
        Ie(this, "_typedSymbol");
        i == null && (i = null), IE(Fd, e, "Typed"), Xt(this, {
            _typedSymbol: kG,
            type: n,
            value: r
        }), le(this, L1, i), this.format()
    }
    format() {
        if (this.type === "array") throw new Error("");
        if (this.type === "dynamicArray") throw new Error("");
        return this.type === "tuple" ? `tuple(${this.value.map(e=>e.format()).join(",")})` : this.type
    }
    defaultValue() {
        return 0
    }
    minValue() {
        return 0
    }
    maxValue() {
        return 0
    }
    isBigInt() {
        return !!this.type.match(/^u?int[0-9]+$/)
    }
    isData() {
        return this.type.startsWith("bytes")
    }
    isString() {
        return this.type === "string"
    }
    get tupleName() {
        if (this.type !== "tuple") throw TypeError("not a tuple");
        return W(this, L1)
    }
    get arrayLength() {
        if (this.type !== "array") throw TypeError("not an array");
        return W(this, L1) === !0 ? -1 : W(this, L1) === !1 ? this.value.length : null
    }
    static from(e, n) {
        return new Wd(Fd, e, n)
    }
    static uint8(e) {
        return Tt(e, 8)
    }
    static uint16(e) {
        return Tt(e, 16)
    }
    static uint24(e) {
        return Tt(e, 24)
    }
    static uint32(e) {
        return Tt(e, 32)
    }
    static uint40(e) {
        return Tt(e, 40)
    }
    static uint48(e) {
        return Tt(e, 48)
    }
    static uint56(e) {
        return Tt(e, 56)
    }
    static uint64(e) {
        return Tt(e, 64)
    }
    static uint72(e) {
        return Tt(e, 72)
    }
    static uint80(e) {
        return Tt(e, 80)
    }
    static uint88(e) {
        return Tt(e, 88)
    }
    static uint96(e) {
        return Tt(e, 96)
    }
    static uint104(e) {
        return Tt(e, 104)
    }
    static uint112(e) {
        return Tt(e, 112)
    }
    static uint120(e) {
        return Tt(e, 120)
    }
    static uint128(e) {
        return Tt(e, 128)
    }
    static uint136(e) {
        return Tt(e, 136)
    }
    static uint144(e) {
        return Tt(e, 144)
    }
    static uint152(e) {
        return Tt(e, 152)
    }
    static uint160(e) {
        return Tt(e, 160)
    }
    static uint168(e) {
        return Tt(e, 168)
    }
    static uint176(e) {
        return Tt(e, 176)
    }
    static uint184(e) {
        return Tt(e, 184)
    }
    static uint192(e) {
        return Tt(e, 192)
    }
    static uint200(e) {
        return Tt(e, 200)
    }
    static uint208(e) {
        return Tt(e, 208)
    }
    static uint216(e) {
        return Tt(e, 216)
    }
    static uint224(e) {
        return Tt(e, 224)
    }
    static uint232(e) {
        return Tt(e, 232)
    }
    static uint240(e) {
        return Tt(e, 240)
    }
    static uint248(e) {
        return Tt(e, 248)
    }
    static uint256(e) {
        return Tt(e, 256)
    }
    static uint(e) {
        return Tt(e, 256)
    }
    static int8(e) {
        return Tt(e, -8)
    }
    static int16(e) {
        return Tt(e, -16)
    }
    static int24(e) {
        return Tt(e, -24)
    }
    static int32(e) {
        return Tt(e, -32)
    }
    static int40(e) {
        return Tt(e, -40)
    }
    static int48(e) {
        return Tt(e, -48)
    }
    static int56(e) {
        return Tt(e, -56)
    }
    static int64(e) {
        return Tt(e, -64)
    }
    static int72(e) {
        return Tt(e, -72)
    }
    static int80(e) {
        return Tt(e, -80)
    }
    static int88(e) {
        return Tt(e, -88)
    }
    static int96(e) {
        return Tt(e, -96)
    }
    static int104(e) {
        return Tt(e, -104)
    }
    static int112(e) {
        return Tt(e, -112)
    }
    static int120(e) {
        return Tt(e, -120)
    }
    static int128(e) {
        return Tt(e, -128)
    }
    static int136(e) {
        return Tt(e, -136)
    }
    static int144(e) {
        return Tt(e, -144)
    }
    static int152(e) {
        return Tt(e, -152)
    }
    static int160(e) {
        return Tt(e, -160)
    }
    static int168(e) {
        return Tt(e, -168)
    }
    static int176(e) {
        return Tt(e, -176)
    }
    static int184(e) {
        return Tt(e, -184)
    }
    static int192(e) {
        return Tt(e, -192)
    }
    static int200(e) {
        return Tt(e, -200)
    }
    static int208(e) {
        return Tt(e, -208)
    }
    static int216(e) {
        return Tt(e, -216)
    }
    static int224(e) {
        return Tt(e, -224)
    }
    static int232(e) {
        return Tt(e, -232)
    }
    static int240(e) {
        return Tt(e, -240)
    }
    static int248(e) {
        return Tt(e, -248)
    }
    static int256(e) {
        return Tt(e, -256)
    }
    static int(e) {
        return Tt(e, -256)
    }
    static bytes1(e) {
        return dr(e, 1)
    }
    static bytes2(e) {
        return dr(e, 2)
    }
    static bytes3(e) {
        return dr(e, 3)
    }
    static bytes4(e) {
        return dr(e, 4)
    }
    static bytes5(e) {
        return dr(e, 5)
    }
    static bytes6(e) {
        return dr(e, 6)
    }
    static bytes7(e) {
        return dr(e, 7)
    }
    static bytes8(e) {
        return dr(e, 8)
    }
    static bytes9(e) {
        return dr(e, 9)
    }
    static bytes10(e) {
        return dr(e, 10)
    }
    static bytes11(e) {
        return dr(e, 11)
    }
    static bytes12(e) {
        return dr(e, 12)
    }
    static bytes13(e) {
        return dr(e, 13)
    }
    static bytes14(e) {
        return dr(e, 14)
    }
    static bytes15(e) {
        return dr(e, 15)
    }
    static bytes16(e) {
        return dr(e, 16)
    }
    static bytes17(e) {
        return dr(e, 17)
    }
    static bytes18(e) {
        return dr(e, 18)
    }
    static bytes19(e) {
        return dr(e, 19)
    }
    static bytes20(e) {
        return dr(e, 20)
    }
    static bytes21(e) {
        return dr(e, 21)
    }
    static bytes22(e) {
        return dr(e, 22)
    }
    static bytes23(e) {
        return dr(e, 23)
    }
    static bytes24(e) {
        return dr(e, 24)
    }
    static bytes25(e) {
        return dr(e, 25)
    }
    static bytes26(e) {
        return dr(e, 26)
    }
    static bytes27(e) {
        return dr(e, 27)
    }
    static bytes28(e) {
        return dr(e, 28)
    }
    static bytes29(e) {
        return dr(e, 29)
    }
    static bytes30(e) {
        return dr(e, 30)
    }
    static bytes31(e) {
        return dr(e, 31)
    }
    static bytes32(e) {
        return dr(e, 32)
    }
    static address(e) {
        return new Wd(Fd, "address", e)
    }
    static bool(e) {
        return new Wd(Fd, "bool", !!e)
    }
    static bytes(e) {
        return new Wd(Fd, "bytes", e)
    }
    static string(e) {
        return new Wd(Fd, "string", e)
    }
    static array(e, n) {
        throw new Error("not implemented yet")
    }
    static tuple(e, n) {
        throw new Error("not implemented yet")
    }
    static overrides(e) {
        return new Wd(Fd, "overrides", Object.assign({}, e))
    }
    static isTyped(e) {
        return e && typeof e == "object" && "_typedSymbol" in e && e._typedSymbol === kG
    }
    static dereference(e, n) {
        if (Wd.isTyped(e)) {
            if (e.type !== n) throw new Error(`invalid type: expecetd ${n}, got ${e.type}`);
            return e.value
        }
        return e
    }
};
L1 = new WeakMap;
let Po = Wd;
class MOe extends Hh {
    constructor(e) {
        super("address", "address", e, !1)
    }
    defaultValue() {
        return "0x0000000000000000000000000000000000000000"
    }
    encode(e, n) {
        let r = Po.dereference(n, "string");
        try {
            r = Hn(r)
        } catch (i) {
            return this._throwError(i.message, n)
        }
        return e.writeValue(r)
    }
    decode(e) {
        return Hn(zp(e.readValue(), 20))
    }
}
class DOe extends Hh {
    constructor(n) {
        super(n.name, n.type, "_", n.dynamic);
        Ie(this, "coder");
        this.coder = n
    }
    defaultValue() {
        return this.coder.defaultValue()
    }
    encode(n, r) {
        return this.coder.encode(n, r)
    }
    decode(n) {
        return this.coder.decode(n)
    }
}

function Fre(t, e, n) {
    let r = [];
    if (Array.isArray(n)) r = n;
    else if (n && typeof n == "object") {
        let l = {};
        r = e.map(c => {
            const u = c.localName;
            return je(u, "cannot encode object for signature with missing names", "INVALID_ARGUMENT", {
                argument: "values",
                info: {
                    coder: c
                },
                value: n
            }), je(!l[u], "cannot encode object for signature with duplicate names", "INVALID_ARGUMENT", {
                argument: "values",
                info: {
                    coder: c
                },
                value: n
            }), l[u] = !0, n[u]
        })
    } else Ee(!1, "invalid tuple value", "tuple", n);
    Ee(e.length === r.length, "types/value length mismatch", "tuple", n);
    let i = new Tk,
        s = new Tk,
        o = [];
    e.forEach((l, c) => {
        let u = r[c];
        if (l.dynamic) {
            let f = s.length;
            l.encode(s, u);
            let h = i.writeUpdatableValue();
            o.push(g => {
                h(g + f)
            })
        } else l.encode(i, u)
    }), o.forEach(l => {
        l(i.length)
    });
    let a = t.appendWriter(i);
    return a += t.appendWriter(s), a
}

function Ure(t, e) {
    let n = [],
        r = [],
        i = t.subReader(0);
    return e.forEach(s => {
        let o = null;
        if (s.dynamic) {
            let a = t.readIndex(),
                l = i.subReader(a);
            try {
                o = s.decode(l)
            } catch (c) {
                if (No(c, "BUFFER_OVERRUN")) throw c;
                o = c, o.baseType = s.name, o.name = s.localName, o.type = s.type
            }
        } else try {
            o = s.decode(t)
        } catch (a) {
            if (No(a, "BUFFER_OVERRUN")) throw a;
            o = a, o.baseType = s.name, o.name = s.localName, o.type = s.type
        }
        if (o == null) throw new Error("investigate");
        n.push(o), r.push(s.localName || null)
    }), Wp.fromItems(n, r)
}
class $Oe extends Hh {
    constructor(n, r, i) {
        const s = n.type + "[" + (r >= 0 ? r : "") + "]",
            o = r === -1 || n.dynamic;
        super("array", s, i, o);
        Ie(this, "coder");
        Ie(this, "length");
        Xt(this, {
            coder: n,
            length: r
        })
    }
    defaultValue() {
        const n = this.coder.defaultValue(),
            r = [];
        for (let i = 0; i < this.length; i++) r.push(n);
        return r
    }
    encode(n, r) {
        const i = Po.dereference(r, "array");
        Array.isArray(i) || this._throwError("expected array value", i);
        let s = this.length;
        s === -1 && (s = i.length, n.writeValue(i.length)), Kne(i.length, s, "coder array" + (this.localName ? " " + this.localName : ""));
        let o = [];
        for (let a = 0; a < i.length; a++) o.push(this.coder);
        return Fre(n, o, i)
    }
    decode(n) {
        let r = this.length;
        r === -1 && (r = n.readIndex(), je(r * oa <= n.dataLength, "insufficient data length", "BUFFER_OVERRUN", {
            buffer: n.bytes,
            offset: r * oa,
            length: n.dataLength
        }));
        let i = [];
        for (let s = 0; s < r; s++) i.push(new DOe(this.coder));
        return Ure(n, i)
    }
}
class LOe extends Hh {
    constructor(e) {
        super("bool", "bool", e, !1)
    }
    defaultValue() {
        return !1
    }
    encode(e, n) {
        const r = Po.dereference(n, "bool");
        return e.writeValue(r ? 1 : 0)
    }
    decode(e) {
        return !!e.readValue()
    }
}
class jre extends Hh {
    constructor(e, n) {
        super(e, e, n, !0)
    }
    defaultValue() {
        return "0x"
    }
    encode(e, n) {
        n = ra(n);
        let r = e.writeValue(n.length);
        return r += e.writeBytes(n), r
    }
    decode(e) {
        return e.readBytes(e.readIndex(), !0)
    }
}
class BOe extends jre {
    constructor(e) {
        super("bytes", e)
    }
    decode(e) {
        return Ot(super.decode(e))
    }
}
class FOe extends Hh {
    constructor(n, r) {
        let i = "bytes" + String(n);
        super(i, i, r, !1);
        Ie(this, "size");
        Xt(this, {
            size: n
        }, {
            size: "number"
        })
    }
    defaultValue() {
        return "0x0000000000000000000000000000000000000000000000000000000000000000".substring(0, 2 + this.size * 2)
    }
    encode(n, r) {
        let i = ra(Po.dereference(r, this.type));
        return i.length !== this.size && this._throwError("incorrect data length", r), n.writeBytes(i)
    }
    decode(n) {
        return Ot(n.readBytes(this.size))
    }
}
const UOe = new Uint8Array([]);
class jOe extends Hh {
    constructor(e) {
        super("null", "", e, !1)
    }
    defaultValue() {
        return null
    }
    encode(e, n) {
        return n != null && this._throwError("not null", n), e.writeBytes(UOe)
    }
    decode(e) {
        return e.readBytes(0), null
    }
}
const HOe = BigInt(0),
    zOe = BigInt(1),
    WOe = BigInt("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
class VOe extends Hh {
    constructor(n, r, i) {
        const s = (r ? "int" : "uint") + n * 8;
        super(s, s, i, !1);
        Ie(this, "size");
        Ie(this, "signed");
        Xt(this, {
            size: n,
            signed: r
        }, {
            size: "number",
            signed: "boolean"
        })
    }
    defaultValue() {
        return 0
    }
    encode(n, r) {
        let i = kt(Po.dereference(r, this.type)),
            s = c1(WOe, oa * 8);
        if (this.signed) {
            let o = c1(s, this.size * 8 - 1);
            (i > o || i < -(o + zOe)) && this._throwError("value out-of-bounds", r), i = Qne(i, 8 * oa)
        } else(i < HOe || i > c1(s, this.size * 8)) && this._throwError("value out-of-bounds", r);
        return n.writeValue(i)
    }
    decode(n) {
        let r = c1(n.readValue(), this.size * 8);
        return this.signed && (r = NC(r, this.size * 8)), r
    }
}
class GOe extends jre {
    constructor(e) {
        super("string", e)
    }
    defaultValue() {
        return ""
    }
    encode(e, n) {
        return super.encode(e, qf(Po.dereference(n, "string")))
    }
    decode(e) {
        return PC(super.decode(e))
    }
}
class Yx extends Hh {
    constructor(n, r) {
        let i = !1;
        const s = [];
        n.forEach(a => {
            a.dynamic && (i = !0), s.push(a.type)
        });
        const o = "tuple(" + s.join(",") + ")";
        super("tuple", o, r, i);
        Ie(this, "coders");
        Xt(this, {
            coders: Object.freeze(n.slice())
        })
    }
    defaultValue() {
        const n = [];
        this.coders.forEach(i => {
            n.push(i.defaultValue())
        });
        const r = this.coders.reduce((i, s) => {
            const o = s.localName;
            return o && (i[o] || (i[o] = 0), i[o]++), i
        }, {});
        return this.coders.forEach((i, s) => {
            let o = i.localName;
            !o || r[o] !== 1 || (o === "length" && (o = "_length"), n[o] == null && (n[o] = n[s]))
        }), Object.freeze(n)
    }
    encode(n, r) {
        const i = Po.dereference(r, "tuple");
        return Fre(n, this.coders, i)
    }
    decode(n) {
        return Ure(n, this.coders)
    }
}

function Dm(t) {
    return fs(qf(t))
}
var qOe = "AEEUdwmgDS8BxQKKAP4BOgDjATAAngDUAIMAoABoAOAAagCOAEQAhABMAHIAOwA9ACsANgAmAGIAHgAuACgAJwAXAC0AGgAjAB8ALwAUACkAEgAeAAkAGwARABkAFgA5ACgALQArADcAFQApABAAHgAiABAAGgAeABMAGAUhBe8BFxREN8sF2wC5AK5HAW8ArQkDzQCuhzc3NzcBP68NEfMABQdHBuw5BV8FYAA9MzkI9r4ZBg7QyQAWA9CeOwLNCjcCjqkChuA/lm+RAsXTAoP6ASfnEQDytQFJAjWVCkeXAOsA6godAB/cwdAUE0WlBCN/AQUCQRjFD/MRBjHxDQSJbw0jBzUAswBxme+tnIcAYwabAysG8QAjAEMMmxcDqgPKQyDXCMMxA7kUQwD3NXOrAKmFIAAfBC0D3x4BJQDBGdUFAhEgVD8JnwmQJiNWYUzrg0oAGwAUAB0AFnNcACkAFgBP9h3gPfsDOWDKneY2ChglX1UDYD30ABsAFAAdABZzIGRAnwDD8wAjAEEMzRbDqgMB2sAFYwXqAtCnAsS4AwpUJKRtFHsadUz9AMMVbwLpABM1NJEX0ZkCgYMBEyMAxRVvAukAEzUBUFAtmUwSAy4DBTER33EftQHfSwB5MxJ/AjkWKQLzL8E/cwBB6QH9LQDPDtO9ASNriQC5DQANAwCK21EFI91zHwCoL9kBqQcHBwcHKzUDowBvAQohPvU3fAQgHwCyAc8CKQMA5zMSezr7ULgFmDp/LzVQBgEGAi8FYQVgt8AFcTtlQhpCWEmfe5tmZ6IAExsDzQ8t+X8rBKtTAltbAn0jsy8Bl6utPWMDTR8Ei2kRANkDBrNHNysDBzECQWUAcwFpJ3kAiyUhAJ0BUb8AL3EfAbfNAz81KUsFWwF3YQZtAm0A+VEfAzEJDQBRSQCzAQBlAHsAM70GD/v3IZWHBwARKQAxALsjTwHZAeMPEzmXgIHwABIAGQA8AEUAQDt3gdvIEGcQZAkGTRFMdEIVEwK0D64L7REdDNkq09PgADSxB/MDWwfzA1sDWwfzB/MDWwfzA1sDWwNbA1scEvAi28gQZw9QBHUFlgWTBN4IiyZREYkHMAjaVBV0JhxPA00BBCMtSSQ7mzMTJUpMFE0LCAQ2SmyvfUADTzGzVP2QqgPTMlc5dAkGHnkSqAAyD3skNb1OhnpPcagKU0+2tYdJak5vAsY6sEAACikJm2/Dd1YGRRAfJ6kQ+ww3AbkBPw3xS9wE9QY/BM0fgRkdD9GVoAipLeEM8SbnLqWAXiP5KocF8Uv4POELUVFsD10LaQnnOmeBUgMlAREijwrhDT0IcRD3Cs1vDekRSQc9A9lJngCpBwULFR05FbkmFGKwCw05ewb/GvoLkyazEy17AAXXGiUGUQEtGwMA0y7rhbRaNVwgT2MGBwspI8sUrFAkDSlAu3hMGh8HGSWtApVDdEqLUToelyH6PEENai4XUYAH+TwJGVMLhTyiRq9FEhHWPpE9TCJNTDAEOYMsMyePCdMPiQy9fHYBXQklCbUMdRM1ERs3yQg9Bx0xlygnGQglRplgngT7owP3E9UDDwVDCUUHFwO5HDETMhUtBRGBKNsC9zbZLrcCk1aEARsFzw8pH+MQVEfkDu0InwJpA4cl7wAxFSUAGyKfCEdnAGOP3FMJLs8Iy2pwI3gDaxTrZRF3B5UOWwerHDcVwxzlcMxeD4YMKKezCV8BeQmdAWME5wgNNV+MpCBFZ1eLXBifIGVBQ14AAjUMaRWjRMGHfAKPD28SHwE5AXcHPQ0FAnsR8RFvEJkI74YINbkz/DopBFMhhyAVCisDU2zSCysm/Qz8bQGnEmYDEDRBd/Jnr2C6KBgBBx0yyUFkIfULlk/RDKAaxRhGVDIZ6AfDA/ca9yfuQVsGAwOnBxc6UTPyBMELbQiPCUMATQ6nGwfbGG4KdYzUATWPAbudA1uVhwJzkwY7Bw8Aaw+LBX3pACECqwinAAkA0wNbAD0CsQehAB0AiUUBQQMrMwEl6QKTA5cINc8BmTMB9y0EH8cMGQD7O25OAsO1AoBuZqYF4VwCkgJNOQFRKQQJUktVA7N15QDfAE8GF+NLARmvTs8e50cB43MvAMsA/wAJOQcJRQHRAfdxALsBYws1Caa3uQFR7S0AhwAZbwHbAo0A4QA5AIP1AVcAUQVd/QXXAlNNARU1HC9bZQG/AyMBNwERAH0Gz5GpzQsjBHEH1wIQHxXlAu8yB7kFAyLjE9FCyQK94lkAMhoKPAqrCqpgX2Q3CjV2PVQAEh+sPss/UgVVO1c7XDtXO1w7VztcO1c7XDtXO1wDm8Pmw+YKcF9JYe8Mqg3YRMw6TRPfYFVgNhPMLbsUxRXSJVoZQRrAJwkl6FUNDwgt12Y0CDA0eRfAAEMpbINFY4oeNApPHOtTlVT8LR8AtUumM7MNsBsZREQFS3XxYi4WEgomAmSFAmJGX1GzAV83JAKh+wJonAJmDQKfiDgfDwJmPwJmKgRyBIMDfxcDfpY5Cjl7GzmGOicnAmwhAjI6OA4CbcsCbbLzjgM3a0kvAWsA4gDlAE4JB5wMkQECD8YAEbkCdzMCdqZDAnlPRwJ4viFg30WyRvcCfEMCeswCfQ0CfPRIBEiBZygALxlJXEpfGRtK0ALRBQLQ0EsrA4hTA4fqRMmRNgLypV0HAwOyS9JMMSkH001QTbMCi0MCitzFHwshR2sJuwKOOwKOYESbhQKO3QKOYHxRuFM5AQ5S2FSJApP/ApMQAO0AIFUiVbNV1AosHymZijLleGpFPz0Cl6MC77ZYJawAXSkClpMCloCgAK1ZsFoNhVEAPwKWuQKWUlxIXNUCmc8CmWhczl0LHQKcnznGOqECnBoCn58CnryOACETNS4TAp31Ap6WALlBYThh8wKe1wKgcgGtAp6jIwKeUqljzGQrKS8CJ7MCJoICoP8CoFDbAqYzAqXSAqgDAIECp/ZogGi1AAdNaiBq1QKs5wKssgKtawKtBgJXIQJV4AKx5dsDH1JsmwKywRECsuwbbORtZ21MYwMl0QK2YD9DbpQDKUkCuGICuUsZArkue3A6cOUCvR0DLbYDMhUCvoxyBgMzdQK+HnMmc1MCw88CwwhzhnRPOUl05AM8qwEDPJ4DPcMCxYACxksCxhSNAshtVQLISALJUwLJMgJkoQLd1nh9ZXiyeSlL1AMYp2cGAmH4GfeVKHsPXpZevxUCz28Cz3AzT1fW9xejAMqxAs93AS3uA04Wfk8JAtwrAtuOAtJTA1JgA1NjAQUDVZCAjUMEzxrxZEl5A4LSg5EC2ssC2eKEFIRNp0ADhqkAMwNkEoZ1Xf0AWQLfaQLevHd7AuIz7RgB8zQrAfSfAfLWiwLr9wLpdH0DAur9AuroAP1LAb0C7o0C66CWrpcHAu5DA4XkmH1w5HGlAvMHAG0DjhqZlwL3FwORcgOSiwL3nAL53QL4apogmq+/O5siA52HAv7+AR8APZ8gAZ+3AwWRA6ZuA6bdANXJAwZuoYyiCQ0DDE0BEwEjB3EGZb1rCQC/BG/DFY8etxEAG3k9ACcDNxJRA42DAWcrJQCM8wAlAOanC6OVCLsGI6fJBgCvBRnDBvElRUYFFoAFcD9GSDNCKUK8X3kZX8QAls0FOgCQVCGbwTsuYDoZutcONxjOGJHJ/gVfBWAFXwVgBWsFYAVfBWAFXwVgBV8FYAVfBWBOHQjfjW8KCgoKbF7xMwTRA7kGN8PDAMMEr8MA70gxFroFTj5xPnhCR0K+X30/X/AAWBkzswCNBsxzzASm70aCRS4rDDMeLz49fnXfcsH5GcoscQFz13Y4HwVnBXLJycnACNdRYwgICAqEXoWTxgA7P4kACxbZBu21Kw0AjMsTAwkVAOVtJUUsJ1JCuULESUArXy9gPi9AKwnJRQYKTD9LPoA+iT54PnkCkULEUUpDX9NWV3JVEjQAc1w3A3IBE3YnX+g7QiMJb6MKaiszRCUuQrNCxDPMCcwEX9EWJzYREBEEBwIHKn6l33JCNVIfybPJtAltydPUCmhBZw/tEKsZAJOVJU1CLRuxbUHOQAo7P0s+eEJHHA8SJVRPdGM0NVrpvBoKhfUlM0JHHGUQUhEWO1xLSj8MO0ucNAqJIzVCRxv9EFsqKyA4OQgNj2nwZgp5ZNFgE2A1K3YHS2AhQQojJmC7DgpzGG1WYFUZCQYHZO9gHWCdYIVgu2BTYJlwFh8GvRbcXbG8YgtDHrMBwzPVyQonHQgkCyYBgQJ0Ajc4nVqIAwGSCsBPIgDsK3SWEtIVBa5N8gGjAo+kVwVIZwD/AEUSCDweX4ITrRQsJ8K3TwBXFDwEAB0TvzVcAtoTS20RIwDgVgZ9BBImYgA5AL4Coi8LFnezOkCnIQFjAY4KBAPh9RcGsgZSBsEAJctdsWIRu2kTkQstRw7DAcMBKgpPBGIGMDAwKCYnKTQaLg4AKRSVAFwCdl+YUZ0JdicFD3lPAdt1F9ZZKCGxuE3yBxkFVGcA/wBFEgiCBwAOLHQSjxOtQDg1z7deFRMAZ8QTAGtKb1ApIiPHADkAvgKiLy1DFtYCmBiDAlDDWNB0eo7fpaMO/aEVRRv0ATEQZBIODyMEAc8JQhCbDRgzFD4TAEMAu9YBCgCsAOkAm5I3ABwAYxvONnR+MhXJAxgKQyxL2+kkJhMbhQKDBMkSsvF0AD9BNQ6uQC7WqSQHwxEAEEIu1hkhAH2z4iQPwyJPHNWpdyYBRSpnJALzoBAEVPPsH20MxA0CCEQKRgAFyAtFAlMNwwjEDUQJRArELtapMg7DDZgJIw+TGukEIwvDFkMAqAtDEMMMBhioe+QAO3MMRAACrgnEBSPY9Q0FDnbSBoMAB8MSYxkSxAEJAPIJAAB8FWMOFtMc/HcXwxhDAC7DAvOowwAewwJdKDKHAAHDAALrFUQVwwAbwyvzpWMWv8wA/ABpAy++bcYDUKPD0KhDCwKmJ1MAAmMA5+UZwxAagwipBRL/eADfw6fDGOMCGsOjk3l6BwOpo4sAEsMOGxMAA5sAbcMOAAvDp0MJGkMDwgipnNIPAwfIqUMGAOGDAAPzABXDAAcDAAnDAGmTABrDAA7DChjDjnEWAwABYwAOcwAuUyYABsMAF8MIKQANUgC6wy4AA8MADqMq8wCyYgAcIwAB8wqpAAXOCx0V4wAHowBCwwEKAGnDAAuDAB3DAAjDCakABdIAbqcZ3QCZCCkABdIAAAFDAAfjAB2jCCkABqIACYMAGzMAbSMA5sOIAAhjAAhDABTDBAkpAAbSAOOTAAlDC6kOzPtnAAdDAG6kQFAATwAKwwwAA0MACbUDPwAHIwAZgwACE6cDAAojAApDAAoDp/MGwwAJIwADEwAQQwgAFEMAEXMAD5MADfMADcMAGRMOFiMAFUMAbqMWuwHDAMIAE0MLAGkzEgDhUwACQwAEWgAXgwUjAAbYABjDBSYBgzBaAEFNALcQBxUMegAwMngBrA0IZgJ0KxQHBREPd1N0ZzKRJwaIHAZqNT4DqQq8BwngAB4DAwt2AX56T1ocKQNXAh1GATQGC3tOxYNagkgAMQA5CQADAQEAWxLjAIOYNAEzAH7tFRk6TglSAF8NAAlYAQ+S1ACAQwQorQBiAN4dAJ1wPyeTANVzuQDX3AIeEMp9eyMgXiUAEdkBkJizKltbVVAaRMqRAAEAhyQ/SDEz6BmfVwB6ATEsOClKIRcDOF0E/832AFNt5AByAnkCRxGCOs94NjXdAwINGBonDBwPALW2AwICAgAAAAAAAAYDBQMDARrUAwAtAAAAAgEGBgYGBgYFBQUFBQUEBQYHCAkEBQUFBQQAAAICAAAAIgCNAJAAlT0A6gC7ANwApEQAwgCyAK0AqADuAKYA2gCjAOcBCAEDAMcAgQBiANIA1AEDAN4A8gCQAKkBMQDqAN8A3AsBCQ8yO9ra2tq8xuLT1tRJOB0BUgFcNU0BWgFpAWgBWwFMUUlLbhMBUxsNEAs6PhMOACcUKy0vMj5AQENDQ0RFFEYGJFdXV1dZWVhZL1pbXVxcI2NnZ2ZoZypsbnZ1eHh4eHh4enp6enp6enp6enp8fH18e2IARPIASQCaAHgAMgBm+ACOAFcAVwA3AnbvAIsABfj4AGQAk/IAnwBPAGIAZP//sACFAIUAaQBWALEAJAC2AIMCQAJDAPwA5wD+AP4A6AD/AOkA6QDoAOYALwJ7AVEBQAE+AVQBPgE+AT4BOQE4ATgBOAEcAVgXADEQCAEAUx8SHgsdHhYAjgCWAKYAUQBqIAIxAHYAbwCXAxUDJzIDIUlGTzEAkQJPAMcCVwKkAMAClgKWApYClgKWApYCiwKWApYClgKWApYClgKVApUCmAKgApcClgKWApQClAKUApQCkgKVAnUB1AKXAp8ClgKWApUeAIETBQD+DQOfAmECOh8BVBg9AuIZEjMbAU4/G1WZAXusRAFpYQEFA0FPAQYAmTEeIJdyADFoAHEANgCRA5zMk/C2jGINwjMWygIZCaXdfDILBCs5dAE7YnQBugDlhoiHhoiGiYqKhouOjIaNkI6Ij4qQipGGkoaThpSSlYaWhpeKmIaZhpqGm4aci52QnoqfhuIC4XTpAt90AIp0LHSoAIsAdHQEQwRABEIERQRDBEkERgRBBEcESQRIBEQERgRJAJ5udACrA490ALxuAQ10ANFZdHQA13QCFHQA/mJ0AP4BIQD+APwA/AD9APwDhGZ03ASMK23HAP4A/AD8AP0A/CR0dACRYnQA/gCRASEA/gCRAvQA/gCRA4RmdNwEjCttxyR0AP9idAEhAP4A/gD8APwA/QD8AP8A/AD8AP0A/AOEZnTcBIwrbcckdHQAkWJ0ASEA/gCRAP4AkQL0AP4AkQOEZnTcBIwrbcckdAJLAT50AlIBQXQCU8l0dAJfdHQDpgL0A6YDpgOnA6cDpwOnA4RmdNwEjCttxyR0dACRYnQBIQOmAJEDpgCRAvQDpgCRA4RmdNwEjCttxyR0BDh0AJEEOQCRDpU5dSgCADR03gV2CwArdAEFAM5iCnR0AF1iAAYcOgp0dACRCnQAXAEIwWZ0CnRmdHQAkWZ0CnRmdEXgAFF03gp0dEY0tlT2u3SOAQTwscwhjZZKrhYcBSfFp9XNbKiVDOD2b+cpe4/Z17mQnbtzzhaeQtE2GGj0IDNTjRUSyTxxw/RPHW/+vS7d1NfRt9z9QPZg4X7QFfhCnkvgNPIItOsC2eV6hPannZNHlZ9xrwZXIMOlu3jSoQSq78WEjwLjw1ELSlF1aBvfzwk5ZX7AUvQzjPQKbDuQ+sm4wNOp4A6AdVuRS0t1y/DZpg4R6m7FNjM9HgvW7Bi88zaMjOo6lM8wtBBdj8LP4ylv3zCXPhebMKJc066o9sF71oFW/8JXu86HJbwDID5lzw5GWLR/LhT0Qqnp2JQxNZNfcbLIzPy+YypqRm/lBmGmex+82+PisxUumSeJkALIT6rJezxMH+CTJmQtt5uwTVbL3ptmjDUQzlSIvWi8Tl7ng1NpuRn1Ng4n14Qc+3Iil7OwkvNWogLSPkn3pihIFytyIGmMhOe3n1tWsuMy9BdKyqF4Z3v2SgggTL9KVvMXPnCbRe+oOuFFP3HejBG/w9gvmfNYvg6JuWia2lcSSN1uIjBktzoIazOHPJZ7kKHPz8mRWVdW3lA8WGF9dQF6Bm673boov3BUWDU2JNcahR23GtfHKLOz/viZ+rYnZFaIznXO67CYEJ1fXuTRpZhYZkKe54xeoagkNGLs+NTZHE0rX45/XvQ2RGADX6vcAvdxIUBV27wxGm2zjZo4X3ILgAlrOFheuZ6wtsvaIj4yLY7qqawlliaIcrz2G+c3vscAnCkCuMzMmZvMfu9lLwTvfX+3cVSyPdN9ZwgDZhfjRgNJcLiJ67b9xx8JHswprbiE3v9UphotAPIgnXVIN5KmMc0piXhc6cChPnN+MRhG9adtdttQTTwSIpl8I4/j//d3sz1326qTBTpPRM/Hgh3kzqEXs8ZAk4ErQhNO8hzrQ0DLkWMA/N+91tn2MdOJnWC2FCZehkQrwzwbKOjhvZsbM95QoeL9skYyMf4srVPVJSgg7pOLUtr/n9eT99oe9nLtFRpjA9okV2Kj8h9k5HaC0oivRD8VyXkJ81tcd4fHNXPCfloIQasxsuO18/46dR2jgul/UIet2G0kRvnyONMKhHs6J26FEoqSqd+rfYjeEGwHWVDpX1fh1jBBcKGMqRepju9Y00mDVHC+Xdij/j44rKfvfjGinNs1jO/0F3jB83XCDINN/HB84axlP+3E/klktRo+vl3U/aiyMJbIodE1XSsDn6UAzIoMtUObY2+k/4gY/l+AkZJ5Sj2vQrkyLm3FoxjhDX+31UXBFf9XrAH31fFqoBmDEZvhvvpnZ87N+oZEu7U9O/nnk+QWj3x8uyoRbEnf+O5UMr9i0nHP38IF5AvzrBW8YWBUR0mIAzIvndQq9N3v/Jto3aPjPXUPl8ASdPPyAp7jENf8bk7VMM9ol9XGmlBmeDMuGqt+WzuL6CXAxXjIhCPM5vACchgMJ/8XBGLO/D1isVvGhwwHHr1DLaI5mn2Jr/b1pUD90uciDaS8cXNDzCWvNmT/PhQe5e8nTnnnkt8Ds/SIjibcum/fqDhKopxAY8AkSrPn+IGDEKOO+U3XOP6djFs2H5N9+orhOahiQk5KnEUWa+CzkVzhp8bMHRbg81qhjjXuIKbHjSLSIBKWqockGtKinY+z4/RdBUF6pcc3JmnlxVcNgrI4SEzKUZSwcD2QCyxzKve+gAmg6ZuSRkpPFa6mfThu7LJNu3H5K42uCpNvPAsoedolKV/LHe/eJ+BbaG5MG0NaSGVPRUmNFMFFSSpXEcXwbVh7UETOZZtoVNRGOIbbkig3McEtR68cG0RZAoJevWYo7Dg/lZ1CQzblWeUvVHmr8fY4Nqd9JJiH/zEX24mJviH60fAyFr0A3c4bC1j3yZU60VgJxXn8JgJXLUIsiBnmKmMYz+7yBQFBvqb2eYnuW59joZBf56/wXvWIR4R8wTmV80i1mZy+S4+BUES+hzjk0uXpC///z/IlqHZ1monzlXp8aCfhGKMti73FI1KbL1q6IKO4fuBuZ59gagjn5xU79muMpHXg6S+e+gDM/U9BKLHbl9l6o8czQKl4RUkJJiqftQG2i3BMg/TQlUYFkJDYBOOvAugYuzYSDnZbDDd/aSd9x0Oe6F+bJcHfl9+gp6L5/TgA+BdFFovbfCrQ40s5vMPw8866pNX8zyFGeFWdxIpPVp9Rg1UPOVFbFZrvaFq/YAzHQgqMWpahMYfqHpmwXfHL1/kpYmGuHFwT55mQu0dylfNuq2Oq0hTMCPwqfxnuBIPLXfci4Y1ANy+1CUipQxld/izVh16WyG2Q0CQQ9NqtAnx1HCHwDj7sYxOSB0wopZSnOzxQOcExmxrVTF2BkOthVpGfuhaGECfCJpJKpjnihY+xOT2QJxN61+9K6QSqtv2Shr82I3jgJrqBg0wELFZPjvHpvzTtaJnLK6Vb97Yn933koO/saN7fsjwNKzp4l2lJVx2orjCGzC/4ZL4zCver6aQYtC5sdoychuFE6ufOiog+VWi5UDkbmvmtah/3aArEBIi39s5ILUnlFLgilcGuz9CQshEY7fw2ouoILAYPVT/gyAIq3TFAIwVsl+ktkRz/qGfnCDGrm5gsl/l9QdvCWGsjPz3dU7XuqKfdUrr/6XIgjp4rey6AJBmCmUJMjITHVdFb5m1p+dLMCL8t55zD42cmftmLEJC0Da04YiRCVUBLLa8D071/N5UBNBXDh0LFsmhV/5B5ExOB4j3WVG/S3lfK5o+V6ELHvy6RR9n4ac+VsK4VE4yphPvV+kG9FegTBH4ZRXL2HytUHCduJazB/KykjfetYxOXTLws267aGOd+I+JhKP//+VnXmS90OD/jvLcVu0asyqcuYN1mSb6XTlCkqv1vigZPIYwNF/zpWcT1GR/6aEIRjkh0yhg4LXJfaGobYJTY4JI58KiAKgmmgAKWdl5nYCeLqavRJGQNuYuZtZFGx+IkI4w4NS2xwbetNMunOjBu/hmKCI/w7tfiiyUd//4rbTeWt4izBY8YvGIN6vyKYmP/8X8wHKCeN+WRcKM70+tXKNGyevU9H2Dg5BsljnTf8YbsJ1TmMs74Ce2XlHisleguhyeg44rQOHZuw/6HTkhnnurK2d62q6yS7210SsAIaR+jXMQA+svkrLpsUY+F30Uw89uOdGAR6vo4FIME0EfVVeHTu6eKicfhSqOeXJhbftcd08sWEnNUL1C9fnprTgd83IMut8onVUF0hvqzZfHduPjbjwEXIcoYmy+P6tcJZHmeOv6VrvEdkHDJecjHuHeWANe79VG662qTjA/HCvumVv3qL+LrOcpqGps2ZGwQdFJ7PU4iuyRlBrwfO+xnPyr47s2cXVbWzAyznDiBGjCM3ksxjjqM62GE9C8f5U38kB3VjtabKp/nRdvMESPGDG90bWRLAt1Qk5DyLuazRR1YzdC1c+hZXvAWV8xA72S4A8B67vjVhbba3MMop293FeEXpe7zItMWrJG/LOH9ByOXmYnNJfjmfuX9KbrpgLOba4nZ+fl8Gbdv/ihv+6wFGKHCYrVwmhFC0J3V2bn2tIB1wCc1CST3d3X2OyxhguXcs4sm679UngzofuSeBewMFJboIQHbUh/m2JhW2hG9DIvG2t7yZIzKBTz9wBtnNC+2pCRYhSIuQ1j8xsz5VvqnyUIthvuoyyu7fNIrg/KQUVmGQaqkqZk/Vx5b33/gsEs8yX7SC1J+NV4icz6bvIE7C5G6McBaI8rVg56q5QBJWxn/87Q1sPK4+sQa8fLU5gXo4paaq4cOcQ4wR0VBHPGjKh+UlPCbA1nLXyEUX45qZ8J7/Ln4FPJE2TdzD0Z8MLSNQiykMMmSyOCiFfy84Rq60emYB2vD09KjYwsoIpeDcBDTElBbXxND72yhd9pC/1CMid/5HUMvAL27OtcIJDzNKpRPNqPOpyt2aPGz9QWIs9hQ9LiX5s8m9hjTUu/f7MyIatjjd+tSfQ3ufZxPpmJhTaBtZtKLUcfOCUqADuO+QoH8B9v6U+P0HV1GLQmtoNFTb3s74ivZgjES0qfK+8RdGgBbcCMSy8eBvh98+et1KIFqSe1KQPyXULBMTsIYnysIwiZBJYdI20vseV+wuJkcqGemehKjaAb9L57xZm3g2zX0bZ2xk/fU+bCo7TlnbW7JuF1YdURo/2Gw7VclDG1W7LOtas2LX4upifZ/23rzpsnY/ALfRgrcWP5hYmV9VxVOQA1fZvp9F2UNU+7d7xRyVm5wiLp3/0dlV7vdw1PMiZrbDAYzIVqEjRY2YU03sJhPnlwIPcZUG5ltL6S8XCxU1eYS5cjr34veBmXAvy7yN4ZjArIG0dfD/5UpBNlX1ZPoxJOwyqRi3wQWtOzd4oNKh0LkoTm8cwqgIfKhqqGOhwo71I+zXnMemTv2B2AUzABWyFztGgGULjDDzWYwJUVBTjKCn5K2QGMK1CQT7SzziOjo+BhAmqBjzuc3xYym2eedGeOIRJVyTwDw37iCMe4g5Vbnsb5ZBdxOAnMT7HU4DHpxWGuQ7GeiY30Cpbvzss55+5Km1YsbD5ea3NI9QNYIXol5apgSu9dZ8f8xS5dtHpido5BclDuLWY4lhik0tbJa07yJhH0BOyEut/GRbYTS6RfiTYWGMCkNpfSHi7HvdiTglEVHKZXaVhezH4kkXiIvKopYAlPusftpE4a5IZwvw1x/eLvoDIh/zpo9FiQInsTb2SAkKHV42XYBjpJDg4374XiVb3ws4qM0s9eSQ5HzsMU4OZJKuopFjBM+dAZEl8RUMx5uU2N486Kr141tVsGQfGjORYMCJAMsxELeNT4RmWjRcpdTGBwcx6XN9drWqPmJzcrGrH4+DRc7+n1w3kPZwu0BkNr6hQrqgo7JTB9A5kdJ/H7P4cWBMwsmuixAzJB3yrQpnGIq90lxAXLzDCdn1LPibsRt7rHNjgQBklRgPZ8vTbjXdgXrTWQsK5MdrXXQVPp0Rinq3frzZKJ0qD6Qhc40VzAraUXlob1gvkhK3vpmHgI6FRlQZNx6eRqkp0zy4AQlX813fAPtL3jMRaitGFFjo0zmErloC+h+YYdVQ6k4F/epxAoF0BmqEoKNTt6j4vQZNQ2BoqF9Vj53TOIoNmDiu9Xp15RkIgQIGcoLpfoIbenzpGUAtqFJp5W+LLnx38jHeECTJ/navKY1NWfN0sY1T8/pB8kIH3DU3DX+u6W3YwpypBMYOhbSxGjq84RZ84fWJow8pyHqn4S/9J15EcCMsXqrfwyd9mhiu3+rEo9pPpoJkdZqHjra4NvzFwuThNKy6hao/SlLw3ZADUcUp3w3SRVfW2rhl80zOgTYnKE0Hs2qp1J6H3xqPqIkvUDRMFDYyRbsFI3M9MEyovPk8rlw7/0a81cDVLmBsR2ze2pBuKb23fbeZC0uXoIvDppfTwIDxk1Oq2dGesGc+oJXWJLGkOha3CX+DUnzgAp9HGH9RsPZN63Hn4RMA5eSVhPHO+9RcRb/IOgtW31V1Q5IPGtoxPjC+MEJbVlIMYADd9aHYWUIQKopuPOHmoqSkubnAKnzgKHqgIOfW5RdAgotN6BN+O2ZYHkuemLnvQ8U9THVrS1RtLmKbcC7PeeDsYznvqzeg6VCNwmr0Yyx1wnLjyT84BZz3EJyCptD3yeueAyDWIs0L2qs/VQ3HUyqfrja0V1LdDzqAikeWuV4sc7RLIB69jEIBjCkyZedoUHqCrOvShVzyd73OdrJW0hPOuQv2qOoHDc9xVb6Yu6uq3Xqp2ZaH46A7lzevbxQEmfrzvAYSJuZ4WDk1Hz3QX1LVdiUK0EvlAGAYlG3Md30r7dcPN63yqBCIj25prpvZP0nI4+EgWoFG95V596CurXpKRBGRjQlHCvy5Ib/iW8nZJWwrET3mgd6mEhfP4KCuaLjopWs7h+MdXFdIv8dHQJgg1xi1eYqB0uDYjxwVmri0Sv5XKut/onqapC+FQiC2C1lvYJ9MVco6yDYsS3AANUfMtvtbYI2hfwZatiSsnoUeMZd34GVjkMMKA+XnjJpXgRW2SHTZplVowPmJsvXy6w3cfO1AK2dvtZEKTkC/TY9LFiKHCG0DnrMQdGm2lzlBHM9iEYynH2UcVMhUEjsc0oDBTgo2ZSQ1gzkAHeWeBXYFjYLuuf8yzTCy7/RFR81WDjXMbq2BOH5dURnxo6oivmxL3cKzKInlZkD31nvpHB9Kk7GfcfE1t+1V64b9LtgeJGlpRFxQCAqWJ5DoY77ski8gsOEOr2uywZaoO/NGa0X0y1pNQHBi3b2SUGNpcZxDT7rLbBf1FSnQ8guxGW3W+36BW0gBje4DOz6Ba6SVk0xiKgt+q2JOFyr4SYfnu+Ic1QZYIuwHBrgzr6UvOcSCzPTOo7D6IC4ISeS7zkl4h+2VoeHpnG/uWR3+ysNgPcOIXQbv0n4mr3BwQcdKJxgPSeyuP/z1Jjg4e9nUvoXegqQVIE30EHx5GHv+FAVUNTowYDJgyFhf5IvlYmEqRif6+WN1MkEJmDcQITx9FX23a4mxy1AQRsOHO/+eImX9l8EMJI3oPWzVXxSOeHU1dUWYr2uAA7AMb+vAEZSbU3qob9ibCyXeypEMpZ6863o6QPqlqGHZkuWABSTVNd4cOh9hv3qEpSx2Zy/DJMP6cItEmiBJ5PFqQnDEIt3NrA3COlOSgz43D7gpNFNJ5MBh4oFzhDPiglC2ypsNU4ISywY2erkyb1NC3Qh/IfWj0eDgZI4/ln8WPfBsT3meTjq1Uqt1E7Zl/qftqkx6aM9KueMCekSnMrcHj1CqTWWzEzPsZGcDe3Ue4Ws+XFYVxNbOFF8ezkvQGR6ZOtOLU2lQEnMBStx47vE6Pb7AYMBRj2OOfZXfisjJnpTfSNjo6sZ6qSvNxZNmDeS7Gk3yYyCk1HtKN2UnhMIjOXUzAqDv90lx9O/q/AT1ZMnit5XQe9wmQxnE/WSH0CqZ9/2Hy+Sfmpeg8RwsHI5Z8kC8H293m/LHVVM/BA7HaTJYg5Enk7M/xWpq0192ACfBai2LA/qrCjCr6Dh1BIMzMXINBmX96MJ5Hn2nxln/RXPFhwHxUmSV0EV2V0jm86/dxxuYSU1W7sVkEbN9EzkG0QFwPhyHKyb3t+Fj5WoUUTErcazE/N6EW6Lvp0d//SDPj7EV9UdJN+Amnf3Wwk3A0SlJ9Z00yvXZ7n3z70G47Hfsow8Wq1JXcfwnA+Yxa5mFsgV464KKP4T31wqIgzFPd3eCe3j5ory5fBF2hgCFyVFrLzI9eetNXvM7oQqyFgDo4CTp/hDV9NMX9JDHQ/nyHTLvZLNLF6ftn2OxjGm8+PqOwhxnPHWipkE/8wbtyri80Sr7pMNkQGMfo4ZYK9OcCC4ESVFFbLMIvlxSoRqWie0wxqnLfcLSXMSpMMQEJYDVObYsXIQNv4TGNwjq1kvT1UOkicTrG3IaBZ3XdScS3u8sgeZPVpOLkbiF940FjbCeNRINNvDbd01EPBrTCPpm12m43ze1bBB59Ia6Ovhnur/Nvx3IxwSWol+3H2qfCJR8df6aQf4v6WiONxkK+IqT4pKQrZK/LplgDI/PJZbOep8dtbV7oCr6CgfpWa8NczOkPx81iSHbsNhVSJBOtrLIMrL31LK9TqHqAbAHe0RLmmV806kRLDLNEhUEJfm9u0sxpkL93Zgd6rw+tqBfTMi59xqXHLXSHwSbSBl0EK0+loECOPtrl+/nsaFe197di4yUgoe4jKoAJDXc6DGDjrQOoFDWZJ9HXwt8xDrQP+7aRwWKWI1GF8s8O4KzxWBBcwnl3vnl1Oez3oh6Ea1vjR7/z7DDTrFtqU2W/KAEzAuXDNZ7MY73MF216dzdSbWmUp4lcm7keJfWaMHgut9x5C9mj66Z0lJ+yhsjVvyiWrfk1lzPOTdhG15Y7gQlXtacvI7qv/XNSscDwqkgwHT/gUsD5yB7LdRRvJxQGYINn9hTpodKFVSTPrtGvyQw+HlRFXIkodErAGu9Iy1YpfSPc3jkFh5CX3lPxv7aqjE/JAfTIpEjGb/H7MO0e2vsViSW1qa/Lmi4/n4DEI3g7lYrcanspDfEpKkdV1OjSLOy0BCUqVoECaB55vs06rXl4jqmLsPsFM/7vYJ0vrBhDCm/00A/H81l1uekJ/6Lml3Hb9+NKiLqATJmDpyzfYZFHumEjC662L0Bwkxi7E9U4cQA0XMVDuMYAIeLMPgQaMVOd8fmt5SflFIfuBoszeAw7ow5gXPE2Y/yBc/7jExARUf/BxIHQBF5Sn3i61w4z5xJdCyO1F1X3+3ax+JSvMeZ7S6QSKp1Fp/sjYz6Z+VgCZzibGeEoujryfMulH7Rai5kAft9ebcW50DyJr2uo2z97mTWIu45YsSnNSMrrNUuG1XsYBtD9TDYzQffKB87vWbkM4EbPAFgoBV4GQS+vtFDUqOFAoi1nTtmIOvg38N4hT2Sn8r8clmBCXspBlMBYTnrqFJGBT3wZOzAyJDre9dHH7+x7qaaKDOB4UQALD5ecS0DE4obubQEiuJZ0EpBVpLuYcce8Aa4PYd/V4DLDAJBYKQPCWTcrEaZ5HYbJi11Gd6hjGom1ii18VHYnG28NKpkz2UKVPxlhYSp8uZr367iOmoy7zsxehW9wzcy2zG0a80PBMCRQMb32hnaHeOR8fnNDzZhaNYhkOdDsBUZ3loDMa1YP0uS0cjUP3b/6DBlqmZOeNABDsLl5BI5QJups8uxAuWJdkUB/pO6Zax6tsg7fN5mjjDgMGngO+DPcKqiHIDbFIGudxtPTIyDi9SFMKBDcfdGQRv41q1AqmxgkVfJMnP8w/Bc7N9/TR6C7mGObFqFkIEom8sKi2xYqJLTCHK7cxzaZvqODo22c3wisBCP4HeAgcRbNPAsBkNRhSmD48dHupdBRw4mIvtS5oeF6zeT1KMCyhMnmhpkFAGWnGscoNkwvQ8ZM5lE/vgTHFYL99OuNxdFBxTEDd5v2qLR8y9WkXsWgG6kZNndFG+pO/UAkOCipqIhL3hq7cRSdrCq7YhUsTocEcnaFa6nVkhnSeRYUA1YO0z5itF9Sly3VlxYDw239TJJH6f3EUfYO5lb7bcFcz8Bp7Oo8QmnsUHOz/fagVUBtKEw1iT88j+aKkv8cscKNkMxjYr8344D1kFoZ7/td1W6LCNYN594301tUGRmFjAzeRg5vyoM1F6+bJZ/Q54jN/k8SFd3DxPTYaAUsivsBfgTn7Mx8H2SpPt4GOdYRnEJOH6jHM2p6SgB0gzIRq6fHxGMmSmqaPCmlfwxiuloaVIitLGN8wie2CDWhkzLoCJcODh7KIOAqbHEvXdUxaS4TTTs07Clzj/6GmVs9kiZDerMxEnhUB6QQPlcfqkG9882RqHoLiHGBoHfQuXIsAG8GTAtao2KVwRnvvam8jo1e312GQAKWEa4sUVEAMG4G6ckcONDwRcg1e2D3+ohXgY4UAWF8wHKQMrSnzCgfFpsxh+aHXMGtPQroQasRY4U6UdG0rz1Vjbka0MekOGRZQEvqQFlxseFor8zWFgHek3v29+WqN6gaK5gZOTOMZzpQIC1201LkMCXild3vWXSc5UX9xcFYfbRPzGFa1FDcPfPB/jUEq/FeGt419CI3YmBlVoHsa4KdcwQP5ZSwHHhFJ7/Ph/Rap/4vmG91eDwPP0lDfCDRCLszTqfzM71xpmiKi2HwS4WlqvGNwtvwF5Dqpn6KTq8ax00UMPkxDcZrEEEsIvHiUXXEphdb4GB4FymlPwBz4Gperqq5pW7TQ6/yNRhW8VT5NhuP0udlxo4gILq5ZxAZk8ZGh3g4CqxJlPKY7AQxupfUcVpWT5VItp1+30UqoyP4wWsRo3olRRgkWZZ2ZN6VC3OZFeXB8NbnUrSdikNptD1QiGuKkr8EmSR/AK9Rw+FF3s5uwuPbvHGiPeFOViltMK7AUaOsq9+x9cndk3iJEE5LKZRlWJbKOZweROzmPNVPkjE3K/TyA57Rs68TkZ3MR8akKpm7cFjnjPd/DdkWjgYoKHSr5Wu5ssoBYU4acRs5g2DHxUmdq8VXOXRbunD8QN0LhgkssgahcdoYsNvuXGUK/KXD/7oFb+VGdhqIn02veuM5bLudJOc2Ky0GMaG4W/xWBxIJcL7yliJOXOpx0AkBqUgzlDczmLT4iILXDxxtRR1oZa2JWFgiAb43obrJnG/TZC2KSK2wqOzRZTXavZZFMb1f3bXvVaNaK828w9TO610gk8JNf3gMfETzXXsbcvRGCG9JWQZ6+cDPqc4466Yo2RcKH+PILeKOqtnlbInR3MmBeGG3FH10yzkybuqEC2HSQwpA0An7d9+73BkDUTm30bZmoP/RGbgFN+GrCOfADgqr0WbI1a1okpFms8iHYw9hm0zUvlEMivBRxModrbJJ+9/p3jUdQQ9BCtQdxnOGrT5dzRUmw0593/mbRSdBg0nRvRZM5/E16m7ZHmDEtWhwvfdZCZ8J8M12W0yRMszXamWfQTwIZ4ayYktrnscQuWr8idp3PjT2eF/jmtdhIfcpMnb+IfZY2FebW6UY/AK3jP4u3Tu4zE4qlnQgLFbM19EBIsNf7KhjdbqQ/D6yiDb+NlEi2SKD+ivXVUK8ib0oBo366gXkR8ZxGjpJIDcEgZPa9TcYe0TIbiPl/rPUQDu3XBJ9X/GNq3FAUsKsll57DzaGMrjcT+gctp+9MLYXCq+sqP81eVQ0r9lt+gcQfZbACRbEjvlMskztZG8gbC8Qn9tt26Q7y7nDrbZq/LEz7kR6Jc6pg3N9rVX8Y5MJrGlML9p9lU4jbTkKqCveeZUJjHB03m2KRKR2TytoFkTXOLg7keU1s1lrPMQJpoOKLuAAC+y1HlJucU6ysB5hsXhvSPPLq5J7JtnqHKZ4vYjC4Vy8153QY+6780xDuGARsGbOs1WqzH0QS765rnSKEbbKlkO8oI/VDwUd0is13tKpqILu1mDJFNy/iJAWcvDgjxvusIT+PGz3ST/J9r9Mtfd0jpaGeiLYIqXc7DiHSS8TcjFVksi66PEkxW1z6ujbLLUGNNYnzOWpH8BZGK4bCK7iR+MbIv8ncDAz1u4StN3vTTzewr9IQjk9wxFxn+6N1ddKs0vffJiS08N3a4G1SVrlZ97Q/M+8G9fe5AP6d9/Qq4WRnORVhofPIKEdCr3llspUfE0oKIIYoByBRPh+bX1HLS3JWGJRhIvE1aW4NTd8ePi4Z+kXb+Z8snYfSNcqijhAgVsx4RCM54cXUiYkjeBmmC4ajOHrChoELscJJC7+9jjMjw5BagZKlgRMiSNYz7h7vvZIoQqbtQmspc0cUk1G/73iXtSpROl5wtLgQi0mW2Ex8i3WULhcggx6E1LMVHUsdc9GHI1PH3U2Ko0PyGdn9KdVOLm7FPBui0i9a0HpA60MsewVE4z8CAt5d401Gv6zXlIT5Ybit1VIA0FCs7wtvYreru1fUyW3oLAZ/+aTnZrOcYRNVA8spoRtlRoWflsRClFcgzkqiHOrf0/SVw+EpVaFlJ0g4Kxq1MMOmiQdpMNpte8lMMQqm6cIFXlnGbfJllysKDi+0JJMotkqgIxOSQgU9dn/lWkeVf8nUm3iwX2Nl3WDw9i6AUK3vBAbZZrcJpDQ/N64AVwjT07Jef30GSSmtNu2WlW7YoyW2FlWfZFQUwk867EdLYKk9VG6JgEnBiBxkY7LMo4YLQJJlAo9l/oTvJkSARDF/XtyAzM8O2t3eT/iXa6wDN3WewNmQHdPfsxChU/KtLG2Mn8i4ZqKdSlIaBZadxJmRzVS/o4yA65RTSViq60oa395Lqw0pzY4SipwE0SXXsKV+GZraGSkr/RW08wPRvqvSUkYBMA9lPx4m24az+IHmCbXA+0faxTRE9wuGeO06DIXa6QlKJ3puIyiuAVfPr736vzo2pBirS+Vxel3TMm3JKhz9o2ZoRvaFVpIkykb0Hcm4oHFBMcNSNj7/4GJt43ogonY2Vg4nsDQIWxAcorpXACzgBqQPjYsE/VUpXpwNManEru4NwMCFPkXvMoqvoeLN3qyu/N1eWEHttMD65v19l/0kH2mR35iv/FI+yjoHJ9gPMz67af3Mq/BoWXqu3rphiWMXVkmnPSEkpGpUI2h1MThideGFEOK6YZHPwYzMBvpNC7+ZHxPb7epfefGyIB4JzO9DTNEYnDLVVHdQyvOEVefrk6Uv5kTQYVYWWdqrdcIl7yljwwIWdfQ/y+2QB3eR/qxYObuYyB4gTbo2in4PzarU1sO9nETkmj9/AoxDA+JM3GMqQtJR4jtduHtnoCLxd1gQUscHRB/MoRYIEsP2pDZ9KvHgtlk1iTbWWbHhohwFEYX7y51fUV2nuUmnoUcqnWIQAAgl9LTVX+Bc0QGNEhChxHR4YjfE51PUdGfsSFE6ck7BL3/hTf9jLq4G1IafINxOLKeAtO7quulYvH5YOBc+zX7CrMgWnW47/jfRsWnJjYYoE7xMfWV2HN2iyIqLI";
const MG = new Map([
        [8217, "apostrophe"],
        [8260, "fraction slash"],
        [12539, "middle dot"]
    ]),
    DG = 4;

function KOe(t) {
    let e = 0;

    function n() {
        return t[e++] << 8 | t[e++]
    }
    let r = n(),
        i = 1,
        s = [0, 1];
    for (let P = 1; P < r; P++) s.push(i += n());
    let o = n(),
        a = e;
    e += o;
    let l = 0,
        c = 0;

    function u() {
        return l == 0 && (c = c << 8 | t[e++], l = 8), c >> --l & 1
    }
    const f = 31,
        h = 2 ** f,
        g = h >>> 1,
        y = g >> 1,
        _ = h - 1;
    let C = 0;
    for (let P = 0; P < f; P++) C = C << 1 | u();
    let b = [],
        w = 0,
        S = h;
    for (;;) {
        let P = Math.floor(((C - w + 1) * i - 1) / S),
            M = 0,
            A = r;
        for (; A - M > 1;) {
            let H = M + A >>> 1;
            P < s[H] ? A = H : M = H
        }
        if (M == 0) break;
        b.push(M);
        let E = w + Math.floor(S * s[M] / i),
            $ = w + Math.floor(S * s[M + 1] / i) - 1;
        for (; !((E ^ $) & g);) C = C << 1 & _ | u(), E = E << 1 & _, $ = $ << 1 & _ | 1;
        for (; E & ~$ & y;) C = C & g | C << 1 & _ >>> 1 | u(), E = E << 1 ^ g, $ = ($ ^ g) << 1 | g | 1;
        w = E, S = 1 + $ - E
    }
    let I = r - 4;
    return b.map(P => {
        switch (P - I) {
            case 3:
                return I + 65792 + (t[a++] << 16 | t[a++] << 8 | t[a++]);
            case 2:
                return I + 256 + (t[a++] << 8 | t[a++]);
            case 1:
                return I + t[a++];
            default:
                return P - 1
        }
    })
}

function YOe(t) {
    let e = 0;
    return () => t[e++]
}

function Hre(t) {
    return YOe(KOe(ZOe(t)))
}

function ZOe(t) {
    let e = [];
    [..."ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"].forEach((i, s) => e[i.charCodeAt(0)] = s);
    let n = t.length,
        r = new Uint8Array(6 * n >> 3);
    for (let i = 0, s = 0, o = 0, a = 0; i < n; i++) a = a << 6 | e[t.charCodeAt(i)], o += 6, o >= 8 && (r[s++] = a >> (o -= 8));
    return r
}

function QOe(t) {
    return t & 1 ? ~t >> 1 : t >> 1
}

function JOe(t, e) {
    let n = Array(t);
    for (let r = 0, i = 0; r < t; r++) n[r] = i += QOe(e());
    return n
}

function J_(t, e = 0) {
    let n = [];
    for (;;) {
        let r = t(),
            i = t();
        if (!i) break;
        e += r;
        for (let s = 0; s < i; s++) n.push(e + s);
        e += i + 1
    }
    return n
}

function zre(t) {
    return X_(() => {
        let e = J_(t);
        if (e.length) return e
    })
}

function Wre(t) {
    let e = [];
    for (;;) {
        let n = t();
        if (n == 0) break;
        e.push(XOe(n, t))
    }
    for (;;) {
        let n = t() - 1;
        if (n < 0) break;
        e.push(eNe(n, t))
    }
    return e.flat()
}

function X_(t) {
    let e = [];
    for (;;) {
        let n = t(e.length);
        if (!n) break;
        e.push(n)
    }
    return e
}

function Vre(t, e, n) {
    let r = Array(t).fill().map(() => []);
    for (let i = 0; i < e; i++) JOe(t, n).forEach((s, o) => r[o].push(s));
    return r
}

function XOe(t, e) {
    let n = 1 + e(),
        r = e(),
        i = X_(e);
    return Vre(i.length, 1 + t, e).flatMap((o, a) => {
        let [l, ...c] = o;
        return Array(i[a]).fill().map((u, f) => {
            let h = f * r;
            return [l + f * n, c.map(g => g + h)]
        })
    })
}

function eNe(t, e) {
    let n = 1 + e();
    return Vre(n, 1 + t, e).map(i => [i[0], i.slice(1)])
}

function tNe(t) {
    let e = [],
        n = J_(t);
    return i(r([]), []), e;

    function r(s) {
        let o = t(),
            a = X_(() => {
                let l = J_(t).map(c => n[c]);
                if (l.length) return r(l)
            });
        return {
            S: o,
            B: a,
            Q: s
        }
    }

    function i({
        S: s,
        B: o
    }, a, l) {
        if (!(s & 4 && l === a[a.length - 1])) {
            s & 2 && (l = a[a.length - 1]), s & 1 && e.push(a);
            for (let c of o)
                for (let u of c.Q) i(c, [...a, u], l)
        }
    }
}

function nNe(t) {
    return t.toString(16).toUpperCase().padStart(2, "0")
}

function Gre(t) {
    return `{${nNe(t)}}`
}

function rNe(t) {
    let e = [];
    for (let n = 0, r = t.length; n < r;) {
        let i = t.codePointAt(n);
        n += i < 65536 ? 1 : 2, e.push(i)
    }
    return e
}

function Yb(t) {
    let n = t.length;
    if (n < 4096) return String.fromCodePoint(...t);
    let r = [];
    for (let i = 0; i < n;) r.push(String.fromCodePoint(...t.slice(i, i += 4096)));
    return r.join("")
}

function iNe(t, e) {
    let n = t.length,
        r = n - e.length;
    for (let i = 0; r == 0 && i < n; i++) r = t[i] - e[i];
    return r
}
var sNe = "AEUDTAHBCFQATQDRADAAcgAgADQAFAAsABQAHwAOACQADQARAAoAFwAHABIACAAPAAUACwAFAAwABAAQAAMABwAEAAoABQAIAAIACgABAAQAFAALAAIACwABAAIAAQAHAAMAAwAEAAsADAAMAAwACgANAA0AAwAKAAkABAAdAAYAZwDSAdsDJgC0CkMB8xhZAqfoC190UGcThgBurwf7PT09Pb09AjgJum8OjDllxHYUKXAPxzq6tABAxgK8ysUvWAgMPT09PT09PSs6LT2HcgWXWwFLoSMEEEl5RFVMKvO0XQ8ExDdJMnIgsj26PTQyy8FfEQ8AY8IPAGcEbwRwBHEEcgRzBHQEdQR2BHcEeAR6BHsEfAR+BIAEgfndBQoBYgULAWIFDAFiBNcE2ATZBRAFEQUvBdALFAsVDPcNBw13DYcOMA4xDjMB4BllHI0B2grbAMDpHLkQ7QHVAPRNQQFnGRUEg0yEB2uaJF8AJpIBpob5AERSMAKNoAXqaQLUBMCzEiACnwRZEkkVsS7tANAsBG0RuAQLEPABv9HICTUBXigPZwRBApMDOwAamhtaABqEAY8KvKx3LQ4ArAB8UhwEBAVSagD8AEFZADkBIadVj2UMUgx5Il4ANQC9AxIB1BlbEPMAs30CGxlXAhwZKQIECBc6EbsCoxngzv7UzRQA8M0BawL6ZwkN7wABAD33OQRcsgLJCjMCjqUChtw/km+NAsXPAoP2BT84PwURAK0RAvptb6cApQS/OMMey5HJS84UdxpxTPkCogVFITaTOwERAK5pAvkNBOVyA7q3BKlOJSALAgUIBRcEdASpBXqzABXFSWZOawLCOqw//AolCZdvv3dSBkEQGyelEPcMMwG1ATsN7UvYBPEGOwTJH30ZGQ/NlZwIpS3dDO0m4y6hgFoj9SqDBe1L9DzdC01RaA9ZC2UJ4zpjgU4DIQENIosK3Q05CG0Q8wrJaw3lEUUHOQPVSZoApQcBCxEdNRW1JhBirAsJOXcG+xr2C48mrxMpevwF0xohBk0BKRr/AM8u54WwWjFcHE9fBgMLJSPHFKhQIA0lQLd4SBobBxUlqQKRQ3BKh1E2HpMh9jw9DWYuE1F8B/U8BRlPC4E8nkarRQ4R0j6NPUgiSUwsBDV/LC8niwnPD4UMuXxyAVkJIQmxDHETMREXN8UIOQcZLZckJxUIIUaVYJoE958D8xPRAwsFPwlBBxMDtRwtEy4VKQUNgSTXAvM21S6zAo9WgAEXBcsPJR/fEFBH4A7pCJsCZQODJesALRUhABcimwhDYwBfj9hTBS7LCMdqbCN0A2cU52ERcweRDlcHpxwzFb8c4XDIXguGCCijrwlbAXUJmQFfBOMICTVbjKAgQWdTi1gYmyBhQT9d/AIxDGUVn0S9h3gCiw9rEhsBNQFzBzkNAQJ3Ee0RaxCVCOuGBDW1M/g6JQRPIYMgEQonA09szgsnJvkM+GkBoxJiAww0PXfuZ6tgtiQX/QcZMsVBYCHxC5JPzQycGsEYQlQuGeQHvwPzGvMn6kFXBf8DowMTOk0z7gS9C2kIiwk/AEkOoxcH1xhqCnGM0AExiwG3mQNXkYMCb48GNwcLAGcLhwV55QAdAqcIowAFAM8DVwA5Aq0HnQAZAIVBAT0DJy8BIeUCjwOTCDHLAZUvAfMpBBvDDBUA9zduSgLDsQKAamaiBd1YAo4CSTUBTSUEBU5HUQOvceEA2wBLBhPfRwEVq0rLGuNDAd9vKwDHAPsABTUHBUEBzQHzbQC3AV8LMQmis7UBTekpAIMAFWsB1wKJAN0ANQB/8QFTAE0FWfkF0wJPSQERMRgrV2EBuwMfATMBDQB5BsuNpckHHwRtB9MCEBsV4QLvLge1AQMi3xPNQsUCvd5VoWACZIECYkJbTa9bNyACofcCaJgCZgkCn4Q4GwsCZjsCZiYEbgR/A38TA36SOQY5dxc5gjojIwJsHQIyNjgKAm3HAm2u74ozZ0UrAWcA3gDhAEoFB5gMjQD+C8IADbUCdy8CdqI/AnlLQwJ4uh1c20WuRtcCfD8CesgCfQkCfPAFWQUgSABIfWMkAoFtAoAAAoAFAn+uSVhKWxUXSswC0QEC0MxLJwOITwOH5kTFkTIC8qFdAwMDrkvOTC0lA89NTE2vAos/AorYwRsHHUNnBbcCjjcCjlxAl4ECjtkCjlx4UbRTNQpS1FSFApP7ApMMAOkAHFUeVa9V0AYsGymVhjLheGZFOzkCl58C77JYIagAWSUClo8ClnycAKlZrFoJgU0AOwKWtQKWTlxEXNECmcsCmWRcyl0HGQKcmznCOp0CnBYCn5sCnriKAB0PMSoPAp3xAp6SALU9YTRh7wKe0wKgbgGpAp6fHwKeTqVjyGQnJSsCJ68CJn4CoPsCoEwCot0CocQCpi8Cpc4Cp/8AfQKn8mh8aLEAA0lqHGrRAqzjAqyuAq1nAq0CAlcdAlXcArHh1wMfTmyXArK9DQKy6Bds4G1jbUhfAyXNArZcOz9ukAMpRQK4XgK5RxUCuSp3cDZw4QK9GQK72nCWAzIRAr6IcgIDM3ECvhpzInNPAsPLAsMEc4J0SzVFdOADPKcDPJoDPb8CxXwCxkcCxhCJAshpUQLIRALJTwLJLgJknQLd0nh5YXiueSVL0AMYo2cCAmH0GfOVJHsLXpJeuxECz2sCz2wvS1PS8xOfAMatAs9zASnqA04SfksFAtwnAtuKAtJPA1JcA1NfAQEDVYyAiT8AyxbtYEWCHILTgs6DjQLaxwLZ3oQQhEmnPAOGpQAvA2QOhnFZ+QBVAt9lAt64c3cC4i/tFAHzMCcB9JsB8tKHAuvzAulweQLq+QLq5AD5RwG5Au6JAuuclqqXAwLuPwOF4Jh5cOBxoQLzAwBpA44WmZMC9xMDkW4DkocC95gC+dkC+GaaHJqruzebHgOdgwL++gEbADmfHJ+zAwWNA6ZqA6bZANHFAwZqoYiiBQkDDEkCwAA/AwDhQRdTARHzA2sHl2cFAJMtK7evvdsBiZkUfxEEOQH7KQUhDp0JnwCS/SlXxQL3AZ0AtwW5AG8LbUEuFCaNLgFDAYD8AbUmAHUDDgRtACwCFgyhAAAKAj0CagPdA34EkQEgRQUhfAoABQBEABMANhICdwEABdUDa+8KxQIA9wqfJ7+xt+UBkSFBQgHpFH8RNMCJAAQAGwBaAkUChIsABjpTOpSNbQC4Oo860ACNOME63AClAOgAywE6gTo7Ofw5+Tt2iTpbO56JOm85GAFWATMBbAUvNV01njWtNWY1dTW2NcU1gjWRNdI14TWeNa017jX9NbI1wTYCNhE1xjXVNhY2JzXeNe02LjY9Ni41LSE2OjY9Njw2yTcIBJA8VzY4Nt03IDcPNsogN4k3MAoEsDxnNiQ3GTdsOo03IULUQwdC4EMLHA8PCZsobShRVQYA6X8A6bABFCnXAukBowC9BbcAbwNzBL8MDAMMAQgDAAkKCwsLCQoGBAVVBI/DvwDz9b29kaUCb0QtsRTNLt4eGBcSHAMZFhYZEhYEARAEBUEcQRxBHEEcQRxBHEEaQRxBHEFCSTxBPElISUhBNkM2QTYbNklISVmBVIgBFLWZAu0BhQCjBcEAbykBvwGJAaQcEZ0ePCklMAAhMvAIMAL54gC7Bm8EescjzQMpARQpKgDUABavAj626xQAJP0A3etzuf4NNRA7efy2Z9NQrCnC0OSyANz5BBIbJ5IFDR6miIavYS6tprjjmuKebxm5C74Q225X1pkaYYPb6f1DK4k3xMEBb9S2WMjEibTNWhsRJIA+vwNVEiXTE5iXs/wezV66oFLfp9NZGYW+Gk19J2+bCT6Ye2w6LDYdgzKMUabk595eLBCXANz9HUpWbATq9vqXVx9XDg+Pc9Xp4+bsS005SVM/BJBM4687WUuf+Uj9dEi8aDNaPxtpbDxcG1THTImUMZq4UCaaNYpsVqraNyKLJXDYsFZ/5jl7bLRtO88t7P3xZaAxhb5OdPMXqsSkp1WCieG8jXm1U99+blvLlXzPCS+M93VnJCiK+09LfaSaBAVBomyDgJua8dfUzR7ga34IvR2Nvj+A9heJ6lsl1KG4NkI1032Cnff1m1wof2B9oHJK4bi6JkEdSqeNeiuo6QoZZincoc73/TH9SXF8sCE7XyuYyW8WSgbGFCjPV0ihLKhdPs08Tx82fYAkLLc4I2wdl4apY7GU5lHRFzRWJep7Ww3wbeA3qmd59/86P4xuNaqDpygXt6M85glSBHOCGgJDnt+pN9bK7HApMguX6+06RZNjzVmcZJ+wcUrJ9//bpRNxNuKpNl9uFds+S9tdx7LaM5ZkIrPj6nIU9mnbFtVbs9s/uLgl8MVczAwet+iOEzzBlYW7RCMgE6gyNLeq6+1tIx4dpgZnd0DksJS5f+JNDpwwcPNXaaVspq1fbQajOrJgK0ofKtJ1Ne90L6VO4MOl5S886p7u6xo7OLjG8TGL+HU1JXGJgppg4nNbNJ5nlzSpuPYy21JUEcUA94PoFiZfjZue+QnyQ80ekOuZVkxx4g+cvhJfHgNl4hy1/a6+RKcKlar/J29y//EztlbVPHVUeQ1zX86eQVAjR/M3dA9w4W8LfaXp4EgM85wOWasli837PzVMOnsLzR+k3o75/lRPAJSE1xAKQzEi5v10ke+VBvRt1cwQRMd+U5mLCTGVd6XiZtgBG5cDi0w22GKcVNvHiu5LQbZEDVtz0onn7k5+heuKXVsZtSzilkLRAUmjMXEMB3J9YC50XBxPiz53SC+EhnPl9WsKCv92SM/OFFIMJZYfl0WW8tIO3UxYcwdMAj7FSmgrsZ2aAZO03BOhP1bNNZItyXYQFTpC3SG1VuPDqH9GkiCDmE+JwxyIVSO5siDErAOpEXFgjy6PQtOVDj+s6e1r8heWVvmZnTciuf4EiNZzCAd7SOMhXERIOlsHIMG399i9aLTy3m2hRLZjJVDNLS53iGIK11dPqQt0zBDyg6qc7YqkDm2M5Ve6dCWCaCbTXX2rToaIgz6+zh4lYUi/+6nqcFMAkQJKHYLK0wYk5N9szV6xihDbDDFr45lN1K4aCXBq/FitPSud9gLt5ZVn+ZqGX7cwm2z5EGMgfFpIFyhGGuDPmso6TItTMwny+7uPnLCf4W6goFQFV0oQSsc9VfMmVLcLr6ZetDZbaSFTLqnSO/bIPjA3/zAUoqgGFAEQS4IhuMzEp2I3jJzbzkk/IEmyax+rhZTwd6f+CGtwPixu8IvzACquPWPREu9ZvGkUzpRwvRRuaNN6cr0W1wWits9ICdYJ7ltbgMiSL3sTPeufgNcVqMVWFkCPDH4jG2jA0XcVgQj62Cb29v9f/z/+2KbYvIv/zzjpQAPkliaVDzNrW57TZ/ZOyZD0nlfMmAIBIAGAI0D3k/mdN4xr9v85ZbZbbqfH2jGd5hUqNZWwl5SPfoGmfElmazUIeNL1j/mkF7VNAzTq4jNt8JoQ11NQOcmhprXoxSxfRGJ9LDEOAQ+dmxAQH90iti9e2u/MoeuaGcDTHoC+xsmEeWmxEKefQuIzHbpw5Tc5cEocboAD09oipWQhtTO1wivf/O+DRe2rpl/E9wlrzBorjJsOeG1B/XPW4EaJEFdNlECEZga5ZoGRHXgYouGRuVkm8tDESiEyFNo+3s5M5puSdTyUL2llnINVHEt91XUNW4ewdMgJ4boJfEyt/iY5WXqbA+A2Fkt5Z0lutiWhe9nZIyIUjyXDC3UsaG1t+eNx6z4W/OYoTB7A6x+dNSTOi9AInctbESqm5gvOLww7OWXPrmHwVZasrl4eD113pm+JtT7JVOvnCXqdzzdTRHgJ0PiGTFYW5Gvt9R9LD6Lzfs0v/TZZHSmyVNq7viIHE6DBK7Qp07Iz55EM8SYtQvZf/obBniTWi5C2/ovHfw4VndkE5XYdjOhCMRjDeOEfXeN/CwfGduiUIfsoFeUxXeQXba7c7972XNv8w+dTjjUM0QeNAReW+J014dKAD/McQYXT7c0GQPIkn3Ll6R7gGjuiQoZD0TEeEqQpKoZ15g/0OPQI17QiSv9AUROa/V/TQN3dvLArec3RrsYlvBm1b8LWzltdugsC50lNKYLEp2a+ZZYqPejULRlOJh5zj/LVMyTDvwKhMxxwuDkxJ1QpoNI0OTWLom4Z71SNzI9TV1iXJrIu9Wcnd+MCaAw8o1jSXd94YU/1gnkrC9BUEOtQvEIQ7g0i6h+KL2JKk8Ydl7HruvgWMSAmNe+LshGhV4qnWHhO9/RIPQzY1tHRj2VqOyNsDpK0cww+56AdDC4gsWwY0XxoucIWIqs/GcwnWqlaT0KPr8mbK5U94/301i1WLt4YINTVvCFBrFZbIbY8eycOdeJ2teD5IfPLCRg7jjcFTwlMFNl9zdh/o3E/hHPwj7BWg0MU09pPrBLbrCgm54A6H+I6v27+jL5gkjWg/iYdks9jbfVP5y/n0dlgWEMlKasl7JvFZd56LfybW1eeaVO0gxTfXZwD8G4SI116yx7UKVRgui6Ya1YpixqXeNLc8IxtAwCU5IhwQgn+NqHnRaDv61CxKhOq4pOX7M6pkA+Pmpd4j1vn6ACUALoLLc4vpXci8VidLxzm7qFBe7s+quuJs6ETYmnpgS3LwSZxPIltgBDXz8M1k/W2ySNv2f9/NPhxLGK2D21dkHeSGmenRT3Yqcdl0m/h3OYr8V+lXNYGf8aCCpd4bWjE4QIPj7vUKN4Nrfs7ML6Y2OyS830JCnofg/k7lpFpt4SqZc5HGg1HCOrHvOdC8bP6FGDbE/VV0mX4IakzbdS/op+Kt3G24/8QbBV7y86sGSQ/vZzU8FXs7u6jIvwchsEP2BpIhW3G8uWNwa3HmjfH/ZjhhCWvluAcF+nMf14ClKg5hGgtPLJ98ueNAkc5Hs2WZlk2QHvfreCK1CCGO6nMZVSb99VM/ajr8WHTte9JSmkXq/i/U943HEbdzW6Re/S88dKgg8pGOLlAeNiqrcLkUR3/aClFpMXcOUP3rmETcWSfMXZE3TUOi8i+fqRnTYLflVx/Vb/6GJ7eIRZUA6k3RYR3iFSK9c4iDdNwJuZL2FKz/IK5VimcNWEqdXjSoxSgmF0UPlDoUlNrPcM7ftmA8Y9gKiqKEHuWN+AZRIwtVSxye2Kf8rM3lhJ5XcBXU9n4v0Oy1RU2M+4qM8AQPVwse8ErNSob5oFPWxuqZnVzo1qB/IBxkM3EVUKFUUlO3e51259GgNcJbCmlvrdjtoTW7rChm1wyCKzpCTwozUUEOIcWLneRLgMXh+SjGSFkAllzbGS5HK7LlfCMRNRDSvbQPjcXaenNYxCvu2Qyznz6StuxVj66SgI0T8B6/sfHAJYZaZ78thjOSIFumNWLQbeZixDCCC+v0YBtkxiBB3jefHqZ/dFHU+crbj6OvS1x/JDD7vlm7zOVPwpUC01nhxZuY/63E7g";
const e6 = 44032,
    MC = 4352,
    DC = 4449,
    $C = 4519,
    qre = 19,
    Kre = 21,
    Zb = 28,
    LC = Kre * Zb,
    oNe = qre * LC,
    aNe = e6 + oNe,
    lNe = MC + qre,
    cNe = DC + Kre,
    uNe = $C + Zb;

function S3(t) {
    return t >> 24 & 255
}

function Yre(t) {
    return t & 16777215
}
let Dk, $G, $k, n8;

function fNe() {
    let t = Hre(sNe);
    Dk = new Map(zre(t).flatMap((e, n) => e.map(r => [r, n + 1 << 24]))), $G = new Set(J_(t)), $k = new Map, n8 = new Map;
    for (let [e, n] of Wre(t)) {
        if (!$G.has(e) && n.length == 2) {
            let [r, i] = n, s = n8.get(r);
            s || (s = new Map, n8.set(r, s)), s.set(i, e)
        }
        $k.set(e, n.reverse())
    }
}

function Zre(t) {
    return t >= e6 && t < aNe
}

function dNe(t, e) {
    if (t >= MC && t < lNe && e >= DC && e < cNe) return e6 + (t - MC) * LC + (e - DC) * Zb;
    if (Zre(t) && e > $C && e < uNe && (t - e6) % Zb == 0) return t + (e - $C); {
        let n = n8.get(t);
        return n && (n = n.get(e), n) ? n : -1
    }
}

function Qre(t) {
    Dk || fNe();
    let e = [],
        n = [],
        r = !1;

    function i(s) {
        let o = Dk.get(s);
        o && (r = !0, s |= o), e.push(s)
    }
    for (let s of t)
        for (;;) {
            if (s < 128) e.push(s);
            else if (Zre(s)) {
                let o = s - e6,
                    a = o / LC | 0,
                    l = o % LC / Zb | 0,
                    c = o % Zb;
                i(MC + a), i(DC + l), c > 0 && i($C + c)
            } else {
                let o = $k.get(s);
                o ? n.push(...o) : i(s)
            }
            if (!n.length) break;
            s = n.pop()
        }
    if (r && e.length > 1) {
        let s = S3(e[0]);
        for (let o = 1; o < e.length; o++) {
            let a = S3(e[o]);
            if (a == 0 || s <= a) {
                s = a;
                continue
            }
            let l = o - 1;
            for (;;) {
                let c = e[l + 1];
                if (e[l + 1] = e[l], e[l] = c, !l || (s = S3(e[--l]), s <= a)) break
            }
            s = S3(e[o])
        }
    }
    return e
}

function hNe(t) {
    let e = [],
        n = [],
        r = -1,
        i = 0;
    for (let s of t) {
        let o = S3(s),
            a = Yre(s);
        if (r == -1) o == 0 ? r = a : e.push(a);
        else if (i > 0 && i >= o) o == 0 ? (e.push(r, ...n), n.length = 0, r = a) : n.push(a), i = o;
        else {
            let l = dNe(r, a);
            l >= 0 ? r = l : i == 0 && o == 0 ? (e.push(r), r = a) : (n.push(a), i = o)
        }
    }
    return r >= 0 && e.push(r, ...n), e
}

function Jre(t) {
    return Qre(t).map(Yre)
}

function pNe(t) {
    return hNe(Qre(t))
}
const LG = 45,
    Xre = ".",
    eie = 65039,
    tie = 1,
    BC = t => Array.from(t);

function t6(t, e) {
    return t.P.has(e) || t.Q.has(e)
}
class gNe extends Array {
    get is_emoji() {
        return !0
    }
}
let Lk, nie, d1, Bk, rie, ov, _O, _w, Vg, BG, Fk;

function NL() {
    if (Lk) return;
    let t = Hre(qOe);
    const e = () => J_(t),
        n = () => new Set(e()),
        r = (u, f) => f.forEach(h => u.add(h));
    Lk = new Map(Wre(t)), nie = n(), d1 = e(), Bk = new Set(e().map(u => d1[u])), d1 = new Set(d1), rie = n(), n();
    let i = zre(t),
        s = t();
    const o = () => {
        let u = new Set;
        return e().forEach(f => r(u, i[f])), r(u, e()), u
    };
    ov = X_(u => {
        let f = X_(t).map(h => h + 96);
        if (f.length) {
            let h = u >= s;
            f[0] -= 32, f = Yb(f), h && (f = `Restricted[${f}]`);
            let g = o(),
                y = o(),
                _ = !t();
            return {
                N: f,
                P: g,
                Q: y,
                M: _,
                R: h
            }
        }
    }), _O = n(), _w = new Map;
    let a = e().concat(BC(_O)).sort((u, f) => u - f);
    a.forEach((u, f) => {
        let h = t(),
            g = a[f] = h ? a[f - h] : {
                V: [],
                M: new Map
            };
        g.V.push(u), _O.has(u) || _w.set(u, g)
    });
    for (let {
            V: u,
            M: f
        } of new Set(_w.values())) {
        let h = [];
        for (let y of u) {
            let _ = ov.filter(b => t6(b, y)),
                C = h.find(({
                    G: b
                }) => _.some(w => b.has(w)));
            C || (C = {
                G: new Set,
                V: []
            }, h.push(C)), C.V.push(y), r(C.G, _)
        }
        let g = h.flatMap(y => BC(y.G));
        for (let {
                G: y,
                V: _
            } of h) {
            let C = new Set(g.filter(b => !y.has(b)));
            for (let b of _) f.set(b, C)
        }
    }
    Vg = new Set;
    let l = new Set;
    const c = u => Vg.has(u) ? l.add(u) : Vg.add(u);
    for (let u of ov) {
        for (let f of u.P) c(f);
        for (let f of u.Q) c(f)
    }
    for (let u of Vg) !_w.has(u) && !l.has(u) && _w.set(u, tie);
    r(Vg, Jre(Vg)), BG = tNe(t).map(u => gNe.from(u)).sort(iNe), Fk = new Map;
    for (let u of BG) {
        let f = [Fk];
        for (let h of u) {
            let g = f.map(y => {
                let _ = y.get(h);
                return _ || (_ = new Map, y.set(h, _)), _
            });
            h === eie ? f.push(...g) : f = g
        }
        for (let h of f) h.V = u
    }
}

function PL(t) {
    return (iie(t) ? "" : `${kL(e9([t]))} `) + Gre(t)
}

function kL(t) {
    return `"${t}"`
}

function mNe(t) {
    if (t.length >= 4 && t[2] == LG && t[3] == LG) throw new Error(`invalid label extension: "${Yb(t.slice(0,4))}"`)
}

function yNe(t) {
    for (let n = t.lastIndexOf(95); n > 0;)
        if (t[--n] !== 95) throw new Error("underscore allowed only at start")
}

function wNe(t) {
    let e = t[0],
        n = MG.get(e);
    if (n) throw W3(`leading ${n}`);
    let r = t.length,
        i = -1;
    for (let s = 1; s < r; s++) {
        e = t[s];
        let o = MG.get(e);
        if (o) {
            if (i == s) throw W3(`${n} + ${o}`);
            i = s + 1, n = o
        }
    }
    if (i == r) throw W3(`trailing ${n}`)
}

function e9(t, e = 1 / 0, n = Gre) {
    let r = [];
    vNe(t[0]) && r.push(""), t.length > e && (e >>= 1, t = [...t.slice(0, e), 8230, ...t.slice(-e)]);
    let i = 0,
        s = t.length;
    for (let o = 0; o < s; o++) {
        let a = t[o];
        iie(a) && (r.push(Yb(t.slice(i, o))), r.push(n(a)), i = o + 1)
    }
    return r.push(Yb(t.slice(i, s))), r.join("")
}

function vNe(t) {
    return NL(), d1.has(t)
}

function iie(t) {
    return NL(), rie.has(t)
}

function bNe(t) {
    return SNe(_Ne(t, pNe, TNe))
}

function _Ne(t, e, n) {
    if (!t) return [];
    NL();
    let r = 0;
    return t.split(Xre).map(i => {
        let s = rNe(i),
            o = {
                input: s,
                offset: r
            };
        r += s.length + 1;
        try {
            let a = o.tokens = ANe(s, e, n),
                l = a.length,
                c;
            if (!l) throw new Error("empty label");
            let u = o.output = a.flat();
            if (yNe(u), !(o.emoji = l > 1 || a[0].is_emoji) && u.every(h => h < 128)) mNe(u), c = "ASCII";
            else {
                let h = a.flatMap(g => g.is_emoji ? [] : g);
                if (!h.length) c = "Emoji";
                else {
                    if (d1.has(u[0])) throw W3("leading combining mark");
                    for (let _ = 1; _ < l; _++) {
                        let C = a[_];
                        if (!C.is_emoji && d1.has(C[0])) throw W3(`emoji + combining mark: "${Yb(a[_-1])} + ${e9([C[0]])}"`)
                    }
                    wNe(u);
                    let g = BC(new Set(h)),
                        [y] = xNe(g);
                    CNe(y, h), ENe(y, g), c = y.N
                }
            }
            o.type = c
        } catch (a) {
            o.error = a
        }
        return o
    })
}

function ENe(t, e) {
    let n, r = [];
    for (let i of e) {
        let s = _w.get(i);
        if (s === tie) return;
        if (s) {
            let o = s.M.get(i);
            if (n = n ? n.filter(a => o.has(a)) : BC(o), !n.length) return
        } else r.push(i)
    }
    if (n) {
        for (let i of n)
            if (r.every(s => t6(i, s))) throw new Error(`whole-script confusable: ${t.N}/${i.N}`)
    }
}

function xNe(t) {
    let e = ov;
    for (let n of t) {
        let r = e.filter(i => t6(i, n));
        if (!r.length) throw ov.some(i => t6(i, n)) ? oie(e[0], n) : sie(n);
        if (e = r, r.length == 1) break
    }
    return e
}

function SNe(t) {
    return t.map(({
        input: e,
        error: n,
        output: r
    }) => {
        if (n) {
            let i = n.message;
            throw new Error(t.length == 1 ? i : `Invalid label ${kL(e9(e,63))}: ${i}`)
        }
        return Yb(r)
    }).join(Xre)
}

function sie(t) {
    return new Error(`disallowed character: ${PL(t)}`)
}

function oie(t, e) {
    let n = PL(e),
        r = ov.find(i => i.P.has(e));
    return r && (n = `${r.N} ${n}`), new Error(`illegal mixture: ${t.N} + ${n}`)
}

function W3(t) {
    return new Error(`illegal placement: ${t}`)
}

function CNe(t, e) {
    for (let n of e)
        if (!t6(t, n)) throw oie(t, n);
    if (t.M) {
        let n = Jre(e);
        for (let r = 1, i = n.length; r < i; r++)
            if (Bk.has(n[r])) {
                let s = r + 1;
                for (let o; s < i && Bk.has(o = n[s]); s++)
                    for (let a = r; a < s; a++)
                        if (n[a] == o) throw new Error(`duplicate non-spacing marks: ${PL(o)}`);
                if (s - r > DG) throw new Error(`excessive non-spacing marks: ${kL(e9(n.slice(r-1,s)))} (${s-r}/${DG})`);
                r = s
            }
    }
}

function ANe(t, e, n) {
    let r = [],
        i = [];
    for (t = t.slice().reverse(); t.length;) {
        let s = INe(t);
        if (s) i.length && (r.push(e(i)), i = []), r.push(n(s));
        else {
            let o = t.pop();
            if (Vg.has(o)) i.push(o);
            else {
                let a = Lk.get(o);
                if (a) i.push(...a);
                else if (!nie.has(o)) throw sie(o)
            }
        }
    }
    return i.length && r.push(e(i)), r
}

function TNe(t) {
    return t.filter(e => e != eie)
}

function INe(t, e) {
    let n = Fk,
        r, i = t.length;
    for (; i && (n = n.get(t[--i]), !!n);) {
        let {
            V: s
        } = n;
        s && (r = s, t.length = i)
    }
    return r
}
const aie = new Uint8Array(32);
aie.fill(0);

function FG(t) {
    return Ee(t.length !== 0, "invalid ENS name; empty component", "comp", t), t
}

function lie(t) {
    const e = qf(RNe(t)),
        n = [];
    if (t.length === 0) return n;
    let r = 0;
    for (let i = 0; i < e.length; i++) e[i] === 46 && (n.push(FG(e.slice(r, i))), r = i + 1);
    return Ee(r < e.length, "invalid ENS name; empty component", "name", t), n.push(FG(e.slice(r))), n
}

function RNe(t) {
    try {
        if (t.length === 0) throw new Error("empty label");
        return bNe(t)
    } catch (e) {
        Ee(!1, `invalid ENS name (${e.message})`, "name", t)
    }
}

function Uk(t) {
    Ee(typeof t == "string", "invalid ENS name; not a string", "name", t), Ee(t.length, "invalid ENS name (empty label)", "name", t);
    let e = aie;
    const n = lie(t);
    for (; n.length;) e = fs(vi([e, fs(n.pop())]));
    return Ot(e)
}

function ONe(t, e) {
    const n = e;
    return Ee(n <= 255, "DNS encoded label cannot exceed 255", "length", n), Ot(vi(lie(t).map(r => {
        Ee(r.length <= n, `label ${JSON.stringify(t)} exceeds ${n} bytes`, "name", t);
        const i = new Uint8Array(r.length + 1);
        return i.set(r, 1), i[0] = i.length - 1, i
    }))) + "00"
}

function EO(t, e) {
    return {
        address: Hn(t),
        storageKeys: e.map((n, r) => (Ee(Zr(n, 32), "invalid slot", `storageKeys[${r}]`, n), n.toLowerCase()))
    }
}

function wy(t) {
    if (Array.isArray(t)) return t.map((n, r) => Array.isArray(n) ? (Ee(n.length === 2, "invalid slot set", `value[${r}]`, n), EO(n[0], n[1])) : (Ee(n != null && typeof n == "object", "invalid address-slot set", "value", t), EO(n.address, n.storageKeys)));
    Ee(t != null && typeof t == "object", "invalid access list", "value", t);
    const e = Object.keys(t).map(n => {
        const r = t[n].reduce((i, s) => (i[s] = !0, i), {});
        return EO(n, Object.keys(r).sort())
    });
    return e.sort((n, r) => n.address.localeCompare(r.address)), e
}

function NNe(t) {
    let e;
    return typeof t == "string" ? e = Q_.computePublicKey(t, !1) : e = t.publicKey, Hn(fs("0x" + e.substring(4)).substring(26))
}

function PNe(t, e) {
    return NNe(Q_.recoverPublicKey(t, e))
}
const Gs = BigInt(0),
    kNe = BigInt(2),
    MNe = BigInt(27),
    DNe = BigInt(28),
    $Ne = BigInt(35),
    LNe = BigInt("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"),
    xO = 4096 * 32;

function UG(t, e) {
    let n = t.toString(16);
    for (; n.length < 2;) n = "0" + n;
    return n += k2(e).substring(4), "0x" + n
}

function t9(t) {
    return t === "0x" ? null : Hn(t)
}

function ML(t, e) {
    try {
        return wy(t)
    } catch (n) {
        Ee(!1, n.message, e, t)
    }
}

function OE(t, e) {
    return t === "0x" ? 0 : Mn(t, e)
}

function cs(t, e) {
    if (t === "0x") return Gs;
    const n = kt(t, e);
    return Ee(n <= LNe, "value exceeds uint size", e, n), n
}

function si(t, e) {
    const n = kt(t, "value"),
        r = sa(n);
    return Ee(r.length <= 32, "value too large", `tx.${e}`, n), r
}

function DL(t) {
    return wy(t).map(e => [e.address, e.storageKeys])
}

function BNe(t, e) {
    Ee(Array.isArray(t), `invalid ${e}`, "value", t);
    for (let n = 0; n < t.length; n++) Ee(Zr(t[n], 32), "invalid ${ param } hash", `value[${n}]`, t[n]);
    return t
}

function FNe(t) {
    const e = ZT(t);
    Ee(Array.isArray(e) && (e.length === 9 || e.length === 6), "invalid field count for legacy transaction", "data", t);
    const n = {
        type: 0,
        nonce: OE(e[0], "nonce"),
        gasPrice: cs(e[1], "gasPrice"),
        gasLimit: cs(e[2], "gasLimit"),
        to: t9(e[3]),
        value: cs(e[4], "value"),
        data: Ot(e[5]),
        chainId: Gs
    };
    if (e.length === 6) return n;
    const r = cs(e[6], "v"),
        i = cs(e[7], "r"),
        s = cs(e[8], "s");
    if (i === Gs && s === Gs) n.chainId = r;
    else {
        let o = (r - $Ne) / kNe;
        o < Gs && (o = Gs), n.chainId = o, Ee(o !== Gs || r === MNe || r === DNe, "non-canonical legacy v", "v", e[6]), n.signature = Mu.from({
            r: km(e[7], 32),
            s: km(e[8], 32),
            v: r
        })
    }
    return n
}

function UNe(t, e) {
    const n = [si(t.nonce, "nonce"), si(t.gasPrice || 0, "gasPrice"), si(t.gasLimit, "gasLimit"), t.to || "0x", si(t.value, "value"), t.data];
    let r = Gs;
    if (t.chainId != Gs) r = kt(t.chainId, "tx.chainId"), Ee(!e || e.networkV == null || e.legacyChainId === r, "tx.chainId/sig.v mismatch", "sig", e);
    else if (t.signature) {
        const s = t.signature.legacyChainId;
        s != null && (r = s)
    }
    if (!e) return r !== Gs && (n.push(sa(r)), n.push("0x"), n.push("0x")), Mm(n);
    let i = BigInt(27 + e.yParity);
    return r !== Gs ? i = Mu.getChainIdV(r, e.v) : BigInt(e.v) !== i && Ee(!1, "tx.chainId/sig.v mismatch", "sig", e), n.push(sa(i)), n.push(sa(e.r)), n.push(sa(e.s)), Mm(n)
}

function $L(t, e) {
    let n;
    try {
        if (n = OE(e[0], "yParity"), n !== 0 && n !== 1) throw new Error("bad yParity")
    } catch {
        Ee(!1, "invalid yParity", "yParity", e[0])
    }
    const r = km(e[1], 32),
        i = km(e[2], 32),
        s = Mu.from({
            r,
            s: i,
            yParity: n
        });
    t.signature = s
}

function jNe(t) {
    const e = ZT(or(t).slice(1));
    Ee(Array.isArray(e) && (e.length === 9 || e.length === 12), "invalid field count for transaction type: 2", "data", Ot(t));
    const n = {
        type: 2,
        chainId: cs(e[0], "chainId"),
        nonce: OE(e[1], "nonce"),
        maxPriorityFeePerGas: cs(e[2], "maxPriorityFeePerGas"),
        maxFeePerGas: cs(e[3], "maxFeePerGas"),
        gasPrice: null,
        gasLimit: cs(e[4], "gasLimit"),
        to: t9(e[5]),
        value: cs(e[6], "value"),
        data: Ot(e[7]),
        accessList: ML(e[8], "accessList")
    };
    return e.length === 9 || $L(n, e.slice(9)), n
}

function HNe(t, e) {
    const n = [si(t.chainId, "chainId"), si(t.nonce, "nonce"), si(t.maxPriorityFeePerGas || 0, "maxPriorityFeePerGas"), si(t.maxFeePerGas || 0, "maxFeePerGas"), si(t.gasLimit, "gasLimit"), t.to || "0x", si(t.value, "value"), t.data, DL(t.accessList || [])];
    return e && (n.push(si(e.yParity, "yParity")), n.push(sa(e.r)), n.push(sa(e.s))), vi(["0x02", Mm(n)])
}

function zNe(t) {
    const e = ZT(or(t).slice(1));
    Ee(Array.isArray(e) && (e.length === 8 || e.length === 11), "invalid field count for transaction type: 1", "data", Ot(t));
    const n = {
        type: 1,
        chainId: cs(e[0], "chainId"),
        nonce: OE(e[1], "nonce"),
        gasPrice: cs(e[2], "gasPrice"),
        gasLimit: cs(e[3], "gasLimit"),
        to: t9(e[4]),
        value: cs(e[5], "value"),
        data: Ot(e[6]),
        accessList: ML(e[7], "accessList")
    };
    return e.length === 8 || $L(n, e.slice(8)), n
}

function WNe(t, e) {
    const n = [si(t.chainId, "chainId"), si(t.nonce, "nonce"), si(t.gasPrice || 0, "gasPrice"), si(t.gasLimit, "gasLimit"), t.to || "0x", si(t.value, "value"), t.data, DL(t.accessList || [])];
    return e && (n.push(si(e.yParity, "recoveryParam")), n.push(sa(e.r)), n.push(sa(e.s))), vi(["0x01", Mm(n)])
}

function VNe(t) {
    let e = ZT(or(t).slice(1)),
        n = "3",
        r = null;
    if (e.length === 4 && Array.isArray(e[0])) {
        n = "3 (network format)";
        const s = e[1],
            o = e[2],
            a = e[3];
        Ee(Array.isArray(s), "invalid network format: blobs not an array", "fields[1]", s), Ee(Array.isArray(o), "invalid network format: commitments not an array", "fields[2]", o), Ee(Array.isArray(a), "invalid network format: proofs not an array", "fields[3]", a), Ee(s.length === o.length, "invalid network format: blobs/commitments length mismatch", "fields", e), Ee(s.length === a.length, "invalid network format: blobs/proofs length mismatch", "fields", e), r = [];
        for (let l = 0; l < e[1].length; l++) r.push({
            data: s[l],
            commitment: o[l],
            proof: a[l]
        });
        e = e[0]
    }
    Ee(Array.isArray(e) && (e.length === 11 || e.length === 14), `invalid field count for transaction type: ${n}`, "data", Ot(t));
    const i = {
        type: 3,
        chainId: cs(e[0], "chainId"),
        nonce: OE(e[1], "nonce"),
        maxPriorityFeePerGas: cs(e[2], "maxPriorityFeePerGas"),
        maxFeePerGas: cs(e[3], "maxFeePerGas"),
        gasPrice: null,
        gasLimit: cs(e[4], "gasLimit"),
        to: t9(e[5]),
        value: cs(e[6], "value"),
        data: Ot(e[7]),
        accessList: ML(e[8], "accessList"),
        maxFeePerBlobGas: cs(e[9], "maxFeePerBlobGas"),
        blobVersionedHashes: e[10]
    };
    r && (i.blobs = r), Ee(i.to != null, `invalid address for transaction type: ${n}`, "data", t), Ee(Array.isArray(i.blobVersionedHashes), "invalid blobVersionedHashes: must be an array", "data", t);
    for (let s = 0; s < i.blobVersionedHashes.length; s++) Ee(Zr(i.blobVersionedHashes[s], 32), `invalid blobVersionedHash at index ${s}: must be length 32`, "data", t);
    return e.length === 11 || $L(i, e.slice(11)), i
}

function GNe(t, e, n) {
    const r = [si(t.chainId, "chainId"), si(t.nonce, "nonce"), si(t.maxPriorityFeePerGas || 0, "maxPriorityFeePerGas"), si(t.maxFeePerGas || 0, "maxFeePerGas"), si(t.gasLimit, "gasLimit"), t.to || Z_, si(t.value, "value"), t.data, DL(t.accessList || []), si(t.maxFeePerBlobGas || 0, "maxFeePerBlobGas"), BNe(t.blobVersionedHashes || [], "blobVersionedHashes")];
    return e && (r.push(si(e.yParity, "yParity")), r.push(sa(e.r)), r.push(sa(e.s)), n) ? vi(["0x03", Mm([r, n.map(i => i.data), n.map(i => i.commitment), n.map(i => i.proof)])]) : vi(["0x03", Mm(r)])
}
var _f, Vv, Gv, qv, Kv, Yv, Zv, Qv, Jv, Xv, eb, tb, B1, q0, Jd, K0, nb, r8;
const Vd = class Vd {
    constructor() {
        _e(this, nb);
        _e(this, _f);
        _e(this, Vv);
        _e(this, Gv);
        _e(this, qv);
        _e(this, Kv);
        _e(this, Yv);
        _e(this, Zv);
        _e(this, Qv);
        _e(this, Jv);
        _e(this, Xv);
        _e(this, eb);
        _e(this, tb);
        _e(this, B1);
        _e(this, q0);
        _e(this, Jd);
        _e(this, K0);
        le(this, _f, null), le(this, Vv, null), le(this, qv, 0), le(this, Kv, Gs), le(this, Yv, null), le(this, Zv, null), le(this, Qv, null), le(this, Gv, "0x"), le(this, Jv, Gs), le(this, Xv, Gs), le(this, eb, null), le(this, tb, null), le(this, B1, null), le(this, q0, null), le(this, K0, null), le(this, Jd, null)
    }
    get type() {
        return W(this, _f)
    }
    set type(e) {
        switch (e) {
            case null:
                le(this, _f, null);
                break;
            case 0:
            case "legacy":
                le(this, _f, 0);
                break;
            case 1:
            case "berlin":
            case "eip-2930":
                le(this, _f, 1);
                break;
            case 2:
            case "london":
            case "eip-1559":
                le(this, _f, 2);
                break;
            case 3:
            case "cancun":
            case "eip-4844":
                le(this, _f, 3);
                break;
            default:
                Ee(!1, "unsupported transaction type", "type", e)
        }
    }
    get typeName() {
        switch (this.type) {
            case 0:
                return "legacy";
            case 1:
                return "eip-2930";
            case 2:
                return "eip-1559";
            case 3:
                return "eip-4844"
        }
        return null
    }
    get to() {
        const e = W(this, Vv);
        return e == null && this.type === 3 ? Z_ : e
    }
    set to(e) {
        le(this, Vv, e == null ? null : Hn(e))
    }
    get nonce() {
        return W(this, qv)
    }
    set nonce(e) {
        le(this, qv, Mn(e, "value"))
    }
    get gasLimit() {
        return W(this, Kv)
    }
    set gasLimit(e) {
        le(this, Kv, kt(e))
    }
    get gasPrice() {
        const e = W(this, Yv);
        return e == null && (this.type === 0 || this.type === 1) ? Gs : e
    }
    set gasPrice(e) {
        le(this, Yv, e == null ? null : kt(e, "gasPrice"))
    }
    get maxPriorityFeePerGas() {
        const e = W(this, Zv);
        return e ? ? (this.type === 2 || this.type === 3 ? Gs : null)
    }
    set maxPriorityFeePerGas(e) {
        le(this, Zv, e == null ? null : kt(e, "maxPriorityFeePerGas"))
    }
    get maxFeePerGas() {
        const e = W(this, Qv);
        return e ? ? (this.type === 2 || this.type === 3 ? Gs : null)
    }
    set maxFeePerGas(e) {
        le(this, Qv, e == null ? null : kt(e, "maxFeePerGas"))
    }
    get data() {
        return W(this, Gv)
    }
    set data(e) {
        le(this, Gv, Ot(e))
    }
    get value() {
        return W(this, Jv)
    }
    set value(e) {
        le(this, Jv, kt(e, "value"))
    }
    get chainId() {
        return W(this, Xv)
    }
    set chainId(e) {
        le(this, Xv, kt(e))
    }
    get signature() {
        return W(this, eb) || null
    }
    set signature(e) {
        le(this, eb, e == null ? null : Mu.from(e))
    }
    get accessList() {
        const e = W(this, tb) || null;
        return e ? ? (this.type === 1 || this.type === 2 || this.type === 3 ? [] : null)
    }
    set accessList(e) {
        le(this, tb, e == null ? null : wy(e))
    }
    get maxFeePerBlobGas() {
        const e = W(this, B1);
        return e == null && this.type === 3 ? Gs : e
    }
    set maxFeePerBlobGas(e) {
        le(this, B1, e == null ? null : kt(e, "maxFeePerBlobGas"))
    }
    get blobVersionedHashes() {
        let e = W(this, q0);
        return e == null && this.type === 3 ? [] : e
    }
    set blobVersionedHashes(e) {
        if (e != null) {
            Ee(Array.isArray(e), "blobVersionedHashes must be an Array", "value", e), e = e.slice();
            for (let n = 0; n < e.length; n++) Ee(Zr(e[n], 32), "invalid blobVersionedHash", `value[${n}]`, e[n])
        }
        le(this, q0, e)
    }
    get blobs() {
        return W(this, K0) == null ? null : W(this, K0).map(e => Object.assign({}, e))
    }
    set blobs(e) {
        if (e == null) {
            le(this, K0, null);
            return
        }
        const n = [],
            r = [];
        for (let i = 0; i < e.length; i++) {
            const s = e[i];
            if (EL(s)) {
                je(W(this, Jd), "adding a raw blob requires a KZG library", "UNSUPPORTED_OPERATION", {
                    operation: "set blobs()"
                });
                let o = or(s);
                if (Ee(o.length <= xO, "blob is too large", `blobs[${i}]`, s), o.length !== xO) {
                    const c = new Uint8Array(xO);
                    c.set(o), o = c
                }
                const a = W(this, Jd).blobToKzgCommitment(o),
                    l = Ot(W(this, Jd).computeBlobKzgProof(o, a));
                n.push({
                    data: Ot(o),
                    commitment: Ot(a),
                    proof: l
                }), r.push(UG(1, a))
            } else {
                const o = Ot(s.commitment);
                n.push({
                    data: Ot(s.data),
                    commitment: o,
                    proof: Ot(s.proof)
                }), r.push(UG(1, o))
            }
        }
        le(this, K0, n), le(this, q0, r)
    }
    get kzg() {
        return W(this, Jd)
    }
    set kzg(e) {
        le(this, Jd, e)
    }
    get hash() {
        return this.signature == null ? null : fs(De(this, nb, r8).call(this, !0, !1))
    }
    get unsignedHash() {
        return fs(this.unsignedSerialized)
    }
    get from() {
        return this.signature == null ? null : PNe(this.unsignedHash, this.signature)
    }
    get fromPublicKey() {
        return this.signature == null ? null : Q_.recoverPublicKey(this.unsignedHash, this.signature)
    }
    isSigned() {
        return this.signature != null
    }
    get serialized() {
        return De(this, nb, r8).call(this, !0, !0)
    }
    get unsignedSerialized() {
        return De(this, nb, r8).call(this, !1, !1)
    }
    inferType() {
        const e = this.inferTypes();
        return e.indexOf(2) >= 0 ? 2 : e.pop()
    }
    inferTypes() {
        const e = this.gasPrice != null,
            n = this.maxFeePerGas != null || this.maxPriorityFeePerGas != null,
            r = this.accessList != null,
            i = W(this, B1) != null || W(this, q0);
        this.maxFeePerGas != null && this.maxPriorityFeePerGas != null && je(this.maxFeePerGas >= this.maxPriorityFeePerGas, "priorityFee cannot be more than maxFee", "BAD_DATA", {
            value: this
        }), je(!n || this.type !== 0 && this.type !== 1, "transaction type cannot have maxFeePerGas or maxPriorityFeePerGas", "BAD_DATA", {
            value: this
        }), je(this.type !== 0 || !r, "legacy transaction cannot have accessList", "BAD_DATA", {
            value: this
        });
        const s = [];
        return this.type != null ? s.push(this.type) : n ? s.push(2) : e ? (s.push(1), r || s.push(0)) : r ? (s.push(1), s.push(2)) : (i && this.to || (s.push(0), s.push(1), s.push(2)), s.push(3)), s.sort(), s
    }
    isLegacy() {
        return this.type === 0
    }
    isBerlin() {
        return this.type === 1
    }
    isLondon() {
        return this.type === 2
    }
    isCancun() {
        return this.type === 3
    }
    clone() {
        return Vd.from(this)
    }
    toJSON() {
        const e = n => n == null ? null : n.toString();
        return {
            type: this.type,
            to: this.to,
            data: this.data,
            nonce: this.nonce,
            gasLimit: e(this.gasLimit),
            gasPrice: e(this.gasPrice),
            maxPriorityFeePerGas: e(this.maxPriorityFeePerGas),
            maxFeePerGas: e(this.maxFeePerGas),
            value: e(this.value),
            chainId: e(this.chainId),
            sig: this.signature ? this.signature.toJSON() : null,
            accessList: this.accessList
        }
    }
    static from(e) {
        if (e == null) return new Vd;
        if (typeof e == "string") {
            const r = or(e);
            if (r[0] >= 127) return Vd.from(FNe(r));
            switch (r[0]) {
                case 1:
                    return Vd.from(zNe(r));
                case 2:
                    return Vd.from(jNe(r));
                case 3:
                    return Vd.from(VNe(r))
            }
            je(!1, "unsupported transaction type", "UNSUPPORTED_OPERATION", {
                operation: "from"
            })
        }
        const n = new Vd;
        return e.type != null && (n.type = e.type), e.to != null && (n.to = e.to), e.nonce != null && (n.nonce = e.nonce), e.gasLimit != null && (n.gasLimit = e.gasLimit), e.gasPrice != null && (n.gasPrice = e.gasPrice), e.maxPriorityFeePerGas != null && (n.maxPriorityFeePerGas = e.maxPriorityFeePerGas), e.maxFeePerGas != null && (n.maxFeePerGas = e.maxFeePerGas), e.maxFeePerBlobGas != null && (n.maxFeePerBlobGas = e.maxFeePerBlobGas), e.data != null && (n.data = e.data), e.value != null && (n.value = e.value), e.chainId != null && (n.chainId = e.chainId), e.signature != null && (n.signature = Mu.from(e.signature)), e.accessList != null && (n.accessList = e.accessList), e.blobVersionedHashes != null && (n.blobVersionedHashes = e.blobVersionedHashes), e.kzg != null && (n.kzg = e.kzg), e.blobs != null && (n.blobs = e.blobs), e.hash != null && (Ee(n.isSigned(), "unsigned transaction cannot define '.hash'", "tx", e), Ee(n.hash === e.hash, "hash mismatch", "tx", e)), e.from != null && (Ee(n.isSigned(), "unsigned transaction cannot define '.from'", "tx", e), Ee(n.from.toLowerCase() === (e.from || "").toLowerCase(), "from mismatch", "tx", e)), n
    }
};
_f = new WeakMap, Vv = new WeakMap, Gv = new WeakMap, qv = new WeakMap, Kv = new WeakMap, Yv = new WeakMap, Zv = new WeakMap, Qv = new WeakMap, Jv = new WeakMap, Xv = new WeakMap, eb = new WeakMap, tb = new WeakMap, B1 = new WeakMap, q0 = new WeakMap, Jd = new WeakMap, K0 = new WeakMap, nb = new WeakSet, r8 = function(e, n) {
    je(!e || this.signature != null, "cannot serialize unsigned transaction; maybe you meant .unsignedSerialized", "UNSUPPORTED_OPERATION", {
        operation: ".serialized"
    });
    const r = e ? this.signature : null;
    switch (this.inferType()) {
        case 0:
            return UNe(this, r);
        case 1:
            return WNe(this, r);
        case 2:
            return HNe(this, r);
        case 3:
            return GNe(this, r, n ? this.blobs : null)
    }
    je(!1, "unsupported transaction type", "UNSUPPORTED_OPERATION", {
        operation: ".serialized"
    })
};
let FC = Vd;
const cie = new Uint8Array(32);
cie.fill(0);
const qNe = BigInt(-1),
    uie = BigInt(0),
    fie = BigInt(1),
    KNe = BigInt("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");

function YNe(t) {
    const e = or(t),
        n = e.length % 32;
    return n ? vi([e, cie.slice(n)]) : Ot(e)
}
const ZNe = zp(fie, 32),
    QNe = zp(uie, 32),
    jG = {
        name: "string",
        version: "string",
        chainId: "uint256",
        verifyingContract: "address",
        salt: "bytes32"
    },
    SO = ["name", "version", "chainId", "verifyingContract", "salt"];

function HG(t) {
    return function(e) {
        return Ee(typeof e == "string", `invalid domain value for ${JSON.stringify(t)}`, `domain.${t}`, e), e
    }
}
const JNe = {
    name: HG("name"),
    version: HG("version"),
    chainId: function(t) {
        const e = kt(t, "domain.chainId");
        return Ee(e >= 0, "invalid chain ID", "domain.chainId", t), Number.isSafeInteger(e) ? Number(e) : u1(e)
    },
    verifyingContract: function(t) {
        try {
            return Hn(t).toLowerCase()
        } catch {}
        Ee(!1, 'invalid domain value "verifyingContract"', "domain.verifyingContract", t)
    },
    salt: function(t) {
        const e = or(t, "domain.salt");
        return Ee(e.length === 32, 'invalid domain value "salt"', "domain.salt", t), Ot(e)
    }
};

function CO(t) {
    {
        const e = t.match(/^(u?)int(\d+)$/);
        if (e) {
            const n = e[1] === "",
                r = parseInt(e[2]);
            Ee(r % 8 === 0 && r !== 0 && r <= 256 && e[2] === String(r), "invalid numeric width", "type", t);
            const i = c1(KNe, n ? r - 1 : r),
                s = n ? (i + fie) * qNe : uie;
            return function(o) {
                const a = kt(o, "value");
                return Ee(a >= s && a <= i, `value out-of-bounds for ${t}`, "value", a), zp(n ? Qne(a, 256) : a, 32)
            }
        }
    } {
        const e = t.match(/^bytes(\d+)$/);
        if (e) {
            const n = parseInt(e[1]);
            return Ee(n !== 0 && n <= 32 && e[1] === String(n), "invalid bytes width", "type", t),
                function(r) {
                    const i = or(r);
                    return Ee(i.length === n, `invalid length for ${t}`, "value", r), YNe(r)
                }
        }
    }
    switch (t) {
        case "address":
            return function(e) {
                return km(Hn(e), 32)
            };
        case "bool":
            return function(e) {
                return e ? ZNe : QNe
            };
        case "bytes":
            return function(e) {
                return fs(e)
            };
        case "string":
            return function(e) {
                return Dm(e)
            }
    }
    return null
}

function zG(t, e) {
    return `${t}(${e.map(({name:n,type:r})=>r+" "+n).join(",")})`
}

function Zx(t) {
    const e = t.match(/^([^\x5b]*)((\x5b\d*\x5d)*)(\x5b(\d*)\x5d)$/);
    return e ? {
        base: e[1],
        index: e[2] + e[4],
        array: {
            base: e[1],
            prefix: e[1] + e[2],
            count: e[5] ? parseInt(e[5]) : -1
        }
    } : {
        base: t
    }
}
var K6, Xd, rb, tT, die;
const sc = class sc {
    constructor(e) {
        _e(this, tT);
        Ie(this, "primaryType");
        _e(this, K6);
        _e(this, Xd);
        _e(this, rb);
        le(this, Xd, new Map), le(this, rb, new Map);
        const n = new Map,
            r = new Map,
            i = new Map,
            s = {};
        Object.keys(e).forEach(l => {
            s[l] = e[l].map(({
                name: c,
                type: u
            }) => {
                let {
                    base: f,
                    index: h
                } = Zx(u);
                return f === "int" && !e.int && (f = "int256"), f === "uint" && !e.uint && (f = "uint256"), {
                    name: c,
                    type: f + (h || "")
                }
            }), n.set(l, new Set), r.set(l, []), i.set(l, new Set)
        }), le(this, K6, JSON.stringify(s));
        for (const l in s) {
            const c = new Set;
            for (const u of s[l]) {
                Ee(!c.has(u.name), `duplicate variable name ${JSON.stringify(u.name)} in ${JSON.stringify(l)}`, "types", e), c.add(u.name);
                const f = Zx(u.type).base;
                Ee(f !== l, `circular type reference to ${JSON.stringify(f)}`, "types", e), !CO(f) && (Ee(r.has(f), `unknown type ${JSON.stringify(f)}`, "types", e), r.get(f).push(l), n.get(l).add(f))
            }
        }
        const o = Array.from(r.keys()).filter(l => r.get(l).length === 0);
        Ee(o.length !== 0, "missing primary type", "types", e), Ee(o.length === 1, `ambiguous primary types or unused types: ${o.map(l=>JSON.stringify(l)).join(", ")}`, "types", e), Xt(this, {
            primaryType: o[0]
        });

        function a(l, c) {
            Ee(!c.has(l), `circular type reference to ${JSON.stringify(l)}`, "types", e), c.add(l);
            for (const u of n.get(l))
                if (r.has(u)) {
                    a(u, c);
                    for (const f of c) i.get(f).add(u)
                }
            c.delete(l)
        }
        a(this.primaryType, new Set);
        for (const [l, c] of i) {
            const u = Array.from(c);
            u.sort(), W(this, Xd).set(l, zG(l, s[l]) + u.map(f => zG(f, s[f])).join(""))
        }
    }
    get types() {
        return JSON.parse(W(this, K6))
    }
    getEncoder(e) {
        let n = W(this, rb).get(e);
        return n || (n = De(this, tT, die).call(this, e), W(this, rb).set(e, n)), n
    }
    encodeType(e) {
        const n = W(this, Xd).get(e);
        return Ee(n, `unknown type: ${JSON.stringify(e)}`, "name", e), n
    }
    encodeData(e, n) {
        return this.getEncoder(e)(n)
    }
    hashStruct(e, n) {
        return fs(this.encodeData(e, n))
    }
    encode(e) {
        return this.encodeData(this.primaryType, e)
    }
    hash(e) {
        return this.hashStruct(this.primaryType, e)
    }
    _visit(e, n, r) {
        if (CO(e)) return r(e, n);
        const i = Zx(e).array;
        if (i) return Ee(i.count === -1 || i.count === n.length, `array length mismatch; expected length ${i.count}`, "value", n), n.map(o => this._visit(i.prefix, o, r));
        const s = this.types[e];
        if (s) return s.reduce((o, {
            name: a,
            type: l
        }) => (o[a] = this._visit(l, n[a], r), o), {});
        Ee(!1, `unknown type: ${e}`, "type", e)
    }
    visit(e, n) {
        return this._visit(this.primaryType, e, n)
    }
    static from(e) {
        return new sc(e)
    }
    static getPrimaryType(e) {
        return sc.from(e).primaryType
    }
    static hashStruct(e, n, r) {
        return sc.from(n).hashStruct(e, r)
    }
    static hashDomain(e) {
        const n = [];
        for (const r in e) {
            if (e[r] == null) continue;
            const i = jG[r];
            Ee(i, `invalid typed-data domain key: ${JSON.stringify(r)}`, "domain", e), n.push({
                name: r,
                type: i
            })
        }
        return n.sort((r, i) => SO.indexOf(r.name) - SO.indexOf(i.name)), sc.hashStruct("EIP712Domain", {
            EIP712Domain: n
        }, e)
    }
    static encode(e, n, r) {
        return vi(["0x1901", sc.hashDomain(e), sc.from(n).hash(r)])
    }
    static hash(e, n, r) {
        return fs(sc.encode(e, n, r))
    }
    static async resolveNames(e, n, r, i) {
        e = Object.assign({}, e);
        for (const a in e) e[a] == null && delete e[a];
        const s = {};
        e.verifyingContract && !Zr(e.verifyingContract, 20) && (s[e.verifyingContract] = "0x");
        const o = sc.from(n);
        o.visit(r, (a, l) => (a === "address" && !Zr(l, 20) && (s[l] = "0x"), l));
        for (const a in s) s[a] = await i(a);
        return e.verifyingContract && s[e.verifyingContract] && (e.verifyingContract = s[e.verifyingContract]), r = o.visit(r, (a, l) => a === "address" && s[l] ? s[l] : l), {
            domain: e,
            value: r
        }
    }
    static getPayload(e, n, r) {
        sc.hashDomain(e);
        const i = {},
            s = [];
        SO.forEach(l => {
            const c = e[l];
            c != null && (i[l] = JNe[l](c), s.push({
                name: l,
                type: jG[l]
            }))
        });
        const o = sc.from(n);
        n = o.types;
        const a = Object.assign({}, n);
        return Ee(a.EIP712Domain == null, "types must not contain EIP712Domain type", "types.EIP712Domain", n), a.EIP712Domain = s, o.encode(r), {
            types: a,
            domain: i,
            primaryType: o.primaryType,
            message: o.visit(r, (l, c) => {
                if (l.match(/^bytes(\d*)/)) return Ot(or(c));
                if (l.match(/^u?int/)) return kt(c).toString();
                switch (l) {
                    case "address":
                        return c.toLowerCase();
                    case "bool":
                        return !!c;
                    case "string":
                        return Ee(typeof c == "string", "invalid string", "value", c), c
                }
                Ee(!1, "unsupported type", "type", l)
            })
        }
    }
};
K6 = new WeakMap, Xd = new WeakMap, rb = new WeakMap, tT = new WeakSet, die = function(e) {
    {
        const i = CO(e);
        if (i) return i
    }
    const n = Zx(e).array;
    if (n) {
        const i = n.prefix,
            s = this.getEncoder(i);
        return o => {
            Ee(n.count === -1 || n.count === o.length, `array length mismatch; expected length ${n.count}`, "value", o);
            let a = o.map(s);
            return W(this, Xd).has(i) && (a = a.map(fs)), fs(vi(a))
        }
    }
    const r = this.types[e];
    if (r) {
        const i = Dm(W(this, Xd).get(e));
        return s => {
            const o = r.map(({
                name: a,
                type: l
            }) => {
                const c = this.getEncoder(l)(s[a]);
                return W(this, Xd).has(l) ? fs(c) : c
            });
            return o.unshift(i), vi(o)
        }
    }
    Ee(!1, `unknown type: ${e}`, "type", e)
};
let UC = sc;

function la(t) {
    const e = new Set;
    return t.forEach(n => e.add(n)), Object.freeze(e)
}
const XNe = "external public payable override",
    ePe = la(XNe.split(" ")),
    hie = "constant external internal payable private public pure view override",
    tPe = la(hie.split(" ")),
    pie = "constructor error event fallback function receive struct",
    gie = la(pie.split(" ")),
    mie = "calldata memory storage payable indexed",
    nPe = la(mie.split(" ")),
    rPe = "tuple returns",
    iPe = [pie, mie, rPe, hie].join(" "),
    sPe = la(iPe.split(" ")),
    oPe = {
        "(": "OPEN_PAREN",
        ")": "CLOSE_PAREN",
        "[": "OPEN_BRACKET",
        "]": "CLOSE_BRACKET",
        ",": "COMMA",
        "@": "AT"
    },
    aPe = new RegExp("^(\\s*)"),
    lPe = new RegExp("^([0-9]+)"),
    cPe = new RegExp("^([a-zA-Z$_][a-zA-Z0-9$_]*)"),
    yie = new RegExp("^([a-zA-Z$_][a-zA-Z0-9$_]*)$"),
    wie = new RegExp("^(address|bool|bytes([0-9]*)|string|u?int([0-9]*))$");
var no, uu, Y6, jk;
const nT = class nT {
    constructor(e) {
        _e(this, Y6);
        _e(this, no);
        _e(this, uu);
        le(this, no, 0), le(this, uu, e.slice())
    }
    get offset() {
        return W(this, no)
    }
    get length() {
        return W(this, uu).length - W(this, no)
    }
    clone() {
        return new nT(W(this, uu))
    }
    reset() {
        le(this, no, 0)
    }
    popKeyword(e) {
        const n = this.peek();
        if (n.type !== "KEYWORD" || !e.has(n.text)) throw new Error(`expected keyword ${n.text}`);
        return this.pop().text
    }
    popType(e) {
        if (this.peek().type !== e) {
            const n = this.peek();
            throw new Error(`expected ${e}; got ${n.type} ${JSON.stringify(n.text)}`)
        }
        return this.pop().text
    }
    popParen() {
        const e = this.peek();
        if (e.type !== "OPEN_PAREN") throw new Error("bad start");
        const n = De(this, Y6, jk).call(this, W(this, no) + 1, e.match + 1);
        return le(this, no, e.match + 1), n
    }
    popParams() {
        const e = this.peek();
        if (e.type !== "OPEN_PAREN") throw new Error("bad start");
        const n = [];
        for (; W(this, no) < e.match - 1;) {
            const r = this.peek().linkNext;
            n.push(De(this, Y6, jk).call(this, W(this, no) + 1, r)), le(this, no, r)
        }
        return le(this, no, e.match + 1), n
    }
    peek() {
        if (W(this, no) >= W(this, uu).length) throw new Error("out-of-bounds");
        return W(this, uu)[W(this, no)]
    }
    peekKeyword(e) {
        const n = this.peekType("KEYWORD");
        return n != null && e.has(n) ? n : null
    }
    peekType(e) {
        if (this.length === 0) return null;
        const n = this.peek();
        return n.type === e ? n.text : null
    }
    pop() {
        const e = this.peek();
        return s0(this, no)._++, e
    }
    toString() {
        const e = [];
        for (let n = W(this, no); n < W(this, uu).length; n++) {
            const r = W(this, uu)[n];
            e.push(`${r.type}:${r.text}`)
        }
        return `<TokenString ${e.join(" ")}>`
    }
};
no = new WeakMap, uu = new WeakMap, Y6 = new WeakSet, jk = function(e = 0, n = 0) {
    return new nT(W(this, uu).slice(e, n).map(r => Object.freeze(Object.assign({}, r, {
        match: r.match - e,
        linkBack: r.linkBack - e,
        linkNext: r.linkNext - e
    }))))
};
let Du = nT;

function lg(t) {
    const e = [],
        n = o => {
            const a = s < t.length ? JSON.stringify(t[s]) : "$EOI";
            throw new Error(`invalid token ${a} at ${s}: ${o}`)
        };
    let r = [],
        i = [],
        s = 0;
    for (; s < t.length;) {
        let o = t.substring(s),
            a = o.match(aPe);
        a && (s += a[1].length, o = t.substring(s));
        const l = {
            depth: r.length,
            linkBack: -1,
            linkNext: -1,
            match: -1,
            type: "",
            text: "",
            offset: s,
            value: -1
        };
        e.push(l);
        let c = oPe[o[0]] || "";
        if (c) {
            if (l.type = c, l.text = o[0], s++, c === "OPEN_PAREN") r.push(e.length - 1), i.push(e.length - 1);
            else if (c == "CLOSE_PAREN") r.length === 0 && n("no matching open bracket"), l.match = r.pop(), e[l.match].match = e.length - 1, l.depth--, l.linkBack = i.pop(), e[l.linkBack].linkNext = e.length - 1;
            else if (c === "COMMA") l.linkBack = i.pop(), e[l.linkBack].linkNext = e.length - 1, i.push(e.length - 1);
            else if (c === "OPEN_BRACKET") l.type = "BRACKET";
            else if (c === "CLOSE_BRACKET") {
                let u = e.pop().text;
                if (e.length > 0 && e[e.length - 1].type === "NUMBER") {
                    const f = e.pop().text;
                    u = f + u, e[e.length - 1].value = Mn(f)
                }
                if (e.length === 0 || e[e.length - 1].type !== "BRACKET") throw new Error("missing opening bracket");
                e[e.length - 1].text += u
            }
            continue
        }
        if (a = o.match(cPe), a) {
            if (l.text = a[1], s += l.text.length, sPe.has(l.text)) {
                l.type = "KEYWORD";
                continue
            }
            if (l.text.match(wie)) {
                l.type = "TYPE";
                continue
            }
            l.type = "ID";
            continue
        }
        if (a = o.match(lPe), a) {
            l.text = a[1], l.type = "NUMBER", s += l.text.length;
            continue
        }
        throw new Error(`unexpected token ${JSON.stringify(o[0])} at position ${s}`)
    }
    return new Du(e.map(o => Object.freeze(o)))
}

function WG(t, e) {
    let n = [];
    for (const r in e.keys()) t.has(r) && n.push(r);
    if (n.length > 1) throw new Error(`conflicting types: ${n.join(", ")}`)
}

function n9(t, e) {
    if (e.peekKeyword(gie)) {
        const n = e.pop().text;
        if (n !== t) throw new Error(`expected ${t}, got ${n}`)
    }
    return e.popType("ID")
}

function Ah(t, e) {
    const n = new Set;
    for (;;) {
        const r = t.peekType("KEYWORD");
        if (r == null || e && !e.has(r)) break;
        if (t.pop(), n.has(r)) throw new Error(`duplicate keywords: ${JSON.stringify(r)}`);
        n.add(r)
    }
    return Object.freeze(n)
}

function vie(t) {
    let e = Ah(t, tPe);
    return WG(e, la("constant payable nonpayable".split(" "))), WG(e, la("pure view payable nonpayable".split(" "))), e.has("view") ? "view" : e.has("pure") ? "pure" : e.has("payable") ? "payable" : e.has("nonpayable") ? "nonpayable" : e.has("constant") ? "view" : "nonpayable"
}

function gh(t, e) {
    return t.popParams().map(n => Rr.from(n, e))
}

function bie(t) {
    if (t.peekType("AT")) {
        if (t.pop(), t.peekType("NUMBER")) return kt(t.pop().text);
        throw new Error("invalid gas")
    }
    return null
}

function $m(t) {
    if (t.length) throw new Error(`unexpected tokens at offset ${t.offset}: ${t.toString()}`)
}
const uPe = new RegExp(/^(.*)\[([0-9]*)\]$/);

function VG(t) {
    const e = t.match(wie);
    if (Ee(e, "invalid type", "type", t), t === "uint") return "uint256";
    if (t === "int") return "int256";
    if (e[2]) {
        const n = parseInt(e[2]);
        Ee(n !== 0 && n <= 32, "invalid bytes length", "type", t)
    } else if (e[3]) {
        const n = parseInt(e[3]);
        Ee(n !== 0 && n <= 256 && n % 8 === 0, "invalid numeric width", "type", t)
    }
    return t
}
const Ri = {},
    Ya = Symbol.for("_ethers_internal"),
    GG = "_ParamTypeInternal",
    qG = "_ErrorInternal",
    KG = "_EventInternal",
    YG = "_ConstructorInternal",
    ZG = "_FallbackInternal",
    QG = "_FunctionInternal",
    JG = "_StructInternal";
var ib, i8;
const oc = class oc {
    constructor(e, n, r, i, s, o, a, l) {
        _e(this, ib);
        Ie(this, "name");
        Ie(this, "type");
        Ie(this, "baseType");
        Ie(this, "indexed");
        Ie(this, "components");
        Ie(this, "arrayLength");
        Ie(this, "arrayChildren");
        if (IE(e, Ri, "ParamType"), Object.defineProperty(this, Ya, {
                value: GG
            }), o && (o = Object.freeze(o.slice())), i === "array") {
            if (a == null || l == null) throw new Error("")
        } else if (a != null || l != null) throw new Error("");
        if (i === "tuple") {
            if (o == null) throw new Error("")
        } else if (o != null) throw new Error("");
        Xt(this, {
            name: n,
            type: r,
            baseType: i,
            indexed: s,
            components: o,
            arrayLength: a,
            arrayChildren: l
        })
    }
    format(e) {
        if (e == null && (e = "sighash"), e === "json") {
            const r = this.name || "";
            if (this.isArray()) {
                const s = JSON.parse(this.arrayChildren.format("json"));
                return s.name = r, s.type += `[${this.arrayLength<0?"":String(this.arrayLength)}]`, JSON.stringify(s)
            }
            const i = {
                type: this.baseType === "tuple" ? "tuple" : this.type,
                name: r
            };
            return typeof this.indexed == "boolean" && (i.indexed = this.indexed), this.isTuple() && (i.components = this.components.map(s => JSON.parse(s.format(e)))), JSON.stringify(i)
        }
        let n = "";
        return this.isArray() ? (n += this.arrayChildren.format(e), n += `[${this.arrayLength<0?"":String(this.arrayLength)}]`) : this.isTuple() ? n += "(" + this.components.map(r => r.format(e)).join(e === "full" ? ", " : ",") + ")" : n += this.type, e !== "sighash" && (this.indexed === !0 && (n += " indexed"), e === "full" && this.name && (n += " " + this.name)), n
    }
    isArray() {
        return this.baseType === "array"
    }
    isTuple() {
        return this.baseType === "tuple"
    }
    isIndexable() {
        return this.indexed != null
    }
    walk(e, n) {
        if (this.isArray()) {
            if (!Array.isArray(e)) throw new Error("invalid array value");
            if (this.arrayLength !== -1 && e.length !== this.arrayLength) throw new Error("array is wrong length");
            const r = this;
            return e.map(i => r.arrayChildren.walk(i, n))
        }
        if (this.isTuple()) {
            if (!Array.isArray(e)) throw new Error("invalid tuple value");
            if (e.length !== this.components.length) throw new Error("array is wrong length");
            const r = this;
            return e.map((i, s) => r.components[s].walk(i, n))
        }
        return n(this.type, e)
    }
    async walkAsync(e, n) {
        const r = [],
            i = [e];
        return De(this, ib, i8).call(this, r, e, n, s => {
            i[0] = s
        }), r.length && await Promise.all(r), i[0]
    }
    static from(e, n) {
        if (oc.isParamType(e)) return e;
        if (typeof e == "string") try {
            return oc.from(lg(e), n)
        } catch {
            Ee(!1, "invalid param type", "obj", e)
        } else if (e instanceof Du) {
            let a = "",
                l = "",
                c = null;
            Ah(e, la(["tuple"])).has("tuple") || e.peekType("OPEN_PAREN") ? (l = "tuple", c = e.popParams().map(_ => oc.from(_)), a = `tuple(${c.map(_=>_.format()).join(",")})`) : (a = VG(e.popType("TYPE")), l = a);
            let u = null,
                f = null;
            for (; e.length && e.peekType("BRACKET");) {
                const _ = e.pop();
                u = new oc(Ri, "", a, l, null, c, f, u), f = _.value, a += _.text, l = "array", c = null
            }
            let h = null;
            if (Ah(e, nPe).has("indexed")) {
                if (!n) throw new Error("");
                h = !0
            }
            const y = e.peekType("ID") ? e.pop().text : "";
            if (e.length) throw new Error("leftover tokens");
            return new oc(Ri, y, a, l, h, c, f, u)
        }
        const r = e.name;
        Ee(!r || typeof r == "string" && r.match(yie), "invalid name", "obj.name", r);
        let i = e.indexed;
        i != null && (Ee(n, "parameter cannot be indexed", "obj.indexed", e.indexed), i = !!i);
        let s = e.type,
            o = s.match(uPe);
        if (o) {
            const a = parseInt(o[2] || "-1"),
                l = oc.from({
                    type: o[1],
                    components: e.components
                });
            return new oc(Ri, r || "", s, "array", i, null, a, l)
        }
        if (s === "tuple" || s.startsWith("tuple(") || s.startsWith("(")) {
            const a = e.components != null ? e.components.map(c => oc.from(c)) : null;
            return new oc(Ri, r || "", s, "tuple", i, a, null, null)
        }
        return s = VG(e.type), new oc(Ri, r || "", s, s, i, null, null, null)
    }
    static isParamType(e) {
        return e && e[Ya] === GG
    }
};
ib = new WeakSet, i8 = function(e, n, r, i) {
    if (this.isArray()) {
        if (!Array.isArray(n)) throw new Error("invalid array value");
        if (this.arrayLength !== -1 && n.length !== this.arrayLength) throw new Error("array is wrong length");
        const o = this.arrayChildren,
            a = n.slice();
        a.forEach((l, c) => {
            var u;
            De(u = o, ib, i8).call(u, e, l, r, f => {
                a[c] = f
            })
        }), i(a);
        return
    }
    if (this.isTuple()) {
        const o = this.components;
        let a;
        if (Array.isArray(n)) a = n.slice();
        else {
            if (n == null || typeof n != "object") throw new Error("invalid tuple value");
            a = o.map(l => {
                if (!l.name) throw new Error("cannot use object value with unnamed components");
                if (!(l.name in n)) throw new Error(`missing value for component ${l.name}`);
                return n[l.name]
            })
        }
        if (a.length !== this.components.length) throw new Error("array is wrong length");
        a.forEach((l, c) => {
            var u;
            De(u = o[c], ib, i8).call(u, e, l, r, f => {
                a[c] = f
            })
        }), i(a);
        return
    }
    const s = r(this.type, n);
    s.then ? e.push(async function() {
        i(await s)
    }()) : i(s)
};
let Rr = oc;
class Lm {
    constructor(e, n, r) {
        Ie(this, "type");
        Ie(this, "inputs");
        IE(e, Ri, "Fragment"), r = Object.freeze(r.slice()), Xt(this, {
            type: n,
            inputs: r
        })
    }
    static from(e) {
        if (typeof e == "string") {
            try {
                Lm.from(JSON.parse(e))
            } catch {}
            return Lm.from(lg(e))
        }
        if (e instanceof Du) switch (e.peekKeyword(gie)) {
            case "constructor":
                return lh.from(e);
            case "error":
                return La.from(e);
            case "event":
                return Pf.from(e);
            case "fallback":
            case "receive":
                return Gd.from(e);
            case "function":
                return kf.from(e);
            case "struct":
                return nm.from(e)
        } else if (typeof e == "object") {
            switch (e.type) {
                case "constructor":
                    return lh.from(e);
                case "error":
                    return La.from(e);
                case "event":
                    return Pf.from(e);
                case "fallback":
                case "receive":
                    return Gd.from(e);
                case "function":
                    return kf.from(e);
                case "struct":
                    return nm.from(e)
            }
            je(!1, `unsupported type: ${e.type}`, "UNSUPPORTED_OPERATION", {
                operation: "Fragment.from"
            })
        }
        Ee(!1, "unsupported frgament object", "obj", e)
    }
    static isConstructor(e) {
        return lh.isFragment(e)
    }
    static isError(e) {
        return La.isFragment(e)
    }
    static isEvent(e) {
        return Pf.isFragment(e)
    }
    static isFunction(e) {
        return kf.isFragment(e)
    }
    static isStruct(e) {
        return nm.isFragment(e)
    }
}
class r9 extends Lm {
    constructor(n, r, i, s) {
        super(n, r, s);
        Ie(this, "name");
        Ee(typeof i == "string" && i.match(yie), "invalid identifier", "name", i), s = Object.freeze(s.slice()), Xt(this, {
            name: i
        })
    }
}

function n6(t, e) {
    return "(" + e.map(n => n.format(t)).join(t === "full" ? ", " : ",") + ")"
}
class La extends r9 {
    constructor(e, n, r) {
        super(e, "error", n, r), Object.defineProperty(this, Ya, {
            value: qG
        })
    }
    get selector() {
        return Dm(this.format("sighash")).substring(0, 10)
    }
    format(e) {
        if (e == null && (e = "sighash"), e === "json") return JSON.stringify({
            type: "error",
            name: this.name,
            inputs: this.inputs.map(r => JSON.parse(r.format(e)))
        });
        const n = [];
        return e !== "sighash" && n.push("error"), n.push(this.name + n6(e, this.inputs)), n.join(" ")
    }
    static from(e) {
        if (La.isFragment(e)) return e;
        if (typeof e == "string") return La.from(lg(e));
        if (e instanceof Du) {
            const n = n9("error", e),
                r = gh(e);
            return $m(e), new La(Ri, n, r)
        }
        return new La(Ri, e.name, e.inputs ? e.inputs.map(Rr.from) : [])
    }
    static isFragment(e) {
        return e && e[Ya] === qG
    }
}
class Pf extends r9 {
    constructor(n, r, i, s) {
        super(n, "event", r, i);
        Ie(this, "anonymous");
        Object.defineProperty(this, Ya, {
            value: KG
        }), Xt(this, {
            anonymous: s
        })
    }
    get topicHash() {
        return Dm(this.format("sighash"))
    }
    format(n) {
        if (n == null && (n = "sighash"), n === "json") return JSON.stringify({
            type: "event",
            anonymous: this.anonymous,
            name: this.name,
            inputs: this.inputs.map(i => JSON.parse(i.format(n)))
        });
        const r = [];
        return n !== "sighash" && r.push("event"), r.push(this.name + n6(n, this.inputs)), n !== "sighash" && this.anonymous && r.push("anonymous"), r.join(" ")
    }
    static getTopicHash(n, r) {
        return r = (r || []).map(s => Rr.from(s)), new Pf(Ri, n, r, !1).topicHash
    }
    static from(n) {
        if (Pf.isFragment(n)) return n;
        if (typeof n == "string") try {
            return Pf.from(lg(n))
        } catch {
            Ee(!1, "invalid event fragment", "obj", n)
        } else if (n instanceof Du) {
            const r = n9("event", n),
                i = gh(n, !0),
                s = !!Ah(n, la(["anonymous"])).has("anonymous");
            return $m(n), new Pf(Ri, r, i, s)
        }
        return new Pf(Ri, n.name, n.inputs ? n.inputs.map(r => Rr.from(r, !0)) : [], !!n.anonymous)
    }
    static isFragment(n) {
        return n && n[Ya] === KG
    }
}
class lh extends Lm {
    constructor(n, r, i, s, o) {
        super(n, r, i);
        Ie(this, "payable");
        Ie(this, "gas");
        Object.defineProperty(this, Ya, {
            value: YG
        }), Xt(this, {
            payable: s,
            gas: o
        })
    }
    format(n) {
        if (je(n != null && n !== "sighash", "cannot format a constructor for sighash", "UNSUPPORTED_OPERATION", {
                operation: "format(sighash)"
            }), n === "json") return JSON.stringify({
            type: "constructor",
            stateMutability: this.payable ? "payable" : "undefined",
            payable: this.payable,
            gas: this.gas != null ? this.gas : void 0,
            inputs: this.inputs.map(i => JSON.parse(i.format(n)))
        });
        const r = [`constructor${n6(n,this.inputs)}`];
        return this.payable && r.push("payable"), this.gas != null && r.push(`@${this.gas.toString()}`), r.join(" ")
    }
    static from(n) {
        if (lh.isFragment(n)) return n;
        if (typeof n == "string") try {
            return lh.from(lg(n))
        } catch {
            Ee(!1, "invalid constuctor fragment", "obj", n)
        } else if (n instanceof Du) {
            Ah(n, la(["constructor"]));
            const r = gh(n),
                i = !!Ah(n, ePe).has("payable"),
                s = bie(n);
            return $m(n), new lh(Ri, "constructor", r, i, s)
        }
        return new lh(Ri, "constructor", n.inputs ? n.inputs.map(Rr.from) : [], !!n.payable, n.gas != null ? n.gas : null)
    }
    static isFragment(n) {
        return n && n[Ya] === YG
    }
}
class Gd extends Lm {
    constructor(n, r, i) {
        super(n, "fallback", r);
        Ie(this, "payable");
        Object.defineProperty(this, Ya, {
            value: ZG
        }), Xt(this, {
            payable: i
        })
    }
    format(n) {
        const r = this.inputs.length === 0 ? "receive" : "fallback";
        if (n === "json") {
            const i = this.payable ? "payable" : "nonpayable";
            return JSON.stringify({
                type: r,
                stateMutability: i
            })
        }
        return `${r}()${this.payable?" payable":""}`
    }
    static from(n) {
        if (Gd.isFragment(n)) return n;
        if (typeof n == "string") try {
            return Gd.from(lg(n))
        } catch {
            Ee(!1, "invalid fallback fragment", "obj", n)
        } else if (n instanceof Du) {
            const r = n.toString(),
                i = n.peekKeyword(la(["fallback", "receive"]));
            if (Ee(i, "type must be fallback or receive", "obj", r), n.popKeyword(la(["fallback", "receive"])) === "receive") {
                const l = gh(n);
                return Ee(l.length === 0, "receive cannot have arguments", "obj.inputs", l), Ah(n, la(["payable"])), $m(n), new Gd(Ri, [], !0)
            }
            let o = gh(n);
            o.length ? Ee(o.length === 1 && o[0].type === "bytes", "invalid fallback inputs", "obj.inputs", o.map(l => l.format("minimal")).join(", ")) : o = [Rr.from("bytes")];
            const a = vie(n);
            if (Ee(a === "nonpayable" || a === "payable", "fallback cannot be constants", "obj.stateMutability", a), Ah(n, la(["returns"])).has("returns")) {
                const l = gh(n);
                Ee(l.length === 1 && l[0].type === "bytes", "invalid fallback outputs", "obj.outputs", l.map(c => c.format("minimal")).join(", "))
            }
            return $m(n), new Gd(Ri, o, a === "payable")
        }
        if (n.type === "receive") return new Gd(Ri, [], !0);
        if (n.type === "fallback") {
            const r = [Rr.from("bytes")],
                i = n.stateMutability === "payable";
            return new Gd(Ri, r, i)
        }
        Ee(!1, "invalid fallback description", "obj", n)
    }
    static isFragment(n) {
        return n && n[Ya] === ZG
    }
}
class kf extends r9 {
    constructor(n, r, i, s, o, a) {
        super(n, "function", r, s);
        Ie(this, "constant");
        Ie(this, "outputs");
        Ie(this, "stateMutability");
        Ie(this, "payable");
        Ie(this, "gas");
        Object.defineProperty(this, Ya, {
            value: QG
        }), o = Object.freeze(o.slice()), Xt(this, {
            constant: i === "view" || i === "pure",
            gas: a,
            outputs: o,
            payable: i === "payable",
            stateMutability: i
        })
    }
    get selector() {
        return Dm(this.format("sighash")).substring(0, 10)
    }
    format(n) {
        if (n == null && (n = "sighash"), n === "json") return JSON.stringify({
            type: "function",
            name: this.name,
            constant: this.constant,
            stateMutability: this.stateMutability !== "nonpayable" ? this.stateMutability : void 0,
            payable: this.payable,
            gas: this.gas != null ? this.gas : void 0,
            inputs: this.inputs.map(i => JSON.parse(i.format(n))),
            outputs: this.outputs.map(i => JSON.parse(i.format(n)))
        });
        const r = [];
        return n !== "sighash" && r.push("function"), r.push(this.name + n6(n, this.inputs)), n !== "sighash" && (this.stateMutability !== "nonpayable" && r.push(this.stateMutability), this.outputs && this.outputs.length && (r.push("returns"), r.push(n6(n, this.outputs))), this.gas != null && r.push(`@${this.gas.toString()}`)), r.join(" ")
    }
    static getSelector(n, r) {
        return r = (r || []).map(s => Rr.from(s)), new kf(Ri, n, "view", r, [], null).selector
    }
    static from(n) {
        if (kf.isFragment(n)) return n;
        if (typeof n == "string") try {
            return kf.from(lg(n))
        } catch {
            Ee(!1, "invalid function fragment", "obj", n)
        } else if (n instanceof Du) {
            const i = n9("function", n),
                s = gh(n),
                o = vie(n);
            let a = [];
            Ah(n, la(["returns"])).has("returns") && (a = gh(n));
            const l = bie(n);
            return $m(n), new kf(Ri, i, o, s, a, l)
        }
        let r = n.stateMutability;
        return r == null && (r = "payable", typeof n.constant == "boolean" ? (r = "view", n.constant || (r = "payable", typeof n.payable == "boolean" && !n.payable && (r = "nonpayable"))) : typeof n.payable == "boolean" && !n.payable && (r = "nonpayable")), new kf(Ri, n.name, r, n.inputs ? n.inputs.map(Rr.from) : [], n.outputs ? n.outputs.map(Rr.from) : [], n.gas != null ? n.gas : null)
    }
    static isFragment(n) {
        return n && n[Ya] === QG
    }
}
class nm extends r9 {
    constructor(e, n, r) {
        super(e, "struct", n, r), Object.defineProperty(this, Ya, {
            value: JG
        })
    }
    format() {
        throw new Error("@TODO")
    }
    static from(e) {
        if (typeof e == "string") try {
            return nm.from(lg(e))
        } catch {
            Ee(!1, "invalid struct fragment", "obj", e)
        } else if (e instanceof Du) {
            const n = n9("struct", e),
                r = gh(e);
            return $m(e), new nm(Ri, n, r)
        }
        return new nm(Ri, e.name, e.inputs ? e.inputs.map(Rr.from) : [])
    }
    static isFragment(e) {
        return e && e[Ya] === JG
    }
}
const zu = new Map;
zu.set(0, "GENERIC_PANIC");
zu.set(1, "ASSERT_FALSE");
zu.set(17, "OVERFLOW");
zu.set(18, "DIVIDE_BY_ZERO");
zu.set(33, "ENUM_RANGE_ERROR");
zu.set(34, "BAD_STORAGE_DATA");
zu.set(49, "STACK_UNDERFLOW");
zu.set(50, "ARRAY_RANGE_ERROR");
zu.set(65, "OUT_OF_MEMORY");
zu.set(81, "UNINITIALIZED_FUNCTION_CALL");
const fPe = new RegExp(/^bytes([0-9]*)$/),
    dPe = new RegExp(/^(u?int)([0-9]*)$/);
let AO = null,
    XG = 1024;

function hPe(t, e, n, r) {
    let i = "missing revert data",
        s = null;
    const o = null;
    let a = null;
    if (n) {
        i = "execution reverted";
        const c = or(n);
        if (n = Ot(n), c.length === 0) i += " (no data present; likely require(false) occurred", s = "require(false)";
        else if (c.length % 32 !== 4) i += " (could not decode reason; invalid data length)";
        else if (Ot(c.slice(0, 4)) === "0x08c379a0") try {
            s = r.decode(["string"], c.slice(4))[0], a = {
                signature: "Error(string)",
                name: "Error",
                args: [s]
            }, i += `: ${JSON.stringify(s)}`
        } catch {
            i += " (could not decode reason; invalid string data)"
        } else if (Ot(c.slice(0, 4)) === "0x4e487b71") try {
            const u = Number(r.decode(["uint256"], c.slice(4))[0]);
            a = {
                signature: "Panic(uint256)",
                name: "Panic",
                args: [u]
            }, s = `Panic due to ${zu.get(u)||"UNKNOWN"}(${u})`, i += `: ${s}`
        } catch {
            i += " (could not decode panic code)"
        } else i += " (unknown custom error)"
    }
    const l = {
        to: e.to ? Hn(e.to) : null,
        data: e.data || "0x"
    };
    return e.from && (l.from = Hn(e.from)), pi(i, "CALL_EXCEPTION", {
        action: t,
        data: n,
        reason: s,
        transaction: l,
        invocation: o,
        revert: a
    })
}
var Y0, Ew;
const rT = class rT {
    constructor() {
        _e(this, Y0)
    }
    getDefaultValue(e) {
        const n = e.map(i => De(this, Y0, Ew).call(this, Rr.from(i)));
        return new Yx(n, "_").defaultValue()
    }
    encode(e, n) {
        Kne(n.length, e.length, "types/values length mismatch");
        const r = e.map(o => De(this, Y0, Ew).call(this, Rr.from(o))),
            i = new Yx(r, "_"),
            s = new Tk;
        return i.encode(s, n), s.data
    }
    decode(e, n, r) {
        const i = e.map(o => De(this, Y0, Ew).call(this, Rr.from(o)));
        return new Yx(i, "_").decode(new Ik(n, r, XG))
    }
    static _setDefaultMaxInflation(e) {
        Ee(typeof e == "number" && Number.isInteger(e), "invalid defaultMaxInflation factor", "value", e), XG = e
    }
    static defaultAbiCoder() {
        return AO == null && (AO = new rT), AO
    }
    static getBuiltinCallException(e, n, r) {
        return hPe(e, n, r, rT.defaultAbiCoder())
    }
};
Y0 = new WeakSet, Ew = function(e) {
    if (e.isArray()) return new $Oe(De(this, Y0, Ew).call(this, e.arrayChildren), e.arrayLength, e.name);
    if (e.isTuple()) return new Yx(e.components.map(r => De(this, Y0, Ew).call(this, r)), e.name);
    switch (e.baseType) {
        case "address":
            return new MOe(e.name);
        case "bool":
            return new LOe(e.name);
        case "string":
            return new GOe(e.name);
        case "bytes":
            return new BOe(e.name);
        case "":
            return new jOe(e.name)
    }
    let n = e.type.match(dPe);
    if (n) {
        let r = parseInt(n[2] || "256");
        return Ee(r !== 0 && r <= 256 && r % 8 === 0, "invalid " + n[1] + " bit length", "param", e), new VOe(r / 8, n[1] === "int", e.name)
    }
    if (n = e.type.match(fPe), n) {
        let r = parseInt(n[1]);
        return Ee(r !== 0 && r <= 32, "invalid bytes length", "param", e), new FOe(r, e.name)
    }
    Ee(!1, "invalid type", "type", e.type)
};
let Jo = rT;
class pPe {
    constructor(e, n, r) {
        Ie(this, "fragment");
        Ie(this, "name");
        Ie(this, "signature");
        Ie(this, "topic");
        Ie(this, "args");
        const i = e.name,
            s = e.format();
        Xt(this, {
            fragment: e,
            name: i,
            signature: s,
            topic: n,
            args: r
        })
    }
}
class gPe {
    constructor(e, n, r, i) {
        Ie(this, "fragment");
        Ie(this, "name");
        Ie(this, "args");
        Ie(this, "signature");
        Ie(this, "selector");
        Ie(this, "value");
        const s = e.name,
            o = e.format();
        Xt(this, {
            fragment: e,
            name: s,
            args: r,
            signature: o,
            selector: n,
            value: i
        })
    }
}
class mPe {
    constructor(e, n, r) {
        Ie(this, "fragment");
        Ie(this, "name");
        Ie(this, "args");
        Ie(this, "signature");
        Ie(this, "selector");
        const i = e.name,
            s = e.format();
        Xt(this, {
            fragment: e,
            name: i,
            args: r,
            signature: s,
            selector: n
        })
    }
}
class eq {
    constructor(e) {
        Ie(this, "hash");
        Ie(this, "_isIndexed");
        Xt(this, {
            hash: e,
            _isIndexed: !0
        })
    }
    static isIndexed(e) {
        return !!(e && e._isIndexed)
    }
}
const tq = {
        0: "generic panic",
        1: "assert(false)",
        17: "arithmetic overflow",
        18: "division or modulo by zero",
        33: "enum overflow",
        34: "invalid encoded storage byte array accessed",
        49: "out-of-bounds array access; popping on an empty array",
        50: "out-of-bounds access of an array or bytesN",
        65: "out of memory",
        81: "uninitialized function"
    },
    nq = {
        "0x08c379a0": {
            signature: "Error(string)",
            name: "Error",
            inputs: ["string"],
            reason: t => `reverted with reason string ${JSON.stringify(t)}`
        },
        "0x4e487b71": {
            signature: "Panic(uint256)",
            name: "Panic",
            inputs: ["uint256"],
            reason: t => {
                let e = "unknown panic code";
                return t >= 0 && t <= 255 && tq[t.toString()] && (e = tq[t.toString()]), `reverted with panic code 0x${t.toString(16)} (${e})`
            }
        }
    };
var Ef, xf, Sf, Co, Qf, s8, o8;
const i1 = class i1 {
    constructor(e) {
        _e(this, Qf);
        Ie(this, "fragments");
        Ie(this, "deploy");
        Ie(this, "fallback");
        Ie(this, "receive");
        _e(this, Ef);
        _e(this, xf);
        _e(this, Sf);
        _e(this, Co);
        let n = [];
        typeof e == "string" ? n = JSON.parse(e) : n = e, le(this, Sf, new Map), le(this, Ef, new Map), le(this, xf, new Map);
        const r = [];
        for (const o of n) try {
            r.push(Lm.from(o))
        } catch (a) {
            console.log(`[Warning] Invalid Fragment ${JSON.stringify(o)}:`, a.message)
        }
        Xt(this, {
            fragments: Object.freeze(r)
        });
        let i = null,
            s = !1;
        le(this, Co, this.getAbiCoder()), this.fragments.forEach((o, a) => {
            let l;
            switch (o.type) {
                case "constructor":
                    if (this.deploy) {
                        console.log("duplicate definition - constructor");
                        return
                    }
                    Xt(this, {
                        deploy: o
                    });
                    return;
                case "fallback":
                    o.inputs.length === 0 ? s = !0 : (Ee(!i || o.payable !== i.payable, "conflicting fallback fragments", `fragments[${a}]`, o), i = o, s = i.payable);
                    return;
                case "function":
                    l = W(this, Sf);
                    break;
                case "event":
                    l = W(this, xf);
                    break;
                case "error":
                    l = W(this, Ef);
                    break;
                default:
                    return
            }
            const c = o.format();
            l.has(c) || l.set(c, o)
        }), this.deploy || Xt(this, {
            deploy: lh.from("constructor()")
        }), Xt(this, {
            fallback: i,
            receive: s
        })
    }
    format(e) {
        const n = e ? "minimal" : "full";
        return this.fragments.map(i => i.format(n))
    }
    formatJson() {
        const e = this.fragments.map(n => n.format("json"));
        return JSON.stringify(e.map(n => JSON.parse(n)))
    }
    getAbiCoder() {
        return Jo.defaultAbiCoder()
    }
    getFunctionName(e) {
        const n = De(this, Qf, s8).call(this, e, null, !1);
        return Ee(n, "no matching function", "key", e), n.name
    }
    hasFunction(e) {
        return !!De(this, Qf, s8).call(this, e, null, !1)
    }
    getFunction(e, n) {
        return De(this, Qf, s8).call(this, e, n || null, !0)
    }
    forEachFunction(e) {
        const n = Array.from(W(this, Sf).keys());
        n.sort((r, i) => r.localeCompare(i));
        for (let r = 0; r < n.length; r++) {
            const i = n[r];
            e(W(this, Sf).get(i), r)
        }
    }
    getEventName(e) {
        const n = De(this, Qf, o8).call(this, e, null, !1);
        return Ee(n, "no matching event", "key", e), n.name
    }
    hasEvent(e) {
        return !!De(this, Qf, o8).call(this, e, null, !1)
    }
    getEvent(e, n) {
        return De(this, Qf, o8).call(this, e, n || null, !0)
    }
    forEachEvent(e) {
        const n = Array.from(W(this, xf).keys());
        n.sort((r, i) => r.localeCompare(i));
        for (let r = 0; r < n.length; r++) {
            const i = n[r];
            e(W(this, xf).get(i), r)
        }
    }
    getError(e, n) {
        if (Zr(e)) {
            const i = e.toLowerCase();
            if (nq[i]) return La.from(nq[i].signature);
            for (const s of W(this, Ef).values())
                if (i === s.selector) return s;
            return null
        }
        if (e.indexOf("(") === -1) {
            const i = [];
            for (const [s, o] of W(this, Ef)) s.split("(")[0] === e && i.push(o);
            if (i.length === 0) return e === "Error" ? La.from("error Error(string)") : e === "Panic" ? La.from("error Panic(uint256)") : null;
            if (i.length > 1) {
                const s = i.map(o => JSON.stringify(o.format())).join(", ");
                Ee(!1, `ambiguous error description (i.e. ${s})`, "name", e)
            }
            return i[0]
        }
        if (e = La.from(e).format(), e === "Error(string)") return La.from("error Error(string)");
        if (e === "Panic(uint256)") return La.from("error Panic(uint256)");
        const r = W(this, Ef).get(e);
        return r || null
    }
    forEachError(e) {
        const n = Array.from(W(this, Ef).keys());
        n.sort((r, i) => r.localeCompare(i));
        for (let r = 0; r < n.length; r++) {
            const i = n[r];
            e(W(this, Ef).get(i), r)
        }
    }
    _decodeParams(e, n) {
        return W(this, Co).decode(e, n)
    }
    _encodeParams(e, n) {
        return W(this, Co).encode(e, n)
    }
    encodeDeploy(e) {
        return this._encodeParams(this.deploy.inputs, e || [])
    }
    decodeErrorResult(e, n) {
        if (typeof e == "string") {
            const r = this.getError(e);
            Ee(r, "unknown error", "fragment", e), e = r
        }
        return Ee(ji(n, 0, 4) === e.selector, `data signature does not match error ${e.name}.`, "data", n), this._decodeParams(e.inputs, ji(n, 4))
    }
    encodeErrorResult(e, n) {
        if (typeof e == "string") {
            const r = this.getError(e);
            Ee(r, "unknown error", "fragment", e), e = r
        }
        return vi([e.selector, this._encodeParams(e.inputs, n || [])])
    }
    decodeFunctionData(e, n) {
        if (typeof e == "string") {
            const r = this.getFunction(e);
            Ee(r, "unknown function", "fragment", e), e = r
        }
        return Ee(ji(n, 0, 4) === e.selector, `data signature does not match function ${e.name}.`, "data", n), this._decodeParams(e.inputs, ji(n, 4))
    }
    encodeFunctionData(e, n) {
        if (typeof e == "string") {
            const r = this.getFunction(e);
            Ee(r, "unknown function", "fragment", e), e = r
        }
        return vi([e.selector, this._encodeParams(e.inputs, n || [])])
    }
    decodeFunctionResult(e, n) {
        if (typeof e == "string") {
            const s = this.getFunction(e);
            Ee(s, "unknown function", "fragment", e), e = s
        }
        let r = "invalid length for result data";
        const i = ra(n);
        if (i.length % 32 === 0) try {
            return W(this, Co).decode(e.outputs, i)
        } catch {
            r = "could not decode result data"
        }
        je(!1, r, "BAD_DATA", {
            value: Ot(i),
            info: {
                method: e.name,
                signature: e.format()
            }
        })
    }
    makeError(e, n) {
        const r = or(e, "data"),
            i = Jo.getBuiltinCallException("call", n, r);
        if (i.message.startsWith("execution reverted (unknown custom error)")) {
            const a = Ot(r.slice(0, 4)),
                l = this.getError(a);
            if (l) try {
                const c = W(this, Co).decode(l.inputs, r.slice(4));
                i.revert = {
                    name: l.name,
                    signature: l.format(),
                    args: c
                }, i.reason = i.revert.signature, i.message = `execution reverted: ${i.reason}`
            } catch {
                i.message = "execution reverted (coult not decode custom error)"
            }
        }
        const o = this.parseTransaction(n);
        return o && (i.invocation = {
            method: o.name,
            signature: o.signature,
            args: o.args
        }), i
    }
    encodeFunctionResult(e, n) {
        if (typeof e == "string") {
            const r = this.getFunction(e);
            Ee(r, "unknown function", "fragment", e), e = r
        }
        return Ot(W(this, Co).encode(e.outputs, n || []))
    }
    encodeFilterTopics(e, n) {
        if (typeof e == "string") {
            const s = this.getEvent(e);
            Ee(s, "unknown event", "eventFragment", e), e = s
        }
        je(n.length <= e.inputs.length, `too many arguments for ${e.format()}`, "UNEXPECTED_ARGUMENT", {
            count: n.length,
            expectedCount: e.inputs.length
        });
        const r = [];
        e.anonymous || r.push(e.topicHash);
        const i = (s, o) => s.type === "string" ? Dm(o) : s.type === "bytes" ? fs(Ot(o)) : (s.type === "bool" && typeof o == "boolean" ? o = o ? "0x01" : "0x00" : s.type.match(/^u?int/) ? o = zp(o) : s.type.match(/^bytes/) ? o = DIe(o, 32) : s.type === "address" && W(this, Co).encode(["address"], [o]), km(Ot(o), 32));
        for (n.forEach((s, o) => {
                const a = e.inputs[o];
                if (!a.indexed) {
                    Ee(s == null, "cannot filter non-indexed parameters; must be null", "contract." + a.name, s);
                    return
                }
                s == null ? r.push(null) : a.baseType === "array" || a.baseType === "tuple" ? Ee(!1, "filtering with tuples or arrays not supported", "contract." + a.name, s) : Array.isArray(s) ? r.push(s.map(l => i(a, l))) : r.push(i(a, s))
            }); r.length && r[r.length - 1] === null;) r.pop();
        return r
    }
    encodeEventLog(e, n) {
        if (typeof e == "string") {
            const o = this.getEvent(e);
            Ee(o, "unknown event", "eventFragment", e), e = o
        }
        const r = [],
            i = [],
            s = [];
        return e.anonymous || r.push(e.topicHash), Ee(n.length === e.inputs.length, "event arguments/values mismatch", "values", n), e.inputs.forEach((o, a) => {
            const l = n[a];
            if (o.indexed)
                if (o.type === "string") r.push(Dm(l));
                else if (o.type === "bytes") r.push(fs(l));
            else {
                if (o.baseType === "tuple" || o.baseType === "array") throw new Error("not implemented");
                r.push(W(this, Co).encode([o.type], [l]))
            } else i.push(o), s.push(l)
        }), {
            data: W(this, Co).encode(i, s),
            topics: r
        }
    }
    decodeEventLog(e, n, r) {
        if (typeof e == "string") {
            const g = this.getEvent(e);
            Ee(g, "unknown event", "eventFragment", e), e = g
        }
        if (r != null && !e.anonymous) {
            const g = e.topicHash;
            Ee(Zr(r[0], 32) && r[0].toLowerCase() === g, "fragment/topic mismatch", "topics[0]", r[0]), r = r.slice(1)
        }
        const i = [],
            s = [],
            o = [];
        e.inputs.forEach((g, y) => {
            g.indexed ? g.type === "string" || g.type === "bytes" || g.baseType === "tuple" || g.baseType === "array" ? (i.push(Rr.from({
                type: "bytes32",
                name: g.name
            })), o.push(!0)) : (i.push(g), o.push(!1)) : (s.push(g), o.push(!1))
        });
        const a = r != null ? W(this, Co).decode(i, vi(r)) : null,
            l = W(this, Co).decode(s, n, !0),
            c = [],
            u = [];
        let f = 0,
            h = 0;
        return e.inputs.forEach((g, y) => {
            let _ = null;
            if (g.indexed)
                if (a == null) _ = new eq(null);
                else if (o[y]) _ = new eq(a[h++]);
            else try {
                _ = a[h++]
            } catch (C) {
                _ = C
            } else try {
                _ = l[f++]
            } catch (C) {
                _ = C
            }
            c.push(_), u.push(g.name || null)
        }), Wp.fromItems(c, u)
    }
    parseTransaction(e) {
        const n = or(e.data, "tx.data"),
            r = kt(e.value != null ? e.value : 0, "tx.value"),
            i = this.getFunction(Ot(n.slice(0, 4)));
        if (!i) return null;
        const s = W(this, Co).decode(i.inputs, n.slice(4));
        return new gPe(i, i.selector, s, r)
    }
    parseCallResult(e) {
        throw new Error("@TODO")
    }
    parseLog(e) {
        const n = this.getEvent(e.topics[0]);
        return !n || n.anonymous ? null : new pPe(n, n.topicHash, this.decodeEventLog(n, e.data, e.topics))
    }
    parseError(e) {
        const n = Ot(e),
            r = this.getError(ji(n, 0, 4));
        if (!r) return null;
        const i = W(this, Co).decode(r.inputs, ji(n, 4));
        return new mPe(r, r.selector, i)
    }
    static from(e) {
        return e instanceof i1 ? e : typeof e == "string" ? new i1(JSON.parse(e)) : typeof e.formatJson == "function" ? new i1(e.formatJson()) : typeof e.format == "function" ? new i1(e.format("json")) : new i1(e)
    }
};
Ef = new WeakMap, xf = new WeakMap, Sf = new WeakMap, Co = new WeakMap, Qf = new WeakSet, s8 = function(e, n, r) {
    if (Zr(e)) {
        const s = e.toLowerCase();
        for (const o of W(this, Sf).values())
            if (s === o.selector) return o;
        return null
    }
    if (e.indexOf("(") === -1) {
        const s = [];
        for (const [o, a] of W(this, Sf)) o.split("(")[0] === e && s.push(a);
        if (n) {
            const o = n.length > 0 ? n[n.length - 1] : null;
            let a = n.length,
                l = !0;
            Po.isTyped(o) && o.type === "overrides" && (l = !1, a--);
            for (let c = s.length - 1; c >= 0; c--) {
                const u = s[c].inputs.length;
                u !== a && (!l || u !== a - 1) && s.splice(c, 1)
            }
            for (let c = s.length - 1; c >= 0; c--) {
                const u = s[c].inputs;
                for (let f = 0; f < n.length; f++)
                    if (Po.isTyped(n[f])) {
                        if (f >= u.length) {
                            if (n[f].type === "overrides") continue;
                            s.splice(c, 1);
                            break
                        }
                        if (n[f].type !== u[f].baseType) {
                            s.splice(c, 1);
                            break
                        }
                    }
            }
        }
        if (s.length === 1 && n && n.length !== s[0].inputs.length) {
            const o = n[n.length - 1];
            (o == null || Array.isArray(o) || typeof o != "object") && s.splice(0, 1)
        }
        if (s.length === 0) return null;
        if (s.length > 1 && r) {
            const o = s.map(a => JSON.stringify(a.format())).join(", ");
            Ee(!1, `ambiguous function description (i.e. matches ${o})`, "key", e)
        }
        return s[0]
    }
    const i = W(this, Sf).get(kf.from(e).format());
    return i || null
}, o8 = function(e, n, r) {
    if (Zr(e)) {
        const s = e.toLowerCase();
        for (const o of W(this, xf).values())
            if (s === o.topicHash) return o;
        return null
    }
    if (e.indexOf("(") === -1) {
        const s = [];
        for (const [o, a] of W(this, xf)) o.split("(")[0] === e && s.push(a);
        if (n) {
            for (let o = s.length - 1; o >= 0; o--) s[o].inputs.length < n.length && s.splice(o, 1);
            for (let o = s.length - 1; o >= 0; o--) {
                const a = s[o].inputs;
                for (let l = 0; l < n.length; l++)
                    if (Po.isTyped(n[l]) && n[l].type !== a[l].baseType) {
                        s.splice(o, 1);
                        break
                    }
            }
        }
        if (s.length === 0) return null;
        if (s.length > 1 && r) {
            const o = s.map(a => JSON.stringify(a.format())).join(", ");
            Ee(!1, `ambiguous event description (i.e. matches ${o})`, "key", e)
        }
        return s[0]
    }
    const i = W(this, xf).get(Pf.from(e).format());
    return i || null
};
let Hk = i1;
const _ie = BigInt(0);

function av(t) {
    return t ? ? null
}

function is(t) {
    return t == null ? null : t.toString()
}
class rq {
    constructor(e, n, r) {
        Ie(this, "gasPrice");
        Ie(this, "maxFeePerGas");
        Ie(this, "maxPriorityFeePerGas");
        Xt(this, {
            gasPrice: av(e),
            maxFeePerGas: av(n),
            maxPriorityFeePerGas: av(r)
        })
    }
    toJSON() {
        const {
            gasPrice: e,
            maxFeePerGas: n,
            maxPriorityFeePerGas: r
        } = this;
        return {
            _type: "FeeData",
            gasPrice: is(e),
            maxFeePerGas: is(n),
            maxPriorityFeePerGas: is(r)
        }
    }
}

function jC(t) {
    const e = {};
    t.to && (e.to = t.to), t.from && (e.from = t.from), t.data && (e.data = Ot(t.data));
    const n = "chainId,gasLimit,gasPrice,maxFeePerBlobGas,maxFeePerGas,maxPriorityFeePerGas,value".split(/,/);
    for (const i of n) !(i in t) || t[i] == null || (e[i] = kt(t[i], `request.${i}`));
    const r = "type,nonce".split(/,/);
    for (const i of r) !(i in t) || t[i] == null || (e[i] = Mn(t[i], `request.${i}`));
    return t.accessList && (e.accessList = wy(t.accessList)), "blockTag" in t && (e.blockTag = t.blockTag), "enableCcipRead" in t && (e.enableCcipRead = !!t.enableCcipRead), "customData" in t && (e.customData = t.customData), "blobVersionedHashes" in t && t.blobVersionedHashes && (e.blobVersionedHashes = t.blobVersionedHashes.slice()), "kzg" in t && (e.kzg = t.kzg), "blobs" in t && t.blobs && (e.blobs = t.blobs.map(i => EL(i) ? Ot(i) : Object.assign({}, i))), e
}
var eh;
class yPe {
    constructor(e, n) {
        Ie(this, "provider");
        Ie(this, "number");
        Ie(this, "hash");
        Ie(this, "timestamp");
        Ie(this, "parentHash");
        Ie(this, "parentBeaconBlockRoot");
        Ie(this, "nonce");
        Ie(this, "difficulty");
        Ie(this, "gasLimit");
        Ie(this, "gasUsed");
        Ie(this, "stateRoot");
        Ie(this, "receiptsRoot");
        Ie(this, "blobGasUsed");
        Ie(this, "excessBlobGas");
        Ie(this, "miner");
        Ie(this, "prevRandao");
        Ie(this, "extraData");
        Ie(this, "baseFeePerGas");
        _e(this, eh);
        le(this, eh, e.transactions.map(r => typeof r != "string" ? new r6(r, n) : r)), Xt(this, {
            provider: n,
            hash: av(e.hash),
            number: e.number,
            timestamp: e.timestamp,
            parentHash: e.parentHash,
            parentBeaconBlockRoot: e.parentBeaconBlockRoot,
            nonce: e.nonce,
            difficulty: e.difficulty,
            gasLimit: e.gasLimit,
            gasUsed: e.gasUsed,
            blobGasUsed: e.blobGasUsed,
            excessBlobGas: e.excessBlobGas,
            miner: e.miner,
            prevRandao: av(e.prevRandao),
            extraData: e.extraData,
            baseFeePerGas: av(e.baseFeePerGas),
            stateRoot: e.stateRoot,
            receiptsRoot: e.receiptsRoot
        })
    }
    get transactions() {
        return W(this, eh).map(e => typeof e == "string" ? e : e.hash)
    }
    get prefetchedTransactions() {
        const e = W(this, eh).slice();
        return e.length === 0 ? [] : (je(typeof e[0] == "object", "transactions were not prefetched with block request", "UNSUPPORTED_OPERATION", {
            operation: "transactionResponses()"
        }), e)
    }
    toJSON() {
        const {
            baseFeePerGas: e,
            difficulty: n,
            extraData: r,
            gasLimit: i,
            gasUsed: s,
            hash: o,
            miner: a,
            prevRandao: l,
            nonce: c,
            number: u,
            parentHash: f,
            parentBeaconBlockRoot: h,
            stateRoot: g,
            receiptsRoot: y,
            timestamp: _,
            transactions: C
        } = this;
        return {
            _type: "Block",
            baseFeePerGas: is(e),
            difficulty: is(n),
            extraData: r,
            gasLimit: is(i),
            gasUsed: is(s),
            blobGasUsed: is(this.blobGasUsed),
            excessBlobGas: is(this.excessBlobGas),
            hash: o,
            miner: a,
            prevRandao: l,
            nonce: c,
            number: u,
            parentHash: f,
            timestamp: _,
            parentBeaconBlockRoot: h,
            stateRoot: g,
            receiptsRoot: y,
            transactions: C
        }
    }[Symbol.iterator]() {
        let e = 0;
        const n = this.transactions;
        return {
            next: () => e < this.length ? {
                value: n[e++],
                done: !1
            } : {
                value: void 0,
                done: !0
            }
        }
    }
    get length() {
        return W(this, eh).length
    }
    get date() {
        return this.timestamp == null ? null : new Date(this.timestamp * 1e3)
    }
    async getTransaction(e) {
        let n;
        if (typeof e == "number") n = W(this, eh)[e];
        else {
            const r = e.toLowerCase();
            for (const i of W(this, eh))
                if (typeof i == "string") {
                    if (i !== r) continue;
                    n = i;
                    break
                } else {
                    if (i.hash === r) continue;
                    n = i;
                    break
                }
        }
        if (n == null) throw new Error("no such tx");
        return typeof n == "string" ? await this.provider.getTransaction(n) : n
    }
    getPrefetchedTransaction(e) {
        const n = this.prefetchedTransactions;
        if (typeof e == "number") return n[e];
        e = e.toLowerCase();
        for (const r of n)
            if (r.hash === e) return r;
        Ee(!1, "no matching transaction", "indexOrHash", e)
    }
    isMined() {
        return !!this.hash
    }
    isLondon() {
        return !!this.baseFeePerGas
    }
    orphanedEvent() {
        if (!this.isMined()) throw new Error("");
        return wPe(this)
    }
}
eh = new WeakMap;
class NE {
    constructor(e, n) {
        Ie(this, "provider");
        Ie(this, "transactionHash");
        Ie(this, "blockHash");
        Ie(this, "blockNumber");
        Ie(this, "removed");
        Ie(this, "address");
        Ie(this, "data");
        Ie(this, "topics");
        Ie(this, "index");
        Ie(this, "transactionIndex");
        this.provider = n;
        const r = Object.freeze(e.topics.slice());
        Xt(this, {
            transactionHash: e.transactionHash,
            blockHash: e.blockHash,
            blockNumber: e.blockNumber,
            removed: e.removed,
            address: e.address,
            data: e.data,
            topics: r,
            index: e.index,
            transactionIndex: e.transactionIndex
        })
    }
    toJSON() {
        const {
            address: e,
            blockHash: n,
            blockNumber: r,
            data: i,
            index: s,
            removed: o,
            topics: a,
            transactionHash: l,
            transactionIndex: c
        } = this;
        return {
            _type: "log",
            address: e,
            blockHash: n,
            blockNumber: r,
            data: i,
            index: s,
            removed: o,
            topics: a,
            transactionHash: l,
            transactionIndex: c
        }
    }
    async getBlock() {
        const e = await this.provider.getBlock(this.blockHash);
        return je(!!e, "failed to find transaction", "UNKNOWN_ERROR", {}), e
    }
    async getTransaction() {
        const e = await this.provider.getTransaction(this.transactionHash);
        return je(!!e, "failed to find transaction", "UNKNOWN_ERROR", {}), e
    }
    async getTransactionReceipt() {
        const e = await this.provider.getTransactionReceipt(this.transactionHash);
        return je(!!e, "failed to find transaction receipt", "UNKNOWN_ERROR", {}), e
    }
    removedEvent() {
        return vPe(this)
    }
}
var Z6;
class Eie {
    constructor(e, n) {
        Ie(this, "provider");
        Ie(this, "to");
        Ie(this, "from");
        Ie(this, "contractAddress");
        Ie(this, "hash");
        Ie(this, "index");
        Ie(this, "blockHash");
        Ie(this, "blockNumber");
        Ie(this, "logsBloom");
        Ie(this, "gasUsed");
        Ie(this, "blobGasUsed");
        Ie(this, "cumulativeGasUsed");
        Ie(this, "gasPrice");
        Ie(this, "blobGasPrice");
        Ie(this, "type");
        Ie(this, "status");
        Ie(this, "root");
        _e(this, Z6);
        le(this, Z6, Object.freeze(e.logs.map(i => new NE(i, n))));
        let r = _ie;
        e.effectiveGasPrice != null ? r = e.effectiveGasPrice : e.gasPrice != null && (r = e.gasPrice), Xt(this, {
            provider: n,
            to: e.to,
            from: e.from,
            contractAddress: e.contractAddress,
            hash: e.hash,
            index: e.index,
            blockHash: e.blockHash,
            blockNumber: e.blockNumber,
            logsBloom: e.logsBloom,
            gasUsed: e.gasUsed,
            cumulativeGasUsed: e.cumulativeGasUsed,
            blobGasUsed: e.blobGasUsed,
            gasPrice: r,
            blobGasPrice: e.blobGasPrice,
            type: e.type,
            status: e.status,
            root: e.root
        })
    }
    get logs() {
        return W(this, Z6)
    }
    toJSON() {
        const {
            to: e,
            from: n,
            contractAddress: r,
            hash: i,
            index: s,
            blockHash: o,
            blockNumber: a,
            logsBloom: l,
            logs: c,
            status: u,
            root: f
        } = this;
        return {
            _type: "TransactionReceipt",
            blockHash: o,
            blockNumber: a,
            contractAddress: r,
            cumulativeGasUsed: is(this.cumulativeGasUsed),
            from: n,
            gasPrice: is(this.gasPrice),
            blobGasUsed: is(this.blobGasUsed),
            blobGasPrice: is(this.blobGasPrice),
            gasUsed: is(this.gasUsed),
            hash: i,
            index: s,
            logs: c,
            logsBloom: l,
            root: f,
            status: u,
            to: e
        }
    }
    get length() {
        return this.logs.length
    }[Symbol.iterator]() {
        let e = 0;
        return {
            next: () => e < this.length ? {
                value: this.logs[e++],
                done: !1
            } : {
                value: void 0,
                done: !0
            }
        }
    }
    get fee() {
        return this.gasUsed * this.gasPrice
    }
    async getBlock() {
        const e = await this.provider.getBlock(this.blockHash);
        if (e == null) throw new Error("TODO");
        return e
    }
    async getTransaction() {
        const e = await this.provider.getTransaction(this.hash);
        if (e == null) throw new Error("TODO");
        return e
    }
    async getResult() {
        return await this.provider.getTransactionResult(this.hash)
    }
    async confirmations() {
        return await this.provider.getBlockNumber() - this.blockNumber + 1
    }
    removedEvent() {
        return Sie(this)
    }
    reorderedEvent(e) {
        return je(!e || e.isMined(), "unmined 'other' transction cannot be orphaned", "UNSUPPORTED_OPERATION", {
            operation: "reorderedEvent(other)"
        }), xie(this, e)
    }
}
Z6 = new WeakMap;
var Z0;
const cj = class cj {
    constructor(e, n) {
        Ie(this, "provider");
        Ie(this, "blockNumber");
        Ie(this, "blockHash");
        Ie(this, "index");
        Ie(this, "hash");
        Ie(this, "type");
        Ie(this, "to");
        Ie(this, "from");
        Ie(this, "nonce");
        Ie(this, "gasLimit");
        Ie(this, "gasPrice");
        Ie(this, "maxPriorityFeePerGas");
        Ie(this, "maxFeePerGas");
        Ie(this, "maxFeePerBlobGas");
        Ie(this, "data");
        Ie(this, "value");
        Ie(this, "chainId");
        Ie(this, "signature");
        Ie(this, "accessList");
        Ie(this, "blobVersionedHashes");
        _e(this, Z0);
        this.provider = n, this.blockNumber = e.blockNumber != null ? e.blockNumber : null, this.blockHash = e.blockHash != null ? e.blockHash : null, this.hash = e.hash, this.index = e.index, this.type = e.type, this.from = e.from, this.to = e.to || null, this.gasLimit = e.gasLimit, this.nonce = e.nonce, this.data = e.data, this.value = e.value, this.gasPrice = e.gasPrice, this.maxPriorityFeePerGas = e.maxPriorityFeePerGas != null ? e.maxPriorityFeePerGas : null, this.maxFeePerGas = e.maxFeePerGas != null ? e.maxFeePerGas : null, this.maxFeePerBlobGas = e.maxFeePerBlobGas != null ? e.maxFeePerBlobGas : null, this.chainId = e.chainId, this.signature = e.signature, this.accessList = e.accessList != null ? e.accessList : null, this.blobVersionedHashes = e.blobVersionedHashes != null ? e.blobVersionedHashes : null, le(this, Z0, -1)
    }
    toJSON() {
        const {
            blockNumber: e,
            blockHash: n,
            index: r,
            hash: i,
            type: s,
            to: o,
            from: a,
            nonce: l,
            data: c,
            signature: u,
            accessList: f,
            blobVersionedHashes: h
        } = this;
        return {
            _type: "TransactionResponse",
            accessList: f,
            blockNumber: e,
            blockHash: n,
            blobVersionedHashes: h,
            chainId: is(this.chainId),
            data: c,
            from: a,
            gasLimit: is(this.gasLimit),
            gasPrice: is(this.gasPrice),
            hash: i,
            maxFeePerGas: is(this.maxFeePerGas),
            maxPriorityFeePerGas: is(this.maxPriorityFeePerGas),
            maxFeePerBlobGas: is(this.maxFeePerBlobGas),
            nonce: l,
            signature: u,
            to: o,
            index: r,
            type: s,
            value: is(this.value)
        }
    }
    async getBlock() {
        let e = this.blockNumber;
        if (e == null) {
            const r = await this.getTransaction();
            r && (e = r.blockNumber)
        }
        if (e == null) return null;
        const n = this.provider.getBlock(e);
        if (n == null) throw new Error("TODO");
        return n
    }
    async getTransaction() {
        return this.provider.getTransaction(this.hash)
    }
    async confirmations() {
        if (this.blockNumber == null) {
            const {
                tx: n,
                blockNumber: r
            } = await Xo({
                tx: this.getTransaction(),
                blockNumber: this.provider.getBlockNumber()
            });
            return n == null || n.blockNumber == null ? 0 : r - n.blockNumber + 1
        }
        return await this.provider.getBlockNumber() - this.blockNumber + 1
    }
    async wait(e, n) {
        const r = e ? ? 1,
            i = n ? ? 0;
        let s = W(this, Z0),
            o = -1,
            a = s === -1;
        const l = async () => {
                if (a) return null;
                const {
                    blockNumber: h,
                    nonce: g
                } = await Xo({
                    blockNumber: this.provider.getBlockNumber(),
                    nonce: this.provider.getTransactionCount(this.from)
                });
                if (g < this.nonce) {
                    s = h;
                    return
                }
                if (a) return null;
                const y = await this.getTransaction();
                if (!(y && y.blockNumber != null))
                    for (o === -1 && (o = s - 3, o < W(this, Z0) && (o = W(this, Z0))); o <= h;) {
                        if (a) return null;
                        const _ = await this.provider.getBlock(o, !0);
                        if (_ == null) return;
                        for (const C of _)
                            if (C === this.hash) return;
                        for (let C = 0; C < _.length; C++) {
                            const b = await _.getTransaction(C);
                            if (b.from === this.from && b.nonce === this.nonce) {
                                if (a) return null;
                                const w = await this.provider.getTransactionReceipt(b.hash);
                                if (w == null || h - w.blockNumber + 1 < r) return;
                                let S = "replaced";
                                b.data === this.data && b.to === this.to && b.value === this.value ? S = "repriced" : b.data === "0x" && b.from === b.to && b.value === _ie && (S = "cancelled"), je(!1, "transaction was replaced", "TRANSACTION_REPLACED", {
                                    cancelled: S === "replaced" || S === "cancelled",
                                    reason: S,
                                    replacement: b.replaceableTransaction(s),
                                    hash: b.hash,
                                    receipt: w
                                })
                            }
                        }
                        o++
                    }
            },
            c = h => {
                if (h == null || h.status !== 0) return h;
                je(!1, "transaction execution reverted", "CALL_EXCEPTION", {
                    action: "sendTransaction",
                    data: null,
                    reason: null,
                    invocation: null,
                    revert: null,
                    transaction: {
                        to: h.to,
                        from: h.from,
                        data: ""
                    },
                    receipt: h
                })
            },
            u = await this.provider.getTransactionReceipt(this.hash);
        if (r === 0) return c(u);
        if (u) {
            if (await u.confirmations() >= r) return c(u)
        } else if (await l(), r === 0) return null;
        return await new Promise((h, g) => {
            const y = [],
                _ = () => {
                    y.forEach(b => b())
                };
            if (y.push(() => {
                    a = !0
                }), i > 0) {
                const b = setTimeout(() => {
                    _(), g(pi("wait for transaction timeout", "TIMEOUT"))
                }, i);
                y.push(() => {
                    clearTimeout(b)
                })
            }
            const C = async b => {
                if (await b.confirmations() >= r) {
                    _();
                    try {
                        h(c(b))
                    } catch (w) {
                        g(w)
                    }
                }
            };
            if (y.push(() => {
                    this.provider.off(this.hash, C)
                }), this.provider.on(this.hash, C), s >= 0) {
                const b = async () => {
                    try {
                        await l()
                    } catch (w) {
                        if (No(w, "TRANSACTION_REPLACED")) {
                            _(), g(w);
                            return
                        }
                    }
                    a || this.provider.once("block", b)
                };
                y.push(() => {
                    this.provider.off("block", b)
                }), this.provider.once("block", b)
            }
        })
    }
    isMined() {
        return this.blockHash != null
    }
    isLegacy() {
        return this.type === 0
    }
    isBerlin() {
        return this.type === 1
    }
    isLondon() {
        return this.type === 2
    }
    isCancun() {
        return this.type === 3
    }
    removedEvent() {
        return je(this.isMined(), "unmined transaction canot be orphaned", "UNSUPPORTED_OPERATION", {
            operation: "removeEvent()"
        }), Sie(this)
    }
    reorderedEvent(e) {
        return je(this.isMined(), "unmined transaction canot be orphaned", "UNSUPPORTED_OPERATION", {
            operation: "removeEvent()"
        }), je(!e || e.isMined(), "unmined 'other' transaction canot be orphaned", "UNSUPPORTED_OPERATION", {
            operation: "removeEvent()"
        }), xie(this, e)
    }
    replaceableTransaction(e) {
        Ee(Number.isInteger(e) && e >= 0, "invalid startBlock", "startBlock", e);
        const n = new cj(this, this.provider);
        return le(n, Z0, e), n
    }
};
Z0 = new WeakMap;
let r6 = cj;

function wPe(t) {
    return {
        orphan: "drop-block",
        hash: t.hash,
        number: t.number
    }
}

function xie(t, e) {
    return {
        orphan: "reorder-transaction",
        tx: t,
        other: e
    }
}

function Sie(t) {
    return {
        orphan: "drop-transaction",
        tx: t
    }
}

function vPe(t) {
    return {
        orphan: "drop-log",
        log: {
            transactionHash: t.transactionHash,
            blockHash: t.blockHash,
            blockNumber: t.blockNumber,
            address: t.address,
            data: t.data,
            topics: Object.freeze(t.topics.slice()),
            index: t.index
        }
    }
}
class LL extends NE {
    constructor(n, r, i) {
        super(n, n.provider);
        Ie(this, "interface");
        Ie(this, "fragment");
        Ie(this, "args");
        const s = r.decodeEventLog(i, n.data, n.topics);
        Xt(this, {
            args: s,
            fragment: i,
            interface: r
        })
    }
    get eventName() {
        return this.fragment.name
    }
    get eventSignature() {
        return this.fragment.format()
    }
}
class Cie extends NE {
    constructor(n, r) {
        super(n, n.provider);
        Ie(this, "error");
        Xt(this, {
            error: r
        })
    }
}
var sb;
class bPe extends Eie {
    constructor(n, r, i) {
        super(i, r);
        _e(this, sb);
        le(this, sb, n)
    }
    get logs() {
        return super.logs.map(n => {
            const r = n.topics.length ? W(this, sb).getEvent(n.topics[0]) : null;
            if (r) try {
                return new LL(n, W(this, sb), r)
            } catch (i) {
                return new Cie(n, i)
            }
            return n
        })
    }
}
sb = new WeakMap;
var Q6;
class BL extends r6 {
    constructor(n, r, i) {
        super(i, r);
        _e(this, Q6);
        le(this, Q6, n)
    }
    async wait(n, r) {
        const i = await super.wait(n, r);
        return i == null ? null : new bPe(W(this, Q6), this.provider, i)
    }
}
Q6 = new WeakMap;
class Aie extends Jne {
    constructor(n, r, i, s) {
        super(n, r, i);
        Ie(this, "log");
        Xt(this, {
            log: s
        })
    }
    async getBlock() {
        return await this.log.getBlock()
    }
    async getTransaction() {
        return await this.log.getTransaction()
    }
    async getTransactionReceipt() {
        return await this.log.getTransactionReceipt()
    }
}
class _Pe extends Aie {
    constructor(e, n, r, i, s) {
        super(e, n, r, new LL(s, e.interface, i));
        const o = e.interface.decodeEventLog(i, this.log.data, this.log.topics);
        Xt(this, {
            args: o,
            fragment: i
        })
    }
    get eventName() {
        return this.fragment.name
    }
    get eventSignature() {
        return this.fragment.format()
    }
}
const iq = BigInt(0);

function Tie(t) {
    return t && typeof t.call == "function"
}

function Iie(t) {
    return t && typeof t.estimateGas == "function"
}

function i9(t) {
    return t && typeof t.resolveName == "function"
}

function Rie(t) {
    return t && typeof t.sendTransaction == "function"
}

function Oie(t) {
    if (t != null) {
        if (i9(t)) return t;
        if (t.provider) return t.provider
    }
}
var J6;
class EPe {
    constructor(e, n, r) {
        _e(this, J6);
        Ie(this, "fragment");
        if (Xt(this, {
                fragment: n
            }), n.inputs.length < r.length) throw new Error("too many arguments");
        const i = Bm(e.runner, "resolveName"),
            s = i9(i) ? i : null;
        le(this, J6, async function() {
            const o = await Promise.all(n.inputs.map((a, l) => r[l] == null ? null : a.walkAsync(r[l], (u, f) => u === "address" ? Array.isArray(f) ? Promise.all(f.map(h => aa(h, s))) : aa(f, s) : f)));
            return e.interface.encodeFilterTopics(n, o)
        }())
    }
    getTopicFilter() {
        return W(this, J6)
    }
}
J6 = new WeakMap;

function Bm(t, e) {
    return t == null ? null : typeof t[e] == "function" ? t : t.provider && typeof t.provider[e] == "function" ? t.provider : null
}

function h1(t) {
    return t == null ? null : t.provider || null
}
async function Nie(t, e) {
    const n = Po.dereference(t, "overrides");
    Ee(typeof n == "object", "invalid overrides parameter", "overrides", t);
    const r = jC(n);
    return Ee(r.to == null || (e || []).indexOf("to") >= 0, "cannot override to", "overrides.to", r.to), Ee(r.data == null || (e || []).indexOf("data") >= 0, "cannot override data", "overrides.data", r.data), r.from && (r.from = r.from), r
}
async function xPe(t, e, n) {
    const r = Bm(t, "resolveName"),
        i = i9(r) ? r : null;
    return await Promise.all(e.map((s, o) => s.walkAsync(n[o], (a, l) => (l = Po.dereference(l, a), a === "address" ? aa(l, i) : l))))
}

function SPe(t) {
    const e = async function(o) {
            const a = await Nie(o, ["data"]);
            a.to = await t.getAddress(), a.from && (a.from = await aa(a.from, Oie(t.runner)));
            const l = t.interface,
                c = kt(a.value || iq, "overrides.value") === iq,
                u = (a.data || "0x") === "0x";
            l.fallback && !l.fallback.payable && l.receive && !u && !c && Ee(!1, "cannot send data to receive or send value to non-payable fallback", "overrides", o), Ee(l.fallback || u, "cannot send data to receive-only contract", "overrides.data", a.data);
            const f = l.receive || l.fallback && l.fallback.payable;
            return Ee(f || c, "cannot send value to non-payable fallback", "overrides.value", a.value), Ee(l.fallback || u, "cannot send data to receive-only contract", "overrides.data", a.data), a
        },
        n = async function(o) {
            const a = Bm(t.runner, "call");
            je(Tie(a), "contract runner does not support calling", "UNSUPPORTED_OPERATION", {
                operation: "call"
            });
            const l = await e(o);
            try {
                return await a.call(l)
            } catch (c) {
                throw _L(c) && c.data ? t.interface.makeError(c.data, l) : c
            }
        },
        r = async function(o) {
            const a = t.runner;
            je(Rie(a), "contract runner does not support sending transactions", "UNSUPPORTED_OPERATION", {
                operation: "sendTransaction"
            });
            const l = await a.sendTransaction(await e(o)),
                c = h1(t.runner);
            return new BL(t.interface, c, l)
        },
        i = async function(o) {
            const a = Bm(t.runner, "estimateGas");
            return je(Iie(a), "contract runner does not support gas estimation", "UNSUPPORTED_OPERATION", {
                operation: "estimateGas"
            }), await a.estimateGas(await e(o))
        },
        s = async o => await r(o);
    return Xt(s, {
        _contract: t,
        estimateGas: i,
        populateTransaction: e,
        send: r,
        staticCall: n
    }), s
}

function CPe(t, e) {
    const n = function(...c) {
            const u = t.interface.getFunction(e, c);
            return je(u, "no matching fragment", "UNSUPPORTED_OPERATION", {
                operation: "fragment",
                info: {
                    key: e,
                    args: c
                }
            }), u
        },
        r = async function(...c) {
            const u = n(...c);
            let f = {};
            if (u.inputs.length + 1 === c.length && (f = await Nie(c.pop()), f.from && (f.from = await aa(f.from, Oie(t.runner)))), u.inputs.length !== c.length) throw new Error("internal error: fragment inputs doesn't match arguments; should not happen");
            const h = await xPe(t.runner, u.inputs, c);
            return Object.assign({}, f, await Xo({
                to: t.getAddress(),
                data: t.interface.encodeFunctionData(u, h)
            }))
        },
        i = async function(...c) {
            const u = await a(...c);
            return u.length === 1 ? u[0] : u
        },
        s = async function(...c) {
            const u = t.runner;
            je(Rie(u), "contract runner does not support sending transactions", "UNSUPPORTED_OPERATION", {
                operation: "sendTransaction"
            });
            const f = await u.sendTransaction(await r(...c)),
                h = h1(t.runner);
            return new BL(t.interface, h, f)
        },
        o = async function(...c) {
            const u = Bm(t.runner, "estimateGas");
            return je(Iie(u), "contract runner does not support gas estimation", "UNSUPPORTED_OPERATION", {
                operation: "estimateGas"
            }), await u.estimateGas(await r(...c))
        },
        a = async function(...c) {
            const u = Bm(t.runner, "call");
            je(Tie(u), "contract runner does not support calling", "UNSUPPORTED_OPERATION", {
                operation: "call"
            });
            const f = await r(...c);
            let h = "0x";
            try {
                h = await u.call(f)
            } catch (y) {
                throw _L(y) && y.data ? t.interface.makeError(y.data, f) : y
            }
            const g = n(...c);
            return t.interface.decodeFunctionResult(g, h)
        },
        l = async (...c) => n(...c).constant ? await i(...c) : await s(...c);
    return Xt(l, {
        name: t.interface.getFunctionName(e),
        _contract: t,
        _key: e,
        getFragment: n,
        estimateGas: o,
        populateTransaction: r,
        send: s,
        staticCall: i,
        staticCallResult: a
    }), Object.defineProperty(l, "fragment", {
        configurable: !1,
        enumerable: !0,
        get: () => {
            const c = t.interface.getFunction(e);
            return je(c, "no matching fragment", "UNSUPPORTED_OPERATION", {
                operation: "fragment",
                info: {
                    key: e
                }
            }), c
        }
    }), l
}

function APe(t, e) {
    const n = function(...i) {
            const s = t.interface.getEvent(e, i);
            return je(s, "no matching fragment", "UNSUPPORTED_OPERATION", {
                operation: "fragment",
                info: {
                    key: e,
                    args: i
                }
            }), s
        },
        r = function(...i) {
            return new EPe(t, n(...i), i)
        };
    return Xt(r, {
        name: t.interface.getEventName(e),
        _contract: t,
        _key: e,
        getFragment: n
    }), Object.defineProperty(r, "fragment", {
        configurable: !1,
        enumerable: !0,
        get: () => {
            const i = t.interface.getEvent(e);
            return je(i, "no matching fragment", "UNSUPPORTED_OPERATION", {
                operation: "fragment",
                info: {
                    key: e
                }
            }), i
        }
    }), r
}
const HC = Symbol.for("_ethersInternal_contract"),
    Pie = new WeakMap;

function TPe(t, e) {
    Pie.set(t[HC], e)
}

function hl(t) {
    return Pie.get(t[HC])
}

function IPe(t) {
    return t && typeof t == "object" && "getTopicFilter" in t && typeof t.getTopicFilter == "function" && t.fragment
}
async function FL(t, e) {
    let n, r = null;
    if (Array.isArray(e)) {
        const s = function(o) {
            if (Zr(o, 32)) return o;
            const a = t.interface.getEvent(o);
            return Ee(a, "unknown fragment", "name", o), a.topicHash
        };
        n = e.map(o => o == null ? null : Array.isArray(o) ? o.map(s) : s(o))
    } else e === "*" ? n = [null] : typeof e == "string" ? Zr(e, 32) ? n = [e] : (r = t.interface.getEvent(e), Ee(r, "unknown fragment", "event", e), n = [r.topicHash]) : IPe(e) ? n = await e.getTopicFilter() : "fragment" in e ? (r = e.fragment, n = [r.topicHash]) : Ee(!1, "unknown event name", "event", e);
    n = n.map(s => {
        if (s == null) return null;
        if (Array.isArray(s)) {
            const o = Array.from(new Set(s.map(a => a.toLowerCase())).values());
            return o.length === 1 ? o[0] : (o.sort(), o)
        }
        return s.toLowerCase()
    });
    const i = n.map(s => s == null ? "null" : Array.isArray(s) ? s.join("|") : s).join("&");
    return {
        fragment: r,
        tag: i,
        topics: n
    }
}
async function C3(t, e) {
    const {
        subs: n
    } = hl(t);
    return n.get((await FL(t, e)).tag) || null
}
async function sq(t, e, n) {
    const r = h1(t.runner);
    je(r, "contract runner does not support subscribing", "UNSUPPORTED_OPERATION", {
        operation: e
    });
    const {
        fragment: i,
        tag: s,
        topics: o
    } = await FL(t, n), {
        addr: a,
        subs: l
    } = hl(t);
    let c = l.get(s);
    if (!c) {
        const f = {
                address: a || t,
                topics: o
            },
            h = C => {
                let b = i;
                if (b == null) try {
                    b = t.interface.getEvent(C.topics[0])
                } catch {}
                if (b) {
                    const w = b,
                        S = i ? t.interface.decodeEventLog(i, C.data, C.topics) : [];
                    Wk(t, n, S, I => new _Pe(t, I, n, w, C))
                } else Wk(t, n, [], w => new Aie(t, w, n, C))
            };
        let g = [];
        c = {
            tag: s,
            listeners: [],
            start: () => {
                g.length || g.push(r.on(f, h))
            },
            stop: async () => {
                if (g.length == 0) return;
                let C = g;
                g = [], await Promise.all(C), r.off(f, h)
            }
        }, l.set(s, c)
    }
    return c
}
let zk = Promise.resolve();
async function RPe(t, e, n, r) {
    await zk;
    const i = await C3(t, e);
    if (!i) return !1;
    const s = i.listeners.length;
    return i.listeners = i.listeners.filter(({
        listener: o,
        once: a
    }) => {
        const l = Array.from(n);
        r && l.push(r(a ? null : o));
        try {
            o.call(t, ...l)
        } catch {}
        return !a
    }), i.listeners.length === 0 && (i.stop(), hl(t).subs.delete(i.tag)), s > 0
}
async function Wk(t, e, n, r) {
    try {
        await zk
    } catch {}
    const i = RPe(t, e, n, r);
    return zk = i, await i
}
const Qx = ["then"];
var SX;
SX = HC;
const f_ = class f_ {
    constructor(e, n, r, i) {
        Ie(this, "target");
        Ie(this, "interface");
        Ie(this, "runner");
        Ie(this, "filters");
        Ie(this, SX);
        Ie(this, "fallback");
        Ee(typeof e == "string" || Bre(e), "invalid value for Contract target", "target", e), r == null && (r = null);
        const s = Hk.from(n);
        Xt(this, {
            target: e,
            runner: r,
            interface: s
        }), Object.defineProperty(this, HC, {
            value: {}
        });
        let o, a = null,
            l = null;
        if (i) {
            const f = h1(r);
            l = new BL(this.interface, f, i)
        }
        let c = new Map;
        if (typeof e == "string")
            if (Zr(e)) a = e, o = Promise.resolve(e);
            else {
                const f = Bm(r, "resolveName");
                if (!i9(f)) throw pi("contract runner does not support name resolution", "UNSUPPORTED_OPERATION", {
                    operation: "resolveName"
                });
                o = f.resolveName(e).then(h => {
                    if (h == null) throw pi("an ENS name used for a contract target must be correctly configured", "UNCONFIGURED_NAME", {
                        value: e
                    });
                    return hl(this).addr = h, h
                })
            }
        else o = e.getAddress().then(f => {
            if (f == null) throw new Error("TODO");
            return hl(this).addr = f, f
        });
        TPe(this, {
            addrPromise: o,
            addr: a,
            deployTx: l,
            subs: c
        });
        const u = new Proxy({}, {
            get: (f, h, g) => {
                if (typeof h == "symbol" || Qx.indexOf(h) >= 0) return Reflect.get(f, h, g);
                try {
                    return this.getEvent(h)
                } catch (y) {
                    if (!No(y, "INVALID_ARGUMENT") || y.argument !== "key") throw y
                }
            },
            has: (f, h) => Qx.indexOf(h) >= 0 ? Reflect.has(f, h) : Reflect.has(f, h) || this.interface.hasEvent(String(h))
        });
        return Xt(this, {
            filters: u
        }), Xt(this, {
            fallback: s.receive || s.fallback ? SPe(this) : null
        }), new Proxy(this, {
            get: (f, h, g) => {
                if (typeof h == "symbol" || h in f || Qx.indexOf(h) >= 0) return Reflect.get(f, h, g);
                try {
                    return f.getFunction(h)
                } catch (y) {
                    if (!No(y, "INVALID_ARGUMENT") || y.argument !== "key") throw y
                }
            },
            has: (f, h) => typeof h == "symbol" || h in f || Qx.indexOf(h) >= 0 ? Reflect.has(f, h) : f.interface.hasFunction(h)
        })
    }
    connect(e) {
        return new f_(this.target, this.interface, e)
    }
    attach(e) {
        return new f_(e, this.interface, this.runner)
    }
    async getAddress() {
        return await hl(this).addrPromise
    }
    async getDeployedCode() {
        const e = h1(this.runner);
        je(e, "runner does not support .provider", "UNSUPPORTED_OPERATION", {
            operation: "getDeployedCode"
        });
        const n = await e.getCode(await this.getAddress());
        return n === "0x" ? null : n
    }
    async waitForDeployment() {
        const e = this.deploymentTransaction();
        if (e) return await e.wait(), this;
        if (await this.getDeployedCode() != null) return this;
        const r = h1(this.runner);
        return je(r != null, "contract runner does not support .provider", "UNSUPPORTED_OPERATION", {
            operation: "waitForDeployment"
        }), new Promise((i, s) => {
            const o = async () => {
                try {
                    if (await this.getDeployedCode() != null) return i(this);
                    r.once("block", o)
                } catch (a) {
                    s(a)
                }
            };
            o()
        })
    }
    deploymentTransaction() {
        return hl(this).deployTx
    }
    getFunction(e) {
        return typeof e != "string" && (e = e.format()), CPe(this, e)
    }
    getEvent(e) {
        return typeof e != "string" && (e = e.format()), APe(this, e)
    }
    async queryTransaction(e) {
        throw new Error("@TODO")
    }
    async queryFilter(e, n, r) {
        n == null && (n = 0), r == null && (r = "latest");
        const {
            addr: i,
            addrPromise: s
        } = hl(this), o = i || await s, {
            fragment: a,
            topics: l
        } = await FL(this, e), c = {
            address: o,
            topics: l,
            fromBlock: n,
            toBlock: r
        }, u = h1(this.runner);
        return je(u, "contract runner does not have a provider", "UNSUPPORTED_OPERATION", {
            operation: "queryFilter"
        }), (await u.getLogs(c)).map(f => {
            let h = a;
            if (h == null) try {
                h = this.interface.getEvent(f.topics[0])
            } catch {}
            if (h) try {
                return new LL(f, this.interface, h)
            } catch (g) {
                return new Cie(f, g)
            }
            return new NE(f, u)
        })
    }
    async on(e, n) {
        const r = await sq(this, "on", e);
        return r.listeners.push({
            listener: n,
            once: !1
        }), r.start(), this
    }
    async once(e, n) {
        const r = await sq(this, "once", e);
        return r.listeners.push({
            listener: n,
            once: !0
        }), r.start(), this
    }
    async emit(e, ...n) {
        return await Wk(this, e, n, null)
    }
    async listenerCount(e) {
        if (e) {
            const i = await C3(this, e);
            return i ? i.listeners.length : 0
        }
        const {
            subs: n
        } = hl(this);
        let r = 0;
        for (const {
                listeners: i
            } of n.values()) r += i.length;
        return r
    }
    async listeners(e) {
        if (e) {
            const i = await C3(this, e);
            return i ? i.listeners.map(({
                listener: s
            }) => s) : []
        }
        const {
            subs: n
        } = hl(this);
        let r = [];
        for (const {
                listeners: i
            } of n.values()) r = r.concat(i.map(({
            listener: s
        }) => s));
        return r
    }
    async off(e, n) {
        const r = await C3(this, e);
        if (!r) return this;
        if (n) {
            const i = r.listeners.map(({
                listener: s
            }) => s).indexOf(n);
            i >= 0 && r.listeners.splice(i, 1)
        }
        return (n == null || r.listeners.length === 0) && (r.stop(), hl(this).subs.delete(r.tag)), this
    }
    async removeAllListeners(e) {
        if (e) {
            const n = await C3(this, e);
            if (!n) return this;
            n.stop(), hl(this).subs.delete(n.tag)
        } else {
            const {
                subs: n
            } = hl(this);
            for (const {
                    tag: r,
                    stop: i
                } of n.values()) i(), n.delete(r)
        }
        return this
    }
    async addListener(e, n) {
        return await this.on(e, n)
    }
    async removeListener(e, n) {
        return await this.off(e, n)
    }
    static buildClass(e) {
        class n extends f_ {
            constructor(i, s = null) {
                super(i, e, s)
            }
        }
        return n
    }
    static from(e, n, r) {
        return r == null && (r = null), new this(e, n, r)
    }
};
let Vk = f_;

function OPe() {
    return Vk
}
let Qr = class extends OPe() {};

function TO(t) {
    return t.match(/^ipfs:\/\/ipfs\//i) ? t = t.substring(12) : t.match(/^ipfs:\/\//i) ? t = t.substring(7) : Ee(!1, "unsupported IPFS format", "link", t), `https://gateway.ipfs.io/ipfs/${t}`
}
class NPe {
    constructor(e) {
        Ie(this, "name");
        Xt(this, {
            name: e
        })
    }
    connect(e) {
        return this
    }
    supportsCoinType(e) {
        return !1
    }
    async encodeAddress(e, n) {
        throw new Error("unsupported coin")
    }
    async decodeAddress(e, n) {
        throw new Error("unsupported coin")
    }
}
const kie = new RegExp("^(ipfs)://(.*)$", "i"),
    oq = [new RegExp("^(https)://(.*)$", "i"), new RegExp("^(data):(.*)$", "i"), kie, new RegExp("^eip155:[0-9]+/(erc[0-9]+):(.*)$", "i")];
var Q0, F1, J0, xw, iT, Mie;
const Yw = class Yw {
    constructor(e, n, r) {
        _e(this, J0);
        Ie(this, "provider");
        Ie(this, "address");
        Ie(this, "name");
        _e(this, Q0);
        _e(this, F1);
        Xt(this, {
            provider: e,
            address: n,
            name: r
        }), le(this, Q0, null), le(this, F1, new Qr(n, ["function supportsInterface(bytes4) view returns (bool)", "function resolve(bytes, bytes) view returns (bytes)", "function addr(bytes32) view returns (address)", "function addr(bytes32, uint) view returns (bytes)", "function text(bytes32, string) view returns (string)", "function contenthash(bytes32) view returns (bytes)"], e))
    }
    async supportsWildcard() {
        return W(this, Q0) == null && le(this, Q0, (async () => {
            try {
                return await W(this, F1).supportsInterface("0x9061b923")
            } catch (e) {
                if (No(e, "CALL_EXCEPTION")) return !1;
                throw le(this, Q0, null), e
            }
        })()), await W(this, Q0)
    }
    async getAddress(e) {
        if (e == null && (e = 60), e === 60) try {
            const s = await De(this, J0, xw).call(this, "addr(bytes32)");
            return s == null || s === Z_ ? null : s
        } catch (s) {
            if (No(s, "CALL_EXCEPTION")) return null;
            throw s
        }
        if (e >= 0 && e < 2147483648) {
            let s = e + 2147483648;
            const o = await De(this, J0, xw).call(this, "addr(bytes32,uint)", [s]);
            if (Zr(o, 20)) return Hn(o)
        }
        let n = null;
        for (const s of this.provider.plugins)
            if (s instanceof NPe && s.supportsCoinType(e)) {
                n = s;
                break
            }
        if (n == null) return null;
        const r = await De(this, J0, xw).call(this, "addr(bytes32,uint)", [e]);
        if (r == null || r === "0x") return null;
        const i = await n.decodeAddress(e, r);
        if (i != null) return i;
        je(!1, "invalid coin data", "UNSUPPORTED_OPERATION", {
            operation: `getAddress(${e})`,
            info: {
                coinType: e,
                data: r
            }
        })
    }
    async getText(e) {
        const n = await De(this, J0, xw).call(this, "text(bytes32,string)", [e]);
        return n == null || n === "0x" ? null : n
    }
    async getContentHash() {
        const e = await De(this, J0, xw).call(this, "contenthash(bytes32)");
        if (e == null || e === "0x") return null;
        const n = e.match(/^0x(e3010170|e5010172)(([0-9a-f][0-9a-f])([0-9a-f][0-9a-f])([0-9a-f]*))$/);
        if (n) {
            const i = n[1] === "e3010170" ? "ipfs" : "ipns",
                s = parseInt(n[4], 16);
            if (n[5].length === s * 2) return `${i}://${LIe("0x"+n[2])}`
        }
        const r = e.match(/^0xe40101fa011b20([0-9a-f]*)$/);
        if (r && r[1].length === 64) return `bzz://${r[1]}`;
        je(!1, "invalid or unsupported content hash data", "UNSUPPORTED_OPERATION", {
            operation: "getContentHash()",
            info: {
                data: e
            }
        })
    }
    async getAvatar() {
        return (await this._getAvatar()).url
    }
    async _getAvatar() {
        const e = [{
            type: "name",
            value: this.name
        }];
        try {
            const n = await this.getText("avatar");
            if (n == null) return e.push({
                type: "!avatar",
                value: ""
            }), {
                url: null,
                linkage: e
            };
            e.push({
                type: "avatar",
                value: n
            });
            for (let r = 0; r < oq.length; r++) {
                const i = n.match(oq[r]);
                if (i == null) continue;
                const s = i[1].toLowerCase();
                switch (s) {
                    case "https":
                    case "data":
                        return e.push({
                            type: "url",
                            value: n
                        }), {
                            linkage: e,
                            url: n
                        };
                    case "ipfs":
                        {
                            const o = TO(n);
                            return e.push({
                                type: "ipfs",
                                value: n
                            }),
                            e.push({
                                type: "url",
                                value: o
                            }),
                            {
                                linkage: e,
                                url: o
                            }
                        }
                    case "erc721":
                    case "erc1155":
                        {
                            const o = s === "erc721" ? "tokenURI(uint256)" : "uri(uint256)";e.push({
                                type: s,
                                value: n
                            });
                            const a = await this.getAddress();
                            if (a == null) return e.push({
                                type: "!owner",
                                value: ""
                            }), {
                                url: null,
                                linkage: e
                            };
                            const l = (i[2] || "").split("/");
                            if (l.length !== 2) return e.push({
                                type: `!${s}caip`,
                                value: i[2] || ""
                            }), {
                                url: null,
                                linkage: e
                            };
                            const c = l[1],
                                u = new Qr(l[0], ["function tokenURI(uint) view returns (string)", "function ownerOf(uint) view returns (address)", "function uri(uint) view returns (string)", "function balanceOf(address, uint256) view returns (uint)"], this.provider);
                            if (s === "erc721") {
                                const _ = await u.ownerOf(c);
                                if (a !== _) return e.push({
                                    type: "!owner",
                                    value: _
                                }), {
                                    url: null,
                                    linkage: e
                                };
                                e.push({
                                    type: "owner",
                                    value: _
                                })
                            } else if (s === "erc1155") {
                                const _ = await u.balanceOf(a, c);
                                if (!_) return e.push({
                                    type: "!balance",
                                    value: "0"
                                }), {
                                    url: null,
                                    linkage: e
                                };
                                e.push({
                                    type: "balance",
                                    value: _.toString()
                                })
                            }
                            let f = await u[o](c);
                            if (f == null || f === "0x") return e.push({
                                type: "!metadata-url",
                                value: ""
                            }), {
                                url: null,
                                linkage: e
                            };e.push({
                                type: "metadata-url-base",
                                value: f
                            }),
                            s === "erc1155" && (f = f.replace("{id}", zp(c, 32).substring(2)), e.push({
                                type: "metadata-url-expanded",
                                value: f
                            })),
                            f.match(/^ipfs:/i) && (f = TO(f)),
                            e.push({
                                type: "metadata-url",
                                value: f
                            });
                            let h = {};
                            const g = await new od(f).send();g.assertOk();
                            try {
                                h = g.bodyJson
                            } catch {
                                try {
                                    e.push({
                                        type: "!metadata",
                                        value: g.bodyText
                                    })
                                } catch {
                                    const b = g.body;
                                    return b && e.push({
                                        type: "!metadata",
                                        value: Ot(b)
                                    }), {
                                        url: null,
                                        linkage: e
                                    }
                                }
                                return {
                                    url: null,
                                    linkage: e
                                }
                            }
                            if (!h) return e.push({
                                type: "!metadata",
                                value: ""
                            }), {
                                url: null,
                                linkage: e
                            };e.push({
                                type: "metadata",
                                value: JSON.stringify(h)
                            });
                            let y = h.image;
                            if (typeof y != "string") return e.push({
                                type: "!imageUrl",
                                value: ""
                            }), {
                                url: null,
                                linkage: e
                            };
                            if (!y.match(/^(https:\/\/|data:)/i)) {
                                if (y.match(kie) == null) return e.push({
                                    type: "!imageUrl-ipfs",
                                    value: y
                                }), {
                                    url: null,
                                    linkage: e
                                };
                                e.push({
                                    type: "imageUrl-ipfs",
                                    value: y
                                }), y = TO(y)
                            }
                            return e.push({
                                type: "url",
                                value: y
                            }),
                            {
                                linkage: e,
                                url: y
                            }
                        }
                }
            }
        } catch {}
        return {
            linkage: e,
            url: null
        }
    }
    static async getEnsAddress(e) {
        const n = await e.getNetwork(),
            r = n.getPlugin("org.ethers.plugins.network.Ens");
        return je(r, "network does not support ENS", "UNSUPPORTED_OPERATION", {
            operation: "getEnsAddress",
            info: {
                network: n
            }
        }), r.address
    }
    static async fromName(e, n) {
        var i;
        let r = n;
        for (;;) {
            if (r === "" || r === "." || n !== "eth" && r === "eth") return null;
            const s = await De(i = Yw, iT, Mie).call(i, e, r);
            if (s != null) {
                const o = new Yw(e, s, n);
                return r !== n && !await o.supportsWildcard() ? null : o
            }
            r = r.split(".").slice(1).join(".")
        }
    }
};
Q0 = new WeakMap, F1 = new WeakMap, J0 = new WeakSet, xw = async function(e, n) {
    n = (n || []).slice();
    const r = W(this, F1).interface;
    n.unshift(Uk(this.name));
    let i = null;
    await this.supportsWildcard() && (i = r.getFunction(e), je(i, "missing fragment", "UNKNOWN_ERROR", {
        info: {
            funcName: e
        }
    }), n = [ONe(this.name, 255), r.encodeFunctionData(i, n)], e = "resolve(bytes,bytes)"), n.push({
        enableCcipRead: !0
    });
    try {
        const s = await W(this, F1)[e](...n);
        return i ? r.decodeFunctionResult(i, s)[0] : s
    } catch (s) {
        if (!No(s, "CALL_EXCEPTION")) throw s
    }
    return null
}, iT = new WeakSet, Mie = async function(e, n) {
    const r = await Yw.getEnsAddress(e);
    try {
        const s = await new Qr(r, ["function resolver(bytes32) view returns (address)"], e).resolver(Uk(n), {
            enableCcipRead: !0
        });
        return s === Z_ ? null : s
    } catch (i) {
        throw i
    }
    return null
}, _e(Yw, iT);
let zC = Yw;
const aq = BigInt(0);

function sr(t, e) {
    return function(n) {
        return n == null ? e : t(n)
    }
}

function s9(t, e) {
    return n => {
        if (e && n == null) return null;
        if (!Array.isArray(n)) throw new Error("not an array");
        return n.map(r => t(r))
    }
}

function PE(t, e) {
    return n => {
        const r = {};
        for (const i in t) {
            let s = i;
            if (e && i in e && !(s in n)) {
                for (const o of e[i])
                    if (o in n) {
                        s = o;
                        break
                    }
            }
            try {
                const o = t[i](n[s]);
                o !== void 0 && (r[i] = o)
            } catch (o) {
                const a = o instanceof Error ? o.message : "not-an-error";
                je(!1, `invalid value for value.${i} (${a})`, "BAD_DATA", {
                    value: n
                })
            }
        }
        return r
    }
}

function PPe(t) {
    switch (t) {
        case !0:
        case "true":
            return !0;
        case !1:
        case "false":
            return !1
    }
    Ee(!1, `invalid boolean; ${JSON.stringify(t)}`, "value", t)
}

function Qb(t) {
    return Ee(Zr(t, !0), "invalid data", "value", t), t
}

function so(t) {
    return Ee(Zr(t, 32), "invalid hash", "value", t), t
}
const kPe = PE({
    address: Hn,
    blockHash: so,
    blockNumber: Mn,
    data: Qb,
    index: Mn,
    removed: sr(PPe, !1),
    topics: s9(so),
    transactionHash: so,
    transactionIndex: Mn
}, {
    index: ["logIndex"]
});

function MPe(t) {
    return kPe(t)
}
const DPe = PE({
    hash: sr(so),
    parentHash: so,
    parentBeaconBlockRoot: sr(so, null),
    number: Mn,
    timestamp: Mn,
    nonce: sr(Qb),
    difficulty: kt,
    gasLimit: kt,
    gasUsed: kt,
    stateRoot: sr(so, null),
    receiptsRoot: sr(so, null),
    blobGasUsed: sr(kt, null),
    excessBlobGas: sr(kt, null),
    miner: sr(Hn),
    prevRandao: sr(so, null),
    extraData: Qb,
    baseFeePerGas: sr(kt)
}, {
    prevRandao: ["mixHash"]
});

function $Pe(t) {
    const e = DPe(t);
    return e.transactions = t.transactions.map(n => typeof n == "string" ? n : Die(n)), e
}
const LPe = PE({
    transactionIndex: Mn,
    blockNumber: Mn,
    transactionHash: so,
    address: Hn,
    topics: s9(so),
    data: Qb,
    index: Mn,
    blockHash: so
}, {
    index: ["logIndex"]
});

function BPe(t) {
    return LPe(t)
}
const FPe = PE({
    to: sr(Hn, null),
    from: sr(Hn, null),
    contractAddress: sr(Hn, null),
    index: Mn,
    root: sr(Ot),
    gasUsed: kt,
    blobGasUsed: sr(kt, null),
    logsBloom: sr(Qb),
    blockHash: so,
    hash: so,
    logs: s9(BPe),
    blockNumber: Mn,
    cumulativeGasUsed: kt,
    effectiveGasPrice: sr(kt),
    blobGasPrice: sr(kt, null),
    status: sr(Mn),
    type: sr(Mn, 0)
}, {
    effectiveGasPrice: ["gasPrice"],
    hash: ["transactionHash"],
    index: ["transactionIndex"]
});

function UPe(t) {
    return FPe(t)
}

function Die(t) {
    t.to && kt(t.to) === aq && (t.to = "0x0000000000000000000000000000000000000000");
    const e = PE({
        hash: so,
        index: sr(Mn, void 0),
        type: n => n === "0x" || n == null ? 0 : Mn(n),
        accessList: sr(wy, null),
        blobVersionedHashes: sr(s9(so, !0), null),
        blockHash: sr(so, null),
        blockNumber: sr(Mn, null),
        transactionIndex: sr(Mn, null),
        from: Hn,
        gasPrice: sr(kt),
        maxPriorityFeePerGas: sr(kt),
        maxFeePerGas: sr(kt),
        maxFeePerBlobGas: sr(kt, null),
        gasLimit: kt,
        to: sr(Hn, null),
        value: kt,
        nonce: Mn,
        data: Qb,
        creates: sr(Hn, null),
        chainId: sr(kt, null)
    }, {
        data: ["input"],
        gasLimit: ["gas"],
        index: ["transactionIndex"]
    })(t);
    if (e.to == null && e.creates == null && (e.creates = POe(e)), (t.type === 1 || t.type === 2) && t.accessList == null && (e.accessList = []), t.signature ? e.signature = Mu.from(t.signature) : e.signature = Mu.from(t), e.chainId == null) {
        const n = e.signature.legacyChainId;
        n != null && (e.chainId = n)
    }
    return e.blockHash && kt(e.blockHash) === aq && (e.blockHash = null), e
}
const jPe = "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e";
class kE {
    constructor(e) {
        Ie(this, "name");
        Xt(this, {
            name: e
        })
    }
    clone() {
        return new kE(this.name)
    }
}
class o9 extends kE {
    constructor(n, r) {
        n == null && (n = 0);
        super(`org.ethers.network.plugins.GasCost#${n||0}`);
        Ie(this, "effectiveBlock");
        Ie(this, "txBase");
        Ie(this, "txCreate");
        Ie(this, "txDataZero");
        Ie(this, "txDataNonzero");
        Ie(this, "txAccessListStorageKey");
        Ie(this, "txAccessListAddress");
        const i = {
            effectiveBlock: n
        };

        function s(o, a) {
            let l = (r || {})[o];
            l == null && (l = a), Ee(typeof l == "number", `invalud value for ${o}`, "costs", r), i[o] = l
        }
        s("txBase", 21e3), s("txCreate", 32e3), s("txDataZero", 4), s("txDataNonzero", 16), s("txAccessListStorageKey", 1900), s("txAccessListAddress", 2400), Xt(this, i)
    }
    clone() {
        return new o9(this.effectiveBlock, this)
    }
}
class a9 extends kE {
    constructor(n, r) {
        super("org.ethers.plugins.network.Ens");
        Ie(this, "address");
        Ie(this, "targetNetwork");
        Xt(this, {
            address: n || jPe,
            targetNetwork: r ? ? 1
        })
    }
    clone() {
        return new a9(this.address, this.targetNetwork)
    }
}
var X6, eE;
class HPe extends kE {
    constructor(n, r) {
        super("org.ethers.plugins.network.FetchUrlFeeDataPlugin");
        _e(this, X6);
        _e(this, eE);
        le(this, X6, n), le(this, eE, r)
    }
    get url() {
        return W(this, X6)
    }
    get processFunc() {
        return W(this, eE)
    }
    clone() {
        return this
    }
}
X6 = new WeakMap, eE = new WeakMap;
const IO = new Map;
var ob, ab, X0;
const Zw = class Zw {
    constructor(e, n) {
        _e(this, ob);
        _e(this, ab);
        _e(this, X0);
        le(this, ob, e), le(this, ab, kt(n)), le(this, X0, new Map)
    }
    toJSON() {
        return {
            name: this.name,
            chainId: String(this.chainId)
        }
    }
    get name() {
        return W(this, ob)
    }
    set name(e) {
        le(this, ob, e)
    }
    get chainId() {
        return W(this, ab)
    }
    set chainId(e) {
        le(this, ab, kt(e, "chainId"))
    }
    matches(e) {
        if (e == null) return !1;
        if (typeof e == "string") {
            try {
                return this.chainId === kt(e)
            } catch {}
            return this.name === e
        }
        if (typeof e == "number" || typeof e == "bigint") {
            try {
                return this.chainId === kt(e)
            } catch {}
            return !1
        }
        if (typeof e == "object") {
            if (e.chainId != null) {
                try {
                    return this.chainId === kt(e.chainId)
                } catch {}
                return !1
            }
            return e.name != null ? this.name === e.name : !1
        }
        return !1
    }
    get plugins() {
        return Array.from(W(this, X0).values())
    }
    attachPlugin(e) {
        if (W(this, X0).get(e.name)) throw new Error(`cannot replace existing plugin: ${e.name} `);
        return W(this, X0).set(e.name, e.clone()), this
    }
    getPlugin(e) {
        return W(this, X0).get(e) || null
    }
    getPlugins(e) {
        return this.plugins.filter(n => n.name.split("#")[0] === e)
    }
    clone() {
        const e = new Zw(this.name, this.chainId);
        return this.plugins.forEach(n => {
            e.attachPlugin(n.clone())
        }), e
    }
    computeIntrinsicGas(e) {
        const n = this.getPlugin("org.ethers.plugins.network.GasCost") || new o9;
        let r = n.txBase;
        if (e.to == null && (r += n.txCreate), e.data)
            for (let i = 2; i < e.data.length; i += 2) e.data.substring(i, i + 2) === "00" ? r += n.txDataZero : r += n.txDataNonzero;
        if (e.accessList) {
            const i = wy(e.accessList);
            for (const s in i) r += n.txAccessListAddress + n.txAccessListStorageKey * i[s].storageKeys.length
        }
        return r
    }
    static from(e) {
        if (zPe(), e == null) return Zw.from("mainnet");
        if (typeof e == "number" && (e = BigInt(e)), typeof e == "string" || typeof e == "bigint") {
            const n = IO.get(e);
            if (n) return n();
            if (typeof e == "bigint") return new Zw("unknown", e);
            Ee(!1, "unknown network", "network", e)
        }
        if (typeof e.clone == "function") return e.clone();
        if (typeof e == "object") {
            Ee(typeof e.name == "string" && typeof e.chainId == "number", "invalid network object name or chainId", "network", e);
            const n = new Zw(e.name, e.chainId);
            return (e.ensAddress || e.ensNetwork != null) && n.attachPlugin(new a9(e.ensAddress, e.ensNetwork)), n
        }
        Ee(!1, "invalid network", "network", e)
    }
    static register(e, n) {
        typeof e == "number" && (e = BigInt(e));
        const r = IO.get(e);
        r && Ee(!1, `conflicting network for ${JSON.stringify(r.name)}`, "nameOrChainId", e), IO.set(e, n)
    }
};
ob = new WeakMap, ab = new WeakMap, X0 = new WeakMap;
let bu = Zw;

function lq(t, e) {
    const n = String(t);
    if (!n.match(/^[0-9.]+$/)) throw new Error(`invalid gwei value: ${t}`);
    const r = n.split(".");
    if (r.length === 1 && r.push(""), r.length !== 2) throw new Error(`invalid gwei value: ${t}`);
    for (; r[1].length < e;) r[1] += "0";
    if (r[1].length > 9) {
        let i = BigInt(r[1].substring(0, 9));
        r[1].substring(9).match(/^0+$/) || i++, r[1] = i.toString()
    }
    return BigInt(r[0] + r[1])
}

function cq(t) {
    return new HPe(t, async (e, n, r) => {
        r.setHeader("User-Agent", "ethers");
        let i;
        try {
            const [s, o] = await Promise.all([r.send(), e()]);
            i = s;
            const a = i.bodyJson.standard;
            return {
                gasPrice: o.gasPrice,
                maxFeePerGas: lq(a.maxFee, 9),
                maxPriorityFeePerGas: lq(a.maxPriorityFee, 9)
            }
        } catch (s) {
            je(!1, `error encountered with polygon gas station (${JSON.stringify(r.url)})`, "SERVER_ERROR", {
                request: r,
                response: i,
                error: s
            })
        }
    })
}
let uq = !1;

function zPe() {
    if (uq) return;
    uq = !0;

    function t(e, n, r) {
        const i = function() {
            const s = new bu(e, n);
            return r.ensNetwork != null && s.attachPlugin(new a9(null, r.ensNetwork)), s.attachPlugin(new o9), (r.plugins || []).forEach(o => {
                s.attachPlugin(o)
            }), s
        };
        bu.register(e, i), bu.register(n, i), r.altNames && r.altNames.forEach(s => {
            bu.register(s, i)
        })
    }
    t("mainnet", 1, {
        ensNetwork: 1,
        altNames: ["homestead"]
    }), t("ropsten", 3, {
        ensNetwork: 3
    }), t("rinkeby", 4, {
        ensNetwork: 4
    }), t("goerli", 5, {
        ensNetwork: 5
    }), t("kovan", 42, {
        ensNetwork: 42
    }), t("sepolia", 11155111, {
        ensNetwork: 11155111
    }), t("holesky", 17e3, {
        ensNetwork: 17e3
    }), t("classic", 61, {}), t("classicKotti", 6, {}), t("arbitrum", 42161, {
        ensNetwork: 1
    }), t("arbitrum-goerli", 421613, {}), t("arbitrum-sepolia", 421614, {}), t("base", 8453, {
        ensNetwork: 1
    }), t("base-goerli", 84531, {}), t("base-sepolia", 84532, {}), t("bnb", 56, {
        ensNetwork: 1
    }), t("bnbt", 97, {}), t("linea", 59144, {
        ensNetwork: 1
    }), t("linea-goerli", 59140, {}), t("linea-sepolia", 59141, {}), t("matic", 137, {
        ensNetwork: 1,
        plugins: [cq("https://gasstation.polygon.technology/v2")]
    }), t("matic-amoy", 80002, {}), t("matic-mumbai", 80001, {
        altNames: ["maticMumbai", "maticmum"],
        plugins: [cq("https://gasstation-testnet.polygon.technology/v2")]
    }), t("optimism", 10, {
        ensNetwork: 1,
        plugins: []
    }), t("optimism-goerli", 420, {}), t("optimism-sepolia", 11155420, {}), t("xdai", 100, {
        ensNetwork: 1
    })
}

function Gk(t) {
    return JSON.parse(JSON.stringify(t))
}
var th, cc, ep, Cf, lb, a8;
class WPe {
    constructor(e) {
        _e(this, lb);
        _e(this, th);
        _e(this, cc);
        _e(this, ep);
        _e(this, Cf);
        le(this, th, e), le(this, cc, null), le(this, ep, 4e3), le(this, Cf, -2)
    }
    get pollingInterval() {
        return W(this, ep)
    }
    set pollingInterval(e) {
        le(this, ep, e)
    }
    start() {
        W(this, cc) || (le(this, cc, W(this, th)._setTimeout(De(this, lb, a8).bind(this), W(this, ep))), De(this, lb, a8).call(this))
    }
    stop() {
        W(this, cc) && (W(this, th)._clearTimeout(W(this, cc)), le(this, cc, null))
    }
    pause(e) {
        this.stop(), e && le(this, Cf, -2)
    }
    resume() {
        this.start()
    }
}
th = new WeakMap, cc = new WeakMap, ep = new WeakMap, Cf = new WeakMap, lb = new WeakSet, a8 = async function() {
    try {
        const e = await W(this, th).getBlockNumber();
        if (W(this, Cf) === -2) {
            le(this, Cf, e);
            return
        }
        if (e !== W(this, Cf)) {
            for (let n = W(this, Cf) + 1; n <= e; n++) {
                if (W(this, cc) == null) return;
                await W(this, th).emit("block", n)
            }
            le(this, Cf, e)
        }
    } catch {}
    W(this, cc) != null && le(this, cc, W(this, th)._setTimeout(De(this, lb, a8).bind(this), W(this, ep)))
};
var U1, j1, tp;
class UL {
    constructor(e) {
        _e(this, U1);
        _e(this, j1);
        _e(this, tp);
        le(this, U1, e), le(this, tp, !1), le(this, j1, n => {
            this._poll(n, W(this, U1))
        })
    }
    async _poll(e, n) {
        throw new Error("sub-classes must override this")
    }
    start() {
        W(this, tp) || (le(this, tp, !0), W(this, j1).call(this, -2), W(this, U1).on("block", W(this, j1)))
    }
    stop() {
        W(this, tp) && (le(this, tp, !1), W(this, U1).off("block", W(this, j1)))
    }
    pause(e) {
        this.stop()
    }
    resume() {
        this.start()
    }
}
U1 = new WeakMap, j1 = new WeakMap, tp = new WeakMap;
var cb, nh;
class VPe extends UL {
    constructor(n, r) {
        super(n);
        _e(this, cb);
        _e(this, nh);
        le(this, cb, r), le(this, nh, -2)
    }
    pause(n) {
        n && le(this, nh, -2), super.pause(n)
    }
    async _poll(n, r) {
        const i = await r.getBlock(W(this, cb));
        i != null && (W(this, nh) === -2 ? le(this, nh, i.number) : i.number > W(this, nh) && (r.emit(W(this, cb), i.number), le(this, nh, i.number)))
    }
}
cb = new WeakMap, nh = new WeakMap;
var sT;
class GPe extends UL {
    constructor(n, r) {
        super(n);
        _e(this, sT);
        le(this, sT, Gk(r))
    }
    async _poll(n, r) {
        throw new Error("@TODO")
    }
}
sT = new WeakMap;
var ub;
class qPe extends UL {
    constructor(n, r) {
        super(n);
        _e(this, ub);
        le(this, ub, r)
    }
    async _poll(n, r) {
        const i = await r.getTransactionReceipt(W(this, ub));
        i && r.emit(W(this, ub), i)
    }
}
ub = new WeakMap;
var rh, fb, db, np, uc, oT, $ie;
class jL {
    constructor(e, n) {
        _e(this, oT);
        _e(this, rh);
        _e(this, fb);
        _e(this, db);
        _e(this, np);
        _e(this, uc);
        le(this, rh, e), le(this, fb, Gk(n)), le(this, db, De(this, oT, $ie).bind(this)), le(this, np, !1), le(this, uc, -2)
    }
    start() {
        W(this, np) || (le(this, np, !0), W(this, uc) === -2 && W(this, rh).getBlockNumber().then(e => {
            le(this, uc, e)
        }), W(this, rh).on("block", W(this, db)))
    }
    stop() {
        W(this, np) && (le(this, np, !1), W(this, rh).off("block", W(this, db)))
    }
    pause(e) {
        this.stop(), e && le(this, uc, -2)
    }
    resume() {
        this.start()
    }
}
rh = new WeakMap, fb = new WeakMap, db = new WeakMap, np = new WeakMap, uc = new WeakMap, oT = new WeakSet, $ie = async function(e) {
    if (W(this, uc) === -2) return;
    const n = Gk(W(this, fb));
    n.fromBlock = W(this, uc) + 1, n.toBlock = e;
    const r = await W(this, rh).getLogs(n);
    if (r.length === 0) {
        W(this, uc) < e - 60 && le(this, uc, e - 60);
        return
    }
    for (const i of r) W(this, rh).emit(W(this, fb), i), le(this, uc, i.blockNumber)
};
const KPe = BigInt(2),
    YPe = 10;

function Jx(t) {
    return t && typeof t.then == "function"
}

function l8(t, e) {
    return t + ":" + JSON.stringify(e, (n, r) => {
        if (r == null) return "null";
        if (typeof r == "bigint") return `bigint:${r.toString()}`;
        if (typeof r == "string") return r.toLowerCase();
        if (typeof r == "object" && !Array.isArray(r)) {
            const i = Object.keys(r);
            return i.sort(), i.reduce((s, o) => (s[o] = r[o], s), {})
        }
        return r
    })
}
class WC {
    constructor(e) {
        Ie(this, "name");
        Xt(this, {
            name: e
        })
    }
    start() {}
    stop() {}
    pause(e) {}
    resume() {}
}

function ZPe(t) {
    return JSON.parse(JSON.stringify(t))
}

function qk(t) {
    return t = Array.from(new Set(t).values()), t.sort(), t
}
async function RO(t, e) {
    if (t == null) throw new Error("invalid event");
    if (Array.isArray(t) && (t = {
            topics: t
        }), typeof t == "string") switch (t) {
        case "block":
        case "debug":
        case "error":
        case "finalized":
        case "network":
        case "pending":
        case "safe":
            return {
                type: t,
                tag: t
            }
    }
    if (Zr(t, 32)) {
        const n = t.toLowerCase();
        return {
            type: "transaction",
            tag: l8("tx", {
                hash: n
            }),
            hash: n
        }
    }
    if (t.orphan) {
        const n = t;
        return {
            type: "orphan",
            tag: l8("orphan", n),
            filter: ZPe(n)
        }
    }
    if (t.address || t.topics) {
        const n = t,
            r = {
                topics: (n.topics || []).map(i => i == null ? null : Array.isArray(i) ? qk(i.map(s => s.toLowerCase())) : i.toLowerCase())
            };
        if (n.address) {
            const i = [],
                s = [],
                o = a => {
                    Zr(a) ? i.push(a) : s.push((async () => {
                        i.push(await aa(a, e))
                    })())
                };
            Array.isArray(n.address) ? n.address.forEach(o) : o(n.address), s.length && await Promise.all(s), r.address = qk(i.map(a => a.toLowerCase()))
        }
        return {
            filter: r,
            tag: l8("event", r),
            type: "event"
        }
    }
    Ee(!1, "unknown ProviderEvent", "event", t)
}

function OO() {
    return new Date().getTime()
}
const QPe = {
    cacheTimeout: 250,
    pollingInterval: 4e3
};
var Ao, rp, To, hb, wl, H1, ip, ih, tE, fc, pb, gb, jn, ul, Kk, Yk, A3, Zk, T3, c8;
class JPe {
    constructor(e, n) {
        _e(this, jn);
        _e(this, Ao);
        _e(this, rp);
        _e(this, To);
        _e(this, hb);
        _e(this, wl);
        _e(this, H1);
        _e(this, ip);
        _e(this, ih);
        _e(this, tE);
        _e(this, fc);
        _e(this, pb);
        _e(this, gb);
        if (le(this, gb, Object.assign({}, QPe, n || {})), e === "any") le(this, H1, !0), le(this, wl, null);
        else if (e) {
            const r = bu.from(e);
            le(this, H1, !1), le(this, wl, Promise.resolve(r)), setTimeout(() => {
                this.emit("network", r, null)
            }, 0)
        } else le(this, H1, !1), le(this, wl, null);
        le(this, ih, -1), le(this, ip, new Map), le(this, Ao, new Map), le(this, rp, new Map), le(this, To, null), le(this, hb, !1), le(this, tE, 1), le(this, fc, new Map), le(this, pb, !1)
    }
    get pollingInterval() {
        return W(this, gb).pollingInterval
    }
    get provider() {
        return this
    }
    get plugins() {
        return Array.from(W(this, rp).values())
    }
    attachPlugin(e) {
        if (W(this, rp).get(e.name)) throw new Error(`cannot replace existing plugin: ${e.name} `);
        return W(this, rp).set(e.name, e.connect(this)), this
    }
    getPlugin(e) {
        return W(this, rp).get(e) || null
    }
    get disableCcipRead() {
        return W(this, pb)
    }
    set disableCcipRead(e) {
        le(this, pb, !!e)
    }
    async ccipReadFetch(e, n, r) {
        if (this.disableCcipRead || r.length === 0 || e.to == null) return null;
        const i = e.to.toLowerCase(),
            s = n.toLowerCase(),
            o = [];
        for (let a = 0; a < r.length; a++) {
            const l = r[a],
                c = l.replace("{sender}", i).replace("{data}", s),
                u = new od(c);
            l.indexOf("{data}") === -1 && (u.body = {
                data: s,
                sender: i
            }), this.emit("debug", {
                action: "sendCcipReadFetchRequest",
                request: u,
                index: a,
                urls: r
            });
            let f = "unknown error";
            const h = await u.send();
            try {
                const g = h.bodyJson;
                if (g.data) return this.emit("debug", {
                    action: "receiveCcipReadFetchResult",
                    request: u,
                    result: g
                }), g.data;
                g.message && (f = g.message), this.emit("debug", {
                    action: "receiveCcipReadFetchError",
                    request: u,
                    result: g
                })
            } catch {}
            je(h.statusCode < 400 || h.statusCode >= 500, `response not found during CCIP fetch: ${f}`, "OFFCHAIN_FAULT", {
                reason: "404_MISSING_RESOURCE",
                transaction: e,
                info: {
                    url: l,
                    errorMessage: f
                }
            }), o.push(f)
        }
        je(!1, `error encountered during CCIP fetch: ${o.map(a=>JSON.stringify(a)).join(", ")}`, "OFFCHAIN_FAULT", {
            reason: "500_SERVER_ERROR",
            transaction: e,
            info: {
                urls: r,
                errorMessages: o
            }
        })
    }
    _wrapBlock(e, n) {
        return new yPe($Pe(e), this)
    }
    _wrapLog(e, n) {
        return new NE(MPe(e), this)
    }
    _wrapTransactionReceipt(e, n) {
        return new Eie(UPe(e), this)
    }
    _wrapTransactionResponse(e, n) {
        return new r6(Die(e), this)
    }
    _detectNetwork() {
        je(!1, "sub-classes must implement this", "UNSUPPORTED_OPERATION", {
            operation: "_detectNetwork"
        })
    }
    async _perform(e) {
        je(!1, `unsupported method: ${e.method}`, "UNSUPPORTED_OPERATION", {
            operation: e.method,
            info: e
        })
    }
    async getBlockNumber() {
        const e = Mn(await De(this, jn, ul).call(this, {
            method: "getBlockNumber"
        }), "%response");
        return W(this, ih) >= 0 && le(this, ih, e), e
    }
    _getAddress(e) {
        return aa(e, this)
    }
    _getBlockTag(e) {
        if (e == null) return "latest";
        switch (e) {
            case "earliest":
                return "0x0";
            case "finalized":
            case "latest":
            case "pending":
            case "safe":
                return e
        }
        if (Zr(e)) return Zr(e, 32) ? e : u1(e);
        if (typeof e == "bigint" && (e = Mn(e, "blockTag")), typeof e == "number") return e >= 0 ? u1(e) : W(this, ih) >= 0 ? u1(W(this, ih) + e) : this.getBlockNumber().then(n => u1(n + e));
        Ee(!1, "invalid blockTag", "blockTag", e)
    }
    _getFilter(e) {
        const n = (e.topics || []).map(l => l == null ? null : Array.isArray(l) ? qk(l.map(c => c.toLowerCase())) : l.toLowerCase()),
            r = "blockHash" in e ? e.blockHash : void 0,
            i = (l, c, u) => {
                let f;
                switch (l.length) {
                    case 0:
                        break;
                    case 1:
                        f = l[0];
                        break;
                    default:
                        l.sort(), f = l
                }
                if (r && (c != null || u != null)) throw new Error("invalid filter");
                const h = {};
                return f && (h.address = f), n.length && (h.topics = n), c && (h.fromBlock = c), u && (h.toBlock = u), r && (h.blockHash = r), h
            };
        let s = [];
        if (e.address)
            if (Array.isArray(e.address))
                for (const l of e.address) s.push(this._getAddress(l));
            else s.push(this._getAddress(e.address));
        let o;
        "fromBlock" in e && (o = this._getBlockTag(e.fromBlock));
        let a;
        return "toBlock" in e && (a = this._getBlockTag(e.toBlock)), s.filter(l => typeof l != "string").length || o != null && typeof o != "string" || a != null && typeof a != "string" ? Promise.all([Promise.all(s), o, a]).then(l => i(l[0], l[1], l[2])) : i(s, o, a)
    }
    _getTransactionRequest(e) {
        const n = jC(e),
            r = [];
        if (["to", "from"].forEach(i => {
                if (n[i] == null) return;
                const s = aa(n[i], this);
                Jx(s) ? r.push(async function() {
                    n[i] = await s
                }()) : n[i] = s
            }), n.blockTag != null) {
            const i = this._getBlockTag(n.blockTag);
            Jx(i) ? r.push(async function() {
                n.blockTag = await i
            }()) : n.blockTag = i
        }
        return r.length ? async function() {
            return await Promise.all(r), n
        }() : n
    }
    async getNetwork() {
        if (W(this, wl) == null) {
            const i = (async () => {
                try {
                    const s = await this._detectNetwork();
                    return this.emit("network", s, null), s
                } catch (s) {
                    throw W(this, wl) === i && le(this, wl, null), s
                }
            })();
            return le(this, wl, i), (await i).clone()
        }
        const e = W(this, wl),
            [n, r] = await Promise.all([e, this._detectNetwork()]);
        return n.chainId !== r.chainId && (W(this, H1) ? (this.emit("network", r, n), W(this, wl) === e && le(this, wl, Promise.resolve(r))) : je(!1, `network changed: ${n.chainId} => ${r.chainId} `, "NETWORK_ERROR", {
            event: "changed"
        })), n.clone()
    }
    async getFeeData() {
        const e = await this.getNetwork(),
            n = async () => {
                const {
                    _block: i,
                    gasPrice: s,
                    priorityFee: o
                } = await Xo({
                    _block: De(this, jn, Zk).call(this, "latest", !1),
                    gasPrice: (async () => {
                        try {
                            const u = await De(this, jn, ul).call(this, {
                                method: "getGasPrice"
                            });
                            return kt(u, "%response")
                        } catch {}
                        return null
                    })(),
                    priorityFee: (async () => {
                        try {
                            const u = await De(this, jn, ul).call(this, {
                                method: "getPriorityFee"
                            });
                            return kt(u, "%response")
                        } catch {}
                        return null
                    })()
                });
                let a = null,
                    l = null;
                const c = this._wrapBlock(i, e);
                return c && c.baseFeePerGas && (l = o ? ? BigInt("1000000000"), a = c.baseFeePerGas * KPe + l), new rq(s, a, l)
            },
            r = e.getPlugin("org.ethers.plugins.network.FetchUrlFeeDataPlugin");
        if (r) {
            const i = new od(r.url),
                s = await r.processFunc(n, this, i);
            return new rq(s.gasPrice, s.maxFeePerGas, s.maxPriorityFeePerGas)
        }
        return await n()
    }
    async estimateGas(e) {
        let n = this._getTransactionRequest(e);
        return Jx(n) && (n = await n), kt(await De(this, jn, ul).call(this, {
            method: "estimateGas",
            transaction: n
        }), "%response")
    }
    async call(e) {
        const {
            tx: n,
            blockTag: r
        } = await Xo({
            tx: this._getTransactionRequest(e),
            blockTag: this._getBlockTag(e.blockTag)
        });
        return await De(this, jn, Yk).call(this, De(this, jn, Kk).call(this, n, r, e.enableCcipRead ? 0 : -1))
    }
    async getBalance(e, n) {
        return kt(await De(this, jn, A3).call(this, {
            method: "getBalance"
        }, e, n), "%response")
    }
    async getTransactionCount(e, n) {
        return Mn(await De(this, jn, A3).call(this, {
            method: "getTransactionCount"
        }, e, n), "%response")
    }
    async getCode(e, n) {
        return Ot(await De(this, jn, A3).call(this, {
            method: "getCode"
        }, e, n))
    }
    async getStorage(e, n, r) {
        const i = kt(n, "position");
        return Ot(await De(this, jn, A3).call(this, {
            method: "getStorage",
            position: i
        }, e, r))
    }
    async broadcastTransaction(e) {
        const {
            blockNumber: n,
            hash: r,
            network: i
        } = await Xo({
            blockNumber: this.getBlockNumber(),
            hash: this._perform({
                method: "broadcastTransaction",
                signedTransaction: e
            }),
            network: this.getNetwork()
        }), s = FC.from(e);
        if (s.hash !== r) throw new Error("@TODO: the returned hash did not match");
        return this._wrapTransactionResponse(s, i).replaceableTransaction(n)
    }
    async getBlock(e, n) {
        const {
            network: r,
            params: i
        } = await Xo({
            network: this.getNetwork(),
            params: De(this, jn, Zk).call(this, e, !!n)
        });
        return i == null ? null : this._wrapBlock(i, r)
    }
    async getTransaction(e) {
        const {
            network: n,
            params: r
        } = await Xo({
            network: this.getNetwork(),
            params: De(this, jn, ul).call(this, {
                method: "getTransaction",
                hash: e
            })
        });
        return r == null ? null : this._wrapTransactionResponse(r, n)
    }
    async getTransactionReceipt(e) {
        const {
            network: n,
            params: r
        } = await Xo({
            network: this.getNetwork(),
            params: De(this, jn, ul).call(this, {
                method: "getTransactionReceipt",
                hash: e
            })
        });
        if (r == null) return null;
        if (r.gasPrice == null && r.effectiveGasPrice == null) {
            const i = await De(this, jn, ul).call(this, {
                method: "getTransaction",
                hash: e
            });
            if (i == null) throw new Error("report this; could not find tx or effectiveGasPrice");
            r.effectiveGasPrice = i.gasPrice
        }
        return this._wrapTransactionReceipt(r, n)
    }
    async getTransactionResult(e) {
        const {
            result: n
        } = await Xo({
            network: this.getNetwork(),
            result: De(this, jn, ul).call(this, {
                method: "getTransactionResult",
                hash: e
            })
        });
        return n == null ? null : Ot(n)
    }
    async getLogs(e) {
        let n = this._getFilter(e);
        Jx(n) && (n = await n);
        const {
            network: r,
            params: i
        } = await Xo({
            network: this.getNetwork(),
            params: De(this, jn, ul).call(this, {
                method: "getLogs",
                filter: n
            })
        });
        return i.map(s => this._wrapLog(s, r))
    }
    _getProvider(e) {
        je(!1, "provider cannot connect to target network", "UNSUPPORTED_OPERATION", {
            operation: "_getProvider()"
        })
    }
    async getResolver(e) {
        return await zC.fromName(this, e)
    }
    async getAvatar(e) {
        const n = await this.getResolver(e);
        return n ? await n.getAvatar() : null
    }
    async resolveName(e) {
        const n = await this.getResolver(e);
        return n ? await n.getAddress() : null
    }
    async lookupAddress(e) {
        e = Hn(e);
        const n = Uk(e.substring(2).toLowerCase() + ".addr.reverse");
        try {
            const r = await zC.getEnsAddress(this),
                s = await new Qr(r, ["function resolver(bytes32) view returns (address)"], this).resolver(n);
            if (s == null || s === Z_) return null;
            const a = await new Qr(s, ["function name(bytes32) view returns (string)"], this).name(n);
            return await this.resolveName(a) !== e ? null : a
        } catch (r) {
            if (No(r, "BAD_DATA") && r.value === "0x" || No(r, "CALL_EXCEPTION")) return null;
            throw r
        }
        return null
    }
    async waitForTransaction(e, n, r) {
        const i = n ? ? 1;
        return i === 0 ? this.getTransactionReceipt(e) : new Promise(async (s, o) => {
            let a = null;
            const l = async c => {
                try {
                    const u = await this.getTransactionReceipt(e);
                    if (u != null && c - u.blockNumber + 1 >= i) {
                        s(u), a && (clearTimeout(a), a = null);
                        return
                    }
                } catch (u) {
                    console.log("EEE", u)
                }
                this.once("block", l)
            };
            r != null && (a = setTimeout(() => {
                a != null && (a = null, this.off("block", l), o(pi("timeout", "TIMEOUT", {
                    reason: "timeout"
                })))
            }, r)), l(await this.getBlockNumber())
        })
    }
    async waitForBlock(e) {
        je(!1, "not implemented yet", "NOT_IMPLEMENTED", {
            operation: "waitForBlock"
        })
    }
    _clearTimeout(e) {
        const n = W(this, fc).get(e);
        n && (n.timer && clearTimeout(n.timer), W(this, fc).delete(e))
    }
    _setTimeout(e, n) {
        n == null && (n = 0);
        const r = s0(this, tE)._++,
            i = () => {
                W(this, fc).delete(r), e()
            };
        if (this.paused) W(this, fc).set(r, {
            timer: null,
            func: i,
            time: n
        });
        else {
            const s = setTimeout(i, n);
            W(this, fc).set(r, {
                timer: s,
                func: i,
                time: OO()
            })
        }
        return r
    }
    _forEachSubscriber(e) {
        for (const n of W(this, Ao).values()) e(n.subscriber)
    }
    _getSubscriber(e) {
        switch (e.type) {
            case "debug":
            case "error":
            case "network":
                return new WC(e.type);
            case "block":
                {
                    const n = new WPe(this);
                    return n.pollingInterval = this.pollingInterval,
                    n
                }
            case "safe":
            case "finalized":
                return new VPe(this, e.type);
            case "event":
                return new jL(this, e.filter);
            case "transaction":
                return new qPe(this, e.hash);
            case "orphan":
                return new GPe(this, e.filter)
        }
        throw new Error(`unsupported event: ${e.type}`)
    }
    _recoverSubscriber(e, n) {
        for (const r of W(this, Ao).values())
            if (r.subscriber === e) {
                r.started && r.subscriber.stop(), r.subscriber = n, r.started && n.start(), W(this, To) != null && n.pause(W(this, To));
                break
            }
    }
    async on(e, n) {
        const r = await De(this, jn, c8).call(this, e);
        return r.listeners.push({
            listener: n,
            once: !1
        }), r.started || (r.subscriber.start(), r.started = !0, W(this, To) != null && r.subscriber.pause(W(this, To))), this
    }
    async once(e, n) {
        const r = await De(this, jn, c8).call(this, e);
        return r.listeners.push({
            listener: n,
            once: !0
        }), r.started || (r.subscriber.start(), r.started = !0, W(this, To) != null && r.subscriber.pause(W(this, To))), this
    }
    async emit(e, ...n) {
        const r = await De(this, jn, T3).call(this, e, n);
        if (!r || r.listeners.length === 0) return !1;
        const i = r.listeners.length;
        return r.listeners = r.listeners.filter(({
            listener: s,
            once: o
        }) => {
            const a = new Jne(this, o ? null : s, e);
            try {
                s.call(this, ...n, a)
            } catch {}
            return !o
        }), r.listeners.length === 0 && (r.started && r.subscriber.stop(), W(this, Ao).delete(r.tag)), i > 0
    }
    async listenerCount(e) {
        if (e) {
            const r = await De(this, jn, T3).call(this, e);
            return r ? r.listeners.length : 0
        }
        let n = 0;
        for (const {
                listeners: r
            } of W(this, Ao).values()) n += r.length;
        return n
    }
    async listeners(e) {
        if (e) {
            const r = await De(this, jn, T3).call(this, e);
            return r ? r.listeners.map(({
                listener: i
            }) => i) : []
        }
        let n = [];
        for (const {
                listeners: r
            } of W(this, Ao).values()) n = n.concat(r.map(({
            listener: i
        }) => i));
        return n
    }
    async off(e, n) {
        const r = await De(this, jn, T3).call(this, e);
        if (!r) return this;
        if (n) {
            const i = r.listeners.map(({
                listener: s
            }) => s).indexOf(n);
            i >= 0 && r.listeners.splice(i, 1)
        }
        return (!n || r.listeners.length === 0) && (r.started && r.subscriber.stop(), W(this, Ao).delete(r.tag)), this
    }
    async removeAllListeners(e) {
        if (e) {
            const {
                tag: n,
                started: r,
                subscriber: i
            } = await De(this, jn, c8).call(this, e);
            r && i.stop(), W(this, Ao).delete(n)
        } else
            for (const [n, {
                    started: r,
                    subscriber: i
                }] of W(this, Ao)) r && i.stop(), W(this, Ao).delete(n);
        return this
    }
    async addListener(e, n) {
        return await this.on(e, n)
    }
    async removeListener(e, n) {
        return this.off(e, n)
    }
    get destroyed() {
        return W(this, hb)
    }
    destroy() {
        this.removeAllListeners();
        for (const e of W(this, fc).keys()) this._clearTimeout(e);
        le(this, hb, !0)
    }
    get paused() {
        return W(this, To) != null
    }
    set paused(e) {
        !!e !== this.paused && (this.paused ? this.resume() : this.pause(!1))
    }
    pause(e) {
        if (le(this, ih, -1), W(this, To) != null) {
            if (W(this, To) == !!e) return;
            je(!1, "cannot change pause type; resume first", "UNSUPPORTED_OPERATION", {
                operation: "pause"
            })
        }
        this._forEachSubscriber(n => n.pause(e)), le(this, To, !!e);
        for (const n of W(this, fc).values()) n.timer && clearTimeout(n.timer), n.time = OO() - n.time
    }
    resume() {
        if (W(this, To) != null) {
            this._forEachSubscriber(e => e.resume()), le(this, To, null);
            for (const e of W(this, fc).values()) {
                let n = e.time;
                n < 0 && (n = 0), e.time = OO(), setTimeout(e.func, n)
            }
        }
    }
}
Ao = new WeakMap, rp = new WeakMap, To = new WeakMap, hb = new WeakMap, wl = new WeakMap, H1 = new WeakMap, ip = new WeakMap, ih = new WeakMap, tE = new WeakMap, fc = new WeakMap, pb = new WeakMap, gb = new WeakMap, jn = new WeakSet, ul = async function(e) {
    const n = W(this, gb).cacheTimeout;
    if (n < 0) return await this._perform(e);
    const r = l8(e.method, e);
    let i = W(this, ip).get(r);
    return i || (i = this._perform(e), W(this, ip).set(r, i), setTimeout(() => {
        W(this, ip).get(r) === i && W(this, ip).delete(r)
    }, n)), await i
}, Kk = async function(e, n, r) {
    je(r < YPe, "CCIP read exceeded maximum redirections", "OFFCHAIN_FAULT", {
        reason: "TOO_MANY_REDIRECTS",
        transaction: Object.assign({}, e, {
            blockTag: n,
            enableCcipRead: !0
        })
    });
    const i = jC(e);
    try {
        return Ot(await this._perform({
            method: "call",
            transaction: i,
            blockTag: n
        }))
    } catch (s) {
        if (!this.disableCcipRead && _L(s) && s.data && r >= 0 && n === "latest" && i.to != null && ji(s.data, 0, 4) === "0x556f1830") {
            const o = s.data,
                a = await aa(i.to, this);
            let l;
            try {
                l = rke(ji(s.data, 4))
            } catch (f) {
                je(!1, f.message, "OFFCHAIN_FAULT", {
                    reason: "BAD_DATA",
                    transaction: i,
                    info: {
                        data: o
                    }
                })
            }
            je(l.sender.toLowerCase() === a.toLowerCase(), "CCIP Read sender mismatch", "CALL_EXCEPTION", {
                action: "call",
                data: o,
                reason: "OffchainLookup",
                transaction: i,
                invocation: null,
                revert: {
                    signature: "OffchainLookup(address,string[],bytes,bytes4,bytes)",
                    name: "OffchainLookup",
                    args: l.errorArgs
                }
            });
            const c = await this.ccipReadFetch(i, l.calldata, l.urls);
            je(c != null, "CCIP Read failed to fetch data", "OFFCHAIN_FAULT", {
                reason: "FETCH_FAILED",
                transaction: i,
                info: {
                    data: s.data,
                    errorArgs: l.errorArgs
                }
            });
            const u = {
                to: a,
                data: vi([l.selector, nke([c, l.extraData])])
            };
            this.emit("debug", {
                action: "sendCcipReadCall",
                transaction: u
            });
            try {
                const f = await De(this, jn, Kk).call(this, u, n, r + 1);
                return this.emit("debug", {
                    action: "receiveCcipReadCallResult",
                    transaction: Object.assign({}, u),
                    result: f
                }), f
            } catch (f) {
                throw this.emit("debug", {
                    action: "receiveCcipReadCallError",
                    transaction: Object.assign({}, u),
                    error: f
                }), f
            }
        }
        throw s
    }
}, Yk = async function(e) {
    const {
        value: n
    } = await Xo({
        network: this.getNetwork(),
        value: e
    });
    return n
}, A3 = async function(e, n, r) {
    let i = this._getAddress(n),
        s = this._getBlockTag(r);
    return (typeof i != "string" || typeof s != "string") && ([i, s] = await Promise.all([i, s])), await De(this, jn, Yk).call(this, De(this, jn, ul).call(this, Object.assign(e, {
        address: i,
        blockTag: s
    })))
}, Zk = async function(e, n) {
    if (Zr(e, 32)) return await De(this, jn, ul).call(this, {
        method: "getBlock",
        blockHash: e,
        includeTransactions: n
    });
    let r = this._getBlockTag(e);
    return typeof r != "string" && (r = await r), await De(this, jn, ul).call(this, {
        method: "getBlock",
        blockTag: r,
        includeTransactions: n
    })
}, T3 = async function(e, n) {
    let r = await RO(e, this);
    return r.type === "event" && n && n.length > 0 && n[0].removed === !0 && (r = await RO({
        orphan: "drop-log",
        log: n[0]
    }, this)), W(this, Ao).get(r.tag) || null
}, c8 = async function(e) {
    const n = await RO(e, this),
        r = n.tag;
    let i = W(this, Ao).get(r);
    return i || (i = {
        subscriber: this._getSubscriber(n),
        tag: r,
        addressableMap: new WeakMap,
        nameMap: new Map,
        started: !1,
        listeners: []
    }, W(this, Ao).set(r, i)), i
};

function XPe(t, e) {
    try {
        const n = Qk(t, e);
        if (n) return PC(n)
    } catch {}
    return null
}

function Qk(t, e) {
    if (t === "0x") return null;
    try {
        const n = Mn(ji(t, e, e + 32)),
            r = Mn(ji(t, n, n + 32));
        return ji(t, n + 32, n + 32 + r)
    } catch {}
    return null
}

function fq(t) {
    const e = sa(t);
    if (e.length > 32) throw new Error("internal; should not happen");
    const n = new Uint8Array(32);
    return n.set(e, 32 - e.length), n
}

function eke(t) {
    if (t.length % 32 === 0) return t;
    const e = new Uint8Array(Math.ceil(t.length / 32) * 32);
    return e.set(t), e
}
const tke = new Uint8Array([]);

function nke(t) {
    const e = [];
    let n = 0;
    for (let r = 0; r < t.length; r++) e.push(tke), n += 32;
    for (let r = 0; r < t.length; r++) {
        const i = or(t[r]);
        e[r] = fq(n), e.push(fq(i.length)), e.push(eke(i)), n += 32 + Math.ceil(i.length / 32) * 32
    }
    return vi(e)
}
const dq = "0x0000000000000000000000000000000000000000000000000000000000000000";

function rke(t) {
    const e = {
        sender: "",
        urls: [],
        calldata: "",
        selector: "",
        extraData: "",
        errorArgs: []
    };
    je(iv(t) >= 5 * 32, "insufficient OffchainLookup data", "OFFCHAIN_FAULT", {
        reason: "insufficient OffchainLookup data"
    });
    const n = ji(t, 0, 32);
    je(ji(n, 0, 12) === ji(dq, 0, 12), "corrupt OffchainLookup sender", "OFFCHAIN_FAULT", {
        reason: "corrupt OffchainLookup sender"
    }), e.sender = ji(n, 12);
    try {
        const r = [],
            i = Mn(ji(t, 32, 64)),
            s = Mn(ji(t, i, i + 32)),
            o = ji(t, i + 32);
        for (let a = 0; a < s; a++) {
            const l = XPe(o, a * 32);
            if (l == null) throw new Error("abort");
            r.push(l)
        }
        e.urls = r
    } catch {
        je(!1, "corrupt OffchainLookup urls", "OFFCHAIN_FAULT", {
            reason: "corrupt OffchainLookup urls"
        })
    }
    try {
        const r = Qk(t, 64);
        if (r == null) throw new Error("abort");
        e.calldata = r
    } catch {
        je(!1, "corrupt OffchainLookup calldata", "OFFCHAIN_FAULT", {
            reason: "corrupt OffchainLookup calldata"
        })
    }
    je(ji(t, 100, 128) === ji(dq, 0, 28), "corrupt OffchainLookup callbaackSelector", "OFFCHAIN_FAULT", {
        reason: "corrupt OffchainLookup callbaackSelector"
    }), e.selector = ji(t, 96, 100);
    try {
        const r = Qk(t, 128);
        if (r == null) throw new Error("abort");
        e.extraData = r
    } catch {
        je(!1, "corrupt OffchainLookup extraData", "OFFCHAIN_FAULT", {
            reason: "corrupt OffchainLookup extraData"
        })
    }
    return e.errorArgs = "sender,urls,calldata,selector,extraData".split(/,/).map(r => e[r]), e
}

function nw(t, e) {
    if (t.provider) return t.provider;
    je(!1, "missing provider", "UNSUPPORTED_OPERATION", {
        operation: e
    })
}
async function hq(t, e) {
    let n = jC(e);
    if (n.to != null && (n.to = aa(n.to, t)), n.from != null) {
        const r = n.from;
        n.from = Promise.all([t.getAddress(), aa(r, t)]).then(([i, s]) => (Ee(i.toLowerCase() === s.toLowerCase(), "transaction from mismatch", "tx.from", s), i))
    } else n.from = t.getAddress();
    return await Xo(n)
}
class ike {
    constructor(e) {
        Ie(this, "provider");
        Xt(this, {
            provider: e || null
        })
    }
    async getNonce(e) {
        return nw(this, "getTransactionCount").getTransactionCount(await this.getAddress(), e)
    }
    async populateCall(e) {
        return await hq(this, e)
    }
    async populateTransaction(e) {
        const n = nw(this, "populateTransaction"),
            r = await hq(this, e);
        r.nonce == null && (r.nonce = await this.getNonce("pending")), r.gasLimit == null && (r.gasLimit = await this.estimateGas(r));
        const i = await this.provider.getNetwork();
        if (r.chainId != null) {
            const o = kt(r.chainId);
            Ee(o === i.chainId, "transaction chainId mismatch", "tx.chainId", e.chainId)
        } else r.chainId = i.chainId;
        const s = r.maxFeePerGas != null || r.maxPriorityFeePerGas != null;
        if (r.gasPrice != null && (r.type === 2 || s) ? Ee(!1, "eip-1559 transaction do not support gasPrice", "tx", e) : (r.type === 0 || r.type === 1) && s && Ee(!1, "pre-eip-1559 transaction do not support maxFeePerGas/maxPriorityFeePerGas", "tx", e), (r.type === 2 || r.type == null) && r.maxFeePerGas != null && r.maxPriorityFeePerGas != null) r.type = 2;
        else if (r.type === 0 || r.type === 1) {
            const o = await n.getFeeData();
            je(o.gasPrice != null, "network does not support gasPrice", "UNSUPPORTED_OPERATION", {
                operation: "getGasPrice"
            }), r.gasPrice == null && (r.gasPrice = o.gasPrice)
        } else {
            const o = await n.getFeeData();
            if (r.type == null)
                if (o.maxFeePerGas != null && o.maxPriorityFeePerGas != null)
                    if (r.type = 2, r.gasPrice != null) {
                        const a = r.gasPrice;
                        delete r.gasPrice, r.maxFeePerGas = a, r.maxPriorityFeePerGas = a
                    } else r.maxFeePerGas == null && (r.maxFeePerGas = o.maxFeePerGas), r.maxPriorityFeePerGas == null && (r.maxPriorityFeePerGas = o.maxPriorityFeePerGas);
            else o.gasPrice != null ? (je(!s, "network does not support EIP-1559", "UNSUPPORTED_OPERATION", {
                operation: "populateTransaction"
            }), r.gasPrice == null && (r.gasPrice = o.gasPrice), r.type = 0) : je(!1, "failed to get consistent fee data", "UNSUPPORTED_OPERATION", {
                operation: "signer.getFeeData"
            });
            else(r.type === 2 || r.type === 3) && (r.maxFeePerGas == null && (r.maxFeePerGas = o.maxFeePerGas), r.maxPriorityFeePerGas == null && (r.maxPriorityFeePerGas = o.maxPriorityFeePerGas))
        }
        return await Xo(r)
    }
    async estimateGas(e) {
        return nw(this, "estimateGas").estimateGas(await this.populateCall(e))
    }
    async call(e) {
        return nw(this, "call").call(await this.populateCall(e))
    }
    async resolveName(e) {
        return await nw(this, "resolveName").resolveName(e)
    }
    async sendTransaction(e) {
        const n = nw(this, "sendTransaction"),
            r = await this.populateTransaction(e);
        delete r.from;
        const i = FC.from(r);
        return await n.broadcastTransaction(await this.signTransaction(i))
    }
}
const pq = new Set;

function ske(t) {
    pq.has(t) || (pq.add(t), console.log("========= NOTICE ========="), console.log(`Request-Rate Exceeded for ${t} (this message will not be repeated)`), console.log(""), console.log("The default API keys for each service are provided as a highly-throttled,"), console.log("community resource for low-traffic projects and early prototyping."), console.log(""), console.log("While your application will continue to function, we highly recommended"), console.log("signing up for your own API keys to improve performance, increase your"), console.log("request rate/limit and enable other perks, such as metrics and advanced APIs."), console.log(""), console.log("For more details: https://docs.ethers.org/api-keys/"), console.log("=========================="))
}

function oke(t) {
    return JSON.parse(JSON.stringify(t))
}
var Zo, Af, z1, sp, W1, mb, Jp, Jk, Xk;
class Lie {
    constructor(e) {
        _e(this, Jp);
        _e(this, Zo);
        _e(this, Af);
        _e(this, z1);
        _e(this, sp);
        _e(this, W1);
        _e(this, mb);
        le(this, Zo, e), le(this, Af, null), le(this, z1, De(this, Jp, Jk).bind(this)), le(this, sp, !1), le(this, W1, null), le(this, mb, !1)
    }
    _subscribe(e) {
        throw new Error("subclasses must override this")
    }
    _emitResults(e, n) {
        throw new Error("subclasses must override this")
    }
    _recover(e) {
        throw new Error("subclasses must override this")
    }
    start() {
        W(this, sp) || (le(this, sp, !0), De(this, Jp, Jk).call(this, -2))
    }
    stop() {
        W(this, sp) && (le(this, sp, !1), le(this, mb, !0), De(this, Jp, Xk).call(this), W(this, Zo).off("block", W(this, z1)))
    }
    pause(e) {
        e && De(this, Jp, Xk).call(this), W(this, Zo).off("block", W(this, z1))
    }
    resume() {
        this.start()
    }
}
Zo = new WeakMap, Af = new WeakMap, z1 = new WeakMap, sp = new WeakMap, W1 = new WeakMap, mb = new WeakMap, Jp = new WeakSet, Jk = async function(e) {
    try {
        W(this, Af) == null && le(this, Af, this._subscribe(W(this, Zo)));
        let n = null;
        try {
            n = await W(this, Af)
        } catch (s) {
            if (!No(s, "UNSUPPORTED_OPERATION") || s.operation !== "eth_newFilter") throw s
        }
        if (n == null) {
            le(this, Af, null), W(this, Zo)._recoverSubscriber(this, this._recover(W(this, Zo)));
            return
        }
        const r = await W(this, Zo).getNetwork();
        if (W(this, W1) || le(this, W1, r), W(this, W1).chainId !== r.chainId) throw new Error("chaid changed");
        if (W(this, mb)) return;
        const i = await W(this, Zo).send("eth_getFilterChanges", [n]);
        await this._emitResults(W(this, Zo), i)
    } catch (n) {
        console.log("@TODO", n)
    }
    W(this, Zo).once("block", W(this, z1))
}, Xk = function() {
    const e = W(this, Af);
    e && (le(this, Af, null), e.then(n => {
        W(this, Zo).destroyed || W(this, Zo).send("eth_uninstallFilter", [n])
    }))
};
var V1;
class ake extends Lie {
    constructor(n, r) {
        super(n);
        _e(this, V1);
        le(this, V1, oke(r))
    }
    _recover(n) {
        return new jL(n, W(this, V1))
    }
    async _subscribe(n) {
        return await n.send("eth_newFilter", [W(this, V1)])
    }
    async _emitResults(n, r) {
        for (const i of r) n.emit(W(this, V1), n._wrapLog(i, n._network))
    }
}
V1 = new WeakMap;
class lke extends Lie {
    async _subscribe(e) {
        return await e.send("eth_newPendingTransactionFilter", [])
    }
    async _emitResults(e, n) {
        for (const r of n) e.emit("pending", r)
    }
}
const cke = "bigint,boolean,function,number,string,symbol".split(/,/g);

function u8(t) {
    if (t == null || cke.indexOf(typeof t) >= 0 || typeof t.getAddress == "function") return t;
    if (Array.isArray(t)) return t.map(u8);
    if (typeof t == "object") return Object.keys(t).reduce((e, n) => (e[n] = t[n], e), {});
    throw new Error(`should not happen: ${t} (${typeof t})`)
}

function uke(t) {
    return new Promise(e => {
        setTimeout(e, t)
    })
}

function rw(t) {
    return t && t.toLowerCase()
}

function gq(t) {
    return t && typeof t.pollingInterval == "number"
}
const Bie = {
    polling: !1,
    staticNetwork: null,
    batchStallTime: 10,
    batchMaxSize: 1 << 20,
    batchMaxCount: 100,
    cacheTimeout: 250,
    pollingInterval: 4e3
};
class f8 extends ike {
    constructor(n, r) {
        super(n);
        Ie(this, "address");
        r = Hn(r), Xt(this, {
            address: r
        })
    }
    connect(n) {
        je(!1, "cannot reconnect JsonRpcSigner", "UNSUPPORTED_OPERATION", {
            operation: "signer.connect"
        })
    }
    async getAddress() {
        return this.address
    }
    async populateTransaction(n) {
        return await this.populateCall(n)
    }
    async sendUncheckedTransaction(n) {
        const r = u8(n),
            i = [];
        if (r.from) {
            const o = r.from;
            i.push((async () => {
                const a = await aa(o, this.provider);
                Ee(a != null && a.toLowerCase() === this.address.toLowerCase(), "from address mismatch", "transaction", n), r.from = a
            })())
        } else r.from = this.address;
        if (r.gasLimit == null && i.push((async () => {
                r.gasLimit = await this.provider.estimateGas({ ...r,
                    from: this.address
                })
            })()), r.to != null) {
            const o = r.to;
            i.push((async () => {
                r.to = await aa(o, this.provider)
            })())
        }
        i.length && await Promise.all(i);
        const s = this.provider.getRpcTransaction(r);
        return this.provider.send("eth_sendTransaction", [s])
    }
    async sendTransaction(n) {
        const r = await this.provider.getBlockNumber(),
            i = await this.sendUncheckedTransaction(n);
        return await new Promise((s, o) => {
            const a = [1e3, 100];
            let l = 0;
            const c = async () => {
                try {
                    const u = await this.provider.getTransaction(i);
                    if (u != null) {
                        s(u.replaceableTransaction(r));
                        return
                    }
                } catch (u) {
                    if (No(u, "CANCELLED") || No(u, "BAD_DATA") || No(u, "NETWORK_ERROR")) {
                        u.info == null && (u.info = {}), u.info.sendTransactionHash = i, o(u);
                        return
                    }
                    if (No(u, "INVALID_ARGUMENT") && (l++, u.info == null && (u.info = {}), u.info.sendTransactionHash = i, l > 10)) {
                        o(u);
                        return
                    }
                    this.provider.emit("error", pi("failed to fetch transation after sending (will try again)", "UNKNOWN_ERROR", {
                        error: u
                    }))
                }
                this.provider._setTimeout(() => {
                    c()
                }, a.pop() || 4e3)
            };
            c()
        })
    }
    async signTransaction(n) {
        const r = u8(n);
        if (r.from) {
            const s = await aa(r.from, this.provider);
            Ee(s != null && s.toLowerCase() === this.address.toLowerCase(), "from address mismatch", "transaction", n), r.from = s
        } else r.from = this.address;
        const i = this.provider.getRpcTransaction(r);
        return await this.provider.send("eth_signTransaction", [i])
    }
    async signMessage(n) {
        const r = typeof n == "string" ? qf(n) : n;
        return await this.provider.send("personal_sign", [Ot(r), this.address.toLowerCase()])
    }
    async signTypedData(n, r, i) {
        const s = u8(i),
            o = await UC.resolveNames(n, r, s, async a => {
                const l = await aa(a);
                return Ee(l != null, "TypedData does not support null address", "value", a), l
            });
        return await this.provider.send("eth_signTypedData_v4", [this.address.toLowerCase(), JSON.stringify(UC.getPayload(o.domain, r, o.value))])
    }
    async unlock(n) {
        return this.provider.send("personal_unlockAccount", [this.address.toLowerCase(), n, null])
    }
    async _legacySignMessage(n) {
        const r = typeof n == "string" ? qf(n) : n;
        return await this.provider.send("eth_sign", [this.address.toLowerCase(), Ot(r)])
    }
}
var G1, yb, sh, Tf, fu, dc, Da, nE, eM;
class Fie extends JPe {
    constructor(n, r) {
        super(n, r);
        _e(this, nE);
        _e(this, G1);
        _e(this, yb);
        _e(this, sh);
        _e(this, Tf);
        _e(this, fu);
        _e(this, dc);
        _e(this, Da);
        le(this, yb, 1), le(this, G1, Object.assign({}, Bie, r || {})), le(this, sh, []), le(this, Tf, null), le(this, dc, null), le(this, Da, null); {
            let s = null;
            const o = new Promise(a => {
                s = a
            });
            le(this, fu, {
                promise: o,
                resolve: s
            })
        }
        const i = this._getOption("staticNetwork");
        typeof i == "boolean" ? (Ee(!i || n !== "any", "staticNetwork cannot be used on special network 'any'", "options", r), i && n != null && le(this, dc, bu.from(n))) : i && (Ee(n == null || i.matches(n), "staticNetwork MUST match network object", "options", r), le(this, dc, i))
    }
    _getOption(n) {
        return W(this, G1)[n]
    }
    get _network() {
        return je(W(this, dc), "network is not available yet", "NETWORK_ERROR"), W(this, dc)
    }
    async _perform(n) {
        if (n.method === "call" || n.method === "estimateGas") {
            let i = n.transaction;
            if (i && i.type != null && kt(i.type) && i.maxFeePerGas == null && i.maxPriorityFeePerGas == null) {
                const s = await this.getFeeData();
                s.maxFeePerGas == null && s.maxPriorityFeePerGas == null && (n = Object.assign({}, n, {
                    transaction: Object.assign({}, i, {
                        type: void 0
                    })
                }))
            }
        }
        const r = this.getRpcRequest(n);
        return r != null ? await this.send(r.method, r.args) : super._perform(n)
    }
    async _detectNetwork() {
        const n = this._getOption("staticNetwork");
        if (n)
            if (n === !0) {
                if (W(this, dc)) return W(this, dc)
            } else return n;
        return W(this, Da) ? await W(this, Da) : this.ready ? (le(this, Da, (async () => {
            try {
                const r = bu.from(kt(await this.send("eth_chainId", [])));
                return le(this, Da, null), r
            } catch (r) {
                throw le(this, Da, null), r
            }
        })()), await W(this, Da)) : (le(this, Da, (async () => {
            const r = {
                id: s0(this, yb)._++,
                method: "eth_chainId",
                params: [],
                jsonrpc: "2.0"
            };
            this.emit("debug", {
                action: "sendRpcPayload",
                payload: r
            });
            let i;
            try {
                i = (await this._send(r))[0], le(this, Da, null)
            } catch (s) {
                throw le(this, Da, null), this.emit("debug", {
                    action: "receiveRpcError",
                    error: s
                }), s
            }
            if (this.emit("debug", {
                    action: "receiveRpcResult",
                    result: i
                }), "result" in i) return bu.from(kt(i.result));
            throw this.getRpcError(r, i)
        })()), await W(this, Da))
    }
    _start() {
        W(this, fu) == null || W(this, fu).resolve == null || (W(this, fu).resolve(), le(this, fu, null), (async () => {
            for (; W(this, dc) == null && !this.destroyed;) try {
                le(this, dc, await this._detectNetwork())
            } catch (n) {
                if (this.destroyed) break;
                console.log("JsonRpcProvider failed to detect network and cannot start up; retry in 1s (perhaps the URL is wrong or the node is not started)"), this.emit("error", pi("failed to bootstrap network detection", "NETWORK_ERROR", {
                    event: "initial-network-discovery",
                    info: {
                        error: n
                    }
                })), await uke(1e3)
            }
            De(this, nE, eM).call(this)
        })())
    }
    async _waitUntilReady() {
        if (W(this, fu) != null) return await W(this, fu).promise
    }
    _getSubscriber(n) {
        return n.type === "pending" ? new lke(this) : n.type === "event" ? this._getOption("polling") ? new jL(this, n.filter) : new ake(this, n.filter) : n.type === "orphan" && n.filter.orphan === "drop-log" ? new WC("orphan") : super._getSubscriber(n)
    }
    get ready() {
        return W(this, fu) == null
    }
    getRpcTransaction(n) {
        const r = {};
        return ["chainId", "gasLimit", "gasPrice", "type", "maxFeePerGas", "maxPriorityFeePerGas", "nonce", "value"].forEach(i => {
            if (n[i] == null) return;
            let s = i;
            i === "gasLimit" && (s = "gas"), r[s] = u1(kt(n[i], `tx.${i}`))
        }), ["from", "to", "data"].forEach(i => {
            n[i] != null && (r[i] = Ot(n[i]))
        }), n.accessList && (r.accessList = wy(n.accessList)), n.blobVersionedHashes && (r.blobVersionedHashes = n.blobVersionedHashes.map(i => i.toLowerCase())), r
    }
    getRpcRequest(n) {
        switch (n.method) {
            case "chainId":
                return {
                    method: "eth_chainId",
                    args: []
                };
            case "getBlockNumber":
                return {
                    method: "eth_blockNumber",
                    args: []
                };
            case "getGasPrice":
                return {
                    method: "eth_gasPrice",
                    args: []
                };
            case "getPriorityFee":
                return {
                    method: "eth_maxPriorityFeePerGas",
                    args: []
                };
            case "getBalance":
                return {
                    method: "eth_getBalance",
                    args: [rw(n.address), n.blockTag]
                };
            case "getTransactionCount":
                return {
                    method: "eth_getTransactionCount",
                    args: [rw(n.address), n.blockTag]
                };
            case "getCode":
                return {
                    method: "eth_getCode",
                    args: [rw(n.address), n.blockTag]
                };
            case "getStorage":
                return {
                    method: "eth_getStorageAt",
                    args: [rw(n.address), "0x" + n.position.toString(16), n.blockTag]
                };
            case "broadcastTransaction":
                return {
                    method: "eth_sendRawTransaction",
                    args: [n.signedTransaction]
                };
            case "getBlock":
                if ("blockTag" in n) return {
                    method: "eth_getBlockByNumber",
                    args: [n.blockTag, !!n.includeTransactions]
                };
                if ("blockHash" in n) return {
                    method: "eth_getBlockByHash",
                    args: [n.blockHash, !!n.includeTransactions]
                };
                break;
            case "getTransaction":
                return {
                    method: "eth_getTransactionByHash",
                    args: [n.hash]
                };
            case "getTransactionReceipt":
                return {
                    method: "eth_getTransactionReceipt",
                    args: [n.hash]
                };
            case "call":
                return {
                    method: "eth_call",
                    args: [this.getRpcTransaction(n.transaction), n.blockTag]
                };
            case "estimateGas":
                return {
                    method: "eth_estimateGas",
                    args: [this.getRpcTransaction(n.transaction)]
                };
            case "getLogs":
                return n.filter && n.filter.address != null && (Array.isArray(n.filter.address) ? n.filter.address = n.filter.address.map(rw) : n.filter.address = rw(n.filter.address)), {
                    method: "eth_getLogs",
                    args: [n.filter]
                }
        }
        return null
    }
    getRpcError(n, r) {
        const {
            method: i
        } = n, {
            error: s
        } = r;
        if (i === "eth_estimateGas" && s.message) {
            const l = s.message;
            if (!l.match(/revert/i) && l.match(/insufficient funds/i)) return pi("insufficient funds", "INSUFFICIENT_FUNDS", {
                transaction: n.params[0],
                info: {
                    payload: n,
                    error: s
                }
            })
        }
        if (i === "eth_call" || i === "eth_estimateGas") {
            const l = tM(s),
                c = Jo.getBuiltinCallException(i === "eth_call" ? "call" : "estimateGas", n.params[0], l ? l.data : null);
            return c.info = {
                error: s,
                payload: n
            }, c
        }
        const o = JSON.stringify(fke(s));
        if (typeof s.message == "string" && s.message.match(/user denied|ethers-user-denied/i)) return pi("user rejected action", "ACTION_REJECTED", {
            action: {
                eth_sign: "signMessage",
                personal_sign: "signMessage",
                eth_signTypedData_v4: "signTypedData",
                eth_signTransaction: "signTransaction",
                eth_sendTransaction: "sendTransaction",
                eth_requestAccounts: "requestAccess",
                wallet_requestAccounts: "requestAccess"
            }[i] || "unknown",
            reason: "rejected",
            info: {
                payload: n,
                error: s
            }
        });
        if (i === "eth_sendRawTransaction" || i === "eth_sendTransaction") {
            const l = n.params[0];
            if (o.match(/insufficient funds|base fee exceeds gas limit/i)) return pi("insufficient funds for intrinsic transaction cost", "INSUFFICIENT_FUNDS", {
                transaction: l,
                info: {
                    error: s
                }
            });
            if (o.match(/nonce/i) && o.match(/too low/i)) return pi("nonce has already been used", "NONCE_EXPIRED", {
                transaction: l,
                info: {
                    error: s
                }
            });
            if (o.match(/replacement transaction/i) && o.match(/underpriced/i)) return pi("replacement fee too low", "REPLACEMENT_UNDERPRICED", {
                transaction: l,
                info: {
                    error: s
                }
            });
            if (o.match(/only replay-protected/i)) return pi("legacy pre-eip-155 transactions not supported", "UNSUPPORTED_OPERATION", {
                operation: i,
                info: {
                    transaction: l,
                    info: {
                        error: s
                    }
                }
            })
        }
        let a = !!o.match(/the method .* does not exist/i);
        return a || s && s.details && s.details.startsWith("Unauthorized method:") && (a = !0), a ? pi("unsupported operation", "UNSUPPORTED_OPERATION", {
            operation: n.method,
            info: {
                error: s,
                payload: n
            }
        }) : pi("could not coalesce error", "UNKNOWN_ERROR", {
            error: s,
            payload: n
        })
    }
    send(n, r) {
        if (this.destroyed) return Promise.reject(pi("provider destroyed; cancelled request", "UNSUPPORTED_OPERATION", {
            operation: n
        }));
        const i = s0(this, yb)._++,
            s = new Promise((o, a) => {
                W(this, sh).push({
                    resolve: o,
                    reject: a,
                    payload: {
                        method: n,
                        params: r,
                        id: i,
                        jsonrpc: "2.0"
                    }
                })
            });
        return De(this, nE, eM).call(this), s
    }
    async getSigner(n) {
        n == null && (n = 0);
        const r = this.send("eth_accounts", []);
        if (typeof n == "number") {
            const s = await r;
            if (n >= s.length) throw new Error("no such account");
            return new f8(this, s[n])
        }
        const {
            accounts: i
        } = await Xo({
            network: this.getNetwork(),
            accounts: r
        });
        n = Hn(n);
        for (const s of i)
            if (Hn(s) === n) return new f8(this, n);
        throw new Error("invalid account")
    }
    async listAccounts() {
        return (await this.send("eth_accounts", [])).map(r => new f8(this, r))
    }
    destroy() {
        W(this, Tf) && (clearTimeout(W(this, Tf)), le(this, Tf, null));
        for (const {
                payload: n,
                reject: r
            } of W(this, sh)) r(pi("provider destroyed; cancelled request", "UNSUPPORTED_OPERATION", {
            operation: n.method
        }));
        le(this, sh, []), super.destroy()
    }
}
G1 = new WeakMap, yb = new WeakMap, sh = new WeakMap, Tf = new WeakMap, fu = new WeakMap, dc = new WeakMap, Da = new WeakMap, nE = new WeakSet, eM = function() {
    if (W(this, Tf)) return;
    const n = this._getOption("batchMaxCount") === 1 ? 0 : this._getOption("batchStallTime");
    le(this, Tf, setTimeout(() => {
        le(this, Tf, null);
        const r = W(this, sh);
        for (le(this, sh, []); r.length;) {
            const i = [r.shift()];
            for (; r.length && i.length !== W(this, G1).batchMaxCount;)
                if (i.push(r.shift()), JSON.stringify(i.map(o => o.payload)).length > W(this, G1).batchMaxSize) {
                    r.unshift(i.pop());
                    break
                }(async () => {
                    const s = i.length === 1 ? i[0].payload : i.map(o => o.payload);
                    this.emit("debug", {
                        action: "sendRpcPayload",
                        payload: s
                    });
                    try {
                        const o = await this._send(s);
                        this.emit("debug", {
                            action: "receiveRpcResult",
                            result: o
                        });
                        for (const {
                                resolve: a,
                                reject: l,
                                payload: c
                            } of i) {
                            if (this.destroyed) {
                                l(pi("provider destroyed; cancelled request", "UNSUPPORTED_OPERATION", {
                                    operation: c.method
                                }));
                                continue
                            }
                            const u = o.filter(f => f.id === c.id)[0];
                            if (u == null) {
                                const f = pi("missing response for request", "BAD_DATA", {
                                    value: o,
                                    info: {
                                        payload: c
                                    }
                                });
                                this.emit("error", f), l(f);
                                continue
                            }
                            if ("error" in u) {
                                l(this.getRpcError(c, u));
                                continue
                            }
                            a(u.result)
                        }
                    } catch (o) {
                        this.emit("debug", {
                            action: "receiveRpcError",
                            error: o
                        });
                        for (const {
                                reject: a
                            } of i) a(o)
                    }
                })()
        }
    }, n))
};
var op;
class Uie extends Fie {
    constructor(n, r) {
        super(n, r);
        _e(this, op);
        let i = this._getOption("pollingInterval");
        i == null && (i = Bie.pollingInterval), le(this, op, i)
    }
    _getSubscriber(n) {
        const r = super._getSubscriber(n);
        return gq(r) && (r.pollingInterval = W(this, op)), r
    }
    get pollingInterval() {
        return W(this, op)
    }
    set pollingInterval(n) {
        if (!Number.isInteger(n) || n < 0) throw new Error("invalid interval");
        le(this, op, n), this._forEachSubscriber(r => {
            gq(r) && (r.pollingInterval = W(this, op))
        })
    }
}
op = new WeakMap;
var wb;
class HL extends Uie {
    constructor(n, r, i) {
        n == null && (n = "http://localhost:8545");
        super(r, i);
        _e(this, wb);
        typeof n == "string" ? le(this, wb, new od(n)) : le(this, wb, n.clone())
    }
    _getConnection() {
        return W(this, wb).clone()
    }
    async send(n, r) {
        return await this._start(), await super.send(n, r)
    }
    async _send(n) {
        const r = this._getConnection();
        r.body = JSON.stringify(n), r.setHeader("content-type", "application/json");
        const i = await r.send();
        i.assertOk();
        let s = i.bodyJson;
        return Array.isArray(s) || (s = [s]), s
    }
}
wb = new WeakMap;

function tM(t) {
    if (t == null) return null;
    if (typeof t.message == "string" && t.message.match(/revert/i) && Zr(t.data)) return {
        message: t.message,
        data: t.data
    };
    if (typeof t == "object") {
        for (const e in t) {
            const n = tM(t[e]);
            if (n) return n
        }
        return null
    }
    if (typeof t == "string") try {
        return tM(JSON.parse(t))
    } catch {}
    return null
}

function nM(t, e) {
    if (t != null) {
        if (typeof t.message == "string" && e.push(t.message), typeof t == "object")
            for (const n in t) nM(t[n], e);
        if (typeof t == "string") try {
            return nM(JSON.parse(t), e)
        } catch {}
    }
}

function fke(t) {
    const e = [];
    return nM(t, e), e
}

function dke() {
    if (typeof self < "u") return self;
    if (typeof window < "u") return window;
    if (typeof global < "u") return global;
    throw new Error("unable to locate global object")
}
const hke = dke().WebSocket;
var If, rE, ap, q1, lp;
class zL {
    constructor(e, n) {
        _e(this, If);
        _e(this, rE);
        _e(this, ap);
        _e(this, q1);
        _e(this, lp);
        le(this, If, e), le(this, rE, JSON.stringify(n)), le(this, ap, null), le(this, q1, null), le(this, lp, null)
    }
    get filter() {
        return JSON.parse(W(this, rE))
    }
    start() {
        le(this, ap, W(this, If).send("eth_subscribe", this.filter).then(e => (W(this, If)._register(e, this), e)))
    }
    stop() {
        W(this, ap).then(e => {
            W(this, If).destroyed || W(this, If).send("eth_unsubscribe", [e])
        }), le(this, ap, null)
    }
    pause(e) {
        je(e, "preserve logs while paused not supported by SocketSubscriber yet", "UNSUPPORTED_OPERATION", {
            operation: "pause(false)"
        }), le(this, q1, !!e)
    }
    resume() {
        le(this, q1, null)
    }
    _handleMessage(e) {
        if (W(this, ap) != null && W(this, q1) === null) {
            let n = W(this, lp);
            n == null ? n = this._emit(W(this, If), e) : n = n.then(async () => {
                await this._emit(W(this, If), e)
            }), le(this, lp, n.then(() => {
                W(this, lp) === n && le(this, lp, null)
            }))
        }
    }
    async _emit(e, n) {
        throw new Error("sub-classes must implemente this; _emit")
    }
}
If = new WeakMap, rE = new WeakMap, ap = new WeakMap, q1 = new WeakMap, lp = new WeakMap;
class pke extends zL {
    constructor(e) {
        super(e, ["newHeads"])
    }
    async _emit(e, n) {
        e.emit("block", parseInt(n.number))
    }
}
class gke extends zL {
    constructor(e) {
        super(e, ["newPendingTransactions"])
    }
    async _emit(e, n) {
        e.emit("pending", n)
    }
}
var iE;
class mke extends zL {
    constructor(n, r) {
        super(n, ["logs", r]);
        _e(this, iE);
        le(this, iE, JSON.stringify(r))
    }
    get logFilter() {
        return JSON.parse(W(this, iE))
    }
    async _emit(n, r) {
        n.emit(this.logFilter, n._wrapLog(r, n._network))
    }
}
iE = new WeakMap;
var K1, vb, cp;
class yke extends Fie {
    constructor(n, r) {
        const i = Object.assign({}, r ? ? {});
        Ee(i.batchMaxCount == null || i.batchMaxCount === 1, "sockets-based providers do not support batches", "options.batchMaxCount", r), i.batchMaxCount = 1, i.staticNetwork == null && (i.staticNetwork = !0);
        super(n, i);
        _e(this, K1);
        _e(this, vb);
        _e(this, cp);
        le(this, K1, new Map), le(this, vb, new Map), le(this, cp, new Map)
    }
    _getSubscriber(n) {
        switch (n.type) {
            case "close":
                return new WC("close");
            case "block":
                return new pke(this);
            case "pending":
                return new gke(this);
            case "event":
                return new mke(this, n.filter);
            case "orphan":
                if (n.filter.orphan === "drop-log") return new WC("drop-log")
        }
        return super._getSubscriber(n)
    }
    _register(n, r) {
        W(this, vb).set(n, r);
        const i = W(this, cp).get(n);
        if (i) {
            for (const s of i) r._handleMessage(s);
            W(this, cp).delete(n)
        }
    }
    async _send(n) {
        Ee(!Array.isArray(n), "WebSocket does not support batch send", "payload", n);
        const r = new Promise((i, s) => {
            W(this, K1).set(n.id, {
                payload: n,
                resolve: i,
                reject: s
            })
        });
        return await this._waitUntilReady(), await this._write(JSON.stringify(n)), [await r]
    }
    async _processMessage(n) {
        const r = JSON.parse(n);
        if (r && typeof r == "object" && "id" in r) {
            const i = W(this, K1).get(r.id);
            if (i == null) {
                this.emit("error", pi("received result for unknown id", "UNKNOWN_ERROR", {
                    reasonCode: "UNKNOWN_ID",
                    result: r
                }));
                return
            }
            W(this, K1).delete(r.id), i.resolve(r)
        } else if (r && r.method === "eth_subscription") {
            const i = r.params.subscription,
                s = W(this, vb).get(i);
            if (s) s._handleMessage(r.params.result);
            else {
                let o = W(this, cp).get(i);
                o == null && (o = [], W(this, cp).set(i, o)), o.push(r.params.result)
            }
        } else {
            this.emit("error", pi("received unexpected message", "UNKNOWN_ERROR", {
                reasonCode: "UNEXPECTED_MESSAGE",
                result: r
            }));
            return
        }
    }
    async _write(n) {
        throw new Error("sub-classes must override this")
    }
}
K1 = new WeakMap, vb = new WeakMap, cp = new WeakMap;
var Y1, du;
class jie extends yke {
    constructor(n, r, i) {
        super(r, i);
        _e(this, Y1);
        _e(this, du);
        typeof n == "string" ? (le(this, Y1, () => new hke(n)), le(this, du, W(this, Y1).call(this))) : typeof n == "function" ? (le(this, Y1, n), le(this, du, n())) : (le(this, Y1, null), le(this, du, n)), this.websocket.onopen = async () => {
            try {
                await this._start(), this.resume()
            } catch (s) {
                console.log("failed to start WebsocketProvider", s)
            }
        }, this.websocket.onmessage = s => {
            this._processMessage(s.data)
        }
    }
    get websocket() {
        if (W(this, du) == null) throw new Error("websocket closed");
        return W(this, du)
    }
    async _write(n) {
        this.websocket.send(n)
    }
    async destroy() {
        W(this, du) != null && (W(this, du).close(), le(this, du, null)), super.destroy()
    }
}
Y1 = new WeakMap, du = new WeakMap;
const I3 = "84842078b09946638c03157f83405213";

function wke(t) {
    switch (t) {
        case "mainnet":
            return "mainnet.infura.io";
        case "goerli":
            return "goerli.infura.io";
        case "sepolia":
            return "sepolia.infura.io";
        case "arbitrum":
            return "arbitrum-mainnet.infura.io";
        case "arbitrum-goerli":
            return "arbitrum-goerli.infura.io";
        case "arbitrum-sepolia":
            return "arbitrum-sepolia.infura.io";
        case "base":
            return "base-mainnet.infura.io";
        case "base-goerlia":
            return "base-goerli.infura.io";
        case "base-sepolia":
            return "base-sepolia.infura.io";
        case "bnb":
            return "bnbsmartchain-mainnet.infura.io";
        case "bnbt":
            return "bnbsmartchain-testnet.infura.io";
        case "linea":
            return "linea-mainnet.infura.io";
        case "linea-goerli":
            return "linea-goerli.infura.io";
        case "linea-sepolia":
            return "linea-sepolia.infura.io";
        case "matic":
            return "polygon-mainnet.infura.io";
        case "matic-amoy":
            return "polygon-amoy.infura.io";
        case "matic-mumbai":
            return "polygon-mumbai.infura.io";
        case "optimism":
            return "optimism-mainnet.infura.io";
        case "optimism-goerli":
            return "optimism-goerli.infura.io";
        case "optimism-sepolia":
            return "optimism-sepolia.infura.io"
    }
    Ee(!1, "unsupported network", "network", t)
}
class vke extends jie {
    constructor(n, r) {
        const i = new i6(n, r),
            s = i._getConnection();
        je(!s.credentials, "INFURA WebSocket project secrets unsupported", "UNSUPPORTED_OPERATION", {
            operation: "InfuraProvider.getWebSocketProvider()"
        });
        const o = s.url.replace(/^http/i, "ws").replace("/v3/", "/ws/v3/");
        super(o, i._network);
        Ie(this, "projectId");
        Ie(this, "projectSecret");
        Xt(this, {
            projectId: i.projectId,
            projectSecret: i.projectSecret
        })
    }
    isCommunityResource() {
        return this.projectId === I3
    }
}
class i6 extends HL {
    constructor(n, r, i) {
        n == null && (n = "mainnet");
        const s = bu.from(n);
        r == null && (r = I3), i == null && (i = null);
        const o = i6.getRequest(s, r, i);
        super(o, s, {
            staticNetwork: s
        });
        Ie(this, "projectId");
        Ie(this, "projectSecret");
        Xt(this, {
            projectId: r,
            projectSecret: i
        })
    }
    _getProvider(n) {
        try {
            return new i6(n, this.projectId, this.projectSecret)
        } catch {}
        return super._getProvider(n)
    }
    isCommunityResource() {
        return this.projectId === I3
    }
    static getWebSocketProvider(n, r) {
        return new vke(n, r)
    }
    static getRequest(n, r, i) {
        r == null && (r = I3), i == null && (i = null);
        const s = new od(`https://${wke(n.name)}/v3/${r}`);
        return s.allowGzip = !0, i && s.setCredentials("", i), r === I3 && (s.retryFunc = async (o, a, l) => (ske("InfuraProvider"), !0)), s
    }
}
var bb;
class Kf extends Uie {
    constructor(n, r, i) {
        const s = Object.assign({}, i ? ? {}, {
            batchMaxCount: 1
        });
        Ee(n && n.request, "invalid EIP-1193 provider", "ethereum", n);
        super(r, s);
        _e(this, bb);
        le(this, bb, async (o, a) => {
            const l = {
                method: o,
                params: a
            };
            this.emit("debug", {
                action: "sendEip1193Request",
                payload: l
            });
            try {
                const c = await n.request(l);
                return this.emit("debug", {
                    action: "receiveEip1193Result",
                    result: c
                }), c
            } catch (c) {
                const u = new Error(c.message);
                throw u.code = c.code, u.data = c.data, u.payload = l, this.emit("debug", {
                    action: "receiveEip1193Error",
                    error: u
                }), u
            }
        })
    }
    async send(n, r) {
        return await this._start(), await super.send(n, r)
    }
    async _send(n) {
        Ee(!Array.isArray(n), "EIP-1193 does not support batch request", "payload", n);
        try {
            const r = await W(this, bb).call(this, n.method, n.params || []);
            return [{
                id: n.id,
                result: r
            }]
        } catch (r) {
            return [{
                id: n.id,
                error: {
                    code: r.code,
                    data: r.data,
                    message: r.message
                }
            }]
        }
    }
    getRpcError(n, r) {
        switch (r = JSON.parse(JSON.stringify(r)), r.error.code || -1) {
            case 4001:
                r.error.message = `ethers-user-denied: ${r.error.message}`;
                break;
            case 4200:
                r.error.message = `ethers-unsupported: ${r.error.message}`;
                break
        }
        return super.getRpcError(n, r)
    }
    async hasSigner(n) {
        n == null && (n = 0);
        const r = await this.send("eth_accounts", []);
        return typeof n == "number" ? r.length > n : (n = n.toLowerCase(), r.filter(i => i.toLowerCase() === n).length !== 0)
    }
    async getSigner(n) {
        if (n == null && (n = 0), !await this.hasSigner(n)) try {
            await W(this, bb).call(this, "eth_requestAccounts", [])
        } catch (r) {
            const i = r.payload;
            throw this.getRpcError(i, {
                id: i.id,
                error: r
            })
        }
        return await super.getSigner(n)
    }
}
bb = new WeakMap;
const lr = {
        WALLET_ID: "@w3m/wallet_id",
        ERROR_CODE_UNRECOGNIZED_CHAIN_ID: 4902,
        ERROR_CODE_DEFAULT: 5e3
    },
    js = {
        getCaipDefaultChain(t) {
            if (t) return {
                id: `${yt.EIP155}:${t.chainId}`,
                name: t.name,
                imageId: xo.EIP155NetworkImageIds[t.chainId]
            }
        },
        hexStringToNumber(t) {
            const e = t.startsWith("0x") ? t.slice(2) : t;
            return parseInt(e, 16)
        },
        numberToHexString(t) {
            return `0x${t.toString(16)}`
        },
        async getUserInfo(t) {
            const [e, n] = await Promise.all([js.getAddress(t), js.getChainId(t)]);
            return {
                chainId: n,
                address: e
            }
        },
        async getChainId(t) {
            const e = await t.request({
                method: "eth_chainId"
            });
            return Number(e)
        },
        async getAddress(t) {
            const [e] = await t.request({
                method: "eth_accounts"
            });
            return e
        },
        async addEthereumChain(t, e) {
            await t.request({
                method: "wallet_addEthereumChain",
                params: [{
                    chainId: js.numberToHexString(e.chainId),
                    rpcUrls: [e.rpcUrl],
                    chainName: e.name,
                    nativeCurrency: {
                        name: e.currency,
                        decimals: 18,
                        symbol: e.currency
                    },
                    blockExplorerUrls: [e.explorerUrl],
                    iconUrls: [xo.EIP155NetworkImageIds[e.chainId]]
                }]
            })
        }
    },
    wo = Fo({
        provider: void 0,
        providerType: void 0,
        address: void 0,
        chainId: void 0,
        isConnected: !1
    }),
    ht = {
        state: wo,
        subscribeKey(t, e) {
            return Dc(wo, t, e)
        },
        subscribe(t) {
            return Uu(wo, () => t(wo))
        },
        setProvider(t) {
            t && (wo.provider = Eb(t))
        },
        setProviderType(t) {
            wo.providerType = t
        },
        setAddress(t) {
            wo.address = t
        },
        setChainId(t) {
            wo.chainId = t
        },
        setIsConnected(t) {
            wo.isConnected = t
        },
        setError(t) {
            wo.error = t
        },
        reset() {
            wo.provider = void 0, wo.address = void 0, wo.chainId = void 0, wo.providerType = void 0, wo.isConnected = !1, wo.error = void 0
        }
    };
class bke extends SEe {
    constructor(e) {
        const {
            ethersConfig: n,
            siweConfig: r,
            chains: i,
            defaultChain: s,
            tokens: o,
            chainImages: a,
            _sdkVersion: l,
            ...c
        } = e;
        if (!n) throw new Error("web3modal:constructor - ethersConfig is undefined");
        if (!c.projectId) throw new Error("web3modal:constructor - projectId is undefined");
        const u = {
                switchCaipNetwork: async h => {
                    const g = $x.caipNetworkIdToNumber(h == null ? void 0 : h.id);
                    if (g) try {
                        await this.switchNetwork(g)
                    } catch (y) {
                        ht.setError(y)
                    }
                },
                getApprovedCaipNetworksData: async () => new Promise(async h => {
                    var y, _, C, b;
                    const g = localStorage.getItem(lr.WALLET_ID);
                    if (g != null && g.includes(yt.WALLET_CONNECT_CONNECTOR_ID)) {
                        const w = await this.getWalletConnectProvider();
                        if (!w) throw new Error("networkControllerClient:getApprovedCaipNetworks - connector is undefined");
                        const S = (_ = (y = w.signer) == null ? void 0 : y.session) == null ? void 0 : _.namespaces,
                            I = (C = S == null ? void 0 : S[yt.EIP155]) == null ? void 0 : C.methods,
                            P = (b = S == null ? void 0 : S[yt.EIP155]) == null ? void 0 : b.chains,
                            M = {
                                supportsAllNetworks: (I == null ? void 0 : I.includes(yt.ADD_CHAIN_METHOD)) ? ? !1,
                                approvedCaipNetworkIds: P
                            };
                        h(M)
                    } else h({
                        approvedCaipNetworkIds: void 0,
                        supportsAllNetworks: !0
                    })
                })
            },
            f = {
                connectWalletConnect: async h => {
                    const g = await this.getWalletConnectProvider();
                    if (!g) throw new Error("connectionControllerClient:getWalletConnectUri - provider is undefined");
                    g.on("display_uri", y => {
                        h(y)
                    }), await g.connect(), await this.setWalletConnectProvider()
                },
                connectExternal: async ({
                    id: h,
                    info: g,
                    provider: y
                }) => {
                    if (h === yt.INJECTED_CONNECTOR_ID) {
                        const _ = n.injected;
                        if (!_) throw new Error("connectionControllerClient:connectInjected - provider is undefined");
                        try {
                            await _.request({
                                method: "eth_requestAccounts"
                            }), this.setInjectedProvider(n)
                        } catch (C) {
                            ht.setError(C)
                        }
                    } else if (h === yt.EIP6963_CONNECTOR_ID && g && y) try {
                        await y.request({
                            method: "eth_requestAccounts"
                        }), this.setEIP6963Provider(y, g.name)
                    } catch (_) {
                        ht.setError(_)
                    } else if (h === yt.COINBASE_CONNECTOR_ID) {
                        const _ = n.coinbase;
                        if (!_) throw new Error("connectionControllerClient:connectCoinbase - connector is undefined");
                        try {
                            await _.request({
                                method: "eth_requestAccounts"
                            }), this.setCoinbaseProvider(n)
                        } catch (C) {
                            ht.setError(C)
                        }
                    } else h === yt.EMAIL_CONNECTOR_ID && this.setEmailProvider()
                },
                checkInstalled(h) {
                    return h ? n.injected && !(window != null && window.ethereum) ? !1 : h.some(g => {
                        var y;
                        return !!((y = window.ethereum) != null && y[String(g)])
                    }) : !!window.ethereum
                },
                disconnect: async () => {
                    var y, _;
                    const h = ht.state.provider,
                        g = ht.state.providerType;
                    localStorage.removeItem(lr.WALLET_ID), ht.reset(), (y = r == null ? void 0 : r.options) != null && y.signOutOnDisconnect && await r.signOut(), g === yt.WALLET_CONNECT_CONNECTOR_ID ? (await h.disconnect(), h == null || h.emit("disconnect")) : g !== yt.EMAIL_CONNECTOR_ID ? h == null || h.emit("disconnect") : (_ = this.emailProvider) == null || _.disconnect(), h == null || h.emit("disconnect")
                },
                signMessage: async h => {
                    const g = ht.state.provider;
                    if (!g) throw new Error("connectionControllerClient:signMessage - provider is undefined");
                    return await g.request({
                        method: "personal_sign",
                        params: [h, this.getAddress()]
                    })
                }
            };
        super({
            networkControllerClient: u,
            connectionControllerClient: f,
            siweControllerClient: r,
            defaultChain: js.getCaipDefaultChain(s),
            tokens: $x.getCaipTokens(o),
            _sdkVersion: l ? ? `html-ethers-${yt.VERSION}`,
            ...c
        }), this.hasSyncedConnectedAccount = !1, this.EIP6963Providers = [], this.options = void 0, this.options = e, this.metadata = n.metadata, this.projectId = c.projectId, this.chains = i, this.createProvider(), ht.subscribeKey("address", () => {
            this.syncAccount()
        }), ht.subscribeKey("chainId", () => {
            this.syncNetwork(a)
        }), this.syncRequestedNetworks(i, a), this.syncConnectors(n), n.EIP6963 && typeof window < "u" && (this.listenConnectors(n.EIP6963), this.checkActive6963Provider()), n.email && this.syncEmailConnector(c.projectId), n.injected && this.checkActiveInjectedProvider(n), n.coinbase && this.checkActiveCoinbaseProvider(n)
    }
    getState() {
        const e = super.getState();
        return { ...e,
            selectedNetworkId: $x.caipNetworkIdToNumber(e.selectedNetworkId)
        }
    }
    subscribeState(e) {
        return super.subscribeState(n => e({ ...n,
            selectedNetworkId: $x.caipNetworkIdToNumber(n.selectedNetworkId)
        }))
    }
    setAddress(e) {
        const n = e ? Hn(e) : void 0;
        ht.setAddress(n)
    }
    getAddress() {
        const {
            address: e
        } = ht.state;
        return e ? Hn(e) : void 0
    }
    getError() {
        return ht.state.error
    }
    getChainId() {
        return ht.state.chainId
    }
    getIsConnected() {
        return ht.state.isConnected
    }
    getWalletProvider() {
        return ht.state.provider
    }
    getWalletProviderType() {
        return ht.state.providerType
    }
    subscribeProvider(e) {
        return ht.subscribe(e)
    }
    async disconnect() {
        const {
            provider: e,
            providerType: n
        } = ht.state;
        if (localStorage.removeItem(lr.WALLET_ID), ht.reset(), n === "injected" || n === "eip6963") e == null || e.emit("disconnect");
        else {
            const r = e;
            if (r) try {
                await r.disconnect()
            } catch (i) {
                ht.setError(i)
            }
        }
    }
    createProvider() {
        return !this.walletConnectProviderInitPromise && typeof window < "u" && (this.walletConnectProviderInitPromise = this.initWalletConnectProvider()), this.walletConnectProviderInitPromise
    }
    async initWalletConnectProvider() {
        const e = {
            projectId: this.projectId,
            showQrModal: !1,
            rpcMap: this.chains ? this.chains.reduce((n, r) => (n[r.chainId] = r.rpcUrl, n), {}) : {},
            optionalChains: [...this.chains.map(n => n.chainId)],
            metadata: {
                name: this.metadata ? this.metadata.name : "",
                description: this.metadata ? this.metadata.description : "",
                url: this.metadata ? this.metadata.url : "",
                icons: this.metadata ? this.metadata.icons : [""]
            }
        };
        this.walletConnectProvider = await PIe.init(e), await this.checkActiveWalletConnectProvider()
    }
    async getWalletConnectProvider() {
        if (!this.walletConnectProvider) try {
            await this.createProvider()
        } catch (e) {
            ht.setError(e)
        }
        return this.walletConnectProvider
    }
    syncRequestedNetworks(e, n) {
        const r = e == null ? void 0 : e.map(i => ({
            id: `${yt.EIP155}:${i.chainId}`,
            name: i.name,
            imageId: xo.EIP155NetworkImageIds[i.chainId],
            imageUrl: n == null ? void 0 : n[i.chainId]
        }));
        this.setRequestedCaipNetworks(r ? ? [])
    }
    async checkActiveWalletConnectProvider() {
        const e = await this.getWalletConnectProvider(),
            n = localStorage.getItem(lr.WALLET_ID);
        e && n === yt.WALLET_CONNECT_CONNECTOR_ID && await this.setWalletConnectProvider()
    }
    checkActiveInjectedProvider(e) {
        const n = e.injected,
            r = localStorage.getItem(lr.WALLET_ID);
        n && r === yt.INJECTED_CONNECTOR_ID && (this.setInjectedProvider(e), this.watchInjected(e))
    }
    checkActiveCoinbaseProvider(e) {
        var i;
        const n = e.coinbase,
            r = localStorage.getItem(lr.WALLET_ID);
        n && r === yt.COINBASE_CONNECTOR_ID && (n._addresses && ((i = n._addresses) == null ? void 0 : i.length) > 0 ? (this.setCoinbaseProvider(e), this.watchCoinbase(e)) : (localStorage.removeItem(lr.WALLET_ID), ht.reset()))
    }
    checkActive6963Provider() {
        const e = window == null ? void 0 : window.localStorage.getItem(lr.WALLET_ID);
        if (e) {
            const n = this.EIP6963Providers.find(r => r.name === e);
            n && this.setEIP6963Provider(n.provider, n.name)
        }
    }
    async setWalletConnectProvider() {
        var n;
        window == null || window.localStorage.setItem(lr.WALLET_ID, yt.WALLET_CONNECT_CONNECTOR_ID);
        const e = await this.getWalletConnectProvider();
        e && (ht.setChainId(e.chainId), ht.setProviderType("walletConnect"), ht.setProvider(e), ht.setIsConnected(!0), this.setAddress((n = e.accounts) == null ? void 0 : n[0]), this.watchWalletConnect())
    }
    async setInjectedProvider(e) {
        window == null || window.localStorage.setItem(lr.WALLET_ID, yt.INJECTED_CONNECTOR_ID);
        const n = e.injected;
        if (n) {
            const {
                address: r,
                chainId: i
            } = await js.getUserInfo(n);
            r && i && (ht.setChainId(i), ht.setProviderType("injected"), ht.setProvider(e.injected), ht.setIsConnected(!0), this.setAddress(r), this.watchCoinbase(e))
        }
    }
    async setEIP6963Provider(e, n) {
        if (window == null || window.localStorage.setItem(lr.WALLET_ID, n), e) {
            const {
                address: r,
                chainId: i
            } = await js.getUserInfo(e);
            r && i && (ht.setChainId(i), ht.setProviderType("eip6963"), ht.setProvider(e), ht.setIsConnected(!0), this.setAddress(r), this.watchEIP6963(e))
        }
    }
    async setCoinbaseProvider(e) {
        window == null || window.localStorage.setItem(lr.WALLET_ID, yt.COINBASE_CONNECTOR_ID);
        const n = e.coinbase;
        if (n) {
            const {
                address: r,
                chainId: i
            } = await js.getUserInfo(n);
            r && i && (ht.setChainId(i), ht.setProviderType("coinbaseWallet"), ht.setProvider(e.coinbase), ht.setIsConnected(!0), this.setAddress(r), this.watchCoinbase(e))
        }
    }
    async setEmailProvider() {
        if (window == null || window.localStorage.setItem(lr.WALLET_ID, yt.EMAIL_CONNECTOR_ID), this.emailProvider) {
            const {
                address: e,
                chainId: n
            } = await this.emailProvider.connect();
            super.setLoading(!1), e && n && (ht.setChainId(n), ht.setProviderType(yt.EMAIL_CONNECTOR_ID), ht.setProvider(this.emailProvider), ht.setIsConnected(!0), ht.setAddress(e), this.watchEmail())
        }
    }
    async watchWalletConnect() {
        const e = await this.getWalletConnectProvider();

        function n() {
            localStorage.removeItem(lr.WALLET_ID), ht.reset(), e == null || e.removeListener("disconnect", n), e == null || e.removeListener("accountsChanged", i), e == null || e.removeListener("chainChanged", r)
        }

        function r(s) {
            if (s) {
                const o = js.hexStringToNumber(s);
                ht.setChainId(o)
            }
        }
        const i = async s => {
            s.length > 0 && await this.setWalletConnectProvider()
        };
        e && (e.on("disconnect", n), e.on("accountsChanged", i), e.on("chainChanged", r))
    }
    watchInjected(e) {
        const n = e.injected;

        function r() {
            localStorage.removeItem(lr.WALLET_ID), ht.reset(), n == null || n.removeListener("disconnect", r), n == null || n.removeListener("accountsChanged", i), n == null || n.removeListener("chainChanged", s)
        }

        function i(o) {
            const a = o == null ? void 0 : o[0];
            a ? ht.setAddress(Hn(a)) : (localStorage.removeItem(lr.WALLET_ID), ht.reset())
        }

        function s(o) {
            if (o) {
                const a = typeof o == "string" ? js.hexStringToNumber(o) : Number(o);
                ht.setChainId(a)
            }
        }
        n && (n.on("disconnect", r), n.on("accountsChanged", i), n.on("chainChanged", s))
    }
    watchEIP6963(e) {
        function n() {
            localStorage.removeItem(lr.WALLET_ID), ht.reset(), e.removeListener("disconnect", n), e.removeListener("accountsChanged", r), e.removeListener("chainChanged", i)
        }

        function r(s) {
            const o = s == null ? void 0 : s[0];
            o ? ht.setAddress(Hn(o)) : (localStorage.removeItem(lr.WALLET_ID), ht.reset())
        }

        function i(s) {
            if (s) {
                const o = typeof s == "string" ? js.hexStringToNumber(s) : Number(s);
                ht.setChainId(o)
            }
        }
        e && (e.on("disconnect", n), e.on("accountsChanged", r), e.on("chainChanged", i))
    }
    watchCoinbase(e) {
        const n = e.coinbase,
            r = localStorage.getItem(lr.WALLET_ID);

        function i() {
            localStorage.removeItem(lr.WALLET_ID), ht.reset(), n == null || n.removeListener("disconnect", i), n == null || n.removeListener("accountsChanged", s), n == null || n.removeListener("chainChanged", o)
        }

        function s(a) {
            const l = a == null ? void 0 : a[0];
            l ? ht.setAddress(Hn(l)) : (localStorage.removeItem(lr.WALLET_ID), ht.reset())
        }

        function o(a) {
            if (a && r === yt.COINBASE_CONNECTOR_ID) {
                const l = Number(a);
                ht.setChainId(l)
            }
        }
        n && (n.on("disconnect", i), n.on("accountsChanged", s), n.on("chainChanged", o))
    }
    watchEmail() {
        this.emailProvider && (this.emailProvider.onRpcRequest(e => {
            const r = e.payload;
            ite.SAFE_RPC_METHODS.includes(r.method) || super.open({
                view: "ApproveTransaction"
            })
        }), this.emailProvider.onRpcResponse(() => {
            super.close()
        }), this.emailProvider.onIsConnected(() => {
            super.setLoading(!1)
        }))
    }
    async syncAccount() {
        const e = ht.state.address,
            n = ht.state.chainId,
            r = ht.state.isConnected;
        if (this.resetAccount(), r && e && n) {
            const i = `${yt.EIP155}:${n}:${e}`;
            this.setIsConnected(r), this.setCaipAddress(i), await Promise.all([this.syncProfile(e), this.syncBalance(e), this.getApprovedCaipNetworksData()]), this.hasSyncedConnectedAccount = !0
        } else !r && this.hasSyncedConnectedAccount && (this.resetWcConnection(), this.resetNetwork())
    }
    async syncNetwork(e) {
        const n = ht.state.address,
            r = ht.state.chainId,
            i = ht.state.isConnected;
        if (this.chains) {
            const s = this.chains.find(o => o.chainId === r);
            if (s) {
                const o = `${yt.EIP155}:${s.chainId}`;
                if (this.setCaipNetwork({
                        id: o,
                        name: s.name,
                        imageId: xo.EIP155NetworkImageIds[s.chainId],
                        imageUrl: e == null ? void 0 : e[s.chainId]
                    }), i && n) {
                    const a = `${yt.EIP155}:${r}:${n}`;
                    if (this.setCaipAddress(a), s.explorerUrl) {
                        const l = `${s.explorerUrl}/address/${n}`;
                        this.setAddressExplorerUrl(l)
                    } else this.setAddressExplorerUrl(void 0);
                    this.hasSyncedConnectedAccount && (await this.syncProfile(n), await this.syncBalance(n))
                }
            }
        }
    }
    async syncProfile(e) {
        if (ht.state.chainId === 1) {
            const r = new i6("mainnet"),
                i = await r.lookupAddress(e),
                s = await r.getAvatar(e);
            i && this.setProfileName(i), s && this.setProfileImage(s)
        } else this.setProfileName(null), this.setProfileImage(null)
    }
    async syncBalance(e) {
        const n = ht.state.chainId;
        if (n && this.chains) {
            const r = this.chains.find(i => i.chainId === n);
            if (r) {
                const i = new HL(r.rpcUrl, {
                    chainId: n,
                    name: r.name
                });
                if (i) {
                    const s = await i.getBalance(e),
                        o = rRe(s);
                    this.setBalance(o, r.currency)
                }
            }
        }
    }
    async switchNetwork(e) {
        var i, s, o, a, l, c, u, f, h;
        const n = ht.state.provider,
            r = ht.state.providerType;
        if (this.chains) {
            const g = this.chains.find(y => y.chainId === e);
            if (r === yt.WALLET_CONNECT_CONNECTOR_ID && g) {
                const y = n;
                if (y) try {
                    await y.request({
                        method: "wallet_switchEthereumChain",
                        params: [{
                            chainId: js.numberToHexString(g.chainId)
                        }]
                    }), ht.setChainId(e)
                } catch (_) {
                    if (_.code === lr.ERROR_CODE_UNRECOGNIZED_CHAIN_ID || _.code === lr.ERROR_CODE_DEFAULT || ((s = (i = _ == null ? void 0 : _.data) == null ? void 0 : i.originalError) == null ? void 0 : s.code) === lr.ERROR_CODE_UNRECOGNIZED_CHAIN_ID) await js.addEthereumChain(y, g);
                    else throw new Error("Chain is not supported")
                }
            } else if (r === yt.INJECTED_CONNECTOR_ID && g) {
                const y = n;
                if (y) try {
                    await y.request({
                        method: "wallet_switchEthereumChain",
                        params: [{
                            chainId: js.numberToHexString(g.chainId)
                        }]
                    }), ht.setChainId(g.chainId)
                } catch (_) {
                    if (_.code === lr.ERROR_CODE_UNRECOGNIZED_CHAIN_ID || _.code === lr.ERROR_CODE_DEFAULT || ((a = (o = _ == null ? void 0 : _.data) == null ? void 0 : o.originalError) == null ? void 0 : a.code) === lr.ERROR_CODE_UNRECOGNIZED_CHAIN_ID) await js.addEthereumChain(y, g);
                    else throw new Error("Chain is not supported")
                }
            } else if (r === yt.EIP6963_CONNECTOR_ID && g) {
                const y = n;
                if (y) try {
                    await y.request({
                        method: "wallet_switchEthereumChain",
                        params: [{
                            chainId: js.numberToHexString(g.chainId)
                        }]
                    }), ht.setChainId(g.chainId)
                } catch (_) {
                    if (_.code === lr.ERROR_CODE_UNRECOGNIZED_CHAIN_ID || _.code === lr.ERROR_CODE_DEFAULT || ((c = (l = _ == null ? void 0 : _.data) == null ? void 0 : l.originalError) == null ? void 0 : c.code) === lr.ERROR_CODE_UNRECOGNIZED_CHAIN_ID) await js.addEthereumChain(y, g);
                    else throw new Error("Chain is not supported")
                }
            } else if (r === yt.COINBASE_CONNECTOR_ID && g) {
                const y = n;
                if (y) try {
                    await y.request({
                        method: "wallet_switchEthereumChain",
                        params: [{
                            chainId: js.numberToHexString(g.chainId)
                        }]
                    }), ht.setChainId(g.chainId)
                } catch (_) {
                    (_.code === lr.ERROR_CODE_UNRECOGNIZED_CHAIN_ID || _.code === lr.ERROR_CODE_DEFAULT || ((f = (u = _ == null ? void 0 : _.data) == null ? void 0 : u.originalError) == null ? void 0 : f.code) === lr.ERROR_CODE_UNRECOGNIZED_CHAIN_ID) && await js.addEthereumChain(y, g)
                }
            } else if (r === yt.EMAIL_CONNECTOR_ID && this.emailProvider && g != null && g.chainId) try {
                await ((h = this.emailProvider) == null ? void 0 : h.switchNetwork(g == null ? void 0 : g.chainId)), ht.setChainId(g.chainId)
            } catch {
                throw new Error("Switching chain failed")
            }
        }
    }
    syncConnectors(e) {
        var i, s, o, a, l, c;
        const n = [],
            r = xo.ConnectorTypesMap[yt.WALLET_CONNECT_CONNECTOR_ID];
        if (n.push({
                id: yt.WALLET_CONNECT_CONNECTOR_ID,
                explorerId: xo.ConnectorExplorerIds[yt.WALLET_CONNECT_CONNECTOR_ID],
                imageId: xo.ConnectorImageIds[yt.WALLET_CONNECT_CONNECTOR_ID],
                imageUrl: (s = (i = this.options) == null ? void 0 : i.connectorImages) == null ? void 0 : s[yt.WALLET_CONNECT_CONNECTOR_ID],
                name: xo.ConnectorNamesMap[yt.WALLET_CONNECT_CONNECTOR_ID],
                type: r
            }), e.injected) {
            const u = xo.ConnectorTypesMap[yt.INJECTED_CONNECTOR_ID];
            n.push({
                id: yt.INJECTED_CONNECTOR_ID,
                explorerId: xo.ConnectorExplorerIds[yt.INJECTED_CONNECTOR_ID],
                imageId: xo.ConnectorImageIds[yt.INJECTED_CONNECTOR_ID],
                imageUrl: (a = (o = this.options) == null ? void 0 : o.connectorImages) == null ? void 0 : a[yt.INJECTED_CONNECTOR_ID],
                name: xo.ConnectorNamesMap[yt.INJECTED_CONNECTOR_ID],
                type: u
            })
        }
        e.coinbase && n.push({
            id: yt.COINBASE_CONNECTOR_ID,
            explorerId: xo.ConnectorExplorerIds[yt.COINBASE_CONNECTOR_ID],
            imageId: xo.ConnectorImageIds[yt.COINBASE_CONNECTOR_ID],
            imageUrl: (c = (l = this.options) == null ? void 0 : l.connectorImages) == null ? void 0 : c[yt.COINBASE_CONNECTOR_ID],
            name: xo.ConnectorNamesMap[yt.COINBASE_CONNECTOR_ID],
            type: "EXTERNAL"
        }), this.setConnectors(n)
    }
    async syncEmailConnector(e) {
        if (typeof window < "u") {
            this.emailProvider = new H6e(e), this.addConnector({
                id: yt.EMAIL_CONNECTOR_ID,
                type: "EMAIL",
                name: "Email",
                provider: this.emailProvider
            }), super.setLoading(!0);
            const n = this.emailProvider.getLoginEmailUsed();
            super.setLoading(n), await this.emailProvider.isConnected() ? this.setEmailProvider() : super.setLoading(!1)
        }
    }
    eip6963EventHandler(e) {
        var n, r;
        if (e.detail) {
            const {
                info: i,
                provider: s
            } = e.detail;
            if (!this.getConnectors().find(l => l.name === i.name)) {
                const l = xo.ConnectorTypesMap[yt.EIP6963_CONNECTOR_ID]; {
                    this.addConnector({
                        id: yt.EIP6963_CONNECTOR_ID,
                        type: l,
                        imageUrl: i.icon ? ? ((r = (n = this.options) == null ? void 0 : n.connectorImages) == null ? void 0 : r[yt.EIP6963_CONNECTOR_ID]),
                        name: i.name,
                        provider: s,
                        info: i
                    });
                    const c = {
                        name: i.name,
                        provider: s
                    };
                    this.EIP6963Providers.push(c)
                }
            }
        }
    }
    listenConnectors(e) {
        if (typeof window < "u" && e) {
            const n = this.eip6963EventHandler.bind(this);
            window.addEventListener(yt.EIP6963_ANNOUNCE_EVENT, n), window.dispatchEvent(new Event(yt.EIP6963_REQUEST_EVENT))
        }
    }
}
let b0;

function _ke(t) {
    t && (b0 = t)
}

function WL() {
    if (!b0) throw new Error('Please call "createWeb3Modal" before using "useWeb3Modal" hook');
    async function t(n) {
        await (b0 == null ? void 0 : b0.open(n))
    }
    async function e() {
        await (b0 == null ? void 0 : b0.close())
    }
    return {
        open: t,
        close: e
    }
}
var M2 = {},
    l9 = {};
l9.byteLength = Ske;
l9.toByteArray = Ake;
l9.fromByteArray = Rke;
var Mf = [],
    ac = [],
    Eke = typeof Uint8Array < "u" ? Uint8Array : Array,
    NO = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
for (var iw = 0, xke = NO.length; iw < xke; ++iw) Mf[iw] = NO[iw], ac[NO.charCodeAt(iw)] = iw;
ac[45] = 62;
ac[95] = 63;

function Hie(t) {
    var e = t.length;
    if (e % 4 > 0) throw new Error("Invalid string. Length must be a multiple of 4");
    var n = t.indexOf("=");
    n === -1 && (n = e);
    var r = n === e ? 0 : 4 - n % 4;
    return [n, r]
}

function Ske(t) {
    var e = Hie(t),
        n = e[0],
        r = e[1];
    return (n + r) * 3 / 4 - r
}

function Cke(t, e, n) {
    return (e + n) * 3 / 4 - n
}

function Ake(t) {
    var e, n = Hie(t),
        r = n[0],
        i = n[1],
        s = new Eke(Cke(t, r, i)),
        o = 0,
        a = i > 0 ? r - 4 : r,
        l;
    for (l = 0; l < a; l += 4) e = ac[t.charCodeAt(l)] << 18 | ac[t.charCodeAt(l + 1)] << 12 | ac[t.charCodeAt(l + 2)] << 6 | ac[t.charCodeAt(l + 3)], s[o++] = e >> 16 & 255, s[o++] = e >> 8 & 255, s[o++] = e & 255;
    return i === 2 && (e = ac[t.charCodeAt(l)] << 2 | ac[t.charCodeAt(l + 1)] >> 4, s[o++] = e & 255), i === 1 && (e = ac[t.charCodeAt(l)] << 10 | ac[t.charCodeAt(l + 1)] << 4 | ac[t.charCodeAt(l + 2)] >> 2, s[o++] = e >> 8 & 255, s[o++] = e & 255), s
}

function Tke(t) {
    return Mf[t >> 18 & 63] + Mf[t >> 12 & 63] + Mf[t >> 6 & 63] + Mf[t & 63]
}

function Ike(t, e, n) {
    for (var r, i = [], s = e; s < n; s += 3) r = (t[s] << 16 & 16711680) + (t[s + 1] << 8 & 65280) + (t[s + 2] & 255), i.push(Tke(r));
    return i.join("")
}

function Rke(t) {
    for (var e, n = t.length, r = n % 3, i = [], s = 16383, o = 0, a = n - r; o < a; o += s) i.push(Ike(t, o, o + s > a ? a : o + s));
    return r === 1 ? (e = t[n - 1], i.push(Mf[e >> 2] + Mf[e << 4 & 63] + "==")) : r === 2 && (e = (t[n - 2] << 8) + t[n - 1], i.push(Mf[e >> 10] + Mf[e >> 4 & 63] + Mf[e << 2 & 63] + "=")), i.join("")
}
var VL = {}; /*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
VL.read = function(t, e, n, r, i) {
    var s, o, a = i * 8 - r - 1,
        l = (1 << a) - 1,
        c = l >> 1,
        u = -7,
        f = n ? i - 1 : 0,
        h = n ? -1 : 1,
        g = t[e + f];
    for (f += h, s = g & (1 << -u) - 1, g >>= -u, u += a; u > 0; s = s * 256 + t[e + f], f += h, u -= 8);
    for (o = s & (1 << -u) - 1, s >>= -u, u += r; u > 0; o = o * 256 + t[e + f], f += h, u -= 8);
    if (s === 0) s = 1 - c;
    else {
        if (s === l) return o ? NaN : (g ? -1 : 1) * (1 / 0);
        o = o + Math.pow(2, r), s = s - c
    }
    return (g ? -1 : 1) * o * Math.pow(2, s - r)
};
VL.write = function(t, e, n, r, i, s) {
    var o, a, l, c = s * 8 - i - 1,
        u = (1 << c) - 1,
        f = u >> 1,
        h = i === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0,
        g = r ? 0 : s - 1,
        y = r ? 1 : -1,
        _ = e < 0 || e === 0 && 1 / e < 0 ? 1 : 0;
    for (e = Math.abs(e), isNaN(e) || e === 1 / 0 ? (a = isNaN(e) ? 1 : 0, o = u) : (o = Math.floor(Math.log(e) / Math.LN2), e * (l = Math.pow(2, -o)) < 1 && (o--, l *= 2), o + f >= 1 ? e += h / l : e += h * Math.pow(2, 1 - f), e * l >= 2 && (o++, l /= 2), o + f >= u ? (a = 0, o = u) : o + f >= 1 ? (a = (e * l - 1) * Math.pow(2, i), o = o + f) : (a = e * Math.pow(2, f - 1) * Math.pow(2, i), o = 0)); i >= 8; t[n + g] = a & 255, g += y, a /= 256, i -= 8);
    for (o = o << i | a, c += i; c > 0; t[n + g] = o & 255, g += y, o /= 256, c -= 8);
    t[n + g - y] |= _ * 128
};
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
(function(t) {
    const e = l9,
        n = VL,
        r = typeof Symbol == "function" && typeof Symbol.for == "function" ? Symbol.for("nodejs.util.inspect.custom") : null;
    t.Buffer = a, t.SlowBuffer = w, t.INSPECT_MAX_BYTES = 50;
    const i = 2147483647;
    t.kMaxLength = i, a.TYPED_ARRAY_SUPPORT = s(), !a.TYPED_ARRAY_SUPPORT && typeof console < "u" && typeof console.error == "function" && console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support.");

    function s() {
        try {
            const Q = new Uint8Array(1),
                D = {
                    foo: function() {
                        return 42
                    }
                };
            return Object.setPrototypeOf(D, Uint8Array.prototype), Object.setPrototypeOf(Q, D), Q.foo() === 42
        } catch {
            return !1
        }
    }
    Object.defineProperty(a.prototype, "parent", {
        enumerable: !0,
        get: function() {
            if (a.isBuffer(this)) return this.buffer
        }
    }), Object.defineProperty(a.prototype, "offset", {
        enumerable: !0,
        get: function() {
            if (a.isBuffer(this)) return this.byteOffset
        }
    });

    function o(Q) {
        if (Q > i) throw new RangeError('The value "' + Q + '" is invalid for option "size"');
        const D = new Uint8Array(Q);
        return Object.setPrototypeOf(D, a.prototype), D
    }

    function a(Q, D, B) {
        if (typeof Q == "number") {
            if (typeof D == "string") throw new TypeError('The "string" argument must be of type string. Received type number');
            return f(Q)
        }
        return l(Q, D, B)
    }
    a.poolSize = 8192;

    function l(Q, D, B) {
        if (typeof Q == "string") return h(Q, D);
        if (ArrayBuffer.isView(Q)) return y(Q);
        if (Q == null) throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof Q);
        if (_t(Q, ArrayBuffer) || Q && _t(Q.buffer, ArrayBuffer) || typeof SharedArrayBuffer < "u" && (_t(Q, SharedArrayBuffer) || Q && _t(Q.buffer, SharedArrayBuffer))) return _(Q, D, B);
        if (typeof Q == "number") throw new TypeError('The "value" argument must not be of type number. Received type number');
        const se = Q.valueOf && Q.valueOf();
        if (se != null && se !== Q) return a.from(se, D, B);
        const de = C(Q);
        if (de) return de;
        if (typeof Symbol < "u" && Symbol.toPrimitive != null && typeof Q[Symbol.toPrimitive] == "function") return a.from(Q[Symbol.toPrimitive]("string"), D, B);
        throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof Q)
    }
    a.from = function(Q, D, B) {
        return l(Q, D, B)
    }, Object.setPrototypeOf(a.prototype, Uint8Array.prototype), Object.setPrototypeOf(a, Uint8Array);

    function c(Q) {
        if (typeof Q != "number") throw new TypeError('"size" argument must be of type number');
        if (Q < 0) throw new RangeError('The value "' + Q + '" is invalid for option "size"')
    }

    function u(Q, D, B) {
        return c(Q), Q <= 0 ? o(Q) : D !== void 0 ? typeof B == "string" ? o(Q).fill(D, B) : o(Q).fill(D) : o(Q)
    }
    a.alloc = function(Q, D, B) {
        return u(Q, D, B)
    };

    function f(Q) {
        return c(Q), o(Q < 0 ? 0 : b(Q) | 0)
    }
    a.allocUnsafe = function(Q) {
        return f(Q)
    }, a.allocUnsafeSlow = function(Q) {
        return f(Q)
    };

    function h(Q, D) {
        if ((typeof D != "string" || D === "") && (D = "utf8"), !a.isEncoding(D)) throw new TypeError("Unknown encoding: " + D);
        const B = S(Q, D) | 0;
        let se = o(B);
        const de = se.write(Q, D);
        return de !== B && (se = se.slice(0, de)), se
    }

    function g(Q) {
        const D = Q.length < 0 ? 0 : b(Q.length) | 0,
            B = o(D);
        for (let se = 0; se < D; se += 1) B[se] = Q[se] & 255;
        return B
    }

    function y(Q) {
        if (_t(Q, Uint8Array)) {
            const D = new Uint8Array(Q);
            return _(D.buffer, D.byteOffset, D.byteLength)
        }
        return g(Q)
    }

    function _(Q, D, B) {
        if (D < 0 || Q.byteLength < D) throw new RangeError('"offset" is outside of buffer bounds');
        if (Q.byteLength < D + (B || 0)) throw new RangeError('"length" is outside of buffer bounds');
        let se;
        return D === void 0 && B === void 0 ? se = new Uint8Array(Q) : B === void 0 ? se = new Uint8Array(Q, D) : se = new Uint8Array(Q, D, B), Object.setPrototypeOf(se, a.prototype), se
    }

    function C(Q) {
        if (a.isBuffer(Q)) {
            const D = b(Q.length) | 0,
                B = o(D);
            return B.length === 0 || Q.copy(B, 0, 0, D), B
        }
        if (Q.length !== void 0) return typeof Q.length != "number" || ot(Q.length) ? o(0) : g(Q);
        if (Q.type === "Buffer" && Array.isArray(Q.data)) return g(Q.data)
    }

    function b(Q) {
        if (Q >= i) throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + i.toString(16) + " bytes");
        return Q | 0
    }

    function w(Q) {
        return +Q != Q && (Q = 0), a.alloc(+Q)
    }
    a.isBuffer = function(D) {
        return D != null && D._isBuffer === !0 && D !== a.prototype
    }, a.compare = function(D, B) {
        if (_t(D, Uint8Array) && (D = a.from(D, D.offset, D.byteLength)), _t(B, Uint8Array) && (B = a.from(B, B.offset, B.byteLength)), !a.isBuffer(D) || !a.isBuffer(B)) throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
        if (D === B) return 0;
        let se = D.length,
            de = B.length;
        for (let ye = 0, Se = Math.min(se, de); ye < Se; ++ye)
            if (D[ye] !== B[ye]) {
                se = D[ye], de = B[ye];
                break
            }
        return se < de ? -1 : de < se ? 1 : 0
    }, a.isEncoding = function(D) {
        switch (String(D).toLowerCase()) {
            case "hex":
            case "utf8":
            case "utf-8":
            case "ascii":
            case "latin1":
            case "binary":
            case "base64":
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
                return !0;
            default:
                return !1
        }
    }, a.concat = function(D, B) {
        if (!Array.isArray(D)) throw new TypeError('"list" argument must be an Array of Buffers');
        if (D.length === 0) return a.alloc(0);
        let se;
        if (B === void 0)
            for (B = 0, se = 0; se < D.length; ++se) B += D[se].length;
        const de = a.allocUnsafe(B);
        let ye = 0;
        for (se = 0; se < D.length; ++se) {
            let Se = D[se];
            if (_t(Se, Uint8Array)) ye + Se.length > de.length ? (a.isBuffer(Se) || (Se = a.from(Se)), Se.copy(de, ye)) : Uint8Array.prototype.set.call(de, Se, ye);
            else if (a.isBuffer(Se)) Se.copy(de, ye);
            else throw new TypeError('"list" argument must be an Array of Buffers');
            ye += Se.length
        }
        return de
    };

    function S(Q, D) {
        if (a.isBuffer(Q)) return Q.length;
        if (ArrayBuffer.isView(Q) || _t(Q, ArrayBuffer)) return Q.byteLength;
        if (typeof Q != "string") throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof Q);
        const B = Q.length,
            se = arguments.length > 2 && arguments[2] === !0;
        if (!se && B === 0) return 0;
        let de = !1;
        for (;;) switch (D) {
            case "ascii":
            case "latin1":
            case "binary":
                return B;
            case "utf8":
            case "utf-8":
                return Be(Q).length;
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
                return B * 2;
            case "hex":
                return B >>> 1;
            case "base64":
                return at(Q).length;
            default:
                if (de) return se ? -1 : Be(Q).length;
                D = ("" + D).toLowerCase(), de = !0
        }
    }
    a.byteLength = S;

    function I(Q, D, B) {
        let se = !1;
        if ((D === void 0 || D < 0) && (D = 0), D > this.length || ((B === void 0 || B > this.length) && (B = this.length), B <= 0) || (B >>>= 0, D >>>= 0, B <= D)) return "";
        for (Q || (Q = "utf8");;) switch (Q) {
            case "hex":
                return L(this, D, B);
            case "utf8":
            case "utf-8":
                return m(this, D, B);
            case "ascii":
                return N(this, D, B);
            case "latin1":
            case "binary":
                return O(this, D, B);
            case "base64":
                return U(this, D, B);
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
                return G(this, D, B);
            default:
                if (se) throw new TypeError("Unknown encoding: " + Q);
                Q = (Q + "").toLowerCase(), se = !0
        }
    }
    a.prototype._isBuffer = !0;

    function P(Q, D, B) {
        const se = Q[D];
        Q[D] = Q[B], Q[B] = se
    }
    a.prototype.swap16 = function() {
        const D = this.length;
        if (D % 2 !== 0) throw new RangeError("Buffer size must be a multiple of 16-bits");
        for (let B = 0; B < D; B += 2) P(this, B, B + 1);
        return this
    }, a.prototype.swap32 = function() {
        const D = this.length;
        if (D % 4 !== 0) throw new RangeError("Buffer size must be a multiple of 32-bits");
        for (let B = 0; B < D; B += 4) P(this, B, B + 3), P(this, B + 1, B + 2);
        return this
    }, a.prototype.swap64 = function() {
        const D = this.length;
        if (D % 8 !== 0) throw new RangeError("Buffer size must be a multiple of 64-bits");
        for (let B = 0; B < D; B += 8) P(this, B, B + 7), P(this, B + 1, B + 6), P(this, B + 2, B + 5), P(this, B + 3, B + 4);
        return this
    }, a.prototype.toString = function() {
        const D = this.length;
        return D === 0 ? "" : arguments.length === 0 ? m(this, 0, D) : I.apply(this, arguments)
    }, a.prototype.toLocaleString = a.prototype.toString, a.prototype.equals = function(D) {
        if (!a.isBuffer(D)) throw new TypeError("Argument must be a Buffer");
        return this === D ? !0 : a.compare(this, D) === 0
    }, a.prototype.inspect = function() {
        let D = "";
        const B = t.INSPECT_MAX_BYTES;
        return D = this.toString("hex", 0, B).replace(/(.{2})/g, "$1 ").trim(), this.length > B && (D += " ... "), "<Buffer " + D + ">"
    }, r && (a.prototype[r] = a.prototype.inspect), a.prototype.compare = function(D, B, se, de, ye) {
        if (_t(D, Uint8Array) && (D = a.from(D, D.offset, D.byteLength)), !a.isBuffer(D)) throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof D);
        if (B === void 0 && (B = 0), se === void 0 && (se = D ? D.length : 0), de === void 0 && (de = 0), ye === void 0 && (ye = this.length), B < 0 || se > D.length || de < 0 || ye > this.length) throw new RangeError("out of range index");
        if (de >= ye && B >= se) return 0;
        if (de >= ye) return -1;
        if (B >= se) return 1;
        if (B >>>= 0, se >>>= 0, de >>>= 0, ye >>>= 0, this === D) return 0;
        let Se = ye - de,
            nt = se - B;
        const Ke = Math.min(Se, nt),
            mt = this.slice(de, ye),
            en = D.slice(B, se);
        for (let vt = 0; vt < Ke; ++vt)
            if (mt[vt] !== en[vt]) {
                Se = mt[vt], nt = en[vt];
                break
            }
        return Se < nt ? -1 : nt < Se ? 1 : 0
    };

    function M(Q, D, B, se, de) {
        if (Q.length === 0) return -1;
        if (typeof B == "string" ? (se = B, B = 0) : B > 2147483647 ? B = 2147483647 : B < -2147483648 && (B = -2147483648), B = +B, ot(B) && (B = de ? 0 : Q.length - 1), B < 0 && (B = Q.length + B), B >= Q.length) {
            if (de) return -1;
            B = Q.length - 1
        } else if (B < 0)
            if (de) B = 0;
            else return -1;
        if (typeof D == "string" && (D = a.from(D, se)), a.isBuffer(D)) return D.length === 0 ? -1 : A(Q, D, B, se, de);
        if (typeof D == "number") return D = D & 255, typeof Uint8Array.prototype.indexOf == "function" ? de ? Uint8Array.prototype.indexOf.call(Q, D, B) : Uint8Array.prototype.lastIndexOf.call(Q, D, B) : A(Q, [D], B, se, de);
        throw new TypeError("val must be string, number or Buffer")
    }

    function A(Q, D, B, se, de) {
        let ye = 1,
            Se = Q.length,
            nt = D.length;
        if (se !== void 0 && (se = String(se).toLowerCase(), se === "ucs2" || se === "ucs-2" || se === "utf16le" || se === "utf-16le")) {
            if (Q.length < 2 || D.length < 2) return -1;
            ye = 2, Se /= 2, nt /= 2, B /= 2
        }

        function Ke(en, vt) {
            return ye === 1 ? en[vt] : en.readUInt16BE(vt * ye)
        }
        let mt;
        if (de) {
            let en = -1;
            for (mt = B; mt < Se; mt++)
                if (Ke(Q, mt) === Ke(D, en === -1 ? 0 : mt - en)) {
                    if (en === -1 && (en = mt), mt - en + 1 === nt) return en * ye
                } else en !== -1 && (mt -= mt - en), en = -1
        } else
            for (B + nt > Se && (B = Se - nt), mt = B; mt >= 0; mt--) {
                let en = !0;
                for (let vt = 0; vt < nt; vt++)
                    if (Ke(Q, mt + vt) !== Ke(D, vt)) {
                        en = !1;
                        break
                    }
                if (en) return mt
            }
        return -1
    }
    a.prototype.includes = function(D, B, se) {
        return this.indexOf(D, B, se) !== -1
    }, a.prototype.indexOf = function(D, B, se) {
        return M(this, D, B, se, !0)
    }, a.prototype.lastIndexOf = function(D, B, se) {
        return M(this, D, B, se, !1)
    };

    function E(Q, D, B, se) {
        B = Number(B) || 0;
        const de = Q.length - B;
        se ? (se = Number(se), se > de && (se = de)) : se = de;
        const ye = D.length;
        se > ye / 2 && (se = ye / 2);
        let Se;
        for (Se = 0; Se < se; ++Se) {
            const nt = parseInt(D.substr(Se * 2, 2), 16);
            if (ot(nt)) return Se;
            Q[B + Se] = nt
        }
        return Se
    }

    function $(Q, D, B, se) {
        return tt(Be(D, Q.length - B), Q, B, se)
    }

    function H(Q, D, B, se) {
        return tt(bt(D), Q, B, se)
    }

    function K(Q, D, B, se) {
        return tt(at(D), Q, B, se)
    }

    function te(Q, D, B, se) {
        return tt(mn(D, Q.length - B), Q, B, se)
    }
    a.prototype.write = function(D, B, se, de) {
        if (B === void 0) de = "utf8", se = this.length, B = 0;
        else if (se === void 0 && typeof B == "string") de = B, se = this.length, B = 0;
        else if (isFinite(B)) B = B >>> 0, isFinite(se) ? (se = se >>> 0, de === void 0 && (de = "utf8")) : (de = se, se = void 0);
        else throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
        const ye = this.length - B;
        if ((se === void 0 || se > ye) && (se = ye), D.length > 0 && (se < 0 || B < 0) || B > this.length) throw new RangeError("Attempt to write outside buffer bounds");
        de || (de = "utf8");
        let Se = !1;
        for (;;) switch (de) {
            case "hex":
                return E(this, D, B, se);
            case "utf8":
            case "utf-8":
                return $(this, D, B, se);
            case "ascii":
            case "latin1":
            case "binary":
                return H(this, D, B, se);
            case "base64":
                return K(this, D, B, se);
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
                return te(this, D, B, se);
            default:
                if (Se) throw new TypeError("Unknown encoding: " + de);
                de = ("" + de).toLowerCase(), Se = !0
        }
    }, a.prototype.toJSON = function() {
        return {
            type: "Buffer",
            data: Array.prototype.slice.call(this._arr || this, 0)
        }
    };

    function U(Q, D, B) {
        return D === 0 && B === Q.length ? e.fromByteArray(Q) : e.fromByteArray(Q.slice(D, B))
    }

    function m(Q, D, B) {
        B = Math.min(Q.length, B);
        const se = [];
        let de = D;
        for (; de < B;) {
            const ye = Q[de];
            let Se = null,
                nt = ye > 239 ? 4 : ye > 223 ? 3 : ye > 191 ? 2 : 1;
            if (de + nt <= B) {
                let Ke, mt, en, vt;
                switch (nt) {
                    case 1:
                        ye < 128 && (Se = ye);
                        break;
                    case 2:
                        Ke = Q[de + 1], (Ke & 192) === 128 && (vt = (ye & 31) << 6 | Ke & 63, vt > 127 && (Se = vt));
                        break;
                    case 3:
                        Ke = Q[de + 1], mt = Q[de + 2], (Ke & 192) === 128 && (mt & 192) === 128 && (vt = (ye & 15) << 12 | (Ke & 63) << 6 | mt & 63, vt > 2047 && (vt < 55296 || vt > 57343) && (Se = vt));
                        break;
                    case 4:
                        Ke = Q[de + 1], mt = Q[de + 2], en = Q[de + 3], (Ke & 192) === 128 && (mt & 192) === 128 && (en & 192) === 128 && (vt = (ye & 15) << 18 | (Ke & 63) << 12 | (mt & 63) << 6 | en & 63, vt > 65535 && vt < 1114112 && (Se = vt))
                }
            }
            Se === null ? (Se = 65533, nt = 1) : Se > 65535 && (Se -= 65536, se.push(Se >>> 10 & 1023 | 55296), Se = 56320 | Se & 1023), se.push(Se), de += nt
        }
        return T(se)
    }
    const v = 4096;

    function T(Q) {
        const D = Q.length;
        if (D <= v) return String.fromCharCode.apply(String, Q);
        let B = "",
            se = 0;
        for (; se < D;) B += String.fromCharCode.apply(String, Q.slice(se, se += v));
        return B
    }

    function N(Q, D, B) {
        let se = "";
        B = Math.min(Q.length, B);
        for (let de = D; de < B; ++de) se += String.fromCharCode(Q[de] & 127);
        return se
    }

    function O(Q, D, B) {
        let se = "";
        B = Math.min(Q.length, B);
        for (let de = D; de < B; ++de) se += String.fromCharCode(Q[de]);
        return se
    }

    function L(Q, D, B) {
        const se = Q.length;
        (!D || D < 0) && (D = 0), (!B || B < 0 || B > se) && (B = se);
        let de = "";
        for (let ye = D; ye < B; ++ye) de += lt[Q[ye]];
        return de
    }

    function G(Q, D, B) {
        const se = Q.slice(D, B);
        let de = "";
        for (let ye = 0; ye < se.length - 1; ye += 2) de += String.fromCharCode(se[ye] + se[ye + 1] * 256);
        return de
    }
    a.prototype.slice = function(D, B) {
        const se = this.length;
        D = ~~D, B = B === void 0 ? se : ~~B, D < 0 ? (D += se, D < 0 && (D = 0)) : D > se && (D = se), B < 0 ? (B += se, B < 0 && (B = 0)) : B > se && (B = se), B < D && (B = D);
        const de = this.subarray(D, B);
        return Object.setPrototypeOf(de, a.prototype), de
    };

    function j(Q, D, B) {
        if (Q % 1 !== 0 || Q < 0) throw new RangeError("offset is not uint");
        if (Q + D > B) throw new RangeError("Trying to access beyond buffer length")
    }
    a.prototype.readUintLE = a.prototype.readUIntLE = function(D, B, se) {
        D = D >>> 0, B = B >>> 0, se || j(D, B, this.length);
        let de = this[D],
            ye = 1,
            Se = 0;
        for (; ++Se < B && (ye *= 256);) de += this[D + Se] * ye;
        return de
    }, a.prototype.readUintBE = a.prototype.readUIntBE = function(D, B, se) {
        D = D >>> 0, B = B >>> 0, se || j(D, B, this.length);
        let de = this[D + --B],
            ye = 1;
        for (; B > 0 && (ye *= 256);) de += this[D + --B] * ye;
        return de
    }, a.prototype.readUint8 = a.prototype.readUInt8 = function(D, B) {
        return D = D >>> 0, B || j(D, 1, this.length), this[D]
    }, a.prototype.readUint16LE = a.prototype.readUInt16LE = function(D, B) {
        return D = D >>> 0, B || j(D, 2, this.length), this[D] | this[D + 1] << 8
    }, a.prototype.readUint16BE = a.prototype.readUInt16BE = function(D, B) {
        return D = D >>> 0, B || j(D, 2, this.length), this[D] << 8 | this[D + 1]
    }, a.prototype.readUint32LE = a.prototype.readUInt32LE = function(D, B) {
        return D = D >>> 0, B || j(D, 4, this.length), (this[D] | this[D + 1] << 8 | this[D + 2] << 16) + this[D + 3] * 16777216
    }, a.prototype.readUint32BE = a.prototype.readUInt32BE = function(D, B) {
        return D = D >>> 0, B || j(D, 4, this.length), this[D] * 16777216 + (this[D + 1] << 16 | this[D + 2] << 8 | this[D + 3])
    }, a.prototype.readBigUInt64LE = wt(function(D) {
        D = D >>> 0, ge(D, "offset");
        const B = this[D],
            se = this[D + 7];
        (B === void 0 || se === void 0) && me(D, this.length - 8);
        const de = B + this[++D] * 2 ** 8 + this[++D] * 2 ** 16 + this[++D] * 2 ** 24,
            ye = this[++D] + this[++D] * 2 ** 8 + this[++D] * 2 ** 16 + se * 2 ** 24;
        return BigInt(de) + (BigInt(ye) << BigInt(32))
    }), a.prototype.readBigUInt64BE = wt(function(D) {
        D = D >>> 0, ge(D, "offset");
        const B = this[D],
            se = this[D + 7];
        (B === void 0 || se === void 0) && me(D, this.length - 8);
        const de = B * 2 ** 24 + this[++D] * 2 ** 16 + this[++D] * 2 ** 8 + this[++D],
            ye = this[++D] * 2 ** 24 + this[++D] * 2 ** 16 + this[++D] * 2 ** 8 + se;
        return (BigInt(de) << BigInt(32)) + BigInt(ye)
    }), a.prototype.readIntLE = function(D, B, se) {
        D = D >>> 0, B = B >>> 0, se || j(D, B, this.length);
        let de = this[D],
            ye = 1,
            Se = 0;
        for (; ++Se < B && (ye *= 256);) de += this[D + Se] * ye;
        return ye *= 128, de >= ye && (de -= Math.pow(2, 8 * B)), de
    }, a.prototype.readIntBE = function(D, B, se) {
        D = D >>> 0, B = B >>> 0, se || j(D, B, this.length);
        let de = B,
            ye = 1,
            Se = this[D + --de];
        for (; de > 0 && (ye *= 256);) Se += this[D + --de] * ye;
        return ye *= 128, Se >= ye && (Se -= Math.pow(2, 8 * B)), Se
    }, a.prototype.readInt8 = function(D, B) {
        return D = D >>> 0, B || j(D, 1, this.length), this[D] & 128 ? (255 - this[D] + 1) * -1 : this[D]
    }, a.prototype.readInt16LE = function(D, B) {
        D = D >>> 0, B || j(D, 2, this.length);
        const se = this[D] | this[D + 1] << 8;
        return se & 32768 ? se | 4294901760 : se
    }, a.prototype.readInt16BE = function(D, B) {
        D = D >>> 0, B || j(D, 2, this.length);
        const se = this[D + 1] | this[D] << 8;
        return se & 32768 ? se | 4294901760 : se
    }, a.prototype.readInt32LE = function(D, B) {
        return D = D >>> 0, B || j(D, 4, this.length), this[D] | this[D + 1] << 8 | this[D + 2] << 16 | this[D + 3] << 24
    }, a.prototype.readInt32BE = function(D, B) {
        return D = D >>> 0, B || j(D, 4, this.length), this[D] << 24 | this[D + 1] << 16 | this[D + 2] << 8 | this[D + 3]
    }, a.prototype.readBigInt64LE = wt(function(D) {
        D = D >>> 0, ge(D, "offset");
        const B = this[D],
            se = this[D + 7];
        (B === void 0 || se === void 0) && me(D, this.length - 8);
        const de = this[D + 4] + this[D + 5] * 2 ** 8 + this[D + 6] * 2 ** 16 + (se << 24);
        return (BigInt(de) << BigInt(32)) + BigInt(B + this[++D] * 2 ** 8 + this[++D] * 2 ** 16 + this[++D] * 2 ** 24)
    }), a.prototype.readBigInt64BE = wt(function(D) {
        D = D >>> 0, ge(D, "offset");
        const B = this[D],
            se = this[D + 7];
        (B === void 0 || se === void 0) && me(D, this.length - 8);
        const de = (B << 24) + this[++D] * 2 ** 16 + this[++D] * 2 ** 8 + this[++D];
        return (BigInt(de) << BigInt(32)) + BigInt(this[++D] * 2 ** 24 + this[++D] * 2 ** 16 + this[++D] * 2 ** 8 + se)
    }), a.prototype.readFloatLE = function(D, B) {
        return D = D >>> 0, B || j(D, 4, this.length), n.read(this, D, !0, 23, 4)
    }, a.prototype.readFloatBE = function(D, B) {
        return D = D >>> 0, B || j(D, 4, this.length), n.read(this, D, !1, 23, 4)
    }, a.prototype.readDoubleLE = function(D, B) {
        return D = D >>> 0, B || j(D, 8, this.length), n.read(this, D, !0, 52, 8)
    }, a.prototype.readDoubleBE = function(D, B) {
        return D = D >>> 0, B || j(D, 8, this.length), n.read(this, D, !1, 52, 8)
    };

    function R(Q, D, B, se, de, ye) {
        if (!a.isBuffer(Q)) throw new TypeError('"buffer" argument must be a Buffer instance');
        if (D > de || D < ye) throw new RangeError('"value" argument is out of bounds');
        if (B + se > Q.length) throw new RangeError("Index out of range")
    }
    a.prototype.writeUintLE = a.prototype.writeUIntLE = function(D, B, se, de) {
        if (D = +D, B = B >>> 0, se = se >>> 0, !de) {
            const nt = Math.pow(2, 8 * se) - 1;
            R(this, D, B, se, nt, 0)
        }
        let ye = 1,
            Se = 0;
        for (this[B] = D & 255; ++Se < se && (ye *= 256);) this[B + Se] = D / ye & 255;
        return B + se
    }, a.prototype.writeUintBE = a.prototype.writeUIntBE = function(D, B, se, de) {
        if (D = +D, B = B >>> 0, se = se >>> 0, !de) {
            const nt = Math.pow(2, 8 * se) - 1;
            R(this, D, B, se, nt, 0)
        }
        let ye = se - 1,
            Se = 1;
        for (this[B + ye] = D & 255; --ye >= 0 && (Se *= 256);) this[B + ye] = D / Se & 255;
        return B + se
    }, a.prototype.writeUint8 = a.prototype.writeUInt8 = function(D, B, se) {
        return D = +D, B = B >>> 0, se || R(this, D, B, 1, 255, 0), this[B] = D & 255, B + 1
    }, a.prototype.writeUint16LE = a.prototype.writeUInt16LE = function(D, B, se) {
        return D = +D, B = B >>> 0, se || R(this, D, B, 2, 65535, 0), this[B] = D & 255, this[B + 1] = D >>> 8, B + 2
    }, a.prototype.writeUint16BE = a.prototype.writeUInt16BE = function(D, B, se) {
        return D = +D, B = B >>> 0, se || R(this, D, B, 2, 65535, 0), this[B] = D >>> 8, this[B + 1] = D & 255, B + 2
    }, a.prototype.writeUint32LE = a.prototype.writeUInt32LE = function(D, B, se) {
        return D = +D, B = B >>> 0, se || R(this, D, B, 4, 4294967295, 0), this[B + 3] = D >>> 24, this[B + 2] = D >>> 16, this[B + 1] = D >>> 8, this[B] = D & 255, B + 4
    }, a.prototype.writeUint32BE = a.prototype.writeUInt32BE = function(D, B, se) {
        return D = +D, B = B >>> 0, se || R(this, D, B, 4, 4294967295, 0), this[B] = D >>> 24, this[B + 1] = D >>> 16, this[B + 2] = D >>> 8, this[B + 3] = D & 255, B + 4
    };

    function Y(Q, D, B, se, de) {
        Z(D, se, de, Q, B, 7);
        let ye = Number(D & BigInt(4294967295));
        Q[B++] = ye, ye = ye >> 8, Q[B++] = ye, ye = ye >> 8, Q[B++] = ye, ye = ye >> 8, Q[B++] = ye;
        let Se = Number(D >> BigInt(32) & BigInt(4294967295));
        return Q[B++] = Se, Se = Se >> 8, Q[B++] = Se, Se = Se >> 8, Q[B++] = Se, Se = Se >> 8, Q[B++] = Se, B
    }

    function ve(Q, D, B, se, de) {
        Z(D, se, de, Q, B, 7);
        let ye = Number(D & BigInt(4294967295));
        Q[B + 7] = ye, ye = ye >> 8, Q[B + 6] = ye, ye = ye >> 8, Q[B + 5] = ye, ye = ye >> 8, Q[B + 4] = ye;
        let Se = Number(D >> BigInt(32) & BigInt(4294967295));
        return Q[B + 3] = Se, Se = Se >> 8, Q[B + 2] = Se, Se = Se >> 8, Q[B + 1] = Se, Se = Se >> 8, Q[B] = Se, B + 8
    }
    a.prototype.writeBigUInt64LE = wt(function(D, B = 0) {
        return Y(this, D, B, BigInt(0), BigInt("0xffffffffffffffff"))
    }), a.prototype.writeBigUInt64BE = wt(function(D, B = 0) {
        return ve(this, D, B, BigInt(0), BigInt("0xffffffffffffffff"))
    }), a.prototype.writeIntLE = function(D, B, se, de) {
        if (D = +D, B = B >>> 0, !de) {
            const Ke = Math.pow(2, 8 * se - 1);
            R(this, D, B, se, Ke - 1, -Ke)
        }
        let ye = 0,
            Se = 1,
            nt = 0;
        for (this[B] = D & 255; ++ye < se && (Se *= 256);) D < 0 && nt === 0 && this[B + ye - 1] !== 0 && (nt = 1), this[B + ye] = (D / Se >> 0) - nt & 255;
        return B + se
    }, a.prototype.writeIntBE = function(D, B, se, de) {
        if (D = +D, B = B >>> 0, !de) {
            const Ke = Math.pow(2, 8 * se - 1);
            R(this, D, B, se, Ke - 1, -Ke)
        }
        let ye = se - 1,
            Se = 1,
            nt = 0;
        for (this[B + ye] = D & 255; --ye >= 0 && (Se *= 256);) D < 0 && nt === 0 && this[B + ye + 1] !== 0 && (nt = 1), this[B + ye] = (D / Se >> 0) - nt & 255;
        return B + se
    }, a.prototype.writeInt8 = function(D, B, se) {
        return D = +D, B = B >>> 0, se || R(this, D, B, 1, 127, -128), D < 0 && (D = 255 + D + 1), this[B] = D & 255, B + 1
    }, a.prototype.writeInt16LE = function(D, B, se) {
        return D = +D, B = B >>> 0, se || R(this, D, B, 2, 32767, -32768), this[B] = D & 255, this[B + 1] = D >>> 8, B + 2
    }, a.prototype.writeInt16BE = function(D, B, se) {
        return D = +D, B = B >>> 0, se || R(this, D, B, 2, 32767, -32768), this[B] = D >>> 8, this[B + 1] = D & 255, B + 2
    }, a.prototype.writeInt32LE = function(D, B, se) {
        return D = +D, B = B >>> 0, se || R(this, D, B, 4, 2147483647, -2147483648), this[B] = D & 255, this[B + 1] = D >>> 8, this[B + 2] = D >>> 16, this[B + 3] = D >>> 24, B + 4
    }, a.prototype.writeInt32BE = function(D, B, se) {
        return D = +D, B = B >>> 0, se || R(this, D, B, 4, 2147483647, -2147483648), D < 0 && (D = 4294967295 + D + 1), this[B] = D >>> 24, this[B + 1] = D >>> 16, this[B + 2] = D >>> 8, this[B + 3] = D & 255, B + 4
    }, a.prototype.writeBigInt64LE = wt(function(D, B = 0) {
        return Y(this, D, B, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"))
    }), a.prototype.writeBigInt64BE = wt(function(D, B = 0) {
        return ve(this, D, B, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"))
    });

    function V(Q, D, B, se, de, ye) {
        if (B + se > Q.length) throw new RangeError("Index out of range");
        if (B < 0) throw new RangeError("Index out of range")
    }

    function X(Q, D, B, se, de) {
        return D = +D, B = B >>> 0, de || V(Q, D, B, 4), n.write(Q, D, B, se, 23, 4), B + 4
    }
    a.prototype.writeFloatLE = function(D, B, se) {
        return X(this, D, B, !0, se)
    }, a.prototype.writeFloatBE = function(D, B, se) {
        return X(this, D, B, !1, se)
    };

    function q(Q, D, B, se, de) {
        return D = +D, B = B >>> 0, de || V(Q, D, B, 8), n.write(Q, D, B, se, 52, 8), B + 8
    }
    a.prototype.writeDoubleLE = function(D, B, se) {
        return q(this, D, B, !0, se)
    }, a.prototype.writeDoubleBE = function(D, B, se) {
        return q(this, D, B, !1, se)
    }, a.prototype.copy = function(D, B, se, de) {
        if (!a.isBuffer(D)) throw new TypeError("argument should be a Buffer");
        if (se || (se = 0), !de && de !== 0 && (de = this.length), B >= D.length && (B = D.length), B || (B = 0), de > 0 && de < se && (de = se), de === se || D.length === 0 || this.length === 0) return 0;
        if (B < 0) throw new RangeError("targetStart out of bounds");
        if (se < 0 || se >= this.length) throw new RangeError("Index out of range");
        if (de < 0) throw new RangeError("sourceEnd out of bounds");
        de > this.length && (de = this.length), D.length - B < de - se && (de = D.length - B + se);
        const ye = de - se;
        return this === D && typeof Uint8Array.prototype.copyWithin == "function" ? this.copyWithin(B, se, de) : Uint8Array.prototype.set.call(D, this.subarray(se, de), B), ye
    }, a.prototype.fill = function(D, B, se, de) {
        if (typeof D == "string") {
            if (typeof B == "string" ? (de = B, B = 0, se = this.length) : typeof se == "string" && (de = se, se = this.length), de !== void 0 && typeof de != "string") throw new TypeError("encoding must be a string");
            if (typeof de == "string" && !a.isEncoding(de)) throw new TypeError("Unknown encoding: " + de);
            if (D.length === 1) {
                const Se = D.charCodeAt(0);
                (de === "utf8" && Se < 128 || de === "latin1") && (D = Se)
            }
        } else typeof D == "number" ? D = D & 255 : typeof D == "boolean" && (D = Number(D));
        if (B < 0 || this.length < B || this.length < se) throw new RangeError("Out of range index");
        if (se <= B) return this;
        B = B >>> 0, se = se === void 0 ? this.length : se >>> 0, D || (D = 0);
        let ye;
        if (typeof D == "number")
            for (ye = B; ye < se; ++ye) this[ye] = D;
        else {
            const Se = a.isBuffer(D) ? D : a.from(D, de),
                nt = Se.length;
            if (nt === 0) throw new TypeError('The value "' + D + '" is invalid for argument "value"');
            for (ye = 0; ye < se - B; ++ye) this[ye + B] = Se[ye % nt]
        }
        return this
    };
    const ne = {};

    function ie(Q, D, B) {
        ne[Q] = class extends B {
            constructor() {
                super(), Object.defineProperty(this, "message", {
                    value: D.apply(this, arguments),
                    writable: !0,
                    configurable: !0
                }), this.name = `${this.name} [${Q}]`, this.stack, delete this.name
            }
            get code() {
                return Q
            }
            set code(de) {
                Object.defineProperty(this, "code", {
                    configurable: !0,
                    enumerable: !0,
                    value: de,
                    writable: !0
                })
            }
            toString() {
                return `${this.name} [${Q}]: ${this.message}`
            }
        }
    }
    ie("ERR_BUFFER_OUT_OF_BOUNDS", function(Q) {
        return Q ? `${Q} is outside of buffer bounds` : "Attempt to access memory outside buffer bounds"
    }, RangeError), ie("ERR_INVALID_ARG_TYPE", function(Q, D) {
        return `The "${Q}" argument must be of type number. Received type ${typeof D}`
    }, TypeError), ie("ERR_OUT_OF_RANGE", function(Q, D, B) {
        let se = `The value of "${Q}" is out of range.`,
            de = B;
        return Number.isInteger(B) && Math.abs(B) > 2 ** 32 ? de = k(String(B)) : typeof B == "bigint" && (de = String(B), (B > BigInt(2) ** BigInt(32) || B < -(BigInt(2) ** BigInt(32))) && (de = k(de)), de += "n"), se += ` It must be ${D}. Received ${de}`, se
    }, RangeError);

    function k(Q) {
        let D = "",
            B = Q.length;
        const se = Q[0] === "-" ? 1 : 0;
        for (; B >= se + 4; B -= 3) D = `_${Q.slice(B-3,B)}${D}`;
        return `${Q.slice(0,B)}${D}`
    }

    function z(Q, D, B) {
        ge(D, "offset"), (Q[D] === void 0 || Q[D + B] === void 0) && me(D, Q.length - (B + 1))
    }

    function Z(Q, D, B, se, de, ye) {
        if (Q > B || Q < D) {
            const Se = typeof D == "bigint" ? "n" : "";
            let nt;
            throw D === 0 || D === BigInt(0) ? nt = `>= 0${Se} and < 2${Se} ** ${(ye+1)*8}${Se}` : nt = `>= -(2${Se} ** ${(ye+1)*8-1}${Se}) and < 2 ** ${(ye+1)*8-1}${Se}`, new ne.ERR_OUT_OF_RANGE("value", nt, Q)
        }
        z(se, de, ye)
    }

    function ge(Q, D) {
        if (typeof Q != "number") throw new ne.ERR_INVALID_ARG_TYPE(D, "number", Q)
    }

    function me(Q, D, B) {
        throw Math.floor(Q) !== Q ? (ge(Q, B), new ne.ERR_OUT_OF_RANGE("offset", "an integer", Q)) : D < 0 ? new ne.ERR_BUFFER_OUT_OF_BOUNDS : new ne.ERR_OUT_OF_RANGE("offset", `>= 0 and <= ${D}`, Q)
    }
    const Re = /[^+/0-9A-Za-z-_]/g;

    function He(Q) {
        if (Q = Q.split("=")[0], Q = Q.trim().replace(Re, ""), Q.length < 2) return "";
        for (; Q.length % 4 !== 0;) Q = Q + "=";
        return Q
    }

    function Be(Q, D) {
        D = D || 1 / 0;
        let B;
        const se = Q.length;
        let de = null;
        const ye = [];
        for (let Se = 0; Se < se; ++Se) {
            if (B = Q.charCodeAt(Se), B > 55295 && B < 57344) {
                if (!de) {
                    if (B > 56319) {
                        (D -= 3) > -1 && ye.push(239, 191, 189);
                        continue
                    } else if (Se + 1 === se) {
                        (D -= 3) > -1 && ye.push(239, 191, 189);
                        continue
                    }
                    de = B;
                    continue
                }
                if (B < 56320) {
                    (D -= 3) > -1 && ye.push(239, 191, 189), de = B;
                    continue
                }
                B = (de - 55296 << 10 | B - 56320) + 65536
            } else de && (D -= 3) > -1 && ye.push(239, 191, 189);
            if (de = null, B < 128) {
                if ((D -= 1) < 0) break;
                ye.push(B)
            } else if (B < 2048) {
                if ((D -= 2) < 0) break;
                ye.push(B >> 6 | 192, B & 63 | 128)
            } else if (B < 65536) {
                if ((D -= 3) < 0) break;
                ye.push(B >> 12 | 224, B >> 6 & 63 | 128, B & 63 | 128)
            } else if (B < 1114112) {
                if ((D -= 4) < 0) break;
                ye.push(B >> 18 | 240, B >> 12 & 63 | 128, B >> 6 & 63 | 128, B & 63 | 128)
            } else throw new Error("Invalid code point")
        }
        return ye
    }

    function bt(Q) {
        const D = [];
        for (let B = 0; B < Q.length; ++B) D.push(Q.charCodeAt(B) & 255);
        return D
    }

    function mn(Q, D) {
        let B, se, de;
        const ye = [];
        for (let Se = 0; Se < Q.length && !((D -= 2) < 0); ++Se) B = Q.charCodeAt(Se), se = B >> 8, de = B % 256, ye.push(de), ye.push(se);
        return ye
    }

    function at(Q) {
        return e.toByteArray(He(Q))
    }

    function tt(Q, D, B, se) {
        let de;
        for (de = 0; de < se && !(de + B >= D.length || de >= Q.length); ++de) D[de + B] = Q[de];
        return de
    }

    function _t(Q, D) {
        return Q instanceof D || Q != null && Q.constructor != null && Q.constructor.name != null && Q.constructor.name === D.name
    }

    function ot(Q) {
        return Q !== Q
    }
    const lt = function() {
        const Q = "0123456789abcdef",
            D = new Array(256);
        for (let B = 0; B < 16; ++B) {
            const se = B * 16;
            for (let de = 0; de < 16; ++de) D[se + de] = Q[B] + Q[de]
        }
        return D
    }();

    function wt(Q) {
        return typeof BigInt > "u" ? Xe : Q
    }

    function Xe() {
        throw new Error("BigInt not supported")
    }
})(M2);
var CX;
typeof window < "u" && (window.Buffer || (window.Buffer = M2.Buffer), window.global || (window.global = window), window.process || (window.process = {}), (CX = window.process) != null && CX.env || (window.process = {
    env: {}
}));
var zie = {},
    s6 = {},
    c9 = {};
Object.defineProperty(c9, "__esModule", {
    value: !0
});
c9.walletLogo = void 0;
const Oke = (t, e) => {
    let n;
    switch (t) {
        case "standard":
            return n = e, `data:image/svg+xml,%3Csvg width='${e}' height='${n}' viewBox='0 0 1024 1024' fill='none' xmlns='http://www.w3.org/2000/svg'%3E %3Crect width='1024' height='1024' fill='%230052FF'/%3E %3Cpath fill-rule='evenodd' clip-rule='evenodd' d='M152 512C152 710.823 313.177 872 512 872C710.823 872 872 710.823 872 512C872 313.177 710.823 152 512 152C313.177 152 152 313.177 152 512ZM420 396C406.745 396 396 406.745 396 420V604C396 617.255 406.745 628 420 628H604C617.255 628 628 617.255 628 604V420C628 406.745 617.255 396 604 396H420Z' fill='white'/%3E %3C/svg%3E `;
        case "circle":
            return n = e, `data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='${e}' height='${n}' viewBox='0 0 999.81 999.81'%3E%3Cdefs%3E%3Cstyle%3E.cls-1%7Bfill:%230052fe;%7D.cls-2%7Bfill:%23fefefe;%7D.cls-3%7Bfill:%230152fe;%7D%3C/style%3E%3C/defs%3E%3Cpath class='cls-1' d='M655-115.9h56c.83,1.59,2.36.88,3.56,1a478,478,0,0,1,75.06,10.42C891.4-81.76,978.33-32.58,1049.19,44q116.7,126,131.94,297.61c.38,4.14-.34,8.53,1.78,12.45v59c-1.58.84-.91,2.35-1,3.56a482.05,482.05,0,0,1-10.38,74.05c-24,106.72-76.64,196.76-158.83,268.93s-178.18,112.82-287.2,122.6c-4.83.43-9.86-.25-14.51,1.77H654c-1-1.68-2.69-.91-4.06-1a496.89,496.89,0,0,1-105.9-18.59c-93.54-27.42-172.78-77.59-236.91-150.94Q199.34,590.1,184.87,426.58c-.47-5.19.25-10.56-1.77-15.59V355c1.68-1,.91-2.7,1-4.06a498.12,498.12,0,0,1,18.58-105.9c26-88.75,72.64-164.9,140.6-227.57q126-116.27,297.21-131.61C645.32-114.57,650.35-113.88,655-115.9Zm377.92,500c0-192.44-156.31-349.49-347.56-350.15-194.13-.68-350.94,155.13-352.29,347.42-1.37,194.55,155.51,352.1,348.56,352.47C876.15,734.23,1032.93,577.84,1032.93,384.11Z' transform='translate(-183.1 115.9)'/%3E%3Cpath class='cls-2' d='M1032.93,384.11c0,193.73-156.78,350.12-351.29,349.74-193-.37-349.93-157.92-348.56-352.47C334.43,189.09,491.24,33.28,685.37,34,876.62,34.62,1032.94,191.67,1032.93,384.11ZM683,496.81q43.74,0,87.48,0c15.55,0,25.32-9.72,25.33-25.21q0-87.48,0-175c0-15.83-9.68-25.46-25.59-25.46H595.77c-15.88,0-25.57,9.64-25.58,25.46q0,87.23,0,174.45c0,16.18,9.59,25.7,25.84,25.71Z' transform='translate(-183.1 115.9)'/%3E%3Cpath class='cls-3' d='M683,496.81H596c-16.25,0-25.84-9.53-25.84-25.71q0-87.23,0-174.45c0-15.82,9.7-25.46,25.58-25.46H770.22c15.91,0,25.59,9.63,25.59,25.46q0,87.47,0,175c0,15.49-9.78,25.2-25.33,25.21Q726.74,496.84,683,496.81Z' transform='translate(-183.1 115.9)'/%3E%3C/svg%3E`;
        case "text":
            return n = (.1 * e).toFixed(2), `data:image/svg+xml,%3Csvg width='${e}' height='${n}' xmlns='http://www.w3.org/2000/svg' viewBox='0 0 528.15 53.64'%3E%3Cdefs%3E%3Cstyle%3E.cls-1%7Bfill:%230052ff;%7D%3C/style%3E%3C/defs%3E%3Ctitle%3ECoinbase_Wordmark_SubBrands_ALL%3C/title%3E%3Cpath class='cls-1' d='M164.45,15a15,15,0,0,0-11.74,5.4V0h-8.64V52.92h8.5V48a15,15,0,0,0,11.88,5.62c10.37,0,18.21-8.21,18.21-19.3S174.67,15,164.45,15Zm-1.3,30.67c-6.19,0-10.73-4.83-10.73-11.31S157,23,163.22,23s10.66,4.82,10.66,11.37S169.34,45.65,163.15,45.65Zm83.31-14.91-6.34-.93c-3-.43-5.18-1.44-5.18-3.82,0-2.59,2.8-3.89,6.62-3.89,4.18,0,6.84,1.8,7.42,4.76h8.35c-.94-7.49-6.7-11.88-15.55-11.88-9.15,0-15.2,4.68-15.2,11.3,0,6.34,4,10,12,11.16l6.33.94c3.1.43,4.83,1.65,4.83,4,0,2.95-3,4.17-7.2,4.17-5.12,0-8-2.09-8.43-5.25h-8.49c.79,7.27,6.48,12.38,16.84,12.38,9.44,0,15.7-4.32,15.7-11.74C258.12,35.28,253.58,31.82,246.46,30.74Zm-27.65-2.3c0-8.06-4.9-13.46-15.27-13.46-9.79,0-15.26,5-16.34,12.6h8.57c.43-3,2.73-5.4,7.63-5.4,4.39,0,6.55,1.94,6.55,4.32,0,3.09-4,3.88-8.85,4.39-6.63.72-14.84,3-14.84,11.66,0,6.7,5,11,12.89,11,6.19,0,10.08-2.59,12-6.7.28,3.67,3,6.05,6.84,6.05h5v-7.7h-4.25Zm-8.5,9.36c0,5-4.32,8.64-9.57,8.64-3.24,0-6-1.37-6-4.25,0-3.67,4.39-4.68,8.42-5.11s6-1.22,7.13-2.88ZM281.09,15c-11.09,0-19.23,8.35-19.23,19.36,0,11.6,8.72,19.3,19.37,19.3,9,0,16.06-5.33,17.86-12.89h-9c-1.3,3.31-4.47,5.19-8.71,5.19-5.55,0-9.72-3.46-10.66-9.51H299.3V33.12C299.3,22.46,291.53,15,281.09,15Zm-9.87,15.26c1.37-5.18,5.26-7.7,9.72-7.7,4.9,0,8.64,2.8,9.51,7.7ZM19.3,23a9.84,9.84,0,0,1,9.5,7h9.14c-1.65-8.93-9-15-18.57-15A19,19,0,0,0,0,34.34c0,11.09,8.28,19.3,19.37,19.3,9.36,0,16.85-6,18.5-15H28.8a9.75,9.75,0,0,1-9.43,7.06c-6.27,0-10.66-4.83-10.66-11.31S13,23,19.3,23Zm41.11-8A19,19,0,0,0,41,34.34c0,11.09,8.28,19.3,19.37,19.3A19,19,0,0,0,79.92,34.27C79.92,23.33,71.64,15,60.41,15Zm.07,30.67c-6.19,0-10.73-4.83-10.73-11.31S54.22,23,60.41,23s10.8,4.89,10.8,11.37S66.67,45.65,60.48,45.65ZM123.41,15c-5.62,0-9.29,2.3-11.45,5.54V15.7h-8.57V52.92H112V32.69C112,27,115.63,23,121,23c5,0,8.06,3.53,8.06,8.64V52.92h8.64V31C137.66,21.6,132.84,15,123.41,15ZM92,.36a5.36,5.36,0,0,0-5.55,5.47,5.55,5.55,0,0,0,11.09,0A5.35,5.35,0,0,0,92,.36Zm-9.72,23h5.4V52.92h8.64V15.7h-14Zm298.17-7.7L366.2,52.92H372L375.29,44H392l3.33,8.88h6L386.87,15.7ZM377,39.23l6.45-17.56h.1l6.56,17.56ZM362.66,15.7l-7.88,29h-.11l-8.14-29H341l-8,28.93h-.1l-8-28.87H319L329.82,53h5.45l8.19-29.24h.11L352,53h5.66L368.1,15.7Zm135.25,0v4.86h12.32V52.92h5.6V20.56h12.32V15.7ZM467.82,52.92h25.54V48.06H473.43v-12h18.35V31.35H473.43V20.56h19.93V15.7H467.82ZM443,15.7h-5.6V52.92h24.32V48.06H443Zm-30.45,0h-5.61V52.92h24.32V48.06H412.52Z'/%3E%3C/svg%3E`;
        case "textWithLogo":
            return n = (.25 * e).toFixed(2), `data:image/svg+xml,%3Csvg width='${e}' height='${n}' xmlns='http://www.w3.org/2000/svg' viewBox='0 0 308.44 77.61'%3E%3Cdefs%3E%3Cstyle%3E.cls-1%7Bfill:%230052ff;%7D%3C/style%3E%3C/defs%3E%3Cpath class='cls-1' d='M142.94,20.2l-7.88,29H135l-8.15-29h-5.55l-8,28.93h-.11l-8-28.87H99.27l10.84,37.27h5.44l8.2-29.24h.1l8.41,29.24h5.66L148.39,20.2Zm17.82,0L146.48,57.42h5.82l3.28-8.88h16.65l3.34,8.88h6L167.16,20.2Zm-3.44,23.52,6.45-17.55h.11l6.56,17.55ZM278.2,20.2v4.86h12.32V57.42h5.6V25.06h12.32V20.2ZM248.11,57.42h25.54V52.55H253.71V40.61h18.35V35.85H253.71V25.06h19.94V20.2H248.11ZM223.26,20.2h-5.61V57.42H242V52.55H223.26Zm-30.46,0h-5.6V57.42h24.32V52.55H192.8Zm-154,38A19.41,19.41,0,1,1,57.92,35.57H77.47a38.81,38.81,0,1,0,0,6.47H57.92A19.39,19.39,0,0,1,38.81,58.21Z'/%3E%3C/svg%3E`;
        case "textLight":
            return n = (.1 * e).toFixed(2), `data:image/svg+xml,%3Csvg width='${e}' height='${n}' xmlns='http://www.w3.org/2000/svg' viewBox='0 0 528.15 53.64'%3E%3Cdefs%3E%3Cstyle%3E.cls-1%7Bfill:%23fefefe;%7D%3C/style%3E%3C/defs%3E%3Ctitle%3ECoinbase_Wordmark_SubBrands_ALL%3C/title%3E%3Cpath class='cls-1' d='M164.45,15a15,15,0,0,0-11.74,5.4V0h-8.64V52.92h8.5V48a15,15,0,0,0,11.88,5.62c10.37,0,18.21-8.21,18.21-19.3S174.67,15,164.45,15Zm-1.3,30.67c-6.19,0-10.73-4.83-10.73-11.31S157,23,163.22,23s10.66,4.82,10.66,11.37S169.34,45.65,163.15,45.65Zm83.31-14.91-6.34-.93c-3-.43-5.18-1.44-5.18-3.82,0-2.59,2.8-3.89,6.62-3.89,4.18,0,6.84,1.8,7.42,4.76h8.35c-.94-7.49-6.7-11.88-15.55-11.88-9.15,0-15.2,4.68-15.2,11.3,0,6.34,4,10,12,11.16l6.33.94c3.1.43,4.83,1.65,4.83,4,0,2.95-3,4.17-7.2,4.17-5.12,0-8-2.09-8.43-5.25h-8.49c.79,7.27,6.48,12.38,16.84,12.38,9.44,0,15.7-4.32,15.7-11.74C258.12,35.28,253.58,31.82,246.46,30.74Zm-27.65-2.3c0-8.06-4.9-13.46-15.27-13.46-9.79,0-15.26,5-16.34,12.6h8.57c.43-3,2.73-5.4,7.63-5.4,4.39,0,6.55,1.94,6.55,4.32,0,3.09-4,3.88-8.85,4.39-6.63.72-14.84,3-14.84,11.66,0,6.7,5,11,12.89,11,6.19,0,10.08-2.59,12-6.7.28,3.67,3,6.05,6.84,6.05h5v-7.7h-4.25Zm-8.5,9.36c0,5-4.32,8.64-9.57,8.64-3.24,0-6-1.37-6-4.25,0-3.67,4.39-4.68,8.42-5.11s6-1.22,7.13-2.88ZM281.09,15c-11.09,0-19.23,8.35-19.23,19.36,0,11.6,8.72,19.3,19.37,19.3,9,0,16.06-5.33,17.86-12.89h-9c-1.3,3.31-4.47,5.19-8.71,5.19-5.55,0-9.72-3.46-10.66-9.51H299.3V33.12C299.3,22.46,291.53,15,281.09,15Zm-9.87,15.26c1.37-5.18,5.26-7.7,9.72-7.7,4.9,0,8.64,2.8,9.51,7.7ZM19.3,23a9.84,9.84,0,0,1,9.5,7h9.14c-1.65-8.93-9-15-18.57-15A19,19,0,0,0,0,34.34c0,11.09,8.28,19.3,19.37,19.3,9.36,0,16.85-6,18.5-15H28.8a9.75,9.75,0,0,1-9.43,7.06c-6.27,0-10.66-4.83-10.66-11.31S13,23,19.3,23Zm41.11-8A19,19,0,0,0,41,34.34c0,11.09,8.28,19.3,19.37,19.3A19,19,0,0,0,79.92,34.27C79.92,23.33,71.64,15,60.41,15Zm.07,30.67c-6.19,0-10.73-4.83-10.73-11.31S54.22,23,60.41,23s10.8,4.89,10.8,11.37S66.67,45.65,60.48,45.65ZM123.41,15c-5.62,0-9.29,2.3-11.45,5.54V15.7h-8.57V52.92H112V32.69C112,27,115.63,23,121,23c5,0,8.06,3.53,8.06,8.64V52.92h8.64V31C137.66,21.6,132.84,15,123.41,15ZM92,.36a5.36,5.36,0,0,0-5.55,5.47,5.55,5.55,0,0,0,11.09,0A5.35,5.35,0,0,0,92,.36Zm-9.72,23h5.4V52.92h8.64V15.7h-14Zm298.17-7.7L366.2,52.92H372L375.29,44H392l3.33,8.88h6L386.87,15.7ZM377,39.23l6.45-17.56h.1l6.56,17.56ZM362.66,15.7l-7.88,29h-.11l-8.14-29H341l-8,28.93h-.1l-8-28.87H319L329.82,53h5.45l8.19-29.24h.11L352,53h5.66L368.1,15.7Zm135.25,0v4.86h12.32V52.92h5.6V20.56h12.32V15.7ZM467.82,52.92h25.54V48.06H473.43v-12h18.35V31.35H473.43V20.56h19.93V15.7H467.82ZM443,15.7h-5.6V52.92h24.32V48.06H443Zm-30.45,0h-5.61V52.92h24.32V48.06H412.52Z'/%3E%3C/svg%3E`;
        case "textWithLogoLight":
            return n = (.25 * e).toFixed(2), `data:image/svg+xml,%3Csvg width='${e}' height='${n}' xmlns='http://www.w3.org/2000/svg' viewBox='0 0 308.44 77.61'%3E%3Cdefs%3E%3Cstyle%3E.cls-1%7Bfill:%23fefefe;%7D%3C/style%3E%3C/defs%3E%3Cpath class='cls-1' d='M142.94,20.2l-7.88,29H135l-8.15-29h-5.55l-8,28.93h-.11l-8-28.87H99.27l10.84,37.27h5.44l8.2-29.24h.1l8.41,29.24h5.66L148.39,20.2Zm17.82,0L146.48,57.42h5.82l3.28-8.88h16.65l3.34,8.88h6L167.16,20.2Zm-3.44,23.52,6.45-17.55h.11l6.56,17.55ZM278.2,20.2v4.86h12.32V57.42h5.6V25.06h12.32V20.2ZM248.11,57.42h25.54V52.55H253.71V40.61h18.35V35.85H253.71V25.06h19.94V20.2H248.11ZM223.26,20.2h-5.61V57.42H242V52.55H223.26Zm-30.46,0h-5.6V57.42h24.32V52.55H192.8Zm-154,38A19.41,19.41,0,1,1,57.92,35.57H77.47a38.81,38.81,0,1,0,0,6.47H57.92A19.39,19.39,0,0,1,38.81,58.21Z'/%3E%3C/svg%3E`;
        default:
            return n = e, `data:image/svg+xml,%3Csvg width='${e}' height='${n}' viewBox='0 0 1024 1024' fill='none' xmlns='http://www.w3.org/2000/svg'%3E %3Crect width='1024' height='1024' fill='%230052FF'/%3E %3Cpath fill-rule='evenodd' clip-rule='evenodd' d='M152 512C152 710.823 313.177 872 512 872C710.823 872 872 710.823 872 512C872 313.177 710.823 152 512 152C313.177 152 152 313.177 152 512ZM420 396C406.745 396 396 406.745 396 420V604C396 617.255 406.745 628 420 628H604C617.255 628 628 617.255 628 604V420C628 406.745 617.255 396 604 396H420Z' fill='white'/%3E %3C/svg%3E `
    }
};
c9.walletLogo = Oke;
var u9 = {};
Object.defineProperty(u9, "__esModule", {
    value: !0
});
u9.LINK_API_URL = void 0;
u9.LINK_API_URL = "https://www.walletlink.org";
var f9 = {};
Object.defineProperty(f9, "__esModule", {
    value: !0
});
f9.ScopedLocalStorage = void 0;
class Nke {
    constructor(e) {
        this.scope = e
    }
    setItem(e, n) {
        localStorage.setItem(this.scopedKey(e), n)
    }
    getItem(e) {
        return localStorage.getItem(this.scopedKey(e))
    }
    removeItem(e) {
        localStorage.removeItem(this.scopedKey(e))
    }
    clear() {
        const e = this.scopedKey(""),
            n = [];
        for (let r = 0; r < localStorage.length; r++) {
            const i = localStorage.key(r);
            typeof i == "string" && i.startsWith(e) && n.push(i)
        }
        n.forEach(r => localStorage.removeItem(r))
    }
    scopedKey(e) {
        return `${this.scope}:${e}`
    }
}
f9.ScopedLocalStorage = Nke;
var Jb = {},
    vy = {};
Object.defineProperty(vy, "__esModule", {
    value: !0
});
const Pke = uo;

function mq(t, e, n) {
    try {
        Reflect.apply(t, e, n)
    } catch (r) {
        setTimeout(() => {
            throw r
        })
    }
}

function kke(t) {
    const e = t.length,
        n = new Array(e);
    for (let r = 0; r < e; r += 1) n[r] = t[r];
    return n
}
let Mke = class extends Pke.EventEmitter {
    emit(e, ...n) {
        let r = e === "error";
        const i = this._events;
        if (i !== void 0) r = r && i.error === void 0;
        else if (!r) return !1;
        if (r) {
            let o;
            if (n.length > 0 && ([o] = n), o instanceof Error) throw o;
            const a = new Error(`Unhandled error.${o?` (${o.message})`:""}`);
            throw a.context = o, a
        }
        const s = i[e];
        if (s === void 0) return !1;
        if (typeof s == "function") mq(s, this, n);
        else {
            const o = s.length,
                a = kke(s);
            for (let l = 0; l < o; l += 1) mq(a[l], this, n)
        }
        return !0
    }
};
vy.default = Mke;
var GL = {
    exports: {}
};
GL.exports;
(function(t) {
    (function(e, n) {
        function r(U, m) {
            if (!U) throw new Error(m || "Assertion failed")
        }

        function i(U, m) {
            U.super_ = m;
            var v = function() {};
            v.prototype = m.prototype, U.prototype = new v, U.prototype.constructor = U
        }

        function s(U, m, v) {
            if (s.isBN(U)) return U;
            this.negative = 0, this.words = null, this.length = 0, this.red = null, U !== null && ((m === "le" || m === "be") && (v = m, m = 10), this._init(U || 0, m || 10, v || "be"))
        }
        typeof e == "object" ? e.exports = s : n.BN = s, s.BN = s, s.wordSize = 26;
        var o;
        try {
            typeof window < "u" && typeof window.Buffer < "u" ? o = window.Buffer : o = vE.Buffer
        } catch {}
        s.isBN = function(m) {
            return m instanceof s ? !0 : m !== null && typeof m == "object" && m.constructor.wordSize === s.wordSize && Array.isArray(m.words)
        }, s.max = function(m, v) {
            return m.cmp(v) > 0 ? m : v
        }, s.min = function(m, v) {
            return m.cmp(v) < 0 ? m : v
        }, s.prototype._init = function(m, v, T) {
            if (typeof m == "number") return this._initNumber(m, v, T);
            if (typeof m == "object") return this._initArray(m, v, T);
            v === "hex" && (v = 16), r(v === (v | 0) && v >= 2 && v <= 36), m = m.toString().replace(/\s+/g, "");
            var N = 0;
            m[0] === "-" && (N++, this.negative = 1), N < m.length && (v === 16 ? this._parseHex(m, N, T) : (this._parseBase(m, v, N), T === "le" && this._initArray(this.toArray(), v, T)))
        }, s.prototype._initNumber = function(m, v, T) {
            m < 0 && (this.negative = 1, m = -m), m < 67108864 ? (this.words = [m & 67108863], this.length = 1) : m < 4503599627370496 ? (this.words = [m & 67108863, m / 67108864 & 67108863], this.length = 2) : (r(m < 9007199254740992), this.words = [m & 67108863, m / 67108864 & 67108863, 1], this.length = 3), T === "le" && this._initArray(this.toArray(), v, T)
        }, s.prototype._initArray = function(m, v, T) {
            if (r(typeof m.length == "number"), m.length <= 0) return this.words = [0], this.length = 1, this;
            this.length = Math.ceil(m.length / 3), this.words = new Array(this.length);
            for (var N = 0; N < this.length; N++) this.words[N] = 0;
            var O, L, G = 0;
            if (T === "be")
                for (N = m.length - 1, O = 0; N >= 0; N -= 3) L = m[N] | m[N - 1] << 8 | m[N - 2] << 16, this.words[O] |= L << G & 67108863, this.words[O + 1] = L >>> 26 - G & 67108863, G += 24, G >= 26 && (G -= 26, O++);
            else if (T === "le")
                for (N = 0, O = 0; N < m.length; N += 3) L = m[N] | m[N + 1] << 8 | m[N + 2] << 16, this.words[O] |= L << G & 67108863, this.words[O + 1] = L >>> 26 - G & 67108863, G += 24, G >= 26 && (G -= 26, O++);
            return this._strip()
        };

        function a(U, m) {
            var v = U.charCodeAt(m);
            if (v >= 48 && v <= 57) return v - 48;
            if (v >= 65 && v <= 70) return v - 55;
            if (v >= 97 && v <= 102) return v - 87;
            r(!1, "Invalid character in " + U)
        }

        function l(U, m, v) {
            var T = a(U, v);
            return v - 1 >= m && (T |= a(U, v - 1) << 4), T
        }
        s.prototype._parseHex = function(m, v, T) {
            this.length = Math.ceil((m.length - v) / 6), this.words = new Array(this.length);
            for (var N = 0; N < this.length; N++) this.words[N] = 0;
            var O = 0,
                L = 0,
                G;
            if (T === "be")
                for (N = m.length - 1; N >= v; N -= 2) G = l(m, v, N) << O, this.words[L] |= G & 67108863, O >= 18 ? (O -= 18, L += 1, this.words[L] |= G >>> 26) : O += 8;
            else {
                var j = m.length - v;
                for (N = j % 2 === 0 ? v + 1 : v; N < m.length; N += 2) G = l(m, v, N) << O, this.words[L] |= G & 67108863, O >= 18 ? (O -= 18, L += 1, this.words[L] |= G >>> 26) : O += 8
            }
            this._strip()
        };

        function c(U, m, v, T) {
            for (var N = 0, O = 0, L = Math.min(U.length, v), G = m; G < L; G++) {
                var j = U.charCodeAt(G) - 48;
                N *= T, j >= 49 ? O = j - 49 + 10 : j >= 17 ? O = j - 17 + 10 : O = j, r(j >= 0 && O < T, "Invalid character"), N += O
            }
            return N
        }
        s.prototype._parseBase = function(m, v, T) {
            this.words = [0], this.length = 1;
            for (var N = 0, O = 1; O <= 67108863; O *= v) N++;
            N--, O = O / v | 0;
            for (var L = m.length - T, G = L % N, j = Math.min(L, L - G) + T, R = 0, Y = T; Y < j; Y += N) R = c(m, Y, Y + N, v), this.imuln(O), this.words[0] + R < 67108864 ? this.words[0] += R : this._iaddn(R);
            if (G !== 0) {
                var ve = 1;
                for (R = c(m, Y, m.length, v), Y = 0; Y < G; Y++) ve *= v;
                this.imuln(ve), this.words[0] + R < 67108864 ? this.words[0] += R : this._iaddn(R)
            }
            this._strip()
        }, s.prototype.copy = function(m) {
            m.words = new Array(this.length);
            for (var v = 0; v < this.length; v++) m.words[v] = this.words[v];
            m.length = this.length, m.negative = this.negative, m.red = this.red
        };

        function u(U, m) {
            U.words = m.words, U.length = m.length, U.negative = m.negative, U.red = m.red
        }
        if (s.prototype._move = function(m) {
                u(m, this)
            }, s.prototype.clone = function() {
                var m = new s(null);
                return this.copy(m), m
            }, s.prototype._expand = function(m) {
                for (; this.length < m;) this.words[this.length++] = 0;
                return this
            }, s.prototype._strip = function() {
                for (; this.length > 1 && this.words[this.length - 1] === 0;) this.length--;
                return this._normSign()
            }, s.prototype._normSign = function() {
                return this.length === 1 && this.words[0] === 0 && (this.negative = 0), this
            }, typeof Symbol < "u" && typeof Symbol.for == "function") try {
            s.prototype[Symbol.for("nodejs.util.inspect.custom")] = f
        } catch {
            s.prototype.inspect = f
        } else s.prototype.inspect = f;

        function f() {
            return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">"
        }
        var h = ["", "0", "00", "000", "0000", "00000", "000000", "0000000", "00000000", "000000000", "0000000000", "00000000000", "000000000000", "0000000000000", "00000000000000", "000000000000000", "0000000000000000", "00000000000000000", "000000000000000000", "0000000000000000000", "00000000000000000000", "000000000000000000000", "0000000000000000000000", "00000000000000000000000", "000000000000000000000000", "0000000000000000000000000"],
            g = [0, 0, 25, 16, 12, 11, 10, 9, 8, 8, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5],
            y = [0, 0, 33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216, 43046721, 1e7, 19487171, 35831808, 62748517, 7529536, 11390625, 16777216, 24137569, 34012224, 47045881, 64e6, 4084101, 5153632, 6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149, 243e5, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176];
        s.prototype.toString = function(m, v) {
            m = m || 10, v = v | 0 || 1;
            var T;
            if (m === 16 || m === "hex") {
                T = "";
                for (var N = 0, O = 0, L = 0; L < this.length; L++) {
                    var G = this.words[L],
                        j = ((G << N | O) & 16777215).toString(16);
                    O = G >>> 24 - N & 16777215, N += 2, N >= 26 && (N -= 26, L--), O !== 0 || L !== this.length - 1 ? T = h[6 - j.length] + j + T : T = j + T
                }
                for (O !== 0 && (T = O.toString(16) + T); T.length % v !== 0;) T = "0" + T;
                return this.negative !== 0 && (T = "-" + T), T
            }
            if (m === (m | 0) && m >= 2 && m <= 36) {
                var R = g[m],
                    Y = y[m];
                T = "";
                var ve = this.clone();
                for (ve.negative = 0; !ve.isZero();) {
                    var V = ve.modrn(Y).toString(m);
                    ve = ve.idivn(Y), ve.isZero() ? T = V + T : T = h[R - V.length] + V + T
                }
                for (this.isZero() && (T = "0" + T); T.length % v !== 0;) T = "0" + T;
                return this.negative !== 0 && (T = "-" + T), T
            }
            r(!1, "Base should be between 2 and 36")
        }, s.prototype.toNumber = function() {
            var m = this.words[0];
            return this.length === 2 ? m += this.words[1] * 67108864 : this.length === 3 && this.words[2] === 1 ? m += 4503599627370496 + this.words[1] * 67108864 : this.length > 2 && r(!1, "Number can only safely store up to 53 bits"), this.negative !== 0 ? -m : m
        }, s.prototype.toJSON = function() {
            return this.toString(16, 2)
        }, o && (s.prototype.toBuffer = function(m, v) {
            return this.toArrayLike(o, m, v)
        }), s.prototype.toArray = function(m, v) {
            return this.toArrayLike(Array, m, v)
        };
        var _ = function(m, v) {
            return m.allocUnsafe ? m.allocUnsafe(v) : new m(v)
        };
        s.prototype.toArrayLike = function(m, v, T) {
            this._strip();
            var N = this.byteLength(),
                O = T || Math.max(1, N);
            r(N <= O, "byte array longer than desired length"), r(O > 0, "Requested array length <= 0");
            var L = _(m, O),
                G = v === "le" ? "LE" : "BE";
            return this["_toArrayLike" + G](L, N), L
        }, s.prototype._toArrayLikeLE = function(m, v) {
            for (var T = 0, N = 0, O = 0, L = 0; O < this.length; O++) {
                var G = this.words[O] << L | N;
                m[T++] = G & 255, T < m.length && (m[T++] = G >> 8 & 255), T < m.length && (m[T++] = G >> 16 & 255), L === 6 ? (T < m.length && (m[T++] = G >> 24 & 255), N = 0, L = 0) : (N = G >>> 24, L += 2)
            }
            if (T < m.length)
                for (m[T++] = N; T < m.length;) m[T++] = 0
        }, s.prototype._toArrayLikeBE = function(m, v) {
            for (var T = m.length - 1, N = 0, O = 0, L = 0; O < this.length; O++) {
                var G = this.words[O] << L | N;
                m[T--] = G & 255, T >= 0 && (m[T--] = G >> 8 & 255), T >= 0 && (m[T--] = G >> 16 & 255), L === 6 ? (T >= 0 && (m[T--] = G >> 24 & 255), N = 0, L = 0) : (N = G >>> 24, L += 2)
            }
            if (T >= 0)
                for (m[T--] = N; T >= 0;) m[T--] = 0
        }, Math.clz32 ? s.prototype._countBits = function(m) {
            return 32 - Math.clz32(m)
        } : s.prototype._countBits = function(m) {
            var v = m,
                T = 0;
            return v >= 4096 && (T += 13, v >>>= 13), v >= 64 && (T += 7, v >>>= 7), v >= 8 && (T += 4, v >>>= 4), v >= 2 && (T += 2, v >>>= 2), T + v
        }, s.prototype._zeroBits = function(m) {
            if (m === 0) return 26;
            var v = m,
                T = 0;
            return v & 8191 || (T += 13, v >>>= 13), v & 127 || (T += 7, v >>>= 7), v & 15 || (T += 4, v >>>= 4), v & 3 || (T += 2, v >>>= 2), v & 1 || T++, T
        }, s.prototype.bitLength = function() {
            var m = this.words[this.length - 1],
                v = this._countBits(m);
            return (this.length - 1) * 26 + v
        };

        function C(U) {
            for (var m = new Array(U.bitLength()), v = 0; v < m.length; v++) {
                var T = v / 26 | 0,
                    N = v % 26;
                m[v] = U.words[T] >>> N & 1
            }
            return m
        }
        s.prototype.zeroBits = function() {
            if (this.isZero()) return 0;
            for (var m = 0, v = 0; v < this.length; v++) {
                var T = this._zeroBits(this.words[v]);
                if (m += T, T !== 26) break
            }
            return m
        }, s.prototype.byteLength = function() {
            return Math.ceil(this.bitLength() / 8)
        }, s.prototype.toTwos = function(m) {
            return this.negative !== 0 ? this.abs().inotn(m).iaddn(1) : this.clone()
        }, s.prototype.fromTwos = function(m) {
            return this.testn(m - 1) ? this.notn(m).iaddn(1).ineg() : this.clone()
        }, s.prototype.isNeg = function() {
            return this.negative !== 0
        }, s.prototype.neg = function() {
            return this.clone().ineg()
        }, s.prototype.ineg = function() {
            return this.isZero() || (this.negative ^= 1), this
        }, s.prototype.iuor = function(m) {
            for (; this.length < m.length;) this.words[this.length++] = 0;
            for (var v = 0; v < m.length; v++) this.words[v] = this.words[v] | m.words[v];
            return this._strip()
        }, s.prototype.ior = function(m) {
            return r((this.negative | m.negative) === 0), this.iuor(m)
        }, s.prototype.or = function(m) {
            return this.length > m.length ? this.clone().ior(m) : m.clone().ior(this)
        }, s.prototype.uor = function(m) {
            return this.length > m.length ? this.clone().iuor(m) : m.clone().iuor(this)
        }, s.prototype.iuand = function(m) {
            var v;
            this.length > m.length ? v = m : v = this;
            for (var T = 0; T < v.length; T++) this.words[T] = this.words[T] & m.words[T];
            return this.length = v.length, this._strip()
        }, s.prototype.iand = function(m) {
            return r((this.negative | m.negative) === 0), this.iuand(m)
        }, s.prototype.and = function(m) {
            return this.length > m.length ? this.clone().iand(m) : m.clone().iand(this)
        }, s.prototype.uand = function(m) {
            return this.length > m.length ? this.clone().iuand(m) : m.clone().iuand(this)
        }, s.prototype.iuxor = function(m) {
            var v, T;
            this.length > m.length ? (v = this, T = m) : (v = m, T = this);
            for (var N = 0; N < T.length; N++) this.words[N] = v.words[N] ^ T.words[N];
            if (this !== v)
                for (; N < v.length; N++) this.words[N] = v.words[N];
            return this.length = v.length, this._strip()
        }, s.prototype.ixor = function(m) {
            return r((this.negative | m.negative) === 0), this.iuxor(m)
        }, s.prototype.xor = function(m) {
            return this.length > m.length ? this.clone().ixor(m) : m.clone().ixor(this)
        }, s.prototype.uxor = function(m) {
            return this.length > m.length ? this.clone().iuxor(m) : m.clone().iuxor(this)
        }, s.prototype.inotn = function(m) {
            r(typeof m == "number" && m >= 0);
            var v = Math.ceil(m / 26) | 0,
                T = m % 26;
            this._expand(v), T > 0 && v--;
            for (var N = 0; N < v; N++) this.words[N] = ~this.words[N] & 67108863;
            return T > 0 && (this.words[N] = ~this.words[N] & 67108863 >> 26 - T), this._strip()
        }, s.prototype.notn = function(m) {
            return this.clone().inotn(m)
        }, s.prototype.setn = function(m, v) {
            r(typeof m == "number" && m >= 0);
            var T = m / 26 | 0,
                N = m % 26;
            return this._expand(T + 1), v ? this.words[T] = this.words[T] | 1 << N : this.words[T] = this.words[T] & ~(1 << N), this._strip()
        }, s.prototype.iadd = function(m) {
            var v;
            if (this.negative !== 0 && m.negative === 0) return this.negative = 0, v = this.isub(m), this.negative ^= 1, this._normSign();
            if (this.negative === 0 && m.negative !== 0) return m.negative = 0, v = this.isub(m), m.negative = 1, v._normSign();
            var T, N;
            this.length > m.length ? (T = this, N = m) : (T = m, N = this);
            for (var O = 0, L = 0; L < N.length; L++) v = (T.words[L] | 0) + (N.words[L] | 0) + O, this.words[L] = v & 67108863, O = v >>> 26;
            for (; O !== 0 && L < T.length; L++) v = (T.words[L] | 0) + O, this.words[L] = v & 67108863, O = v >>> 26;
            if (this.length = T.length, O !== 0) this.words[this.length] = O, this.length++;
            else if (T !== this)
                for (; L < T.length; L++) this.words[L] = T.words[L];
            return this
        }, s.prototype.add = function(m) {
            var v;
            return m.negative !== 0 && this.negative === 0 ? (m.negative = 0, v = this.sub(m), m.negative ^= 1, v) : m.negative === 0 && this.negative !== 0 ? (this.negative = 0, v = m.sub(this), this.negative = 1, v) : this.length > m.length ? this.clone().iadd(m) : m.clone().iadd(this)
        }, s.prototype.isub = function(m) {
            if (m.negative !== 0) {
                m.negative = 0;
                var v = this.iadd(m);
                return m.negative = 1, v._normSign()
            } else if (this.negative !== 0) return this.negative = 0, this.iadd(m), this.negative = 1, this._normSign();
            var T = this.cmp(m);
            if (T === 0) return this.negative = 0, this.length = 1, this.words[0] = 0, this;
            var N, O;
            T > 0 ? (N = this, O = m) : (N = m, O = this);
            for (var L = 0, G = 0; G < O.length; G++) v = (N.words[G] | 0) - (O.words[G] | 0) + L, L = v >> 26, this.words[G] = v & 67108863;
            for (; L !== 0 && G < N.length; G++) v = (N.words[G] | 0) + L, L = v >> 26, this.words[G] = v & 67108863;
            if (L === 0 && G < N.length && N !== this)
                for (; G < N.length; G++) this.words[G] = N.words[G];
            return this.length = Math.max(this.length, G), N !== this && (this.negative = 1), this._strip()
        }, s.prototype.sub = function(m) {
            return this.clone().isub(m)
        };

        function b(U, m, v) {
            v.negative = m.negative ^ U.negative;
            var T = U.length + m.length | 0;
            v.length = T, T = T - 1 | 0;
            var N = U.words[0] | 0,
                O = m.words[0] | 0,
                L = N * O,
                G = L & 67108863,
                j = L / 67108864 | 0;
            v.words[0] = G;
            for (var R = 1; R < T; R++) {
                for (var Y = j >>> 26, ve = j & 67108863, V = Math.min(R, m.length - 1), X = Math.max(0, R - U.length + 1); X <= V; X++) {
                    var q = R - X | 0;
                    N = U.words[q] | 0, O = m.words[X] | 0, L = N * O + ve, Y += L / 67108864 | 0, ve = L & 67108863
                }
                v.words[R] = ve | 0, j = Y | 0
            }
            return j !== 0 ? v.words[R] = j | 0 : v.length--, v._strip()
        }
        var w = function(m, v, T) {
            var N = m.words,
                O = v.words,
                L = T.words,
                G = 0,
                j, R, Y, ve = N[0] | 0,
                V = ve & 8191,
                X = ve >>> 13,
                q = N[1] | 0,
                ne = q & 8191,
                ie = q >>> 13,
                k = N[2] | 0,
                z = k & 8191,
                Z = k >>> 13,
                ge = N[3] | 0,
                me = ge & 8191,
                Re = ge >>> 13,
                He = N[4] | 0,
                Be = He & 8191,
                bt = He >>> 13,
                mn = N[5] | 0,
                at = mn & 8191,
                tt = mn >>> 13,
                _t = N[6] | 0,
                ot = _t & 8191,
                lt = _t >>> 13,
                wt = N[7] | 0,
                Xe = wt & 8191,
                Q = wt >>> 13,
                D = N[8] | 0,
                B = D & 8191,
                se = D >>> 13,
                de = N[9] | 0,
                ye = de & 8191,
                Se = de >>> 13,
                nt = O[0] | 0,
                Ke = nt & 8191,
                mt = nt >>> 13,
                en = O[1] | 0,
                vt = en & 8191,
                hn = en >>> 13,
                ui = O[2] | 0,
                bn = ui & 8191,
                On = ui >>> 13,
                Un = O[3] | 0,
                Lt = Un & 8191,
                jt = Un >>> 13,
                qn = O[4] | 0,
                Ht = qn & 8191,
                zt = qn >>> 13,
                Jn = O[5] | 0,
                Vt = Jn & 8191,
                Ft = Jn >>> 13,
                Xn = O[6] | 0,
                Kt = Xn & 8191,
                Qt = Xn >>> 13,
                fe = O[7] | 0,
                he = fe & 8191,
                be = fe >>> 13,
                Pe = O[8] | 0,
                qe = Pe & 8191,
                Je = Pe >>> 13,
                Mt = O[9] | 0,
                Le = Mt & 8191,
                rt = Mt >>> 13;
            T.negative = m.negative ^ v.negative, T.length = 19, j = Math.imul(V, Ke), R = Math.imul(V, mt), R = R + Math.imul(X, Ke) | 0, Y = Math.imul(X, mt);
            var ct = (G + j | 0) + ((R & 8191) << 13) | 0;
            G = (Y + (R >>> 13) | 0) + (ct >>> 26) | 0, ct &= 67108863, j = Math.imul(ne, Ke), R = Math.imul(ne, mt), R = R + Math.imul(ie, Ke) | 0, Y = Math.imul(ie, mt), j = j + Math.imul(V, vt) | 0, R = R + Math.imul(V, hn) | 0, R = R + Math.imul(X, vt) | 0, Y = Y + Math.imul(X, hn) | 0;
            var ft = (G + j | 0) + ((R & 8191) << 13) | 0;
            G = (Y + (R >>> 13) | 0) + (ft >>> 26) | 0, ft &= 67108863, j = Math.imul(z, Ke), R = Math.imul(z, mt), R = R + Math.imul(Z, Ke) | 0, Y = Math.imul(Z, mt), j = j + Math.imul(ne, vt) | 0, R = R + Math.imul(ne, hn) | 0, R = R + Math.imul(ie, vt) | 0, Y = Y + Math.imul(ie, hn) | 0, j = j + Math.imul(V, bn) | 0, R = R + Math.imul(V, On) | 0, R = R + Math.imul(X, bn) | 0, Y = Y + Math.imul(X, On) | 0;
            var an = (G + j | 0) + ((R & 8191) << 13) | 0;
            G = (Y + (R >>> 13) | 0) + (an >>> 26) | 0, an &= 67108863, j = Math.imul(me, Ke), R = Math.imul(me, mt), R = R + Math.imul(Re, Ke) | 0, Y = Math.imul(Re, mt), j = j + Math.imul(z, vt) | 0, R = R + Math.imul(z, hn) | 0, R = R + Math.imul(Z, vt) | 0, Y = Y + Math.imul(Z, hn) | 0, j = j + Math.imul(ne, bn) | 0, R = R + Math.imul(ne, On) | 0, R = R + Math.imul(ie, bn) | 0, Y = Y + Math.imul(ie, On) | 0, j = j + Math.imul(V, Lt) | 0, R = R + Math.imul(V, jt) | 0, R = R + Math.imul(X, Lt) | 0, Y = Y + Math.imul(X, jt) | 0;
            var pn = (G + j | 0) + ((R & 8191) << 13) | 0;
            G = (Y + (R >>> 13) | 0) + (pn >>> 26) | 0, pn &= 67108863, j = Math.imul(Be, Ke), R = Math.imul(Be, mt), R = R + Math.imul(bt, Ke) | 0, Y = Math.imul(bt, mt), j = j + Math.imul(me, vt) | 0, R = R + Math.imul(me, hn) | 0, R = R + Math.imul(Re, vt) | 0, Y = Y + Math.imul(Re, hn) | 0, j = j + Math.imul(z, bn) | 0, R = R + Math.imul(z, On) | 0, R = R + Math.imul(Z, bn) | 0, Y = Y + Math.imul(Z, On) | 0, j = j + Math.imul(ne, Lt) | 0, R = R + Math.imul(ne, jt) | 0, R = R + Math.imul(ie, Lt) | 0, Y = Y + Math.imul(ie, jt) | 0, j = j + Math.imul(V, Ht) | 0, R = R + Math.imul(V, zt) | 0, R = R + Math.imul(X, Ht) | 0, Y = Y + Math.imul(X, zt) | 0;
            var ln = (G + j | 0) + ((R & 8191) << 13) | 0;
            G = (Y + (R >>> 13) | 0) + (ln >>> 26) | 0, ln &= 67108863, j = Math.imul(at, Ke), R = Math.imul(at, mt), R = R + Math.imul(tt, Ke) | 0, Y = Math.imul(tt, mt), j = j + Math.imul(Be, vt) | 0, R = R + Math.imul(Be, hn) | 0, R = R + Math.imul(bt, vt) | 0, Y = Y + Math.imul(bt, hn) | 0, j = j + Math.imul(me, bn) | 0, R = R + Math.imul(me, On) | 0, R = R + Math.imul(Re, bn) | 0, Y = Y + Math.imul(Re, On) | 0, j = j + Math.imul(z, Lt) | 0, R = R + Math.imul(z, jt) | 0, R = R + Math.imul(Z, Lt) | 0, Y = Y + Math.imul(Z, jt) | 0, j = j + Math.imul(ne, Ht) | 0, R = R + Math.imul(ne, zt) | 0, R = R + Math.imul(ie, Ht) | 0, Y = Y + Math.imul(ie, zt) | 0, j = j + Math.imul(V, Vt) | 0, R = R + Math.imul(V, Ft) | 0, R = R + Math.imul(X, Vt) | 0, Y = Y + Math.imul(X, Ft) | 0;
            var cn = (G + j | 0) + ((R & 8191) << 13) | 0;
            G = (Y + (R >>> 13) | 0) + (cn >>> 26) | 0, cn &= 67108863, j = Math.imul(ot, Ke), R = Math.imul(ot, mt), R = R + Math.imul(lt, Ke) | 0, Y = Math.imul(lt, mt), j = j + Math.imul(at, vt) | 0, R = R + Math.imul(at, hn) | 0, R = R + Math.imul(tt, vt) | 0, Y = Y + Math.imul(tt, hn) | 0, j = j + Math.imul(Be, bn) | 0, R = R + Math.imul(Be, On) | 0, R = R + Math.imul(bt, bn) | 0, Y = Y + Math.imul(bt, On) | 0, j = j + Math.imul(me, Lt) | 0, R = R + Math.imul(me, jt) | 0, R = R + Math.imul(Re, Lt) | 0, Y = Y + Math.imul(Re, jt) | 0, j = j + Math.imul(z, Ht) | 0, R = R + Math.imul(z, zt) | 0, R = R + Math.imul(Z, Ht) | 0, Y = Y + Math.imul(Z, zt) | 0, j = j + Math.imul(ne, Vt) | 0, R = R + Math.imul(ne, Ft) | 0, R = R + Math.imul(ie, Vt) | 0, Y = Y + Math.imul(ie, Ft) | 0, j = j + Math.imul(V, Kt) | 0, R = R + Math.imul(V, Qt) | 0, R = R + Math.imul(X, Kt) | 0, Y = Y + Math.imul(X, Qt) | 0;
            var Er = (G + j | 0) + ((R & 8191) << 13) | 0;
            G = (Y + (R >>> 13) | 0) + (Er >>> 26) | 0, Er &= 67108863, j = Math.imul(Xe, Ke), R = Math.imul(Xe, mt), R = R + Math.imul(Q, Ke) | 0, Y = Math.imul(Q, mt), j = j + Math.imul(ot, vt) | 0, R = R + Math.imul(ot, hn) | 0, R = R + Math.imul(lt, vt) | 0, Y = Y + Math.imul(lt, hn) | 0, j = j + Math.imul(at, bn) | 0, R = R + Math.imul(at, On) | 0, R = R + Math.imul(tt, bn) | 0, Y = Y + Math.imul(tt, On) | 0, j = j + Math.imul(Be, Lt) | 0, R = R + Math.imul(Be, jt) | 0, R = R + Math.imul(bt, Lt) | 0, Y = Y + Math.imul(bt, jt) | 0, j = j + Math.imul(me, Ht) | 0, R = R + Math.imul(me, zt) | 0, R = R + Math.imul(Re, Ht) | 0, Y = Y + Math.imul(Re, zt) | 0, j = j + Math.imul(z, Vt) | 0, R = R + Math.imul(z, Ft) | 0, R = R + Math.imul(Z, Vt) | 0, Y = Y + Math.imul(Z, Ft) | 0, j = j + Math.imul(ne, Kt) | 0, R = R + Math.imul(ne, Qt) | 0, R = R + Math.imul(ie, Kt) | 0, Y = Y + Math.imul(ie, Qt) | 0, j = j + Math.imul(V, he) | 0, R = R + Math.imul(V, be) | 0, R = R + Math.imul(X, he) | 0, Y = Y + Math.imul(X, be) | 0;
            var er = (G + j | 0) + ((R & 8191) << 13) | 0;
            G = (Y + (R >>> 13) | 0) + (er >>> 26) | 0, er &= 67108863, j = Math.imul(B, Ke), R = Math.imul(B, mt), R = R + Math.imul(se, Ke) | 0, Y = Math.imul(se, mt), j = j + Math.imul(Xe, vt) | 0, R = R + Math.imul(Xe, hn) | 0, R = R + Math.imul(Q, vt) | 0, Y = Y + Math.imul(Q, hn) | 0, j = j + Math.imul(ot, bn) | 0, R = R + Math.imul(ot, On) | 0, R = R + Math.imul(lt, bn) | 0, Y = Y + Math.imul(lt, On) | 0, j = j + Math.imul(at, Lt) | 0, R = R + Math.imul(at, jt) | 0, R = R + Math.imul(tt, Lt) | 0, Y = Y + Math.imul(tt, jt) | 0, j = j + Math.imul(Be, Ht) | 0, R = R + Math.imul(Be, zt) | 0, R = R + Math.imul(bt, Ht) | 0, Y = Y + Math.imul(bt, zt) | 0, j = j + Math.imul(me, Vt) | 0, R = R + Math.imul(me, Ft) | 0, R = R + Math.imul(Re, Vt) | 0, Y = Y + Math.imul(Re, Ft) | 0, j = j + Math.imul(z, Kt) | 0, R = R + Math.imul(z, Qt) | 0, R = R + Math.imul(Z, Kt) | 0, Y = Y + Math.imul(Z, Qt) | 0, j = j + Math.imul(ne, he) | 0, R = R + Math.imul(ne, be) | 0, R = R + Math.imul(ie, he) | 0, Y = Y + Math.imul(ie, be) | 0, j = j + Math.imul(V, qe) | 0, R = R + Math.imul(V, Je) | 0, R = R + Math.imul(X, qe) | 0, Y = Y + Math.imul(X, Je) | 0;
            var Js = (G + j | 0) + ((R & 8191) << 13) | 0;
            G = (Y + (R >>> 13) | 0) + (Js >>> 26) | 0, Js &= 67108863, j = Math.imul(ye, Ke), R = Math.imul(ye, mt), R = R + Math.imul(Se, Ke) | 0, Y = Math.imul(Se, mt), j = j + Math.imul(B, vt) | 0, R = R + Math.imul(B, hn) | 0, R = R + Math.imul(se, vt) | 0, Y = Y + Math.imul(se, hn) | 0, j = j + Math.imul(Xe, bn) | 0, R = R + Math.imul(Xe, On) | 0, R = R + Math.imul(Q, bn) | 0, Y = Y + Math.imul(Q, On) | 0, j = j + Math.imul(ot, Lt) | 0, R = R + Math.imul(ot, jt) | 0, R = R + Math.imul(lt, Lt) | 0, Y = Y + Math.imul(lt, jt) | 0, j = j + Math.imul(at, Ht) | 0, R = R + Math.imul(at, zt) | 0, R = R + Math.imul(tt, Ht) | 0, Y = Y + Math.imul(tt, zt) | 0, j = j + Math.imul(Be, Vt) | 0, R = R + Math.imul(Be, Ft) | 0, R = R + Math.imul(bt, Vt) | 0, Y = Y + Math.imul(bt, Ft) | 0, j = j + Math.imul(me, Kt) | 0, R = R + Math.imul(me, Qt) | 0, R = R + Math.imul(Re, Kt) | 0, Y = Y + Math.imul(Re, Qt) | 0, j = j + Math.imul(z, he) | 0, R = R + Math.imul(z, be) | 0, R = R + Math.imul(Z, he) | 0, Y = Y + Math.imul(Z, be) | 0, j = j + Math.imul(ne, qe) | 0, R = R + Math.imul(ne, Je) | 0, R = R + Math.imul(ie, qe) | 0, Y = Y + Math.imul(ie, Je) | 0, j = j + Math.imul(V, Le) | 0, R = R + Math.imul(V, rt) | 0, R = R + Math.imul(X, Le) | 0, Y = Y + Math.imul(X, rt) | 0;
            var Qi = (G + j | 0) + ((R & 8191) << 13) | 0;
            G = (Y + (R >>> 13) | 0) + (Qi >>> 26) | 0, Qi &= 67108863, j = Math.imul(ye, vt), R = Math.imul(ye, hn), R = R + Math.imul(Se, vt) | 0, Y = Math.imul(Se, hn), j = j + Math.imul(B, bn) | 0, R = R + Math.imul(B, On) | 0, R = R + Math.imul(se, bn) | 0, Y = Y + Math.imul(se, On) | 0, j = j + Math.imul(Xe, Lt) | 0, R = R + Math.imul(Xe, jt) | 0, R = R + Math.imul(Q, Lt) | 0, Y = Y + Math.imul(Q, jt) | 0, j = j + Math.imul(ot, Ht) | 0, R = R + Math.imul(ot, zt) | 0, R = R + Math.imul(lt, Ht) | 0, Y = Y + Math.imul(lt, zt) | 0, j = j + Math.imul(at, Vt) | 0, R = R + Math.imul(at, Ft) | 0, R = R + Math.imul(tt, Vt) | 0, Y = Y + Math.imul(tt, Ft) | 0, j = j + Math.imul(Be, Kt) | 0, R = R + Math.imul(Be, Qt) | 0, R = R + Math.imul(bt, Kt) | 0, Y = Y + Math.imul(bt, Qt) | 0, j = j + Math.imul(me, he) | 0, R = R + Math.imul(me, be) | 0, R = R + Math.imul(Re, he) | 0, Y = Y + Math.imul(Re, be) | 0, j = j + Math.imul(z, qe) | 0, R = R + Math.imul(z, Je) | 0, R = R + Math.imul(Z, qe) | 0, Y = Y + Math.imul(Z, Je) | 0, j = j + Math.imul(ne, Le) | 0, R = R + Math.imul(ne, rt) | 0, R = R + Math.imul(ie, Le) | 0, Y = Y + Math.imul(ie, rt) | 0;
            var Ji = (G + j | 0) + ((R & 8191) << 13) | 0;
            G = (Y + (R >>> 13) | 0) + (Ji >>> 26) | 0, Ji &= 67108863, j = Math.imul(ye, bn), R = Math.imul(ye, On), R = R + Math.imul(Se, bn) | 0, Y = Math.imul(Se, On), j = j + Math.imul(B, Lt) | 0, R = R + Math.imul(B, jt) | 0, R = R + Math.imul(se, Lt) | 0, Y = Y + Math.imul(se, jt) | 0, j = j + Math.imul(Xe, Ht) | 0, R = R + Math.imul(Xe, zt) | 0, R = R + Math.imul(Q, Ht) | 0, Y = Y + Math.imul(Q, zt) | 0, j = j + Math.imul(ot, Vt) | 0, R = R + Math.imul(ot, Ft) | 0, R = R + Math.imul(lt, Vt) | 0, Y = Y + Math.imul(lt, Ft) | 0, j = j + Math.imul(at, Kt) | 0, R = R + Math.imul(at, Qt) | 0, R = R + Math.imul(tt, Kt) | 0, Y = Y + Math.imul(tt, Qt) | 0, j = j + Math.imul(Be, he) | 0, R = R + Math.imul(Be, be) | 0, R = R + Math.imul(bt, he) | 0, Y = Y + Math.imul(bt, be) | 0, j = j + Math.imul(me, qe) | 0, R = R + Math.imul(me, Je) | 0, R = R + Math.imul(Re, qe) | 0, Y = Y + Math.imul(Re, Je) | 0, j = j + Math.imul(z, Le) | 0, R = R + Math.imul(z, rt) | 0, R = R + Math.imul(Z, Le) | 0, Y = Y + Math.imul(Z, rt) | 0;
            var Xi = (G + j | 0) + ((R & 8191) << 13) | 0;
            G = (Y + (R >>> 13) | 0) + (Xi >>> 26) | 0, Xi &= 67108863, j = Math.imul(ye, Lt), R = Math.imul(ye, jt), R = R + Math.imul(Se, Lt) | 0, Y = Math.imul(Se, jt), j = j + Math.imul(B, Ht) | 0, R = R + Math.imul(B, zt) | 0, R = R + Math.imul(se, Ht) | 0, Y = Y + Math.imul(se, zt) | 0, j = j + Math.imul(Xe, Vt) | 0, R = R + Math.imul(Xe, Ft) | 0, R = R + Math.imul(Q, Vt) | 0, Y = Y + Math.imul(Q, Ft) | 0, j = j + Math.imul(ot, Kt) | 0, R = R + Math.imul(ot, Qt) | 0, R = R + Math.imul(lt, Kt) | 0, Y = Y + Math.imul(lt, Qt) | 0, j = j + Math.imul(at, he) | 0, R = R + Math.imul(at, be) | 0, R = R + Math.imul(tt, he) | 0, Y = Y + Math.imul(tt, be) | 0, j = j + Math.imul(Be, qe) | 0, R = R + Math.imul(Be, Je) | 0, R = R + Math.imul(bt, qe) | 0, Y = Y + Math.imul(bt, Je) | 0, j = j + Math.imul(me, Le) | 0, R = R + Math.imul(me, rt) | 0, R = R + Math.imul(Re, Le) | 0, Y = Y + Math.imul(Re, rt) | 0;
            var Xs = (G + j | 0) + ((R & 8191) << 13) | 0;
            G = (Y + (R >>> 13) | 0) + (Xs >>> 26) | 0, Xs &= 67108863, j = Math.imul(ye, Ht), R = Math.imul(ye, zt), R = R + Math.imul(Se, Ht) | 0, Y = Math.imul(Se, zt), j = j + Math.imul(B, Vt) | 0, R = R + Math.imul(B, Ft) | 0, R = R + Math.imul(se, Vt) | 0, Y = Y + Math.imul(se, Ft) | 0, j = j + Math.imul(Xe, Kt) | 0, R = R + Math.imul(Xe, Qt) | 0, R = R + Math.imul(Q, Kt) | 0, Y = Y + Math.imul(Q, Qt) | 0, j = j + Math.imul(ot, he) | 0, R = R + Math.imul(ot, be) | 0, R = R + Math.imul(lt, he) | 0, Y = Y + Math.imul(lt, be) | 0, j = j + Math.imul(at, qe) | 0, R = R + Math.imul(at, Je) | 0, R = R + Math.imul(tt, qe) | 0, Y = Y + Math.imul(tt, Je) | 0, j = j + Math.imul(Be, Le) | 0, R = R + Math.imul(Be, rt) | 0, R = R + Math.imul(bt, Le) | 0, Y = Y + Math.imul(bt, rt) | 0;
            var Tr = (G + j | 0) + ((R & 8191) << 13) | 0;
            G = (Y + (R >>> 13) | 0) + (Tr >>> 26) | 0, Tr &= 67108863, j = Math.imul(ye, Vt), R = Math.imul(ye, Ft), R = R + Math.imul(Se, Vt) | 0, Y = Math.imul(Se, Ft), j = j + Math.imul(B, Kt) | 0, R = R + Math.imul(B, Qt) | 0, R = R + Math.imul(se, Kt) | 0, Y = Y + Math.imul(se, Qt) | 0, j = j + Math.imul(Xe, he) | 0, R = R + Math.imul(Xe, be) | 0, R = R + Math.imul(Q, he) | 0, Y = Y + Math.imul(Q, be) | 0, j = j + Math.imul(ot, qe) | 0, R = R + Math.imul(ot, Je) | 0, R = R + Math.imul(lt, qe) | 0, Y = Y + Math.imul(lt, Je) | 0, j = j + Math.imul(at, Le) | 0, R = R + Math.imul(at, rt) | 0, R = R + Math.imul(tt, Le) | 0, Y = Y + Math.imul(tt, rt) | 0;
            var Fl = (G + j | 0) + ((R & 8191) << 13) | 0;
            G = (Y + (R >>> 13) | 0) + (Fl >>> 26) | 0, Fl &= 67108863, j = Math.imul(ye, Kt), R = Math.imul(ye, Qt), R = R + Math.imul(Se, Kt) | 0, Y = Math.imul(Se, Qt), j = j + Math.imul(B, he) | 0, R = R + Math.imul(B, be) | 0, R = R + Math.imul(se, he) | 0, Y = Y + Math.imul(se, be) | 0, j = j + Math.imul(Xe, qe) | 0, R = R + Math.imul(Xe, Je) | 0, R = R + Math.imul(Q, qe) | 0, Y = Y + Math.imul(Q, Je) | 0, j = j + Math.imul(ot, Le) | 0, R = R + Math.imul(ot, rt) | 0, R = R + Math.imul(lt, Le) | 0, Y = Y + Math.imul(lt, rt) | 0;
            var Ul = (G + j | 0) + ((R & 8191) << 13) | 0;
            G = (Y + (R >>> 13) | 0) + (Ul >>> 26) | 0, Ul &= 67108863, j = Math.imul(ye, he), R = Math.imul(ye, be), R = R + Math.imul(Se, he) | 0, Y = Math.imul(Se, be), j = j + Math.imul(B, qe) | 0, R = R + Math.imul(B, Je) | 0, R = R + Math.imul(se, qe) | 0, Y = Y + Math.imul(se, Je) | 0, j = j + Math.imul(Xe, Le) | 0, R = R + Math.imul(Xe, rt) | 0, R = R + Math.imul(Q, Le) | 0, Y = Y + Math.imul(Q, rt) | 0;
            var jl = (G + j | 0) + ((R & 8191) << 13) | 0;
            G = (Y + (R >>> 13) | 0) + (jl >>> 26) | 0, jl &= 67108863, j = Math.imul(ye, qe), R = Math.imul(ye, Je), R = R + Math.imul(Se, qe) | 0, Y = Math.imul(Se, Je), j = j + Math.imul(B, Le) | 0, R = R + Math.imul(B, rt) | 0, R = R + Math.imul(se, Le) | 0, Y = Y + Math.imul(se, rt) | 0;
            var un = (G + j | 0) + ((R & 8191) << 13) | 0;
            G = (Y + (R >>> 13) | 0) + (un >>> 26) | 0, un &= 67108863, j = Math.imul(ye, Le), R = Math.imul(ye, rt), R = R + Math.imul(Se, Le) | 0, Y = Math.imul(Se, rt);
            var wr = (G + j | 0) + ((R & 8191) << 13) | 0;
            return G = (Y + (R >>> 13) | 0) + (wr >>> 26) | 0, wr &= 67108863, L[0] = ct, L[1] = ft, L[2] = an, L[3] = pn, L[4] = ln, L[5] = cn, L[6] = Er, L[7] = er, L[8] = Js, L[9] = Qi, L[10] = Ji, L[11] = Xi, L[12] = Xs, L[13] = Tr, L[14] = Fl, L[15] = Ul, L[16] = jl, L[17] = un, L[18] = wr, G !== 0 && (L[19] = G, T.length++), T
        };
        Math.imul || (w = b);

        function S(U, m, v) {
            v.negative = m.negative ^ U.negative, v.length = U.length + m.length;
            for (var T = 0, N = 0, O = 0; O < v.length - 1; O++) {
                var L = N;
                N = 0;
                for (var G = T & 67108863, j = Math.min(O, m.length - 1), R = Math.max(0, O - U.length + 1); R <= j; R++) {
                    var Y = O - R,
                        ve = U.words[Y] | 0,
                        V = m.words[R] | 0,
                        X = ve * V,
                        q = X & 67108863;
                    L = L + (X / 67108864 | 0) | 0, q = q + G | 0, G = q & 67108863, L = L + (q >>> 26) | 0, N += L >>> 26, L &= 67108863
                }
                v.words[O] = G, T = L, L = N
            }
            return T !== 0 ? v.words[O] = T : v.length--, v._strip()
        }

        function I(U, m, v) {
            return S(U, m, v)
        }
        s.prototype.mulTo = function(m, v) {
            var T, N = this.length + m.length;
            return this.length === 10 && m.length === 10 ? T = w(this, m, v) : N < 63 ? T = b(this, m, v) : N < 1024 ? T = S(this, m, v) : T = I(this, m, v), T
        }, s.prototype.mul = function(m) {
            var v = new s(null);
            return v.words = new Array(this.length + m.length), this.mulTo(m, v)
        }, s.prototype.mulf = function(m) {
            var v = new s(null);
            return v.words = new Array(this.length + m.length), I(this, m, v)
        }, s.prototype.imul = function(m) {
            return this.clone().mulTo(m, this)
        }, s.prototype.imuln = function(m) {
            var v = m < 0;
            v && (m = -m), r(typeof m == "number"), r(m < 67108864);
            for (var T = 0, N = 0; N < this.length; N++) {
                var O = (this.words[N] | 0) * m,
                    L = (O & 67108863) + (T & 67108863);
                T >>= 26, T += O / 67108864 | 0, T += L >>> 26, this.words[N] = L & 67108863
            }
            return T !== 0 && (this.words[N] = T, this.length++), v ? this.ineg() : this
        }, s.prototype.muln = function(m) {
            return this.clone().imuln(m)
        }, s.prototype.sqr = function() {
            return this.mul(this)
        }, s.prototype.isqr = function() {
            return this.imul(this.clone())
        }, s.prototype.pow = function(m) {
            var v = C(m);
            if (v.length === 0) return new s(1);
            for (var T = this, N = 0; N < v.length && v[N] === 0; N++, T = T.sqr());
            if (++N < v.length)
                for (var O = T.sqr(); N < v.length; N++, O = O.sqr()) v[N] !== 0 && (T = T.mul(O));
            return T
        }, s.prototype.iushln = function(m) {
            r(typeof m == "number" && m >= 0);
            var v = m % 26,
                T = (m - v) / 26,
                N = 67108863 >>> 26 - v << 26 - v,
                O;
            if (v !== 0) {
                var L = 0;
                for (O = 0; O < this.length; O++) {
                    var G = this.words[O] & N,
                        j = (this.words[O] | 0) - G << v;
                    this.words[O] = j | L, L = G >>> 26 - v
                }
                L && (this.words[O] = L, this.length++)
            }
            if (T !== 0) {
                for (O = this.length - 1; O >= 0; O--) this.words[O + T] = this.words[O];
                for (O = 0; O < T; O++) this.words[O] = 0;
                this.length += T
            }
            return this._strip()
        }, s.prototype.ishln = function(m) {
            return r(this.negative === 0), this.iushln(m)
        }, s.prototype.iushrn = function(m, v, T) {
            r(typeof m == "number" && m >= 0);
            var N;
            v ? N = (v - v % 26) / 26 : N = 0;
            var O = m % 26,
                L = Math.min((m - O) / 26, this.length),
                G = 67108863 ^ 67108863 >>> O << O,
                j = T;
            if (N -= L, N = Math.max(0, N), j) {
                for (var R = 0; R < L; R++) j.words[R] = this.words[R];
                j.length = L
            }
            if (L !== 0)
                if (this.length > L)
                    for (this.length -= L, R = 0; R < this.length; R++) this.words[R] = this.words[R + L];
                else this.words[0] = 0, this.length = 1;
            var Y = 0;
            for (R = this.length - 1; R >= 0 && (Y !== 0 || R >= N); R--) {
                var ve = this.words[R] | 0;
                this.words[R] = Y << 26 - O | ve >>> O, Y = ve & G
            }
            return j && Y !== 0 && (j.words[j.length++] = Y), this.length === 0 && (this.words[0] = 0, this.length = 1), this._strip()
        }, s.prototype.ishrn = function(m, v, T) {
            return r(this.negative === 0), this.iushrn(m, v, T)
        }, s.prototype.shln = function(m) {
            return this.clone().ishln(m)
        }, s.prototype.ushln = function(m) {
            return this.clone().iushln(m)
        }, s.prototype.shrn = function(m) {
            return this.clone().ishrn(m)
        }, s.prototype.ushrn = function(m) {
            return this.clone().iushrn(m)
        }, s.prototype.testn = function(m) {
            r(typeof m == "number" && m >= 0);
            var v = m % 26,
                T = (m - v) / 26,
                N = 1 << v;
            if (this.length <= T) return !1;
            var O = this.words[T];
            return !!(O & N)
        }, s.prototype.imaskn = function(m) {
            r(typeof m == "number" && m >= 0);
            var v = m % 26,
                T = (m - v) / 26;
            if (r(this.negative === 0, "imaskn works only with positive numbers"), this.length <= T) return this;
            if (v !== 0 && T++, this.length = Math.min(T, this.length), v !== 0) {
                var N = 67108863 ^ 67108863 >>> v << v;
                this.words[this.length - 1] &= N
            }
            return this._strip()
        }, s.prototype.maskn = function(m) {
            return this.clone().imaskn(m)
        }, s.prototype.iaddn = function(m) {
            return r(typeof m == "number"), r(m < 67108864), m < 0 ? this.isubn(-m) : this.negative !== 0 ? this.length === 1 && (this.words[0] | 0) <= m ? (this.words[0] = m - (this.words[0] | 0), this.negative = 0, this) : (this.negative = 0, this.isubn(m), this.negative = 1, this) : this._iaddn(m)
        }, s.prototype._iaddn = function(m) {
            this.words[0] += m;
            for (var v = 0; v < this.length && this.words[v] >= 67108864; v++) this.words[v] -= 67108864, v === this.length - 1 ? this.words[v + 1] = 1 : this.words[v + 1]++;
            return this.length = Math.max(this.length, v + 1), this
        }, s.prototype.isubn = function(m) {
            if (r(typeof m == "number"), r(m < 67108864), m < 0) return this.iaddn(-m);
            if (this.negative !== 0) return this.negative = 0, this.iaddn(m), this.negative = 1, this;
            if (this.words[0] -= m, this.length === 1 && this.words[0] < 0) this.words[0] = -this.words[0], this.negative = 1;
            else
                for (var v = 0; v < this.length && this.words[v] < 0; v++) this.words[v] += 67108864, this.words[v + 1] -= 1;
            return this._strip()
        }, s.prototype.addn = function(m) {
            return this.clone().iaddn(m)
        }, s.prototype.subn = function(m) {
            return this.clone().isubn(m)
        }, s.prototype.iabs = function() {
            return this.negative = 0, this
        }, s.prototype.abs = function() {
            return this.clone().iabs()
        }, s.prototype._ishlnsubmul = function(m, v, T) {
            var N = m.length + T,
                O;
            this._expand(N);
            var L, G = 0;
            for (O = 0; O < m.length; O++) {
                L = (this.words[O + T] | 0) + G;
                var j = (m.words[O] | 0) * v;
                L -= j & 67108863, G = (L >> 26) - (j / 67108864 | 0), this.words[O + T] = L & 67108863
            }
            for (; O < this.length - T; O++) L = (this.words[O + T] | 0) + G, G = L >> 26, this.words[O + T] = L & 67108863;
            if (G === 0) return this._strip();
            for (r(G === -1), G = 0, O = 0; O < this.length; O++) L = -(this.words[O] | 0) + G, G = L >> 26, this.words[O] = L & 67108863;
            return this.negative = 1, this._strip()
        }, s.prototype._wordDiv = function(m, v) {
            var T = this.length - m.length,
                N = this.clone(),
                O = m,
                L = O.words[O.length - 1] | 0,
                G = this._countBits(L);
            T = 26 - G, T !== 0 && (O = O.ushln(T), N.iushln(T), L = O.words[O.length - 1] | 0);
            var j = N.length - O.length,
                R;
            if (v !== "mod") {
                R = new s(null), R.length = j + 1, R.words = new Array(R.length);
                for (var Y = 0; Y < R.length; Y++) R.words[Y] = 0
            }
            var ve = N.clone()._ishlnsubmul(O, 1, j);
            ve.negative === 0 && (N = ve, R && (R.words[j] = 1));
            for (var V = j - 1; V >= 0; V--) {
                var X = (N.words[O.length + V] | 0) * 67108864 + (N.words[O.length + V - 1] | 0);
                for (X = Math.min(X / L | 0, 67108863), N._ishlnsubmul(O, X, V); N.negative !== 0;) X--, N.negative = 0, N._ishlnsubmul(O, 1, V), N.isZero() || (N.negative ^= 1);
                R && (R.words[V] = X)
            }
            return R && R._strip(), N._strip(), v !== "div" && T !== 0 && N.iushrn(T), {
                div: R || null,
                mod: N
            }
        }, s.prototype.divmod = function(m, v, T) {
            if (r(!m.isZero()), this.isZero()) return {
                div: new s(0),
                mod: new s(0)
            };
            var N, O, L;
            return this.negative !== 0 && m.negative === 0 ? (L = this.neg().divmod(m, v), v !== "mod" && (N = L.div.neg()), v !== "div" && (O = L.mod.neg(), T && O.negative !== 0 && O.iadd(m)), {
                div: N,
                mod: O
            }) : this.negative === 0 && m.negative !== 0 ? (L = this.divmod(m.neg(), v), v !== "mod" && (N = L.div.neg()), {
                div: N,
                mod: L.mod
            }) : this.negative & m.negative ? (L = this.neg().divmod(m.neg(), v), v !== "div" && (O = L.mod.neg(), T && O.negative !== 0 && O.isub(m)), {
                div: L.div,
                mod: O
            }) : m.length > this.length || this.cmp(m) < 0 ? {
                div: new s(0),
                mod: this
            } : m.length === 1 ? v === "div" ? {
                div: this.divn(m.words[0]),
                mod: null
            } : v === "mod" ? {
                div: null,
                mod: new s(this.modrn(m.words[0]))
            } : {
                div: this.divn(m.words[0]),
                mod: new s(this.modrn(m.words[0]))
            } : this._wordDiv(m, v)
        }, s.prototype.div = function(m) {
            return this.divmod(m, "div", !1).div
        }, s.prototype.mod = function(m) {
            return this.divmod(m, "mod", !1).mod
        }, s.prototype.umod = function(m) {
            return this.divmod(m, "mod", !0).mod
        }, s.prototype.divRound = function(m) {
            var v = this.divmod(m);
            if (v.mod.isZero()) return v.div;
            var T = v.div.negative !== 0 ? v.mod.isub(m) : v.mod,
                N = m.ushrn(1),
                O = m.andln(1),
                L = T.cmp(N);
            return L < 0 || O === 1 && L === 0 ? v.div : v.div.negative !== 0 ? v.div.isubn(1) : v.div.iaddn(1)
        }, s.prototype.modrn = function(m) {
            var v = m < 0;
            v && (m = -m), r(m <= 67108863);
            for (var T = (1 << 26) % m, N = 0, O = this.length - 1; O >= 0; O--) N = (T * N + (this.words[O] | 0)) % m;
            return v ? -N : N
        }, s.prototype.modn = function(m) {
            return this.modrn(m)
        }, s.prototype.idivn = function(m) {
            var v = m < 0;
            v && (m = -m), r(m <= 67108863);
            for (var T = 0, N = this.length - 1; N >= 0; N--) {
                var O = (this.words[N] | 0) + T * 67108864;
                this.words[N] = O / m | 0, T = O % m
            }
            return this._strip(), v ? this.ineg() : this
        }, s.prototype.divn = function(m) {
            return this.clone().idivn(m)
        }, s.prototype.egcd = function(m) {
            r(m.negative === 0), r(!m.isZero());
            var v = this,
                T = m.clone();
            v.negative !== 0 ? v = v.umod(m) : v = v.clone();
            for (var N = new s(1), O = new s(0), L = new s(0), G = new s(1), j = 0; v.isEven() && T.isEven();) v.iushrn(1), T.iushrn(1), ++j;
            for (var R = T.clone(), Y = v.clone(); !v.isZero();) {
                for (var ve = 0, V = 1; !(v.words[0] & V) && ve < 26; ++ve, V <<= 1);
                if (ve > 0)
                    for (v.iushrn(ve); ve-- > 0;)(N.isOdd() || O.isOdd()) && (N.iadd(R), O.isub(Y)), N.iushrn(1), O.iushrn(1);
                for (var X = 0, q = 1; !(T.words[0] & q) && X < 26; ++X, q <<= 1);
                if (X > 0)
                    for (T.iushrn(X); X-- > 0;)(L.isOdd() || G.isOdd()) && (L.iadd(R), G.isub(Y)), L.iushrn(1), G.iushrn(1);
                v.cmp(T) >= 0 ? (v.isub(T), N.isub(L), O.isub(G)) : (T.isub(v), L.isub(N), G.isub(O))
            }
            return {
                a: L,
                b: G,
                gcd: T.iushln(j)
            }
        }, s.prototype._invmp = function(m) {
            r(m.negative === 0), r(!m.isZero());
            var v = this,
                T = m.clone();
            v.negative !== 0 ? v = v.umod(m) : v = v.clone();
            for (var N = new s(1), O = new s(0), L = T.clone(); v.cmpn(1) > 0 && T.cmpn(1) > 0;) {
                for (var G = 0, j = 1; !(v.words[0] & j) && G < 26; ++G, j <<= 1);
                if (G > 0)
                    for (v.iushrn(G); G-- > 0;) N.isOdd() && N.iadd(L), N.iushrn(1);
                for (var R = 0, Y = 1; !(T.words[0] & Y) && R < 26; ++R, Y <<= 1);
                if (R > 0)
                    for (T.iushrn(R); R-- > 0;) O.isOdd() && O.iadd(L), O.iushrn(1);
                v.cmp(T) >= 0 ? (v.isub(T), N.isub(O)) : (T.isub(v), O.isub(N))
            }
            var ve;
            return v.cmpn(1) === 0 ? ve = N : ve = O, ve.cmpn(0) < 0 && ve.iadd(m), ve
        }, s.prototype.gcd = function(m) {
            if (this.isZero()) return m.abs();
            if (m.isZero()) return this.abs();
            var v = this.clone(),
                T = m.clone();
            v.negative = 0, T.negative = 0;
            for (var N = 0; v.isEven() && T.isEven(); N++) v.iushrn(1), T.iushrn(1);
            do {
                for (; v.isEven();) v.iushrn(1);
                for (; T.isEven();) T.iushrn(1);
                var O = v.cmp(T);
                if (O < 0) {
                    var L = v;
                    v = T, T = L
                } else if (O === 0 || T.cmpn(1) === 0) break;
                v.isub(T)
            } while (!0);
            return T.iushln(N)
        }, s.prototype.invm = function(m) {
            return this.egcd(m).a.umod(m)
        }, s.prototype.isEven = function() {
            return (this.words[0] & 1) === 0
        }, s.prototype.isOdd = function() {
            return (this.words[0] & 1) === 1
        }, s.prototype.andln = function(m) {
            return this.words[0] & m
        }, s.prototype.bincn = function(m) {
            r(typeof m == "number");
            var v = m % 26,
                T = (m - v) / 26,
                N = 1 << v;
            if (this.length <= T) return this._expand(T + 1), this.words[T] |= N, this;
            for (var O = N, L = T; O !== 0 && L < this.length; L++) {
                var G = this.words[L] | 0;
                G += O, O = G >>> 26, G &= 67108863, this.words[L] = G
            }
            return O !== 0 && (this.words[L] = O, this.length++), this
        }, s.prototype.isZero = function() {
            return this.length === 1 && this.words[0] === 0
        }, s.prototype.cmpn = function(m) {
            var v = m < 0;
            if (this.negative !== 0 && !v) return -1;
            if (this.negative === 0 && v) return 1;
            this._strip();
            var T;
            if (this.length > 1) T = 1;
            else {
                v && (m = -m), r(m <= 67108863, "Number is too big");
                var N = this.words[0] | 0;
                T = N === m ? 0 : N < m ? -1 : 1
            }
            return this.negative !== 0 ? -T | 0 : T
        }, s.prototype.cmp = function(m) {
            if (this.negative !== 0 && m.negative === 0) return -1;
            if (this.negative === 0 && m.negative !== 0) return 1;
            var v = this.ucmp(m);
            return this.negative !== 0 ? -v | 0 : v
        }, s.prototype.ucmp = function(m) {
            if (this.length > m.length) return 1;
            if (this.length < m.length) return -1;
            for (var v = 0, T = this.length - 1; T >= 0; T--) {
                var N = this.words[T] | 0,
                    O = m.words[T] | 0;
                if (N !== O) {
                    N < O ? v = -1 : N > O && (v = 1);
                    break
                }
            }
            return v
        }, s.prototype.gtn = function(m) {
            return this.cmpn(m) === 1
        }, s.prototype.gt = function(m) {
            return this.cmp(m) === 1
        }, s.prototype.gten = function(m) {
            return this.cmpn(m) >= 0
        }, s.prototype.gte = function(m) {
            return this.cmp(m) >= 0
        }, s.prototype.ltn = function(m) {
            return this.cmpn(m) === -1
        }, s.prototype.lt = function(m) {
            return this.cmp(m) === -1
        }, s.prototype.lten = function(m) {
            return this.cmpn(m) <= 0
        }, s.prototype.lte = function(m) {
            return this.cmp(m) <= 0
        }, s.prototype.eqn = function(m) {
            return this.cmpn(m) === 0
        }, s.prototype.eq = function(m) {
            return this.cmp(m) === 0
        }, s.red = function(m) {
            return new K(m)
        }, s.prototype.toRed = function(m) {
            return r(!this.red, "Already a number in reduction context"), r(this.negative === 0, "red works only with positives"), m.convertTo(this)._forceRed(m)
        }, s.prototype.fromRed = function() {
            return r(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this)
        }, s.prototype._forceRed = function(m) {
            return this.red = m, this
        }, s.prototype.forceRed = function(m) {
            return r(!this.red, "Already a number in reduction context"), this._forceRed(m)
        }, s.prototype.redAdd = function(m) {
            return r(this.red, "redAdd works only with red numbers"), this.red.add(this, m)
        }, s.prototype.redIAdd = function(m) {
            return r(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, m)
        }, s.prototype.redSub = function(m) {
            return r(this.red, "redSub works only with red numbers"), this.red.sub(this, m)
        }, s.prototype.redISub = function(m) {
            return r(this.red, "redISub works only with red numbers"), this.red.isub(this, m)
        }, s.prototype.redShl = function(m) {
            return r(this.red, "redShl works only with red numbers"), this.red.shl(this, m)
        }, s.prototype.redMul = function(m) {
            return r(this.red, "redMul works only with red numbers"), this.red._verify2(this, m), this.red.mul(this, m)
        }, s.prototype.redIMul = function(m) {
            return r(this.red, "redMul works only with red numbers"), this.red._verify2(this, m), this.red.imul(this, m)
        }, s.prototype.redSqr = function() {
            return r(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this)
        }, s.prototype.redISqr = function() {
            return r(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this)
        }, s.prototype.redSqrt = function() {
            return r(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this)
        }, s.prototype.redInvm = function() {
            return r(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this)
        }, s.prototype.redNeg = function() {
            return r(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this)
        }, s.prototype.redPow = function(m) {
            return r(this.red && !m.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, m)
        };
        var P = {
            k256: null,
            p224: null,
            p192: null,
            p25519: null
        };

        function M(U, m) {
            this.name = U, this.p = new s(m, 16), this.n = this.p.bitLength(), this.k = new s(1).iushln(this.n).isub(this.p), this.tmp = this._tmp()
        }
        M.prototype._tmp = function() {
            var m = new s(null);
            return m.words = new Array(Math.ceil(this.n / 13)), m
        }, M.prototype.ireduce = function(m) {
            var v = m,
                T;
            do this.split(v, this.tmp), v = this.imulK(v), v = v.iadd(this.tmp), T = v.bitLength(); while (T > this.n);
            var N = T < this.n ? -1 : v.ucmp(this.p);
            return N === 0 ? (v.words[0] = 0, v.length = 1) : N > 0 ? v.isub(this.p) : v.strip !== void 0 ? v.strip() : v._strip(), v
        }, M.prototype.split = function(m, v) {
            m.iushrn(this.n, 0, v)
        }, M.prototype.imulK = function(m) {
            return m.imul(this.k)
        };

        function A() {
            M.call(this, "k256", "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f")
        }
        i(A, M), A.prototype.split = function(m, v) {
            for (var T = 4194303, N = Math.min(m.length, 9), O = 0; O < N; O++) v.words[O] = m.words[O];
            if (v.length = N, m.length <= 9) {
                m.words[0] = 0, m.length = 1;
                return
            }
            var L = m.words[9];
            for (v.words[v.length++] = L & T, O = 10; O < m.length; O++) {
                var G = m.words[O] | 0;
                m.words[O - 10] = (G & T) << 4 | L >>> 22, L = G
            }
            L >>>= 22, m.words[O - 10] = L, L === 0 && m.length > 10 ? m.length -= 10 : m.length -= 9
        }, A.prototype.imulK = function(m) {
            m.words[m.length] = 0, m.words[m.length + 1] = 0, m.length += 2;
            for (var v = 0, T = 0; T < m.length; T++) {
                var N = m.words[T] | 0;
                v += N * 977, m.words[T] = v & 67108863, v = N * 64 + (v / 67108864 | 0)
            }
            return m.words[m.length - 1] === 0 && (m.length--, m.words[m.length - 1] === 0 && m.length--), m
        };

        function E() {
            M.call(this, "p224", "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001")
        }
        i(E, M);

        function $() {
            M.call(this, "p192", "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff")
        }
        i($, M);

        function H() {
            M.call(this, "25519", "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed")
        }
        i(H, M), H.prototype.imulK = function(m) {
            for (var v = 0, T = 0; T < m.length; T++) {
                var N = (m.words[T] | 0) * 19 + v,
                    O = N & 67108863;
                N >>>= 26, m.words[T] = O, v = N
            }
            return v !== 0 && (m.words[m.length++] = v), m
        }, s._prime = function(m) {
            if (P[m]) return P[m];
            var v;
            if (m === "k256") v = new A;
            else if (m === "p224") v = new E;
            else if (m === "p192") v = new $;
            else if (m === "p25519") v = new H;
            else throw new Error("Unknown prime " + m);
            return P[m] = v, v
        };

        function K(U) {
            if (typeof U == "string") {
                var m = s._prime(U);
                this.m = m.p, this.prime = m
            } else r(U.gtn(1), "modulus must be greater than 1"), this.m = U, this.prime = null
        }
        K.prototype._verify1 = function(m) {
            r(m.negative === 0, "red works only with positives"), r(m.red, "red works only with red numbers")
        }, K.prototype._verify2 = function(m, v) {
            r((m.negative | v.negative) === 0, "red works only with positives"), r(m.red && m.red === v.red, "red works only with red numbers")
        }, K.prototype.imod = function(m) {
            return this.prime ? this.prime.ireduce(m)._forceRed(this) : (u(m, m.umod(this.m)._forceRed(this)), m)
        }, K.prototype.neg = function(m) {
            return m.isZero() ? m.clone() : this.m.sub(m)._forceRed(this)
        }, K.prototype.add = function(m, v) {
            this._verify2(m, v);
            var T = m.add(v);
            return T.cmp(this.m) >= 0 && T.isub(this.m), T._forceRed(this)
        }, K.prototype.iadd = function(m, v) {
            this._verify2(m, v);
            var T = m.iadd(v);
            return T.cmp(this.m) >= 0 && T.isub(this.m), T
        }, K.prototype.sub = function(m, v) {
            this._verify2(m, v);
            var T = m.sub(v);
            return T.cmpn(0) < 0 && T.iadd(this.m), T._forceRed(this)
        }, K.prototype.isub = function(m, v) {
            this._verify2(m, v);
            var T = m.isub(v);
            return T.cmpn(0) < 0 && T.iadd(this.m), T
        }, K.prototype.shl = function(m, v) {
            return this._verify1(m), this.imod(m.ushln(v))
        }, K.prototype.imul = function(m, v) {
            return this._verify2(m, v), this.imod(m.imul(v))
        }, K.prototype.mul = function(m, v) {
            return this._verify2(m, v), this.imod(m.mul(v))
        }, K.prototype.isqr = function(m) {
            return this.imul(m, m.clone())
        }, K.prototype.sqr = function(m) {
            return this.mul(m, m)
        }, K.prototype.sqrt = function(m) {
            if (m.isZero()) return m.clone();
            var v = this.m.andln(3);
            if (r(v % 2 === 1), v === 3) {
                var T = this.m.add(new s(1)).iushrn(2);
                return this.pow(m, T)
            }
            for (var N = this.m.subn(1), O = 0; !N.isZero() && N.andln(1) === 0;) O++, N.iushrn(1);
            r(!N.isZero());
            var L = new s(1).toRed(this),
                G = L.redNeg(),
                j = this.m.subn(1).iushrn(1),
                R = this.m.bitLength();
            for (R = new s(2 * R * R).toRed(this); this.pow(R, j).cmp(G) !== 0;) R.redIAdd(G);
            for (var Y = this.pow(R, N), ve = this.pow(m, N.addn(1).iushrn(1)), V = this.pow(m, N), X = O; V.cmp(L) !== 0;) {
                for (var q = V, ne = 0; q.cmp(L) !== 0; ne++) q = q.redSqr();
                r(ne < X);
                var ie = this.pow(Y, new s(1).iushln(X - ne - 1));
                ve = ve.redMul(ie), Y = ie.redSqr(), V = V.redMul(Y), X = ne
            }
            return ve
        }, K.prototype.invm = function(m) {
            var v = m._invmp(this.m);
            return v.negative !== 0 ? (v.negative = 0, this.imod(v).redNeg()) : this.imod(v)
        }, K.prototype.pow = function(m, v) {
            if (v.isZero()) return new s(1).toRed(this);
            if (v.cmpn(1) === 0) return m.clone();
            var T = 4,
                N = new Array(1 << T);
            N[0] = new s(1).toRed(this), N[1] = m;
            for (var O = 2; O < N.length; O++) N[O] = this.mul(N[O - 1], m);
            var L = N[0],
                G = 0,
                j = 0,
                R = v.bitLength() % 26;
            for (R === 0 && (R = 26), O = v.length - 1; O >= 0; O--) {
                for (var Y = v.words[O], ve = R - 1; ve >= 0; ve--) {
                    var V = Y >> ve & 1;
                    if (L !== N[0] && (L = this.sqr(L)), V === 0 && G === 0) {
                        j = 0;
                        continue
                    }
                    G <<= 1, G |= V, j++, !(j !== T && (O !== 0 || ve !== 0)) && (L = this.mul(L, N[G]), j = 0, G = 0)
                }
                R = 26
            }
            return L
        }, K.prototype.convertTo = function(m) {
            var v = m.umod(this.m);
            return v === m ? v.clone() : v
        }, K.prototype.convertFrom = function(m) {
            var v = m.clone();
            return v.red = null, v
        }, s.mont = function(m) {
            return new te(m)
        };

        function te(U) {
            K.call(this, U), this.shift = this.m.bitLength(), this.shift % 26 !== 0 && (this.shift += 26 - this.shift % 26), this.r = new s(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv)
        }
        i(te, K), te.prototype.convertTo = function(m) {
            return this.imod(m.ushln(this.shift))
        }, te.prototype.convertFrom = function(m) {
            var v = this.imod(m.mul(this.rinv));
            return v.red = null, v
        }, te.prototype.imul = function(m, v) {
            if (m.isZero() || v.isZero()) return m.words[0] = 0, m.length = 1, m;
            var T = m.imul(v),
                N = T.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m),
                O = T.isub(N).iushrn(this.shift),
                L = O;
            return O.cmp(this.m) >= 0 ? L = O.isub(this.m) : O.cmpn(0) < 0 && (L = O.iadd(this.m)), L._forceRed(this)
        }, te.prototype.mul = function(m, v) {
            if (m.isZero() || v.isZero()) return new s(0)._forceRed(this);
            var T = m.mul(v),
                N = T.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m),
                O = T.isub(N).iushrn(this.shift),
                L = O;
            return O.cmp(this.m) >= 0 ? L = O.isub(this.m) : O.cmpn(0) < 0 && (L = O.iadd(this.m)), L._forceRed(this)
        }, te.prototype.invm = function(m) {
            var v = this.imod(m._invmp(this.m).mul(this.r2));
            return v._forceRed(this)
        }
    })(t, st)
})(GL);
var ME = GL.exports;
const Dke = co(ME);
var D2 = {};
Object.defineProperty(D2, "__esModule", {
    value: !0
});
D2.EVENTS = void 0;
D2.EVENTS = {
    STARTED_CONNECTING: "walletlink_sdk.started.connecting",
    CONNECTED_STATE_CHANGE: "walletlink_sdk.connected",
    DISCONNECTED: "walletlink_sdk.disconnected",
    METADATA_DESTROYED: "walletlink_sdk_metadata_destroyed",
    LINKED: "walletlink_sdk.linked",
    FAILURE: "walletlink_sdk.generic_failure",
    SESSION_CONFIG_RECEIVED: "walletlink_sdk.session_config_event_received",
    ETH_ACCOUNTS_STATE: "walletlink_sdk.eth_accounts_state",
    SESSION_STATE_CHANGE: "walletlink_sdk.session_state_change",
    UNLINKED_ERROR_STATE: "walletlink_sdk.unlinked_error_state",
    SKIPPED_CLEARING_SESSION: "walletlink_sdk.skipped_clearing_session",
    GENERAL_ERROR: "walletlink_sdk.general_error",
    WEB3_REQUEST: "walletlink_sdk.web3.request",
    WEB3_REQUEST_PUBLISHED: "walletlink_sdk.web3.request_published",
    WEB3_RESPONSE: "walletlink_sdk.web3.response",
    UNKNOWN_ADDRESS_ENCOUNTERED: "walletlink_sdk.unknown_address_encountered"
};
var DE = {},
    qL = {},
    Vp = {},
    $ke = o6;
o6.default = o6;
o6.stable = Gie;
o6.stableStringify = Gie;
var VC = "[...]",
    Wie = "[Circular]",
    Fm = [],
    p1 = [];

function Vie() {
    return {
        depthLimit: Number.MAX_SAFE_INTEGER,
        edgesLimit: Number.MAX_SAFE_INTEGER
    }
}

function o6(t, e, n, r) {
    typeof r > "u" && (r = Vie()), rM(t, "", 0, [], void 0, 0, r);
    var i;
    try {
        p1.length === 0 ? i = JSON.stringify(t, e, n) : i = JSON.stringify(t, qie(e), n)
    } catch {
        return JSON.stringify("[unable to serialize, circular reference is too complex to analyze]")
    } finally {
        for (; Fm.length !== 0;) {
            var s = Fm.pop();
            s.length === 4 ? Object.defineProperty(s[0], s[1], s[3]) : s[0][s[1]] = s[2]
        }
    }
    return i
}

function lv(t, e, n, r) {
    var i = Object.getOwnPropertyDescriptor(r, n);
    i.get !== void 0 ? i.configurable ? (Object.defineProperty(r, n, {
        value: t
    }), Fm.push([r, n, e, i])) : p1.push([e, n, t]) : (r[n] = t, Fm.push([r, n, e]))
}

function rM(t, e, n, r, i, s, o) {
    s += 1;
    var a;
    if (typeof t == "object" && t !== null) {
        for (a = 0; a < r.length; a++)
            if (r[a] === t) {
                lv(Wie, t, e, i);
                return
            }
        if (typeof o.depthLimit < "u" && s > o.depthLimit) {
            lv(VC, t, e, i);
            return
        }
        if (typeof o.edgesLimit < "u" && n + 1 > o.edgesLimit) {
            lv(VC, t, e, i);
            return
        }
        if (r.push(t), Array.isArray(t))
            for (a = 0; a < t.length; a++) rM(t[a], a, a, r, t, s, o);
        else {
            var l = Object.keys(t);
            for (a = 0; a < l.length; a++) {
                var c = l[a];
                rM(t[c], c, a, r, t, s, o)
            }
        }
        r.pop()
    }
}

function Lke(t, e) {
    return t < e ? -1 : t > e ? 1 : 0
}

function Gie(t, e, n, r) {
    typeof r > "u" && (r = Vie());
    var i = iM(t, "", 0, [], void 0, 0, r) || t,
        s;
    try {
        p1.length === 0 ? s = JSON.stringify(i, e, n) : s = JSON.stringify(i, qie(e), n)
    } catch {
        return JSON.stringify("[unable to serialize, circular reference is too complex to analyze]")
    } finally {
        for (; Fm.length !== 0;) {
            var o = Fm.pop();
            o.length === 4 ? Object.defineProperty(o[0], o[1], o[3]) : o[0][o[1]] = o[2]
        }
    }
    return s
}

function iM(t, e, n, r, i, s, o) {
    s += 1;
    var a;
    if (typeof t == "object" && t !== null) {
        for (a = 0; a < r.length; a++)
            if (r[a] === t) {
                lv(Wie, t, e, i);
                return
            }
        try {
            if (typeof t.toJSON == "function") return
        } catch {
            return
        }
        if (typeof o.depthLimit < "u" && s > o.depthLimit) {
            lv(VC, t, e, i);
            return
        }
        if (typeof o.edgesLimit < "u" && n + 1 > o.edgesLimit) {
            lv(VC, t, e, i);
            return
        }
        if (r.push(t), Array.isArray(t))
            for (a = 0; a < t.length; a++) iM(t[a], a, a, r, t, s, o);
        else {
            var l = {},
                c = Object.keys(t).sort(Lke);
            for (a = 0; a < c.length; a++) {
                var u = c[a];
                iM(t[u], u, a, r, t, s, o), l[u] = t[u]
            }
            if (typeof i < "u") Fm.push([i, e, t]), i[e] = l;
            else return l
        }
        r.pop()
    }
}

function qie(t) {
    return t = typeof t < "u" ? t : function(e, n) {
            return n
        },
        function(e, n) {
            if (p1.length > 0)
                for (var r = 0; r < p1.length; r++) {
                    var i = p1[r];
                    if (i[1] === e && i[0] === n) {
                        n = i[2], p1.splice(r, 1);
                        break
                    }
                }
            return t.call(this, e, n)
        }
}
Object.defineProperty(Vp, "__esModule", {
    value: !0
});
Vp.EthereumProviderError = Vp.EthereumRpcError = void 0;
const Bke = $ke;
class Kie extends Error {
    constructor(e, n, r) {
        if (!Number.isInteger(e)) throw new Error('"code" must be an integer.');
        if (!n || typeof n != "string") throw new Error('"message" must be a nonempty string.');
        super(n), this.code = e, r !== void 0 && (this.data = r)
    }
    serialize() {
        const e = {
            code: this.code,
            message: this.message
        };
        return this.data !== void 0 && (e.data = this.data), this.stack && (e.stack = this.stack), e
    }
    toString() {
        return Bke.default(this.serialize(), jke, 2)
    }
}
Vp.EthereumRpcError = Kie;
class Fke extends Kie {
    constructor(e, n, r) {
        if (!Uke(e)) throw new Error('"code" must be an integer such that: 1000 <= code <= 4999');
        super(e, n, r)
    }
}
Vp.EthereumProviderError = Fke;

function Uke(t) {
    return Number.isInteger(t) && t >= 1e3 && t <= 4999
}

function jke(t, e) {
    if (e !== "[Circular]") return e
}
var KL = {},
    Gp = {};
Object.defineProperty(Gp, "__esModule", {
    value: !0
});
Gp.errorValues = Gp.errorCodes = void 0;
Gp.errorCodes = {
    rpc: {
        invalidInput: -32e3,
        resourceNotFound: -32001,
        resourceUnavailable: -32002,
        transactionRejected: -32003,
        methodNotSupported: -32004,
        limitExceeded: -32005,
        parse: -32700,
        invalidRequest: -32600,
        methodNotFound: -32601,
        invalidParams: -32602,
        internal: -32603
    },
    provider: {
        userRejectedRequest: 4001,
        unauthorized: 4100,
        unsupportedMethod: 4200,
        disconnected: 4900,
        chainDisconnected: 4901
    }
};
Gp.errorValues = {
    "-32700": {
        standard: "JSON RPC 2.0",
        message: "Invalid JSON was received by the server. An error occurred on the server while parsing the JSON text."
    },
    "-32600": {
        standard: "JSON RPC 2.0",
        message: "The JSON sent is not a valid Request object."
    },
    "-32601": {
        standard: "JSON RPC 2.0",
        message: "The method does not exist / is not available."
    },
    "-32602": {
        standard: "JSON RPC 2.0",
        message: "Invalid method parameter(s)."
    },
    "-32603": {
        standard: "JSON RPC 2.0",
        message: "Internal JSON-RPC error."
    },
    "-32000": {
        standard: "EIP-1474",
        message: "Invalid input."
    },
    "-32001": {
        standard: "EIP-1474",
        message: "Resource not found."
    },
    "-32002": {
        standard: "EIP-1474",
        message: "Resource unavailable."
    },
    "-32003": {
        standard: "EIP-1474",
        message: "Transaction rejected."
    },
    "-32004": {
        standard: "EIP-1474",
        message: "Method not supported."
    },
    "-32005": {
        standard: "EIP-1474",
        message: "Request limit exceeded."
    },
    4001: {
        standard: "EIP-1193",
        message: "User rejected the request."
    },
    4100: {
        standard: "EIP-1193",
        message: "The requested account and/or method has not been authorized by the user."
    },
    4200: {
        standard: "EIP-1193",
        message: "The requested method is not supported by this Ethereum provider."
    },
    4900: {
        standard: "EIP-1193",
        message: "The provider is disconnected from all chains."
    },
    4901: {
        standard: "EIP-1193",
        message: "The provider is disconnected from the specified chain."
    }
};
(function(t) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    }), t.serializeError = t.isValidCode = t.getMessageFromCode = t.JSON_RPC_SERVER_ERROR_MESSAGE = void 0;
    const e = Gp,
        n = Vp,
        r = e.errorCodes.rpc.internal,
        i = "Unspecified error message. This is a bug, please report it.",
        s = {
            code: r,
            message: o(r)
        };
    t.JSON_RPC_SERVER_ERROR_MESSAGE = "Unspecified server error.";

    function o(h, g = i) {
        if (Number.isInteger(h)) {
            const y = h.toString();
            if (f(e.errorValues, y)) return e.errorValues[y].message;
            if (c(h)) return t.JSON_RPC_SERVER_ERROR_MESSAGE
        }
        return g
    }
    t.getMessageFromCode = o;

    function a(h) {
        if (!Number.isInteger(h)) return !1;
        const g = h.toString();
        return !!(e.errorValues[g] || c(h))
    }
    t.isValidCode = a;

    function l(h, {
        fallbackError: g = s,
        shouldIncludeStack: y = !1
    } = {}) {
        var _, C;
        if (!g || !Number.isInteger(g.code) || typeof g.message != "string") throw new Error("Must provide fallback error with integer number code and string message.");
        if (h instanceof n.EthereumRpcError) return h.serialize();
        const b = {};
        if (h && typeof h == "object" && !Array.isArray(h) && f(h, "code") && a(h.code)) {
            const S = h;
            b.code = S.code, S.message && typeof S.message == "string" ? (b.message = S.message, f(S, "data") && (b.data = S.data)) : (b.message = o(b.code), b.data = {
                originalError: u(h)
            })
        } else {
            b.code = g.code;
            const S = (_ = h) === null || _ === void 0 ? void 0 : _.message;
            b.message = S && typeof S == "string" ? S : g.message, b.data = {
                originalError: u(h)
            }
        }
        const w = (C = h) === null || C === void 0 ? void 0 : C.stack;
        return y && h && w && typeof w == "string" && (b.stack = w), b
    }
    t.serializeError = l;

    function c(h) {
        return h >= -32099 && h <= -32e3
    }

    function u(h) {
        return h && typeof h == "object" && !Array.isArray(h) ? Object.assign({}, h) : h
    }

    function f(h, g) {
        return Object.prototype.hasOwnProperty.call(h, g)
    }
})(KL);
var d9 = {};
Object.defineProperty(d9, "__esModule", {
    value: !0
});
d9.ethErrors = void 0;
const YL = Vp,
    Yie = KL,
    vo = Gp;
d9.ethErrors = {
    rpc: {
        parse: t => Ql(vo.errorCodes.rpc.parse, t),
        invalidRequest: t => Ql(vo.errorCodes.rpc.invalidRequest, t),
        invalidParams: t => Ql(vo.errorCodes.rpc.invalidParams, t),
        methodNotFound: t => Ql(vo.errorCodes.rpc.methodNotFound, t),
        internal: t => Ql(vo.errorCodes.rpc.internal, t),
        server: t => {
            if (!t || typeof t != "object" || Array.isArray(t)) throw new Error("Ethereum RPC Server errors must provide single object argument.");
            const {
                code: e
            } = t;
            if (!Number.isInteger(e) || e > -32005 || e < -32099) throw new Error('"code" must be an integer such that: -32099 <= code <= -32005');
            return Ql(e, t)
        },
        invalidInput: t => Ql(vo.errorCodes.rpc.invalidInput, t),
        resourceNotFound: t => Ql(vo.errorCodes.rpc.resourceNotFound, t),
        resourceUnavailable: t => Ql(vo.errorCodes.rpc.resourceUnavailable, t),
        transactionRejected: t => Ql(vo.errorCodes.rpc.transactionRejected, t),
        methodNotSupported: t => Ql(vo.errorCodes.rpc.methodNotSupported, t),
        limitExceeded: t => Ql(vo.errorCodes.rpc.limitExceeded, t)
    },
    provider: {
        userRejectedRequest: t => G5(vo.errorCodes.provider.userRejectedRequest, t),
        unauthorized: t => G5(vo.errorCodes.provider.unauthorized, t),
        unsupportedMethod: t => G5(vo.errorCodes.provider.unsupportedMethod, t),
        disconnected: t => G5(vo.errorCodes.provider.disconnected, t),
        chainDisconnected: t => G5(vo.errorCodes.provider.chainDisconnected, t),
        custom: t => {
            if (!t || typeof t != "object" || Array.isArray(t)) throw new Error("Ethereum Provider custom errors must provide single object argument.");
            const {
                code: e,
                message: n,
                data: r
            } = t;
            if (!n || typeof n != "string") throw new Error('"message" must be a nonempty string');
            return new YL.EthereumProviderError(e, n, r)
        }
    }
};

function Ql(t, e) {
    const [n, r] = Zie(e);
    return new YL.EthereumRpcError(t, n || Yie.getMessageFromCode(t), r)
}

function G5(t, e) {
    const [n, r] = Zie(e);
    return new YL.EthereumProviderError(t, n || Yie.getMessageFromCode(t), r)
}

function Zie(t) {
    if (t) {
        if (typeof t == "string") return [t];
        if (typeof t == "object" && !Array.isArray(t)) {
            const {
                message: e,
                data: n
            } = t;
            if (e && typeof e != "string") throw new Error("Must specify string message.");
            return [e || void 0, n]
        }
    }
    return []
}(function(t) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    }), t.getMessageFromCode = t.serializeError = t.EthereumProviderError = t.EthereumRpcError = t.ethErrors = t.errorCodes = void 0;
    const e = Vp;
    Object.defineProperty(t, "EthereumRpcError", {
        enumerable: !0,
        get: function() {
            return e.EthereumRpcError
        }
    }), Object.defineProperty(t, "EthereumProviderError", {
        enumerable: !0,
        get: function() {
            return e.EthereumProviderError
        }
    });
    const n = KL;
    Object.defineProperty(t, "serializeError", {
        enumerable: !0,
        get: function() {
            return n.serializeError
        }
    }), Object.defineProperty(t, "getMessageFromCode", {
        enumerable: !0,
        get: function() {
            return n.getMessageFromCode
        }
    });
    const r = d9;
    Object.defineProperty(t, "ethErrors", {
        enumerable: !0,
        get: function() {
            return r.ethErrors
        }
    });
    const i = Gp;
    Object.defineProperty(t, "errorCodes", {
        enumerable: !0,
        get: function() {
            return i.errorCodes
        }
    })
})(qL);
var Kr = {},
    h9 = {};
(function(t) {
    Object.defineProperty(t, "__esModule", {
            value: !0
        }), t.Web3Method = void 0,
        function(e) {
            e.requestEthereumAccounts = "requestEthereumAccounts", e.signEthereumMessage = "signEthereumMessage", e.signEthereumTransaction = "signEthereumTransaction", e.submitEthereumTransaction = "submitEthereumTransaction", e.ethereumAddressFromSignedMessage = "ethereumAddressFromSignedMessage", e.scanQRCode = "scanQRCode", e.generic = "generic", e.childRequestEthereumAccounts = "childRequestEthereumAccounts", e.addEthereumChain = "addEthereumChain", e.switchEthereumChain = "switchEthereumChain", e.makeEthereumJSONRPCRequest = "makeEthereumJSONRPCRequest", e.watchAsset = "watchAsset", e.selectProvider = "selectProvider"
        }(t.Web3Method || (t.Web3Method = {}))
})(h9);
Object.defineProperty(Kr, "__esModule", {
    value: !0
});
Kr.EthereumAddressFromSignedMessageResponse = Kr.SubmitEthereumTransactionResponse = Kr.SignEthereumTransactionResponse = Kr.SignEthereumMessageResponse = Kr.isRequestEthereumAccountsResponse = Kr.SelectProviderResponse = Kr.WatchAssetReponse = Kr.RequestEthereumAccountsResponse = Kr.SwitchEthereumChainResponse = Kr.AddEthereumChainResponse = Kr.isErrorResponse = void 0;
const fd = h9;

function Hke(t) {
    var e, n;
    return ((e = t) === null || e === void 0 ? void 0 : e.method) !== void 0 && ((n = t) === null || n === void 0 ? void 0 : n.errorMessage) !== void 0
}
Kr.isErrorResponse = Hke;

function zke(t) {
    return {
        method: fd.Web3Method.addEthereumChain,
        result: t
    }
}
Kr.AddEthereumChainResponse = zke;

function Wke(t) {
    return {
        method: fd.Web3Method.switchEthereumChain,
        result: t
    }
}
Kr.SwitchEthereumChainResponse = Wke;

function Vke(t) {
    return {
        method: fd.Web3Method.requestEthereumAccounts,
        result: t
    }
}
Kr.RequestEthereumAccountsResponse = Vke;

function Gke(t) {
    return {
        method: fd.Web3Method.watchAsset,
        result: t
    }
}
Kr.WatchAssetReponse = Gke;

function qke(t) {
    return {
        method: fd.Web3Method.selectProvider,
        result: t
    }
}
Kr.SelectProviderResponse = qke;

function Kke(t) {
    return t && t.method === fd.Web3Method.requestEthereumAccounts
}
Kr.isRequestEthereumAccountsResponse = Kke;

function Yke(t) {
    return {
        method: fd.Web3Method.signEthereumMessage,
        result: t
    }
}
Kr.SignEthereumMessageResponse = Yke;

function Zke(t) {
    return {
        method: fd.Web3Method.signEthereumTransaction,
        result: t
    }
}
Kr.SignEthereumTransactionResponse = Zke;

function Qke(t) {
    return {
        method: fd.Web3Method.submitEthereumTransaction,
        result: t
    }
}
Kr.SubmitEthereumTransactionResponse = Qke;

function Jke(t) {
    return {
        method: fd.Web3Method.ethereumAddressFromSignedMessage,
        result: t
    }
}
Kr.EthereumAddressFromSignedMessageResponse = Jke;
var $2 = {};
Object.defineProperty($2, "__esModule", {
    value: !0
});
$2.LIB_VERSION = void 0;
$2.LIB_VERSION = "3.7.2";
(function(t) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    }), t.getErrorCode = t.serializeError = t.standardErrors = t.standardErrorMessage = t.standardErrorCodes = void 0;
    const e = qL,
        n = Kr,
        r = $2;
    t.standardErrorCodes = Object.freeze(Object.assign(Object.assign({}, e.errorCodes), {
        provider: Object.freeze(Object.assign(Object.assign({}, e.errorCodes.provider), {
            unsupportedChain: 4902
        }))
    }));

    function i(u) {
        return u !== void 0 ? (0, e.getMessageFromCode)(u) : "Unknown error"
    }
    t.standardErrorMessage = i, t.standardErrors = Object.freeze(Object.assign(Object.assign({}, e.ethErrors), {
        provider: Object.freeze(Object.assign(Object.assign({}, e.ethErrors.provider), {
            unsupportedChain: (u = "") => e.ethErrors.provider.custom({
                code: t.standardErrorCodes.provider.unsupportedChain,
                message: `Unrecognized chain ID ${u}. Try adding the chain using wallet_addEthereumChain first.`
            })
        }))
    }));

    function s(u, f) {
        const h = (0, e.serializeError)(o(u), {
                shouldIncludeStack: !0
            }),
            g = new URL("https://docs.cloud.coinbase.com/wallet-sdk/docs/errors");
        g.searchParams.set("version", r.LIB_VERSION), g.searchParams.set("code", h.code.toString());
        const y = a(h.data, f);
        return y && g.searchParams.set("method", y), g.searchParams.set("message", h.message), Object.assign(Object.assign({}, h), {
            docUrl: g.href
        })
    }
    t.serializeError = s;

    function o(u) {
        return typeof u == "string" ? {
            message: u,
            code: t.standardErrorCodes.rpc.internal
        } : (0, n.isErrorResponse)(u) ? Object.assign(Object.assign({}, u), {
            message: u.errorMessage,
            code: u.errorCode,
            data: {
                method: u.method,
                result: u.result
            }
        }) : u
    }

    function a(u, f) {
        var h;
        const g = (h = u) === null || h === void 0 ? void 0 : h.method;
        if (g) return g;
        if (f !== void 0) return typeof f == "string" ? f : Array.isArray(f) ? f.length > 0 ? f[0].method : void 0 : f.method
    }

    function l(u) {
        var f;
        if (typeof u == "number") return u;
        if (c(u)) return (f = u.code) !== null && f !== void 0 ? f : u.errorCode
    }
    t.getErrorCode = l;

    function c(u) {
        return typeof u == "object" && u !== null && (typeof u.code == "number" || typeof u.errorCode == "number")
    }
})(DE);
var L2 = {},
    Qie = {
        exports: {}
    },
    sM = {
        exports: {}
    };
typeof Object.create == "function" ? sM.exports = function(e, n) {
    n && (e.super_ = n, e.prototype = Object.create(n.prototype, {
        constructor: {
            value: e,
            enumerable: !1,
            writable: !0,
            configurable: !0
        }
    }))
} : sM.exports = function(e, n) {
    if (n) {
        e.super_ = n;
        var r = function() {};
        r.prototype = n.prototype, e.prototype = new r, e.prototype.constructor = e
    }
};
var Wu = sM.exports,
    oM = {
        exports: {}
    }; /*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
(function(t, e) {
    var n = M2,
        r = n.Buffer;

    function i(o, a) {
        for (var l in o) a[l] = o[l]
    }
    r.from && r.alloc && r.allocUnsafe && r.allocUnsafeSlow ? t.exports = n : (i(n, e), e.Buffer = s);

    function s(o, a, l) {
        return r(o, a, l)
    }
    s.prototype = Object.create(r.prototype), i(r, s), s.from = function(o, a, l) {
        if (typeof o == "number") throw new TypeError("Argument must not be a number");
        return r(o, a, l)
    }, s.alloc = function(o, a, l) {
        if (typeof o != "number") throw new TypeError("Argument must be a number");
        var c = r(o);
        return a !== void 0 ? typeof l == "string" ? c.fill(a, l) : c.fill(a) : c.fill(0), c
    }, s.allocUnsafe = function(o) {
        if (typeof o != "number") throw new TypeError("Argument must be a number");
        return r(o)
    }, s.allocUnsafeSlow = function(o) {
        if (typeof o != "number") throw new TypeError("Argument must be a number");
        return n.SlowBuffer(o)
    }
})(oM, oM.exports);
var cg = oM.exports,
    Jie = cg.Buffer;

function p9(t, e) {
    this._block = Jie.alloc(t), this._finalSize = e, this._blockSize = t, this._len = 0
}
p9.prototype.update = function(t, e) {
    typeof t == "string" && (e = e || "utf8", t = Jie.from(t, e));
    for (var n = this._block, r = this._blockSize, i = t.length, s = this._len, o = 0; o < i;) {
        for (var a = s % r, l = Math.min(i - o, r - a), c = 0; c < l; c++) n[a + c] = t[o + c];
        s += l, o += l, s % r === 0 && this._update(n)
    }
    return this._len += i, this
};
p9.prototype.digest = function(t) {
    var e = this._len % this._blockSize;
    this._block[e] = 128, this._block.fill(0, e + 1), e >= this._finalSize && (this._update(this._block), this._block.fill(0));
    var n = this._len * 8;
    if (n <= 4294967295) this._block.writeUInt32BE(n, this._blockSize - 4);
    else {
        var r = (n & 4294967295) >>> 0,
            i = (n - r) / 4294967296;
        this._block.writeUInt32BE(i, this._blockSize - 8), this._block.writeUInt32BE(r, this._blockSize - 4)
    }
    this._update(this._block);
    var s = this._hash();
    return t ? s.toString(t) : s
};
p9.prototype._update = function() {
    throw new Error("_update must be implemented by subclass")
};
var B2 = p9,
    Xke = Wu,
    Xie = B2,
    eMe = cg.Buffer,
    tMe = [1518500249, 1859775393, -1894007588, -899497514],
    nMe = new Array(80);

function $E() {
    this.init(), this._w = nMe, Xie.call(this, 64, 56)
}
Xke($E, Xie);
$E.prototype.init = function() {
    return this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878, this._e = 3285377520, this
};

function rMe(t) {
    return t << 5 | t >>> 27
}

function iMe(t) {
    return t << 30 | t >>> 2
}

function sMe(t, e, n, r) {
    return t === 0 ? e & n | ~e & r : t === 2 ? e & n | e & r | n & r : e ^ n ^ r
}
$E.prototype._update = function(t) {
    for (var e = this._w, n = this._a | 0, r = this._b | 0, i = this._c | 0, s = this._d | 0, o = this._e | 0, a = 0; a < 16; ++a) e[a] = t.readInt32BE(a * 4);
    for (; a < 80; ++a) e[a] = e[a - 3] ^ e[a - 8] ^ e[a - 14] ^ e[a - 16];
    for (var l = 0; l < 80; ++l) {
        var c = ~~(l / 20),
            u = rMe(n) + sMe(c, r, i, s) + o + e[l] + tMe[c] | 0;
        o = s, s = i, i = iMe(r), r = n, n = u
    }
    this._a = n + this._a | 0, this._b = r + this._b | 0, this._c = i + this._c | 0, this._d = s + this._d | 0, this._e = o + this._e | 0
};
$E.prototype._hash = function() {
    var t = eMe.allocUnsafe(20);
    return t.writeInt32BE(this._a | 0, 0), t.writeInt32BE(this._b | 0, 4), t.writeInt32BE(this._c | 0, 8), t.writeInt32BE(this._d | 0, 12), t.writeInt32BE(this._e | 0, 16), t
};
var oMe = $E,
    aMe = Wu,
    ese = B2,
    lMe = cg.Buffer,
    cMe = [1518500249, 1859775393, -1894007588, -899497514],
    uMe = new Array(80);

function LE() {
    this.init(), this._w = uMe, ese.call(this, 64, 56)
}
aMe(LE, ese);
LE.prototype.init = function() {
    return this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878, this._e = 3285377520, this
};

function fMe(t) {
    return t << 1 | t >>> 31
}

function dMe(t) {
    return t << 5 | t >>> 27
}

function hMe(t) {
    return t << 30 | t >>> 2
}

function pMe(t, e, n, r) {
    return t === 0 ? e & n | ~e & r : t === 2 ? e & n | e & r | n & r : e ^ n ^ r
}
LE.prototype._update = function(t) {
    for (var e = this._w, n = this._a | 0, r = this._b | 0, i = this._c | 0, s = this._d | 0, o = this._e | 0, a = 0; a < 16; ++a) e[a] = t.readInt32BE(a * 4);
    for (; a < 80; ++a) e[a] = fMe(e[a - 3] ^ e[a - 8] ^ e[a - 14] ^ e[a - 16]);
    for (var l = 0; l < 80; ++l) {
        var c = ~~(l / 20),
            u = dMe(n) + pMe(c, r, i, s) + o + e[l] + cMe[c] | 0;
        o = s, s = i, i = hMe(r), r = n, n = u
    }
    this._a = n + this._a | 0, this._b = r + this._b | 0, this._c = i + this._c | 0, this._d = s + this._d | 0, this._e = o + this._e | 0
};
LE.prototype._hash = function() {
    var t = lMe.allocUnsafe(20);
    return t.writeInt32BE(this._a | 0, 0), t.writeInt32BE(this._b | 0, 4), t.writeInt32BE(this._c | 0, 8), t.writeInt32BE(this._d | 0, 12), t.writeInt32BE(this._e | 0, 16), t
};
var gMe = LE,
    mMe = Wu,
    tse = B2,
    yMe = cg.Buffer,
    wMe = [1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298],
    vMe = new Array(64);

function BE() {
    this.init(), this._w = vMe, tse.call(this, 64, 56)
}
mMe(BE, tse);
BE.prototype.init = function() {
    return this._a = 1779033703, this._b = 3144134277, this._c = 1013904242, this._d = 2773480762, this._e = 1359893119, this._f = 2600822924, this._g = 528734635, this._h = 1541459225, this
};

function bMe(t, e, n) {
    return n ^ t & (e ^ n)
}

function _Me(t, e, n) {
    return t & e | n & (t | e)
}

function EMe(t) {
    return (t >>> 2 | t << 30) ^ (t >>> 13 | t << 19) ^ (t >>> 22 | t << 10)
}

function xMe(t) {
    return (t >>> 6 | t << 26) ^ (t >>> 11 | t << 21) ^ (t >>> 25 | t << 7)
}

function SMe(t) {
    return (t >>> 7 | t << 25) ^ (t >>> 18 | t << 14) ^ t >>> 3
}

function CMe(t) {
    return (t >>> 17 | t << 15) ^ (t >>> 19 | t << 13) ^ t >>> 10
}
BE.prototype._update = function(t) {
    for (var e = this._w, n = this._a | 0, r = this._b | 0, i = this._c | 0, s = this._d | 0, o = this._e | 0, a = this._f | 0, l = this._g | 0, c = this._h | 0, u = 0; u < 16; ++u) e[u] = t.readInt32BE(u * 4);
    for (; u < 64; ++u) e[u] = CMe(e[u - 2]) + e[u - 7] + SMe(e[u - 15]) + e[u - 16] | 0;
    for (var f = 0; f < 64; ++f) {
        var h = c + xMe(o) + bMe(o, a, l) + wMe[f] + e[f] | 0,
            g = EMe(n) + _Me(n, r, i) | 0;
        c = l, l = a, a = o, o = s + h | 0, s = i, i = r, r = n, n = h + g | 0
    }
    this._a = n + this._a | 0, this._b = r + this._b | 0, this._c = i + this._c | 0, this._d = s + this._d | 0, this._e = o + this._e | 0, this._f = a + this._f | 0, this._g = l + this._g | 0, this._h = c + this._h | 0
};
BE.prototype._hash = function() {
    var t = yMe.allocUnsafe(32);
    return t.writeInt32BE(this._a, 0), t.writeInt32BE(this._b, 4), t.writeInt32BE(this._c, 8), t.writeInt32BE(this._d, 12), t.writeInt32BE(this._e, 16), t.writeInt32BE(this._f, 20), t.writeInt32BE(this._g, 24), t.writeInt32BE(this._h, 28), t
};
var nse = BE,
    AMe = Wu,
    TMe = nse,
    IMe = B2,
    RMe = cg.Buffer,
    OMe = new Array(64);

function g9() {
    this.init(), this._w = OMe, IMe.call(this, 64, 56)
}
AMe(g9, TMe);
g9.prototype.init = function() {
    return this._a = 3238371032, this._b = 914150663, this._c = 812702999, this._d = 4144912697, this._e = 4290775857, this._f = 1750603025, this._g = 1694076839, this._h = 3204075428, this
};
g9.prototype._hash = function() {
    var t = RMe.allocUnsafe(28);
    return t.writeInt32BE(this._a, 0), t.writeInt32BE(this._b, 4), t.writeInt32BE(this._c, 8), t.writeInt32BE(this._d, 12), t.writeInt32BE(this._e, 16), t.writeInt32BE(this._f, 20), t.writeInt32BE(this._g, 24), t
};
var NMe = g9,
    PMe = Wu,
    rse = B2,
    kMe = cg.Buffer,
    yq = [1116352408, 3609767458, 1899447441, 602891725, 3049323471, 3964484399, 3921009573, 2173295548, 961987163, 4081628472, 1508970993, 3053834265, 2453635748, 2937671579, 2870763221, 3664609560, 3624381080, 2734883394, 310598401, 1164996542, 607225278, 1323610764, 1426881987, 3590304994, 1925078388, 4068182383, 2162078206, 991336113, 2614888103, 633803317, 3248222580, 3479774868, 3835390401, 2666613458, 4022224774, 944711139, 264347078, 2341262773, 604807628, 2007800933, 770255983, 1495990901, 1249150122, 1856431235, 1555081692, 3175218132, 1996064986, 2198950837, 2554220882, 3999719339, 2821834349, 766784016, 2952996808, 2566594879, 3210313671, 3203337956, 3336571891, 1034457026, 3584528711, 2466948901, 113926993, 3758326383, 338241895, 168717936, 666307205, 1188179964, 773529912, 1546045734, 1294757372, 1522805485, 1396182291, 2643833823, 1695183700, 2343527390, 1986661051, 1014477480, 2177026350, 1206759142, 2456956037, 344077627, 2730485921, 1290863460, 2820302411, 3158454273, 3259730800, 3505952657, 3345764771, 106217008, 3516065817, 3606008344, 3600352804, 1432725776, 4094571909, 1467031594, 275423344, 851169720, 430227734, 3100823752, 506948616, 1363258195, 659060556, 3750685593, 883997877, 3785050280, 958139571, 3318307427, 1322822218, 3812723403, 1537002063, 2003034995, 1747873779, 3602036899, 1955562222, 1575990012, 2024104815, 1125592928, 2227730452, 2716904306, 2361852424, 442776044, 2428436474, 593698344, 2756734187, 3733110249, 3204031479, 2999351573, 3329325298, 3815920427, 3391569614, 3928383900, 3515267271, 566280711, 3940187606, 3454069534, 4118630271, 4000239992, 116418474, 1914138554, 174292421, 2731055270, 289380356, 3203993006, 460393269, 320620315, 685471733, 587496836, 852142971, 1086792851, 1017036298, 365543100, 1126000580, 2618297676, 1288033470, 3409855158, 1501505948, 4234509866, 1607167915, 987167468, 1816402316, 1246189591],
    MMe = new Array(160);

function FE() {
    this.init(), this._w = MMe, rse.call(this, 128, 112)
}
PMe(FE, rse);
FE.prototype.init = function() {
    return this._ah = 1779033703, this._bh = 3144134277, this._ch = 1013904242, this._dh = 2773480762, this._eh = 1359893119, this._fh = 2600822924, this._gh = 528734635, this._hh = 1541459225, this._al = 4089235720, this._bl = 2227873595, this._cl = 4271175723, this._dl = 1595750129, this._el = 2917565137, this._fl = 725511199, this._gl = 4215389547, this._hl = 327033209, this
};

function wq(t, e, n) {
    return n ^ t & (e ^ n)
}

function vq(t, e, n) {
    return t & e | n & (t | e)
}

function bq(t, e) {
    return (t >>> 28 | e << 4) ^ (e >>> 2 | t << 30) ^ (e >>> 7 | t << 25)
}

function _q(t, e) {
    return (t >>> 14 | e << 18) ^ (t >>> 18 | e << 14) ^ (e >>> 9 | t << 23)
}

function DMe(t, e) {
    return (t >>> 1 | e << 31) ^ (t >>> 8 | e << 24) ^ t >>> 7
}

function $Me(t, e) {
    return (t >>> 1 | e << 31) ^ (t >>> 8 | e << 24) ^ (t >>> 7 | e << 25)
}

function LMe(t, e) {
    return (t >>> 19 | e << 13) ^ (e >>> 29 | t << 3) ^ t >>> 6
}

function BMe(t, e) {
    return (t >>> 19 | e << 13) ^ (e >>> 29 | t << 3) ^ (t >>> 6 | e << 26)
}

function Bs(t, e) {
    return t >>> 0 < e >>> 0 ? 1 : 0
}
FE.prototype._update = function(t) {
    for (var e = this._w, n = this._ah | 0, r = this._bh | 0, i = this._ch | 0, s = this._dh | 0, o = this._eh | 0, a = this._fh | 0, l = this._gh | 0, c = this._hh | 0, u = this._al | 0, f = this._bl | 0, h = this._cl | 0, g = this._dl | 0, y = this._el | 0, _ = this._fl | 0, C = this._gl | 0, b = this._hl | 0, w = 0; w < 32; w += 2) e[w] = t.readInt32BE(w * 4), e[w + 1] = t.readInt32BE(w * 4 + 4);
    for (; w < 160; w += 2) {
        var S = e[w - 30],
            I = e[w - 15 * 2 + 1],
            P = DMe(S, I),
            M = $Me(I, S);
        S = e[w - 2 * 2], I = e[w - 2 * 2 + 1];
        var A = LMe(S, I),
            E = BMe(I, S),
            $ = e[w - 7 * 2],
            H = e[w - 7 * 2 + 1],
            K = e[w - 16 * 2],
            te = e[w - 16 * 2 + 1],
            U = M + H | 0,
            m = P + $ + Bs(U, M) | 0;
        U = U + E | 0, m = m + A + Bs(U, E) | 0, U = U + te | 0, m = m + K + Bs(U, te) | 0, e[w] = m, e[w + 1] = U
    }
    for (var v = 0; v < 160; v += 2) {
        m = e[v], U = e[v + 1];
        var T = vq(n, r, i),
            N = vq(u, f, h),
            O = bq(n, u),
            L = bq(u, n),
            G = _q(o, y),
            j = _q(y, o),
            R = yq[v],
            Y = yq[v + 1],
            ve = wq(o, a, l),
            V = wq(y, _, C),
            X = b + j | 0,
            q = c + G + Bs(X, b) | 0;
        X = X + V | 0, q = q + ve + Bs(X, V) | 0, X = X + Y | 0, q = q + R + Bs(X, Y) | 0, X = X + U | 0, q = q + m + Bs(X, U) | 0;
        var ne = L + N | 0,
            ie = O + T + Bs(ne, L) | 0;
        c = l, b = C, l = a, C = _, a = o, _ = y, y = g + X | 0, o = s + q + Bs(y, g) | 0, s = i, g = h, i = r, h = f, r = n, f = u, u = X + ne | 0, n = q + ie + Bs(u, X) | 0
    }
    this._al = this._al + u | 0, this._bl = this._bl + f | 0, this._cl = this._cl + h | 0, this._dl = this._dl + g | 0, this._el = this._el + y | 0, this._fl = this._fl + _ | 0, this._gl = this._gl + C | 0, this._hl = this._hl + b | 0, this._ah = this._ah + n + Bs(this._al, u) | 0, this._bh = this._bh + r + Bs(this._bl, f) | 0, this._ch = this._ch + i + Bs(this._cl, h) | 0, this._dh = this._dh + s + Bs(this._dl, g) | 0, this._eh = this._eh + o + Bs(this._el, y) | 0, this._fh = this._fh + a + Bs(this._fl, _) | 0, this._gh = this._gh + l + Bs(this._gl, C) | 0, this._hh = this._hh + c + Bs(this._hl, b) | 0
};
FE.prototype._hash = function() {
    var t = kMe.allocUnsafe(64);

    function e(n, r, i) {
        t.writeInt32BE(n, i), t.writeInt32BE(r, i + 4)
    }
    return e(this._ah, this._al, 0), e(this._bh, this._bl, 8), e(this._ch, this._cl, 16), e(this._dh, this._dl, 24), e(this._eh, this._el, 32), e(this._fh, this._fl, 40), e(this._gh, this._gl, 48), e(this._hh, this._hl, 56), t
};
var ise = FE,
    FMe = Wu,
    UMe = ise,
    jMe = B2,
    HMe = cg.Buffer,
    zMe = new Array(160);

function m9() {
    this.init(), this._w = zMe, jMe.call(this, 128, 112)
}
FMe(m9, UMe);
m9.prototype.init = function() {
    return this._ah = 3418070365, this._bh = 1654270250, this._ch = 2438529370, this._dh = 355462360, this._eh = 1731405415, this._fh = 2394180231, this._gh = 3675008525, this._hh = 1203062813, this._al = 3238371032, this._bl = 914150663, this._cl = 812702999, this._dl = 4144912697, this._el = 4290775857, this._fl = 1750603025, this._gl = 1694076839, this._hl = 3204075428, this
};
m9.prototype._hash = function() {
    var t = HMe.allocUnsafe(48);

    function e(n, r, i) {
        t.writeInt32BE(n, i), t.writeInt32BE(r, i + 4)
    }
    return e(this._ah, this._al, 0), e(this._bh, this._bl, 8), e(this._ch, this._cl, 16), e(this._dh, this._dl, 24), e(this._eh, this._el, 32), e(this._fh, this._fl, 40), t
};
var WMe = m9,
    by = Qie.exports = function(e) {
        e = e.toLowerCase();
        var n = by[e];
        if (!n) throw new Error(e + " is not supported (we accept pull requests)");
        return new n
    };
by.sha = oMe;
by.sha1 = gMe;
by.sha224 = NMe;
by.sha256 = nse;
by.sha384 = WMe;
by.sha512 = ise;
var VMe = Qie.exports,
    Ut = {},
    GMe = Error,
    qMe = EvalError,
    KMe = RangeError,
    YMe = ReferenceError,
    sse = SyntaxError,
    UE = TypeError,
    ZMe = URIError,
    QMe = function() {
        if (typeof Symbol != "function" || typeof Object.getOwnPropertySymbols != "function") return !1;
        if (typeof Symbol.iterator == "symbol") return !0;
        var e = {},
            n = Symbol("test"),
            r = Object(n);
        if (typeof n == "string" || Object.prototype.toString.call(n) !== "[object Symbol]" || Object.prototype.toString.call(r) !== "[object Symbol]") return !1;
        var i = 42;
        e[n] = i;
        for (n in e) return !1;
        if (typeof Object.keys == "function" && Object.keys(e).length !== 0 || typeof Object.getOwnPropertyNames == "function" && Object.getOwnPropertyNames(e).length !== 0) return !1;
        var s = Object.getOwnPropertySymbols(e);
        if (s.length !== 1 || s[0] !== n || !Object.prototype.propertyIsEnumerable.call(e, n)) return !1;
        if (typeof Object.getOwnPropertyDescriptor == "function") {
            var o = Object.getOwnPropertyDescriptor(e, n);
            if (o.value !== i || o.enumerable !== !0) return !1
        }
        return !0
    },
    Eq = typeof Symbol < "u" && Symbol,
    JMe = QMe,
    XMe = function() {
        return typeof Eq != "function" || typeof Symbol != "function" || typeof Eq("foo") != "symbol" || typeof Symbol("bar") != "symbol" ? !1 : JMe()
    },
    PO = {
        __proto__: null,
        foo: {}
    },
    eDe = Object,
    tDe = function() {
        return {
            __proto__: PO
        }.foo === PO.foo && !(PO instanceof eDe)
    },
    nDe = "Function.prototype.bind called on incompatible ",
    rDe = Object.prototype.toString,
    iDe = Math.max,
    sDe = "[object Function]",
    xq = function(e, n) {
        for (var r = [], i = 0; i < e.length; i += 1) r[i] = e[i];
        for (var s = 0; s < n.length; s += 1) r[s + e.length] = n[s];
        return r
    },
    oDe = function(e, n) {
        for (var r = [], i = n, s = 0; i < e.length; i += 1, s += 1) r[s] = e[i];
        return r
    },
    aDe = function(t, e) {
        for (var n = "", r = 0; r < t.length; r += 1) n += t[r], r + 1 < t.length && (n += e);
        return n
    },
    lDe = function(e) {
        var n = this;
        if (typeof n != "function" || rDe.apply(n) !== sDe) throw new TypeError(nDe + n);
        for (var r = oDe(arguments, 1), i, s = function() {
                if (this instanceof i) {
                    var u = n.apply(this, xq(r, arguments));
                    return Object(u) === u ? u : this
                }
                return n.apply(e, xq(r, arguments))
            }, o = iDe(0, n.length - r.length), a = [], l = 0; l < o; l++) a[l] = "$" + l;
        if (i = Function("binder", "return function (" + aDe(a, ",") + "){ return binder.apply(this,arguments); }")(s), n.prototype) {
            var c = function() {};
            c.prototype = n.prototype, i.prototype = new c, c.prototype = null
        }
        return i
    },
    cDe = lDe,
    ZL = Function.prototype.bind || cDe,
    uDe = Function.prototype.call,
    fDe = Object.prototype.hasOwnProperty,
    dDe = ZL,
    hDe = dDe.call(uDe, fDe),
    Zn, pDe = GMe,
    gDe = qMe,
    mDe = KMe,
    yDe = YMe,
    Xb = sse,
    cv = UE,
    wDe = ZMe,
    ose = Function,
    kO = function(t) {
        try {
            return ose('"use strict"; return (' + t + ").constructor;")()
        } catch {}
    },
    rm = Object.getOwnPropertyDescriptor;
if (rm) try {
    rm({}, "")
} catch {
    rm = null
}
var MO = function() {
        throw new cv
    },
    vDe = rm ? function() {
        try {
            return arguments.callee, MO
        } catch {
            try {
                return rm(arguments, "callee").get
            } catch {
                return MO
            }
        }
    }() : MO,
    sw = XMe(),
    bDe = tDe(),
    zs = Object.getPrototypeOf || (bDe ? function(t) {
        return t.__proto__
    } : null),
    Sw = {},
    _De = typeof Uint8Array > "u" || !zs ? Zn : zs(Uint8Array),
    im = {
        __proto__: null,
        "%AggregateError%": typeof AggregateError > "u" ? Zn : AggregateError,
        "%Array%": Array,
        "%ArrayBuffer%": typeof ArrayBuffer > "u" ? Zn : ArrayBuffer,
        "%ArrayIteratorPrototype%": sw && zs ? zs([][Symbol.iterator]()) : Zn,
        "%AsyncFromSyncIteratorPrototype%": Zn,
        "%AsyncFunction%": Sw,
        "%AsyncGenerator%": Sw,
        "%AsyncGeneratorFunction%": Sw,
        "%AsyncIteratorPrototype%": Sw,
        "%Atomics%": typeof Atomics > "u" ? Zn : Atomics,
        "%BigInt%": typeof BigInt > "u" ? Zn : BigInt,
        "%BigInt64Array%": typeof BigInt64Array > "u" ? Zn : BigInt64Array,
        "%BigUint64Array%": typeof BigUint64Array > "u" ? Zn : BigUint64Array,
        "%Boolean%": Boolean,
        "%DataView%": typeof DataView > "u" ? Zn : DataView,
        "%Date%": Date,
        "%decodeURI%": decodeURI,
        "%decodeURIComponent%": decodeURIComponent,
        "%encodeURI%": encodeURI,
        "%encodeURIComponent%": encodeURIComponent,
        "%Error%": pDe,
        "%eval%": eval,
        "%EvalError%": gDe,
        "%Float32Array%": typeof Float32Array > "u" ? Zn : Float32Array,
        "%Float64Array%": typeof Float64Array > "u" ? Zn : Float64Array,
        "%FinalizationRegistry%": typeof FinalizationRegistry > "u" ? Zn : FinalizationRegistry,
        "%Function%": ose,
        "%GeneratorFunction%": Sw,
        "%Int8Array%": typeof Int8Array > "u" ? Zn : Int8Array,
        "%Int16Array%": typeof Int16Array > "u" ? Zn : Int16Array,
        "%Int32Array%": typeof Int32Array > "u" ? Zn : Int32Array,
        "%isFinite%": isFinite,
        "%isNaN%": isNaN,
        "%IteratorPrototype%": sw && zs ? zs(zs([][Symbol.iterator]())) : Zn,
        "%JSON%": typeof JSON == "object" ? JSON : Zn,
        "%Map%": typeof Map > "u" ? Zn : Map,
        "%MapIteratorPrototype%": typeof Map > "u" || !sw || !zs ? Zn : zs(new Map()[Symbol.iterator]()),
        "%Math%": Math,
        "%Number%": Number,
        "%Object%": Object,
        "%parseFloat%": parseFloat,
        "%parseInt%": parseInt,
        "%Promise%": typeof Promise > "u" ? Zn : Promise,
        "%Proxy%": typeof Proxy > "u" ? Zn : Proxy,
        "%RangeError%": mDe,
        "%ReferenceError%": yDe,
        "%Reflect%": typeof Reflect > "u" ? Zn : Reflect,
        "%RegExp%": RegExp,
        "%Set%": typeof Set > "u" ? Zn : Set,
        "%SetIteratorPrototype%": typeof Set > "u" || !sw || !zs ? Zn : zs(new Set()[Symbol.iterator]()),
        "%SharedArrayBuffer%": typeof SharedArrayBuffer > "u" ? Zn : SharedArrayBuffer,
        "%String%": String,
        "%StringIteratorPrototype%": sw && zs ? zs("" [Symbol.iterator]()) : Zn,
        "%Symbol%": sw ? Symbol : Zn,
        "%SyntaxError%": Xb,
        "%ThrowTypeError%": vDe,
        "%TypedArray%": _De,
        "%TypeError%": cv,
        "%Uint8Array%": typeof Uint8Array > "u" ? Zn : Uint8Array,
        "%Uint8ClampedArray%": typeof Uint8ClampedArray > "u" ? Zn : Uint8ClampedArray,
        "%Uint16Array%": typeof Uint16Array > "u" ? Zn : Uint16Array,
        "%Uint32Array%": typeof Uint32Array > "u" ? Zn : Uint32Array,
        "%URIError%": wDe,
        "%WeakMap%": typeof WeakMap > "u" ? Zn : WeakMap,
        "%WeakRef%": typeof WeakRef > "u" ? Zn : WeakRef,
        "%WeakSet%": typeof WeakSet > "u" ? Zn : WeakSet
    };
if (zs) try {
    null.error
} catch (t) {
    var EDe = zs(zs(t));
    im["%Error.prototype%"] = EDe
}
var xDe = function t(e) {
        var n;
        if (e === "%AsyncFunction%") n = kO("async function () {}");
        else if (e === "%GeneratorFunction%") n = kO("function* () {}");
        else if (e === "%AsyncGeneratorFunction%") n = kO("async function* () {}");
        else if (e === "%AsyncGenerator%") {
            var r = t("%AsyncGeneratorFunction%");
            r && (n = r.prototype)
        } else if (e === "%AsyncIteratorPrototype%") {
            var i = t("%AsyncGenerator%");
            i && zs && (n = zs(i.prototype))
        }
        return im[e] = n, n
    },
    Sq = {
        __proto__: null,
        "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
        "%ArrayPrototype%": ["Array", "prototype"],
        "%ArrayProto_entries%": ["Array", "prototype", "entries"],
        "%ArrayProto_forEach%": ["Array", "prototype", "forEach"],
        "%ArrayProto_keys%": ["Array", "prototype", "keys"],
        "%ArrayProto_values%": ["Array", "prototype", "values"],
        "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
        "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
        "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"],
        "%BooleanPrototype%": ["Boolean", "prototype"],
        "%DataViewPrototype%": ["DataView", "prototype"],
        "%DatePrototype%": ["Date", "prototype"],
        "%ErrorPrototype%": ["Error", "prototype"],
        "%EvalErrorPrototype%": ["EvalError", "prototype"],
        "%Float32ArrayPrototype%": ["Float32Array", "prototype"],
        "%Float64ArrayPrototype%": ["Float64Array", "prototype"],
        "%FunctionPrototype%": ["Function", "prototype"],
        "%Generator%": ["GeneratorFunction", "prototype"],
        "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"],
        "%Int8ArrayPrototype%": ["Int8Array", "prototype"],
        "%Int16ArrayPrototype%": ["Int16Array", "prototype"],
        "%Int32ArrayPrototype%": ["Int32Array", "prototype"],
        "%JSONParse%": ["JSON", "parse"],
        "%JSONStringify%": ["JSON", "stringify"],
        "%MapPrototype%": ["Map", "prototype"],
        "%NumberPrototype%": ["Number", "prototype"],
        "%ObjectPrototype%": ["Object", "prototype"],
        "%ObjProto_toString%": ["Object", "prototype", "toString"],
        "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"],
        "%PromisePrototype%": ["Promise", "prototype"],
        "%PromiseProto_then%": ["Promise", "prototype", "then"],
        "%Promise_all%": ["Promise", "all"],
        "%Promise_reject%": ["Promise", "reject"],
        "%Promise_resolve%": ["Promise", "resolve"],
        "%RangeErrorPrototype%": ["RangeError", "prototype"],
        "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
        "%RegExpPrototype%": ["RegExp", "prototype"],
        "%SetPrototype%": ["Set", "prototype"],
        "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
        "%StringPrototype%": ["String", "prototype"],
        "%SymbolPrototype%": ["Symbol", "prototype"],
        "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
        "%TypedArrayPrototype%": ["TypedArray", "prototype"],
        "%TypeErrorPrototype%": ["TypeError", "prototype"],
        "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
        "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
        "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
        "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
        "%URIErrorPrototype%": ["URIError", "prototype"],
        "%WeakMapPrototype%": ["WeakMap", "prototype"],
        "%WeakSetPrototype%": ["WeakSet", "prototype"]
    },
    jE = ZL,
    GC = hDe,
    SDe = jE.call(Function.call, Array.prototype.concat),
    CDe = jE.call(Function.apply, Array.prototype.splice),
    Cq = jE.call(Function.call, String.prototype.replace),
    qC = jE.call(Function.call, String.prototype.slice),
    ADe = jE.call(Function.call, RegExp.prototype.exec),
    TDe = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g,
    IDe = /\\(\\)?/g,
    RDe = function(e) {
        var n = qC(e, 0, 1),
            r = qC(e, -1);
        if (n === "%" && r !== "%") throw new Xb("invalid intrinsic syntax, expected closing `%`");
        if (r === "%" && n !== "%") throw new Xb("invalid intrinsic syntax, expected opening `%`");
        var i = [];
        return Cq(e, TDe, function(s, o, a, l) {
            i[i.length] = a ? Cq(l, IDe, "$1") : o || s
        }), i
    },
    ODe = function(e, n) {
        var r = e,
            i;
        if (GC(Sq, r) && (i = Sq[r], r = "%" + i[0] + "%"), GC(im, r)) {
            var s = im[r];
            if (s === Sw && (s = xDe(r)), typeof s > "u" && !n) throw new cv("intrinsic " + e + " exists, but is not available. Please file an issue!");
            return {
                alias: i,
                name: r,
                value: s
            }
        }
        throw new Xb("intrinsic " + e + " does not exist!")
    },
    F2 = function(e, n) {
        if (typeof e != "string" || e.length === 0) throw new cv("intrinsic name must be a non-empty string");
        if (arguments.length > 1 && typeof n != "boolean") throw new cv('"allowMissing" argument must be a boolean');
        if (ADe(/^%?[^%]*%?$/, e) === null) throw new Xb("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
        var r = RDe(e),
            i = r.length > 0 ? r[0] : "",
            s = ODe("%" + i + "%", n),
            o = s.name,
            a = s.value,
            l = !1,
            c = s.alias;
        c && (i = c[0], CDe(r, SDe([0, 1], c)));
        for (var u = 1, f = !0; u < r.length; u += 1) {
            var h = r[u],
                g = qC(h, 0, 1),
                y = qC(h, -1);
            if ((g === '"' || g === "'" || g === "`" || y === '"' || y === "'" || y === "`") && g !== y) throw new Xb("property names with quotes must have matching quotes");
            if ((h === "constructor" || !f) && (l = !0), i += "." + h, o = "%" + i + "%", GC(im, o)) a = im[o];
            else if (a != null) {
                if (!(h in a)) {
                    if (!n) throw new cv("base intrinsic for " + e + " exists, but the property is not available.");
                    return
                }
                if (rm && u + 1 >= r.length) {
                    var _ = rm(a, h);
                    f = !!_, f && "get" in _ && !("originalValue" in _.get) ? a = _.get : a = a[h]
                } else f = GC(a, h), a = a[h];
                f && !l && (im[o] = a)
            }
        }
        return a
    },
    ase = {
        exports: {}
    },
    DO, Aq;

function QL() {
    if (Aq) return DO;
    Aq = 1;
    var t = F2,
        e = t("%Object.defineProperty%", !0) || !1;
    if (e) try {
        e({}, "a", {
            value: 1
        })
    } catch {
        e = !1
    }
    return DO = e, DO
}
var NDe = F2,
    d8 = NDe("%Object.getOwnPropertyDescriptor%", !0);
if (d8) try {
    d8([], "length")
} catch {
    d8 = null
}
var lse = d8,
    Tq = QL(),
    PDe = sse,
    ow = UE,
    Iq = lse,
    kDe = function(e, n, r) {
        if (!e || typeof e != "object" && typeof e != "function") throw new ow("`obj` must be an object or a function`");
        if (typeof n != "string" && typeof n != "symbol") throw new ow("`property` must be a string or a symbol`");
        if (arguments.length > 3 && typeof arguments[3] != "boolean" && arguments[3] !== null) throw new ow("`nonEnumerable`, if provided, must be a boolean or null");
        if (arguments.length > 4 && typeof arguments[4] != "boolean" && arguments[4] !== null) throw new ow("`nonWritable`, if provided, must be a boolean or null");
        if (arguments.length > 5 && typeof arguments[5] != "boolean" && arguments[5] !== null) throw new ow("`nonConfigurable`, if provided, must be a boolean or null");
        if (arguments.length > 6 && typeof arguments[6] != "boolean") throw new ow("`loose`, if provided, must be a boolean");
        var i = arguments.length > 3 ? arguments[3] : null,
            s = arguments.length > 4 ? arguments[4] : null,
            o = arguments.length > 5 ? arguments[5] : null,
            a = arguments.length > 6 ? arguments[6] : !1,
            l = !!Iq && Iq(e, n);
        if (Tq) Tq(e, n, {
            configurable: o === null && l ? l.configurable : !o,
            enumerable: i === null && l ? l.enumerable : !i,
            value: r,
            writable: s === null && l ? l.writable : !s
        });
        else if (a || !i && !s && !o) e[n] = r;
        else throw new PDe("This environment does not support defining a property as non-configurable, non-writable, or non-enumerable.")
    },
    aM = QL(),
    cse = function() {
        return !!aM
    };
cse.hasArrayLengthDefineBug = function() {
    if (!aM) return null;
    try {
        return aM([], "length", {
            value: 1
        }).length !== 1
    } catch {
        return !0
    }
};
var MDe = cse,
    DDe = F2,
    Rq = kDe,
    $De = MDe(),
    Oq = lse,
    Nq = UE,
    LDe = DDe("%Math.floor%"),
    BDe = function(e, n) {
        if (typeof e != "function") throw new Nq("`fn` is not a function");
        if (typeof n != "number" || n < 0 || n > 4294967295 || LDe(n) !== n) throw new Nq("`length` must be a positive 32-bit integer");
        var r = arguments.length > 2 && !!arguments[2],
            i = !0,
            s = !0;
        if ("length" in e && Oq) {
            var o = Oq(e, "length");
            o && !o.configurable && (i = !1), o && !o.writable && (s = !1)
        }
        return (i || s || !r) && ($De ? Rq(e, "length", n, !0, !0) : Rq(e, "length", n)), e
    };
(function(t) {
    var e = ZL,
        n = F2,
        r = BDe,
        i = UE,
        s = n("%Function.prototype.apply%"),
        o = n("%Function.prototype.call%"),
        a = n("%Reflect.apply%", !0) || e.call(o, s),
        l = QL(),
        c = n("%Math.max%");
    t.exports = function(h) {
        if (typeof h != "function") throw new i("a function is required");
        var g = a(e, o, arguments);
        return r(g, 1 + c(0, h.length - (arguments.length - 1)), !0)
    };
    var u = function() {
        return a(e, s, arguments)
    };
    l ? l(t.exports, "apply", {
        value: u
    }) : t.exports.apply = u
})(ase);
var FDe = ase.exports,
    use = F2,
    fse = FDe,
    UDe = fse(use("String.prototype.indexOf")),
    jDe = function(e, n) {
        var r = use(e, !!n);
        return typeof r == "function" && UDe(e, ".prototype.") > -1 ? fse(r) : r
    },
    JL = typeof Map == "function" && Map.prototype,
    $O = Object.getOwnPropertyDescriptor && JL ? Object.getOwnPropertyDescriptor(Map.prototype, "size") : null,
    KC = JL && $O && typeof $O.get == "function" ? $O.get : null,
    Pq = JL && Map.prototype.forEach,
    XL = typeof Set == "function" && Set.prototype,
    LO = Object.getOwnPropertyDescriptor && XL ? Object.getOwnPropertyDescriptor(Set.prototype, "size") : null,
    YC = XL && LO && typeof LO.get == "function" ? LO.get : null,
    kq = XL && Set.prototype.forEach,
    HDe = typeof WeakMap == "function" && WeakMap.prototype,
    V3 = HDe ? WeakMap.prototype.has : null,
    zDe = typeof WeakSet == "function" && WeakSet.prototype,
    G3 = zDe ? WeakSet.prototype.has : null,
    WDe = typeof WeakRef == "function" && WeakRef.prototype,
    Mq = WDe ? WeakRef.prototype.deref : null,
    VDe = Boolean.prototype.valueOf,
    GDe = Object.prototype.toString,
    qDe = Function.prototype.toString,
    KDe = String.prototype.match,
    eB = String.prototype.slice,
    fp = String.prototype.replace,
    YDe = String.prototype.toUpperCase,
    Dq = String.prototype.toLowerCase,
    dse = RegExp.prototype.test,
    $q = Array.prototype.concat,
    Of = Array.prototype.join,
    ZDe = Array.prototype.slice,
    Lq = Math.floor,
    lM = typeof BigInt == "function" ? BigInt.prototype.valueOf : null,
    BO = Object.getOwnPropertySymbols,
    cM = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? Symbol.prototype.toString : null,
    e2 = typeof Symbol == "function" && typeof Symbol.iterator == "object",
    $o = typeof Symbol == "function" && Symbol.toStringTag && (typeof Symbol.toStringTag === e2 || !0) ? Symbol.toStringTag : null,
    hse = Object.prototype.propertyIsEnumerable,
    Bq = (typeof Reflect == "function" ? Reflect.getPrototypeOf : Object.getPrototypeOf) || ([].__proto__ === Array.prototype ? function(t) {
        return t.__proto__
    } : null);

function Fq(t, e) {
    if (t === 1 / 0 || t === -1 / 0 || t !== t || t && t > -1e3 && t < 1e3 || dse.call(/e/, e)) return e;
    var n = /[0-9](?=(?:[0-9]{3})+(?![0-9]))/g;
    if (typeof t == "number") {
        var r = t < 0 ? -Lq(-t) : Lq(t);
        if (r !== t) {
            var i = String(r),
                s = eB.call(e, i.length + 1);
            return fp.call(i, n, "$&_") + "." + fp.call(fp.call(s, /([0-9]{3})/g, "$&_"), /_$/, "")
        }
    }
    return fp.call(e, n, "$&_")
}
var uM = vE,
    Uq = uM.custom,
    jq = gse(Uq) ? Uq : null,
    QDe = function t(e, n, r, i) {
        var s = n || {};
        if (C0(s, "quoteStyle") && s.quoteStyle !== "single" && s.quoteStyle !== "double") throw new TypeError('option "quoteStyle" must be "single" or "double"');
        if (C0(s, "maxStringLength") && (typeof s.maxStringLength == "number" ? s.maxStringLength < 0 && s.maxStringLength !== 1 / 0 : s.maxStringLength !== null)) throw new TypeError('option "maxStringLength", if provided, must be a positive integer, Infinity, or `null`');
        var o = C0(s, "customInspect") ? s.customInspect : !0;
        if (typeof o != "boolean" && o !== "symbol") throw new TypeError("option \"customInspect\", if provided, must be `true`, `false`, or `'symbol'`");
        if (C0(s, "indent") && s.indent !== null && s.indent !== "	" && !(parseInt(s.indent, 10) === s.indent && s.indent > 0)) throw new TypeError('option "indent" must be "\\t", an integer > 0, or `null`');
        if (C0(s, "numericSeparator") && typeof s.numericSeparator != "boolean") throw new TypeError('option "numericSeparator", if provided, must be `true` or `false`');
        var a = s.numericSeparator;
        if (typeof e > "u") return "undefined";
        if (e === null) return "null";
        if (typeof e == "boolean") return e ? "true" : "false";
        if (typeof e == "string") return yse(e, s);
        if (typeof e == "number") {
            if (e === 0) return 1 / 0 / e > 0 ? "0" : "-0";
            var l = String(e);
            return a ? Fq(e, l) : l
        }
        if (typeof e == "bigint") {
            var c = String(e) + "n";
            return a ? Fq(e, c) : c
        }
        var u = typeof s.depth > "u" ? 5 : s.depth;
        if (typeof r > "u" && (r = 0), r >= u && u > 0 && typeof e == "object") return fM(e) ? "[Array]" : "[Object]";
        var f = g$e(s, r);
        if (typeof i > "u") i = [];
        else if (mse(i, e) >= 0) return "[Circular]";

        function h(U, m, v) {
            if (m && (i = ZDe.call(i), i.push(m)), v) {
                var T = {
                    depth: s.depth
                };
                return C0(s, "quoteStyle") && (T.quoteStyle = s.quoteStyle), t(U, T, r + 1, i)
            }
            return t(U, s, r + 1, i)
        }
        if (typeof e == "function" && !Hq(e)) {
            var g = o$e(e),
                y = Xx(e, h);
            return "[Function" + (g ? ": " + g : " (anonymous)") + "]" + (y.length > 0 ? " { " + Of.call(y, ", ") + " }" : "")
        }
        if (gse(e)) {
            var _ = e2 ? fp.call(String(e), /^(Symbol\(.*\))_[^)]*$/, "$1") : cM.call(e);
            return typeof e == "object" && !e2 ? q5(_) : _
        }
        if (d$e(e)) {
            for (var C = "<" + Dq.call(String(e.nodeName)), b = e.attributes || [], w = 0; w < b.length; w++) C += " " + b[w].name + "=" + pse(JDe(b[w].value), "double", s);
            return C += ">", e.childNodes && e.childNodes.length && (C += "..."), C += "</" + Dq.call(String(e.nodeName)) + ">", C
        }
        if (fM(e)) {
            if (e.length === 0) return "[]";
            var S = Xx(e, h);
            return f && !p$e(S) ? "[" + dM(S, f) + "]" : "[ " + Of.call(S, ", ") + " ]"
        }
        if (e$e(e)) {
            var I = Xx(e, h);
            return !("cause" in Error.prototype) && "cause" in e && !hse.call(e, "cause") ? "{ [" + String(e) + "] " + Of.call($q.call("[cause]: " + h(e.cause), I), ", ") + " }" : I.length === 0 ? "[" + String(e) + "]" : "{ [" + String(e) + "] " + Of.call(I, ", ") + " }"
        }
        if (typeof e == "object" && o) {
            if (jq && typeof e[jq] == "function" && uM) return uM(e, {
                depth: u - r
            });
            if (o !== "symbol" && typeof e.inspect == "function") return e.inspect()
        }
        if (a$e(e)) {
            var P = [];
            return Pq && Pq.call(e, function(U, m) {
                P.push(h(m, e, !0) + " => " + h(U, e))
            }), zq("Map", KC.call(e), P, f)
        }
        if (u$e(e)) {
            var M = [];
            return kq && kq.call(e, function(U) {
                M.push(h(U, e))
            }), zq("Set", YC.call(e), M, f)
        }
        if (l$e(e)) return FO("WeakMap");
        if (f$e(e)) return FO("WeakSet");
        if (c$e(e)) return FO("WeakRef");
        if (n$e(e)) return q5(h(Number(e)));
        if (i$e(e)) return q5(h(lM.call(e)));
        if (r$e(e)) return q5(VDe.call(e));
        if (t$e(e)) return q5(h(String(e)));
        if (typeof window < "u" && e === window) return "{ [object Window] }";
        if (typeof globalThis < "u" && e === globalThis || typeof st < "u" && e === st) return "{ [object globalThis] }";
        if (!XDe(e) && !Hq(e)) {
            var A = Xx(e, h),
                E = Bq ? Bq(e) === Object.prototype : e instanceof Object || e.constructor === Object,
                $ = e instanceof Object ? "" : "null prototype",
                H = !E && $o && Object(e) === e && $o in e ? eB.call(ug(e), 8, -1) : $ ? "Object" : "",
                K = E || typeof e.constructor != "function" ? "" : e.constructor.name ? e.constructor.name + " " : "",
                te = K + (H || $ ? "[" + Of.call($q.call([], H || [], $ || []), ": ") + "] " : "");
            return A.length === 0 ? te + "{}" : f ? te + "{" + dM(A, f) + "}" : te + "{ " + Of.call(A, ", ") + " }"
        }
        return String(e)
    };

function pse(t, e, n) {
    var r = (n.quoteStyle || e) === "double" ? '"' : "'";
    return r + t + r
}

function JDe(t) {
    return fp.call(String(t), /"/g, "&quot;")
}

function fM(t) {
    return ug(t) === "[object Array]" && (!$o || !(typeof t == "object" && $o in t))
}

function XDe(t) {
    return ug(t) === "[object Date]" && (!$o || !(typeof t == "object" && $o in t))
}

function Hq(t) {
    return ug(t) === "[object RegExp]" && (!$o || !(typeof t == "object" && $o in t))
}

function e$e(t) {
    return ug(t) === "[object Error]" && (!$o || !(typeof t == "object" && $o in t))
}

function t$e(t) {
    return ug(t) === "[object String]" && (!$o || !(typeof t == "object" && $o in t))
}

function n$e(t) {
    return ug(t) === "[object Number]" && (!$o || !(typeof t == "object" && $o in t))
}

function r$e(t) {
    return ug(t) === "[object Boolean]" && (!$o || !(typeof t == "object" && $o in t))
}

function gse(t) {
    if (e2) return t && typeof t == "object" && t instanceof Symbol;
    if (typeof t == "symbol") return !0;
    if (!t || typeof t != "object" || !cM) return !1;
    try {
        return cM.call(t), !0
    } catch {}
    return !1
}

function i$e(t) {
    if (!t || typeof t != "object" || !lM) return !1;
    try {
        return lM.call(t), !0
    } catch {}
    return !1
}
var s$e = Object.prototype.hasOwnProperty || function(t) {
    return t in this
};

function C0(t, e) {
    return s$e.call(t, e)
}

function ug(t) {
    return GDe.call(t)
}

function o$e(t) {
    if (t.name) return t.name;
    var e = KDe.call(qDe.call(t), /^function\s*([\w$]+)/);
    return e ? e[1] : null
}

function mse(t, e) {
    if (t.indexOf) return t.indexOf(e);
    for (var n = 0, r = t.length; n < r; n++)
        if (t[n] === e) return n;
    return -1
}

function a$e(t) {
    if (!KC || !t || typeof t != "object") return !1;
    try {
        KC.call(t);
        try {
            YC.call(t)
        } catch {
            return !0
        }
        return t instanceof Map
    } catch {}
    return !1
}

function l$e(t) {
    if (!V3 || !t || typeof t != "object") return !1;
    try {
        V3.call(t, V3);
        try {
            G3.call(t, G3)
        } catch {
            return !0
        }
        return t instanceof WeakMap
    } catch {}
    return !1
}

function c$e(t) {
    if (!Mq || !t || typeof t != "object") return !1;
    try {
        return Mq.call(t), !0
    } catch {}
    return !1
}

function u$e(t) {
    if (!YC || !t || typeof t != "object") return !1;
    try {
        YC.call(t);
        try {
            KC.call(t)
        } catch {
            return !0
        }
        return t instanceof Set
    } catch {}
    return !1
}

function f$e(t) {
    if (!G3 || !t || typeof t != "object") return !1;
    try {
        G3.call(t, G3);
        try {
            V3.call(t, V3)
        } catch {
            return !0
        }
        return t instanceof WeakSet
    } catch {}
    return !1
}

function d$e(t) {
    return !t || typeof t != "object" ? !1 : typeof HTMLElement < "u" && t instanceof HTMLElement ? !0 : typeof t.nodeName == "string" && typeof t.getAttribute == "function"
}

function yse(t, e) {
    if (t.length > e.maxStringLength) {
        var n = t.length - e.maxStringLength,
            r = "... " + n + " more character" + (n > 1 ? "s" : "");
        return yse(eB.call(t, 0, e.maxStringLength), e) + r
    }
    var i = fp.call(fp.call(t, /(['\\])/g, "\\$1"), /[\x00-\x1f]/g, h$e);
    return pse(i, "single", e)
}

function h$e(t) {
    var e = t.charCodeAt(0),
        n = {
            8: "b",
            9: "t",
            10: "n",
            12: "f",
            13: "r"
        }[e];
    return n ? "\\" + n : "\\x" + (e < 16 ? "0" : "") + YDe.call(e.toString(16))
}

function q5(t) {
    return "Object(" + t + ")"
}

function FO(t) {
    return t + " { ? }"
}

function zq(t, e, n, r) {
    var i = r ? dM(n, r) : Of.call(n, ", ");
    return t + " (" + e + ") {" + i + "}"
}

function p$e(t) {
    for (var e = 0; e < t.length; e++)
        if (mse(t[e], `
`) >= 0) return !1;
    return !0
}

function g$e(t, e) {
    var n;
    if (t.indent === "	") n = "	";
    else if (typeof t.indent == "number" && t.indent > 0) n = Of.call(Array(t.indent + 1), " ");
    else return null;
    return {
        base: n,
        prev: Of.call(Array(e + 1), n)
    }
}

function dM(t, e) {
    if (t.length === 0) return "";
    var n = `
` + e.prev + e.base;
    return n + Of.call(t, "," + n) + `
` + e.prev
}

function Xx(t, e) {
    var n = fM(t),
        r = [];
    if (n) {
        r.length = t.length;
        for (var i = 0; i < t.length; i++) r[i] = C0(t, i) ? e(t[i], t) : ""
    }
    var s = typeof BO == "function" ? BO(t) : [],
        o;
    if (e2) {
        o = {};
        for (var a = 0; a < s.length; a++) o["$" + s[a]] = s[a]
    }
    for (var l in t) C0(t, l) && (n && String(Number(l)) === l && l < t.length || e2 && o["$" + l] instanceof Symbol || (dse.call(/[^\w$]/, l) ? r.push(e(l, t) + ": " + e(t[l], t)) : r.push(l + ": " + e(t[l], t))));
    if (typeof BO == "function")
        for (var c = 0; c < s.length; c++) hse.call(t, s[c]) && r.push("[" + e(s[c]) + "]: " + e(t[s[c]], t));
    return r
}
var wse = F2,
    U2 = jDe,
    m$e = QDe,
    y$e = UE,
    eS = wse("%WeakMap%", !0),
    tS = wse("%Map%", !0),
    w$e = U2("WeakMap.prototype.get", !0),
    v$e = U2("WeakMap.prototype.set", !0),
    b$e = U2("WeakMap.prototype.has", !0),
    _$e = U2("Map.prototype.get", !0),
    E$e = U2("Map.prototype.set", !0),
    x$e = U2("Map.prototype.has", !0),
    tB = function(t, e) {
        for (var n = t, r;
            (r = n.next) !== null; n = r)
            if (r.key === e) return n.next = r.next, r.next = t.next, t.next = r, r
    },
    S$e = function(t, e) {
        var n = tB(t, e);
        return n && n.value
    },
    C$e = function(t, e, n) {
        var r = tB(t, e);
        r ? r.value = n : t.next = {
            key: e,
            next: t.next,
            value: n
        }
    },
    A$e = function(t, e) {
        return !!tB(t, e)
    },
    T$e = function() {
        var e, n, r, i = {
            assert: function(s) {
                if (!i.has(s)) throw new y$e("Side channel does not contain " + m$e(s))
            },
            get: function(s) {
                if (eS && s && (typeof s == "object" || typeof s == "function")) {
                    if (e) return w$e(e, s)
                } else if (tS) {
                    if (n) return _$e(n, s)
                } else if (r) return S$e(r, s)
            },
            has: function(s) {
                if (eS && s && (typeof s == "object" || typeof s == "function")) {
                    if (e) return b$e(e, s)
                } else if (tS) {
                    if (n) return x$e(n, s)
                } else if (r) return A$e(r, s);
                return !1
            },
            set: function(s, o) {
                eS && s && (typeof s == "object" || typeof s == "function") ? (e || (e = new eS), v$e(e, s, o)) : tS ? (n || (n = new tS), E$e(n, s, o)) : (r || (r = {
                    key: {},
                    next: null
                }), C$e(r, s, o))
            }
        };
        return i
    },
    I$e = String.prototype.replace,
    R$e = /%20/g,
    UO = {
        RFC1738: "RFC1738",
        RFC3986: "RFC3986"
    },
    nB = {
        default: UO.RFC3986,
        formatters: {
            RFC1738: function(t) {
                return I$e.call(t, R$e, "+")
            },
            RFC3986: function(t) {
                return String(t)
            }
        },
        RFC1738: UO.RFC1738,
        RFC3986: UO.RFC3986
    },
    O$e = nB,
    jO = Object.prototype.hasOwnProperty,
    Jg = Array.isArray,
    of = function() {
        for (var t = [], e = 0; e < 256; ++e) t.push("%" + ((e < 16 ? "0" : "") + e.toString(16)).toUpperCase());
        return t
    }(),
    N$e = function(e) {
        for (; e.length > 1;) {
            var n = e.pop(),
                r = n.obj[n.prop];
            if (Jg(r)) {
                for (var i = [], s = 0; s < r.length; ++s) typeof r[s] < "u" && i.push(r[s]);
                n.obj[n.prop] = i
            }
        }
    },
    vse = function(e, n) {
        for (var r = n && n.plainObjects ? Object.create(null) : {}, i = 0; i < e.length; ++i) typeof e[i] < "u" && (r[i] = e[i]);
        return r
    },
    P$e = function t(e, n, r) {
        if (!n) return e;
        if (typeof n != "object") {
            if (Jg(e)) e.push(n);
            else if (e && typeof e == "object")(r && (r.plainObjects || r.allowPrototypes) || !jO.call(Object.prototype, n)) && (e[n] = !0);
            else return [e, n];
            return e
        }
        if (!e || typeof e != "object") return [e].concat(n);
        var i = e;
        return Jg(e) && !Jg(n) && (i = vse(e, r)), Jg(e) && Jg(n) ? (n.forEach(function(s, o) {
            if (jO.call(e, o)) {
                var a = e[o];
                a && typeof a == "object" && s && typeof s == "object" ? e[o] = t(a, s, r) : e.push(s)
            } else e[o] = s
        }), e) : Object.keys(n).reduce(function(s, o) {
            var a = n[o];
            return jO.call(s, o) ? s[o] = t(s[o], a, r) : s[o] = a, s
        }, i)
    },
    k$e = function(e, n) {
        return Object.keys(n).reduce(function(r, i) {
            return r[i] = n[i], r
        }, e)
    },
    M$e = function(t, e, n) {
        var r = t.replace(/\+/g, " ");
        if (n === "iso-8859-1") return r.replace(/%[0-9a-f]{2}/gi, unescape);
        try {
            return decodeURIComponent(r)
        } catch {
            return r
        }
    },
    HO = 1024,
    D$e = function(e, n, r, i, s) {
        if (e.length === 0) return e;
        var o = e;
        if (typeof e == "symbol" ? o = Symbol.prototype.toString.call(e) : typeof e != "string" && (o = String(e)), r === "iso-8859-1") return escape(o).replace(/%u[0-9a-f]{4}/gi, function(g) {
            return "%26%23" + parseInt(g.slice(2), 16) + "%3B"
        });
        for (var a = "", l = 0; l < o.length; l += HO) {
            for (var c = o.length >= HO ? o.slice(l, l + HO) : o, u = [], f = 0; f < c.length; ++f) {
                var h = c.charCodeAt(f);
                if (h === 45 || h === 46 || h === 95 || h === 126 || h >= 48 && h <= 57 || h >= 65 && h <= 90 || h >= 97 && h <= 122 || s === O$e.RFC1738 && (h === 40 || h === 41)) {
                    u[u.length] = c.charAt(f);
                    continue
                }
                if (h < 128) {
                    u[u.length] = of [h];
                    continue
                }
                if (h < 2048) {
                    u[u.length] = of [192 | h >> 6] + of [128 | h & 63];
                    continue
                }
                if (h < 55296 || h >= 57344) {
                    u[u.length] = of [224 | h >> 12] + of [128 | h >> 6 & 63] + of [128 | h & 63];
                    continue
                }
                f += 1, h = 65536 + ((h & 1023) << 10 | c.charCodeAt(f) & 1023), u[u.length] = of [240 | h >> 18] + of [128 | h >> 12 & 63] + of [128 | h >> 6 & 63] + of [128 | h & 63]
            }
            a += u.join("")
        }
        return a
    },
    $$e = function(e) {
        for (var n = [{
                obj: {
                    o: e
                },
                prop: "o"
            }], r = [], i = 0; i < n.length; ++i)
            for (var s = n[i], o = s.obj[s.prop], a = Object.keys(o), l = 0; l < a.length; ++l) {
                var c = a[l],
                    u = o[c];
                typeof u == "object" && u !== null && r.indexOf(u) === -1 && (n.push({
                    obj: o,
                    prop: c
                }), r.push(u))
            }
        return N$e(n), e
    },
    L$e = function(e) {
        return Object.prototype.toString.call(e) === "[object RegExp]"
    },
    B$e = function(e) {
        return !e || typeof e != "object" ? !1 : !!(e.constructor && e.constructor.isBuffer && e.constructor.isBuffer(e))
    },
    F$e = function(e, n) {
        return [].concat(e, n)
    },
    U$e = function(e, n) {
        if (Jg(e)) {
            for (var r = [], i = 0; i < e.length; i += 1) r.push(n(e[i]));
            return r
        }
        return n(e)
    },
    bse = {
        arrayToObject: vse,
        assign: k$e,
        combine: F$e,
        compact: $$e,
        decode: M$e,
        encode: D$e,
        isBuffer: B$e,
        isRegExp: L$e,
        maybeMap: U$e,
        merge: P$e
    },
    _se = T$e,
    h8 = bse,
    q3 = nB,
    j$e = Object.prototype.hasOwnProperty,
    Ese = {
        brackets: function(e) {
            return e + "[]"
        },
        comma: "comma",
        indices: function(e, n) {
            return e + "[" + n + "]"
        },
        repeat: function(e) {
            return e
        }
    },
    mf = Array.isArray,
    H$e = Array.prototype.push,
    xse = function(t, e) {
        H$e.apply(t, mf(e) ? e : [e])
    },
    z$e = Date.prototype.toISOString,
    Wq = q3.default,
    Ts = {
        addQueryPrefix: !1,
        allowDots: !1,
        allowEmptyArrays: !1,
        arrayFormat: "indices",
        charset: "utf-8",
        charsetSentinel: !1,
        delimiter: "&",
        encode: !0,
        encodeDotInKeys: !1,
        encoder: h8.encode,
        encodeValuesOnly: !1,
        format: Wq,
        formatter: q3.formatters[Wq],
        indices: !1,
        serializeDate: function(e) {
            return z$e.call(e)
        },
        skipNulls: !1,
        strictNullHandling: !1
    },
    W$e = function(e) {
        return typeof e == "string" || typeof e == "number" || typeof e == "boolean" || typeof e == "symbol" || typeof e == "bigint"
    },
    zO = {},
    V$e = function t(e, n, r, i, s, o, a, l, c, u, f, h, g, y, _, C, b, w) {
        for (var S = e, I = w, P = 0, M = !1;
            (I = I.get(zO)) !== void 0 && !M;) {
            var A = I.get(e);
            if (P += 1, typeof A < "u") {
                if (A === P) throw new RangeError("Cyclic object value");
                M = !0
            }
            typeof I.get(zO) > "u" && (P = 0)
        }
        if (typeof u == "function" ? S = u(n, S) : S instanceof Date ? S = g(S) : r === "comma" && mf(S) && (S = h8.maybeMap(S, function(G) {
                return G instanceof Date ? g(G) : G
            })), S === null) {
            if (o) return c && !C ? c(n, Ts.encoder, b, "key", y) : n;
            S = ""
        }
        if (W$e(S) || h8.isBuffer(S)) {
            if (c) {
                var E = C ? n : c(n, Ts.encoder, b, "key", y);
                return [_(E) + "=" + _(c(S, Ts.encoder, b, "value", y))]
            }
            return [_(n) + "=" + _(String(S))]
        }
        var $ = [];
        if (typeof S > "u") return $;
        var H;
        if (r === "comma" && mf(S)) C && c && (S = h8.maybeMap(S, c)), H = [{
            value: S.length > 0 ? S.join(",") || null : void 0
        }];
        else if (mf(u)) H = u;
        else {
            var K = Object.keys(S);
            H = f ? K.sort(f) : K
        }
        var te = l ? n.replace(/\./g, "%2E") : n,
            U = i && mf(S) && S.length === 1 ? te + "[]" : te;
        if (s && mf(S) && S.length === 0) return U + "[]";
        for (var m = 0; m < H.length; ++m) {
            var v = H[m],
                T = typeof v == "object" && typeof v.value < "u" ? v.value : S[v];
            if (!(a && T === null)) {
                var N = h && l ? v.replace(/\./g, "%2E") : v,
                    O = mf(S) ? typeof r == "function" ? r(U, N) : U : U + (h ? "." + N : "[" + N + "]");
                w.set(e, P);
                var L = _se();
                L.set(zO, w), xse($, t(T, O, r, i, s, o, a, l, r === "comma" && C && mf(S) ? null : c, u, f, h, g, y, _, C, b, L))
            }
        }
        return $
    },
    G$e = function(e) {
        if (!e) return Ts;
        if (typeof e.allowEmptyArrays < "u" && typeof e.allowEmptyArrays != "boolean") throw new TypeError("`allowEmptyArrays` option can only be `true` or `false`, when provided");
        if (typeof e.encodeDotInKeys < "u" && typeof e.encodeDotInKeys != "boolean") throw new TypeError("`encodeDotInKeys` option can only be `true` or `false`, when provided");
        if (e.encoder !== null && typeof e.encoder < "u" && typeof e.encoder != "function") throw new TypeError("Encoder has to be a function.");
        var n = e.charset || Ts.charset;
        if (typeof e.charset < "u" && e.charset !== "utf-8" && e.charset !== "iso-8859-1") throw new TypeError("The charset option must be either utf-8, iso-8859-1, or undefined");
        var r = q3.default;
        if (typeof e.format < "u") {
            if (!j$e.call(q3.formatters, e.format)) throw new TypeError("Unknown format option provided.");
            r = e.format
        }
        var i = q3.formatters[r],
            s = Ts.filter;
        (typeof e.filter == "function" || mf(e.filter)) && (s = e.filter);
        var o;
        if (e.arrayFormat in Ese ? o = e.arrayFormat : "indices" in e ? o = e.indices ? "indices" : "repeat" : o = Ts.arrayFormat, "commaRoundTrip" in e && typeof e.commaRoundTrip != "boolean") throw new TypeError("`commaRoundTrip` must be a boolean, or absent");
        var a = typeof e.allowDots > "u" ? e.encodeDotInKeys === !0 ? !0 : Ts.allowDots : !!e.allowDots;
        return {
            addQueryPrefix: typeof e.addQueryPrefix == "boolean" ? e.addQueryPrefix : Ts.addQueryPrefix,
            allowDots: a,
            allowEmptyArrays: typeof e.allowEmptyArrays == "boolean" ? !!e.allowEmptyArrays : Ts.allowEmptyArrays,
            arrayFormat: o,
            charset: n,
            charsetSentinel: typeof e.charsetSentinel == "boolean" ? e.charsetSentinel : Ts.charsetSentinel,
            commaRoundTrip: e.commaRoundTrip,
            delimiter: typeof e.delimiter > "u" ? Ts.delimiter : e.delimiter,
            encode: typeof e.encode == "boolean" ? e.encode : Ts.encode,
            encodeDotInKeys: typeof e.encodeDotInKeys == "boolean" ? e.encodeDotInKeys : Ts.encodeDotInKeys,
            encoder: typeof e.encoder == "function" ? e.encoder : Ts.encoder,
            encodeValuesOnly: typeof e.encodeValuesOnly == "boolean" ? e.encodeValuesOnly : Ts.encodeValuesOnly,
            filter: s,
            format: r,
            formatter: i,
            serializeDate: typeof e.serializeDate == "function" ? e.serializeDate : Ts.serializeDate,
            skipNulls: typeof e.skipNulls == "boolean" ? e.skipNulls : Ts.skipNulls,
            sort: typeof e.sort == "function" ? e.sort : null,
            strictNullHandling: typeof e.strictNullHandling == "boolean" ? e.strictNullHandling : Ts.strictNullHandling
        }
    },
    q$e = function(t, e) {
        var n = t,
            r = G$e(e),
            i, s;
        typeof r.filter == "function" ? (s = r.filter, n = s("", n)) : mf(r.filter) && (s = r.filter, i = s);
        var o = [];
        if (typeof n != "object" || n === null) return "";
        var a = Ese[r.arrayFormat],
            l = a === "comma" && r.commaRoundTrip;
        i || (i = Object.keys(n)), r.sort && i.sort(r.sort);
        for (var c = _se(), u = 0; u < i.length; ++u) {
            var f = i[u];
            r.skipNulls && n[f] === null || xse(o, V$e(n[f], f, a, l, r.allowEmptyArrays, r.strictNullHandling, r.skipNulls, r.encodeDotInKeys, r.encode ? r.encoder : null, r.filter, r.sort, r.allowDots, r.serializeDate, r.format, r.formatter, r.encodeValuesOnly, r.charset, c))
        }
        var h = o.join(r.delimiter),
            g = r.addQueryPrefix === !0 ? "?" : "";
        return r.charsetSentinel && (r.charset === "iso-8859-1" ? g += "utf8=%26%2310003%3B&" : g += "utf8=%E2%9C%93&"), h.length > 0 ? g + h : ""
    },
    t2 = bse,
    hM = Object.prototype.hasOwnProperty,
    K$e = Array.isArray,
    Bi = {
        allowDots: !1,
        allowEmptyArrays: !1,
        allowPrototypes: !1,
        allowSparse: !1,
        arrayLimit: 20,
        charset: "utf-8",
        charsetSentinel: !1,
        comma: !1,
        decodeDotInKeys: !1,
        decoder: t2.decode,
        delimiter: "&",
        depth: 5,
        duplicates: "combine",
        ignoreQueryPrefix: !1,
        interpretNumericEntities: !1,
        parameterLimit: 1e3,
        parseArrays: !0,
        plainObjects: !1,
        strictDepth: !1,
        strictNullHandling: !1
    },
    Y$e = function(t) {
        return t.replace(/&#(\d+);/g, function(e, n) {
            return String.fromCharCode(parseInt(n, 10))
        })
    },
    Sse = function(t, e) {
        return t && typeof t == "string" && e.comma && t.indexOf(",") > -1 ? t.split(",") : t
    },
    Z$e = "utf8=%26%2310003%3B",
    Q$e = "utf8=%E2%9C%93",
    J$e = function(e, n) {
        var r = {
                __proto__: null
            },
            i = n.ignoreQueryPrefix ? e.replace(/^\?/, "") : e;
        i = i.replace(/%5B/gi, "[").replace(/%5D/gi, "]");
        var s = n.parameterLimit === 1 / 0 ? void 0 : n.parameterLimit,
            o = i.split(n.delimiter, s),
            a = -1,
            l, c = n.charset;
        if (n.charsetSentinel)
            for (l = 0; l < o.length; ++l) o[l].indexOf("utf8=") === 0 && (o[l] === Q$e ? c = "utf-8" : o[l] === Z$e && (c = "iso-8859-1"), a = l, l = o.length);
        for (l = 0; l < o.length; ++l)
            if (l !== a) {
                var u = o[l],
                    f = u.indexOf("]="),
                    h = f === -1 ? u.indexOf("=") : f + 1,
                    g, y;
                h === -1 ? (g = n.decoder(u, Bi.decoder, c, "key"), y = n.strictNullHandling ? null : "") : (g = n.decoder(u.slice(0, h), Bi.decoder, c, "key"), y = t2.maybeMap(Sse(u.slice(h + 1), n), function(C) {
                    return n.decoder(C, Bi.decoder, c, "value")
                })), y && n.interpretNumericEntities && c === "iso-8859-1" && (y = Y$e(y)), u.indexOf("[]=") > -1 && (y = K$e(y) ? [y] : y);
                var _ = hM.call(r, g);
                _ && n.duplicates === "combine" ? r[g] = t2.combine(r[g], y) : (!_ || n.duplicates === "last") && (r[g] = y)
            }
        return r
    },
    X$e = function(t, e, n, r) {
        for (var i = r ? e : Sse(e, n), s = t.length - 1; s >= 0; --s) {
            var o, a = t[s];
            if (a === "[]" && n.parseArrays) o = n.allowEmptyArrays && (i === "" || n.strictNullHandling && i === null) ? [] : [].concat(i);
            else {
                o = n.plainObjects ? Object.create(null) : {};
                var l = a.charAt(0) === "[" && a.charAt(a.length - 1) === "]" ? a.slice(1, -1) : a,
                    c = n.decodeDotInKeys ? l.replace(/%2E/g, ".") : l,
                    u = parseInt(c, 10);
                !n.parseArrays && c === "" ? o = {
                    0: i
                } : !isNaN(u) && a !== c && String(u) === c && u >= 0 && n.parseArrays && u <= n.arrayLimit ? (o = [], o[u] = i) : c !== "__proto__" && (o[c] = i)
            }
            i = o
        }
        return i
    },
    eLe = function(e, n, r, i) {
        if (e) {
            var s = r.allowDots ? e.replace(/\.([^.[]+)/g, "[$1]") : e,
                o = /(\[[^[\]]*])/,
                a = /(\[[^[\]]*])/g,
                l = r.depth > 0 && o.exec(s),
                c = l ? s.slice(0, l.index) : s,
                u = [];
            if (c) {
                if (!r.plainObjects && hM.call(Object.prototype, c) && !r.allowPrototypes) return;
                u.push(c)
            }
            for (var f = 0; r.depth > 0 && (l = a.exec(s)) !== null && f < r.depth;) {
                if (f += 1, !r.plainObjects && hM.call(Object.prototype, l[1].slice(1, -1)) && !r.allowPrototypes) return;
                u.push(l[1])
            }
            if (l) {
                if (r.strictDepth === !0) throw new RangeError("Input depth exceeded depth option of " + r.depth + " and strictDepth is true");
                u.push("[" + s.slice(l.index) + "]")
            }
            return X$e(u, n, r, i)
        }
    },
    tLe = function(e) {
        if (!e) return Bi;
        if (typeof e.allowEmptyArrays < "u" && typeof e.allowEmptyArrays != "boolean") throw new TypeError("`allowEmptyArrays` option can only be `true` or `false`, when provided");
        if (typeof e.decodeDotInKeys < "u" && typeof e.decodeDotInKeys != "boolean") throw new TypeError("`decodeDotInKeys` option can only be `true` or `false`, when provided");
        if (e.decoder !== null && typeof e.decoder < "u" && typeof e.decoder != "function") throw new TypeError("Decoder has to be a function.");
        if (typeof e.charset < "u" && e.charset !== "utf-8" && e.charset !== "iso-8859-1") throw new TypeError("The charset option must be either utf-8, iso-8859-1, or undefined");
        var n = typeof e.charset > "u" ? Bi.charset : e.charset,
            r = typeof e.duplicates > "u" ? Bi.duplicates : e.duplicates;
        if (r !== "combine" && r !== "first" && r !== "last") throw new TypeError("The duplicates option must be either combine, first, or last");
        var i = typeof e.allowDots > "u" ? e.decodeDotInKeys === !0 ? !0 : Bi.allowDots : !!e.allowDots;
        return {
            allowDots: i,
            allowEmptyArrays: typeof e.allowEmptyArrays == "boolean" ? !!e.allowEmptyArrays : Bi.allowEmptyArrays,
            allowPrototypes: typeof e.allowPrototypes == "boolean" ? e.allowPrototypes : Bi.allowPrototypes,
            allowSparse: typeof e.allowSparse == "boolean" ? e.allowSparse : Bi.allowSparse,
            arrayLimit: typeof e.arrayLimit == "number" ? e.arrayLimit : Bi.arrayLimit,
            charset: n,
            charsetSentinel: typeof e.charsetSentinel == "boolean" ? e.charsetSentinel : Bi.charsetSentinel,
            comma: typeof e.comma == "boolean" ? e.comma : Bi.comma,
            decodeDotInKeys: typeof e.decodeDotInKeys == "boolean" ? e.decodeDotInKeys : Bi.decodeDotInKeys,
            decoder: typeof e.decoder == "function" ? e.decoder : Bi.decoder,
            delimiter: typeof e.delimiter == "string" || t2.isRegExp(e.delimiter) ? e.delimiter : Bi.delimiter,
            depth: typeof e.depth == "number" || e.depth === !1 ? +e.depth : Bi.depth,
            duplicates: r,
            ignoreQueryPrefix: e.ignoreQueryPrefix === !0,
            interpretNumericEntities: typeof e.interpretNumericEntities == "boolean" ? e.interpretNumericEntities : Bi.interpretNumericEntities,
            parameterLimit: typeof e.parameterLimit == "number" ? e.parameterLimit : Bi.parameterLimit,
            parseArrays: e.parseArrays !== !1,
            plainObjects: typeof e.plainObjects == "boolean" ? e.plainObjects : Bi.plainObjects,
            strictDepth: typeof e.strictDepth == "boolean" ? !!e.strictDepth : Bi.strictDepth,
            strictNullHandling: typeof e.strictNullHandling == "boolean" ? e.strictNullHandling : Bi.strictNullHandling
        }
    },
    nLe = function(t, e) {
        var n = tLe(e);
        if (t === "" || t === null || typeof t > "u") return n.plainObjects ? Object.create(null) : {};
        for (var r = typeof t == "string" ? J$e(t, n) : t, i = n.plainObjects ? Object.create(null) : {}, s = Object.keys(r), o = 0; o < s.length; ++o) {
            var a = s[o],
                l = eLe(a, r[a], n, typeof t == "string");
            i = t2.merge(i, l, n)
        }
        return n.allowSparse === !0 ? i : t2.compact(i)
    },
    rLe = q$e,
    iLe = nLe,
    sLe = nB,
    oLe = {
        formats: sLe,
        parse: iLe,
        stringify: rLe
    },
    HE = {};
(function(t) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    }), t.ProviderType = t.RegExpString = t.IntNumber = t.BigIntString = t.AddressString = t.HexString = t.OpaqueType = void 0;

    function e() {
        return r => r
    }
    t.OpaqueType = e, t.HexString = e(), t.AddressString = e(), t.BigIntString = e();

    function n(r) {
        return Math.floor(r)
    }
    t.IntNumber = n, t.RegExpString = e(),
        function(r) {
            r.CoinbaseWallet = "CoinbaseWallet", r.MetaMask = "MetaMask", r.Unselected = ""
        }(t.ProviderType || (t.ProviderType = {}))
})(HE);
var aLe = st && st.__importDefault || function(t) {
    return t && t.__esModule ? t : {
        default: t
    }
};
Object.defineProperty(Ut, "__esModule", {
    value: !0
});
Ut.isInIFrame = Ut.createQrUrl = Ut.getFavicon = Ut.range = Ut.isBigNumber = Ut.ensureParsedJSONObject = Ut.ensureBN = Ut.ensureRegExpString = Ut.ensureIntNumber = Ut.ensureBuffer = Ut.ensureAddressString = Ut.ensureEvenLengthHexString = Ut.ensureHexString = Ut.isHexString = Ut.prepend0x = Ut.strip0x = Ut.has0xPrefix = Ut.hexStringFromIntNumber = Ut.intNumberFromHexString = Ut.bigIntStringFromBN = Ut.hexStringFromBuffer = Ut.hexStringToUint8Array = Ut.uint8ArrayToHex = Ut.randomBytesHex = void 0;
const k0 = aLe(ME),
    lLe = oLe,
    _y = DE,
    Sc = HE,
    Cse = /^[0-9]*$/,
    Ase = /^[a-f0-9]*$/;

function cLe(t) {
    return Tse(crypto.getRandomValues(new Uint8Array(t)))
}
Ut.randomBytesHex = cLe;

function Tse(t) {
    return [...t].map(e => e.toString(16).padStart(2, "0")).join("")
}
Ut.uint8ArrayToHex = Tse;

function uLe(t) {
    return new Uint8Array(t.match(/.{1,2}/g).map(e => parseInt(e, 16)))
}
Ut.hexStringToUint8Array = uLe;

function fLe(t, e = !1) {
    const n = t.toString("hex");
    return (0, Sc.HexString)(e ? "0x" + n : n)
}
Ut.hexStringFromBuffer = fLe;

function dLe(t) {
    return (0, Sc.BigIntString)(t.toString(10))
}
Ut.bigIntStringFromBN = dLe;

function hLe(t) {
    return (0, Sc.IntNumber)(new k0.default(WE(t, !1), 16).toNumber())
}
Ut.intNumberFromHexString = hLe;

function pLe(t) {
    return (0, Sc.HexString)("0x" + new k0.default(t).toString(16))
}
Ut.hexStringFromIntNumber = pLe;

function rB(t) {
    return t.startsWith("0x") || t.startsWith("0X")
}
Ut.has0xPrefix = rB;

function y9(t) {
    return rB(t) ? t.slice(2) : t
}
Ut.strip0x = y9;

function Ise(t) {
    return rB(t) ? "0x" + t.slice(2) : "0x" + t
}
Ut.prepend0x = Ise;

function zE(t) {
    if (typeof t != "string") return !1;
    const e = y9(t).toLowerCase();
    return Ase.test(e)
}
Ut.isHexString = zE;

function Rse(t, e = !1) {
    if (typeof t == "string") {
        const n = y9(t).toLowerCase();
        if (Ase.test(n)) return (0, Sc.HexString)(e ? "0x" + n : n)
    }
    throw _y.standardErrors.rpc.invalidParams(`"${String(t)}" is not a hexadecimal string`)
}
Ut.ensureHexString = Rse;

function WE(t, e = !1) {
    let n = Rse(t, !1);
    return n.length % 2 === 1 && (n = (0, Sc.HexString)("0" + n)), e ? (0, Sc.HexString)("0x" + n) : n
}
Ut.ensureEvenLengthHexString = WE;

function gLe(t) {
    if (typeof t == "string") {
        const e = y9(t).toLowerCase();
        if (zE(e) && e.length === 40) return (0, Sc.AddressString)(Ise(e))
    }
    throw _y.standardErrors.rpc.invalidParams(`Invalid Ethereum address: ${String(t)}`)
}
Ut.ensureAddressString = gLe;

function mLe(t) {
    if (Buffer.isBuffer(t)) return t;
    if (typeof t == "string")
        if (zE(t)) {
            const e = WE(t, !1);
            return Buffer.from(e, "hex")
        } else return Buffer.from(t, "utf8");
    throw _y.standardErrors.rpc.invalidParams(`Not binary data: ${String(t)}`)
}
Ut.ensureBuffer = mLe;

function Ose(t) {
    if (typeof t == "number" && Number.isInteger(t)) return (0, Sc.IntNumber)(t);
    if (typeof t == "string") {
        if (Cse.test(t)) return (0, Sc.IntNumber)(Number(t));
        if (zE(t)) return (0, Sc.IntNumber)(new k0.default(WE(t, !1), 16).toNumber())
    }
    throw _y.standardErrors.rpc.invalidParams(`Not an integer: ${String(t)}`)
}
Ut.ensureIntNumber = Ose;

function yLe(t) {
    if (t instanceof RegExp) return (0, Sc.RegExpString)(t.toString());
    throw _y.standardErrors.rpc.invalidParams(`Not a RegExp: ${String(t)}`)
}
Ut.ensureRegExpString = yLe;

function wLe(t) {
    if (t !== null && (k0.default.isBN(t) || Nse(t))) return new k0.default(t.toString(10), 10);
    if (typeof t == "number") return new k0.default(Ose(t));
    if (typeof t == "string") {
        if (Cse.test(t)) return new k0.default(t, 10);
        if (zE(t)) return new k0.default(WE(t, !1), 16)
    }
    throw _y.standardErrors.rpc.invalidParams(`Not an integer: ${String(t)}`)
}
Ut.ensureBN = wLe;

function vLe(t) {
    if (typeof t == "string") return JSON.parse(t);
    if (typeof t == "object") return t;
    throw _y.standardErrors.rpc.invalidParams(`Not a JSON string or an object: ${String(t)}`)
}
Ut.ensureParsedJSONObject = vLe;

function Nse(t) {
    if (t == null || typeof t.constructor != "function") return !1;
    const {
        constructor: e
    } = t;
    return typeof e.config == "function" && typeof e.EUCLID == "number"
}
Ut.isBigNumber = Nse;

function bLe(t, e) {
    return Array.from({
        length: e - t
    }, (n, r) => t + r)
}
Ut.range = bLe;

function _Le() {
    const t = document.querySelector('link[sizes="192x192"]') || document.querySelector('link[sizes="180x180"]') || document.querySelector('link[rel="icon"]') || document.querySelector('link[rel="shortcut icon"]'),
        {
            protocol: e,
            host: n
        } = document.location,
        r = t ? t.getAttribute("href") : null;
    return !r || r.startsWith("javascript:") ? null : r.startsWith("http://") || r.startsWith("https://") || r.startsWith("data:") ? r : r.startsWith("//") ? e + r : `${e}//${n}${r}`
}
Ut.getFavicon = _Le;

function ELe(t, e, n, r, i, s) {
    const o = r ? "parent-id" : "id",
        a = (0, lLe.stringify)({
            [o]: t,
            secret: e,
            server: n,
            v: i,
            chainId: s
        });
    return `${n}/#/link?${a}`
}
Ut.createQrUrl = ELe;

function xLe() {
    try {
        return window.frameElement !== null
    } catch {
        return !1
    }
}
Ut.isInIFrame = xLe;
Object.defineProperty(L2, "__esModule", {
    value: !0
});
L2.Session = void 0;
const Vq = VMe,
    Gq = Ut,
    qq = "session:id",
    Kq = "session:secret",
    Yq = "session:linked";
class iB {
    constructor(e, n, r, i) {
        this._storage = e, this._id = n || (0, Gq.randomBytesHex)(16), this._secret = r || (0, Gq.randomBytesHex)(32), this._key = new Vq.sha256().update(`${this._id}, ${this._secret} WalletLink`).digest("hex"), this._linked = !!i
    }
    static load(e) {
        const n = e.getItem(qq),
            r = e.getItem(Yq),
            i = e.getItem(Kq);
        return n && i ? new iB(e, n, i, r === "1") : null
    }
    static hash(e) {
        return new Vq.sha256().update(e).digest("hex")
    }
    get id() {
        return this._id
    }
    get secret() {
        return this._secret
    }
    get key() {
        return this._key
    }
    get linked() {
        return this._linked
    }
    set linked(e) {
        this._linked = e, this.persistLinked()
    }
    save() {
        return this._storage.setItem(qq, this._id), this._storage.setItem(Kq, this._secret), this.persistLinked(), this
    }
    persistLinked() {
        this._storage.setItem(Yq, this._linked ? "1" : "0")
    }
}
L2.Session = iB;
var _u = {};
Object.defineProperty(_u, "__esModule", {
    value: !0
});
_u.WalletSDKRelayAbstract = _u.APP_VERSION_KEY = _u.LOCAL_STORAGE_ADDRESSES_KEY = _u.WALLET_USER_NAME_KEY = void 0;
const Zq = DE;
_u.WALLET_USER_NAME_KEY = "walletUsername";
_u.LOCAL_STORAGE_ADDRESSES_KEY = "Addresses";
_u.APP_VERSION_KEY = "AppVersion";
class SLe {
    async makeEthereumJSONRPCRequest(e, n) {
        if (!n) throw new Error("Error: No jsonRpcUrl provided");
        return window.fetch(n, {
            method: "POST",
            body: JSON.stringify(e),
            mode: "cors",
            headers: {
                "Content-Type": "application/json"
            }
        }).then(r => r.json()).then(r => {
            if (!r) throw Zq.standardErrors.rpc.parse({});
            const i = r,
                {
                    error: s
                } = i;
            if (s) throw (0, Zq.serializeError)(s, e.method);
            return i
        })
    }
}
_u.WalletSDKRelayAbstract = SLe;
var pM = {
        exports: {}
    },
    Pse = uo.EventEmitter,
    WO, Qq;

function CLe() {
    if (Qq) return WO;
    Qq = 1;

    function t(y, _) {
        var C = Object.keys(y);
        if (Object.getOwnPropertySymbols) {
            var b = Object.getOwnPropertySymbols(y);
            _ && (b = b.filter(function(w) {
                return Object.getOwnPropertyDescriptor(y, w).enumerable
            })), C.push.apply(C, b)
        }
        return C
    }

    function e(y) {
        for (var _ = 1; _ < arguments.length; _++) {
            var C = arguments[_] != null ? arguments[_] : {};
            _ % 2 ? t(Object(C), !0).forEach(function(b) {
                n(y, b, C[b])
            }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(y, Object.getOwnPropertyDescriptors(C)) : t(Object(C)).forEach(function(b) {
                Object.defineProperty(y, b, Object.getOwnPropertyDescriptor(C, b))
            })
        }
        return y
    }

    function n(y, _, C) {
        return _ = o(_), _ in y ? Object.defineProperty(y, _, {
            value: C,
            enumerable: !0,
            configurable: !0,
            writable: !0
        }) : y[_] = C, y
    }

    function r(y, _) {
        if (!(y instanceof _)) throw new TypeError("Cannot call a class as a function")
    }

    function i(y, _) {
        for (var C = 0; C < _.length; C++) {
            var b = _[C];
            b.enumerable = b.enumerable || !1, b.configurable = !0, "value" in b && (b.writable = !0), Object.defineProperty(y, o(b.key), b)
        }
    }

    function s(y, _, C) {
        return _ && i(y.prototype, _), Object.defineProperty(y, "prototype", {
            writable: !1
        }), y
    }

    function o(y) {
        var _ = a(y, "string");
        return typeof _ == "symbol" ? _ : String(_)
    }

    function a(y, _) {
        if (typeof y != "object" || y === null) return y;
        var C = y[Symbol.toPrimitive];
        if (C !== void 0) {
            var b = C.call(y, _ || "default");
            if (typeof b != "object") return b;
            throw new TypeError("@@toPrimitive must return a primitive value.")
        }
        return (_ === "string" ? String : Number)(y)
    }
    var l = M2,
        c = l.Buffer,
        u = vE,
        f = u.inspect,
        h = f && f.custom || "inspect";

    function g(y, _, C) {
        c.prototype.copy.call(y, _, C)
    }
    return WO = function() {
        function y() {
            r(this, y), this.head = null, this.tail = null, this.length = 0
        }
        return s(y, [{
            key: "push",
            value: function(C) {
                var b = {
                    data: C,
                    next: null
                };
                this.length > 0 ? this.tail.next = b : this.head = b, this.tail = b, ++this.length
            }
        }, {
            key: "unshift",
            value: function(C) {
                var b = {
                    data: C,
                    next: this.head
                };
                this.length === 0 && (this.tail = b), this.head = b, ++this.length
            }
        }, {
            key: "shift",
            value: function() {
                if (this.length !== 0) {
                    var C = this.head.data;
                    return this.length === 1 ? this.head = this.tail = null : this.head = this.head.next, --this.length, C
                }
            }
        }, {
            key: "clear",
            value: function() {
                this.head = this.tail = null, this.length = 0
            }
        }, {
            key: "join",
            value: function(C) {
                if (this.length === 0) return "";
                for (var b = this.head, w = "" + b.data; b = b.next;) w += C + b.data;
                return w
            }
        }, {
            key: "concat",
            value: function(C) {
                if (this.length === 0) return c.alloc(0);
                for (var b = c.allocUnsafe(C >>> 0), w = this.head, S = 0; w;) g(w.data, b, S), S += w.data.length, w = w.next;
                return b
            }
        }, {
            key: "consume",
            value: function(C, b) {
                var w;
                return C < this.head.data.length ? (w = this.head.data.slice(0, C), this.head.data = this.head.data.slice(C)) : C === this.head.data.length ? w = this.shift() : w = b ? this._getString(C) : this._getBuffer(C), w
            }
        }, {
            key: "first",
            value: function() {
                return this.head.data
            }
        }, {
            key: "_getString",
            value: function(C) {
                var b = this.head,
                    w = 1,
                    S = b.data;
                for (C -= S.length; b = b.next;) {
                    var I = b.data,
                        P = C > I.length ? I.length : C;
                    if (P === I.length ? S += I : S += I.slice(0, C), C -= P, C === 0) {
                        P === I.length ? (++w, b.next ? this.head = b.next : this.head = this.tail = null) : (this.head = b, b.data = I.slice(P));
                        break
                    }++w
                }
                return this.length -= w, S
            }
        }, {
            key: "_getBuffer",
            value: function(C) {
                var b = c.allocUnsafe(C),
                    w = this.head,
                    S = 1;
                for (w.data.copy(b), C -= w.data.length; w = w.next;) {
                    var I = w.data,
                        P = C > I.length ? I.length : C;
                    if (I.copy(b, b.length - C, 0, P), C -= P, C === 0) {
                        P === I.length ? (++S, w.next ? this.head = w.next : this.head = this.tail = null) : (this.head = w, w.data = I.slice(P));
                        break
                    }++S
                }
                return this.length -= S, b
            }
        }, {
            key: h,
            value: function(C, b) {
                return f(this, e(e({}, b), {}, {
                    depth: 0,
                    customInspect: !1
                }))
            }
        }]), y
    }(), WO
}

function ALe(t, e) {
    var n = this,
        r = this._readableState && this._readableState.destroyed,
        i = this._writableState && this._writableState.destroyed;
    return r || i ? (e ? e(t) : t && (this._writableState ? this._writableState.errorEmitted || (this._writableState.errorEmitted = !0, process.nextTick(gM, this, t)) : process.nextTick(gM, this, t)), this) : (this._readableState && (this._readableState.destroyed = !0), this._writableState && (this._writableState.destroyed = !0), this._destroy(t || null, function(s) {
        !e && s ? n._writableState ? n._writableState.errorEmitted ? process.nextTick(p8, n) : (n._writableState.errorEmitted = !0, process.nextTick(Jq, n, s)) : process.nextTick(Jq, n, s) : e ? (process.nextTick(p8, n), e(s)) : process.nextTick(p8, n)
    }), this)
}

function Jq(t, e) {
    gM(t, e), p8(t)
}

function p8(t) {
    t._writableState && !t._writableState.emitClose || t._readableState && !t._readableState.emitClose || t.emit("close")
}

function TLe() {
    this._readableState && (this._readableState.destroyed = !1, this._readableState.reading = !1, this._readableState.ended = !1, this._readableState.endEmitted = !1), this._writableState && (this._writableState.destroyed = !1, this._writableState.ended = !1, this._writableState.ending = !1, this._writableState.finalCalled = !1, this._writableState.prefinished = !1, this._writableState.finished = !1, this._writableState.errorEmitted = !1)
}

function gM(t, e) {
    t.emit("error", e)
}

function ILe(t, e) {
    var n = t._readableState,
        r = t._writableState;
    n && n.autoDestroy || r && r.autoDestroy ? t.destroy(e) : t.emit("error", e)
}
var kse = {
        destroy: ALe,
        undestroy: TLe,
        errorOrDestroy: ILe
    },
    Ey = {};

function RLe(t, e) {
    t.prototype = Object.create(e.prototype), t.prototype.constructor = t, t.__proto__ = e
}
var Mse = {};

function Lc(t, e, n) {
    n || (n = Error);

    function r(s, o, a) {
        return typeof e == "string" ? e : e(s, o, a)
    }
    var i = function(s) {
        RLe(o, s);

        function o(a, l, c) {
            return s.call(this, r(a, l, c)) || this
        }
        return o
    }(n);
    i.prototype.name = n.name, i.prototype.code = t, Mse[t] = i
}

function Xq(t, e) {
    if (Array.isArray(t)) {
        var n = t.length;
        return t = t.map(function(r) {
            return String(r)
        }), n > 2 ? "one of ".concat(e, " ").concat(t.slice(0, n - 1).join(", "), ", or ") + t[n - 1] : n === 2 ? "one of ".concat(e, " ").concat(t[0], " or ").concat(t[1]) : "of ".concat(e, " ").concat(t[0])
    } else return "of ".concat(e, " ").concat(String(t))
}

function OLe(t, e, n) {
    return t.substr(0, e.length) === e
}

function NLe(t, e, n) {
    return (n === void 0 || n > t.length) && (n = t.length), t.substring(n - e.length, n) === e
}

function PLe(t, e, n) {
    return typeof n != "number" && (n = 0), n + e.length > t.length ? !1 : t.indexOf(e, n) !== -1
}
Lc("ERR_INVALID_OPT_VALUE", function(t, e) {
    return 'The value "' + e + '" is invalid for option "' + t + '"'
}, TypeError);
Lc("ERR_INVALID_ARG_TYPE", function(t, e, n) {
    var r;
    typeof e == "string" && OLe(e, "not ") ? (r = "must not be", e = e.replace(/^not /, "")) : r = "must be";
    var i;
    if (NLe(t, " argument")) i = "The ".concat(t, " ").concat(r, " ").concat(Xq(e, "type"));
    else {
        var s = PLe(t, ".") ? "property" : "argument";
        i = 'The "'.concat(t, '" ').concat(s, " ").concat(r, " ").concat(Xq(e, "type"))
    }
    return i += ". Received type ".concat(typeof n), i
}, TypeError);
Lc("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF");
Lc("ERR_METHOD_NOT_IMPLEMENTED", function(t) {
    return "The " + t + " method is not implemented"
});
Lc("ERR_STREAM_PREMATURE_CLOSE", "Premature close");
Lc("ERR_STREAM_DESTROYED", function(t) {
    return "Cannot call " + t + " after a stream was destroyed"
});
Lc("ERR_MULTIPLE_CALLBACK", "Callback called multiple times");
Lc("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable");
Lc("ERR_STREAM_WRITE_AFTER_END", "write after end");
Lc("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError);
Lc("ERR_UNKNOWN_ENCODING", function(t) {
    return "Unknown encoding: " + t
}, TypeError);
Lc("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event");
Ey.codes = Mse;
var kLe = Ey.codes.ERR_INVALID_OPT_VALUE;

function MLe(t, e, n) {
    return t.highWaterMark != null ? t.highWaterMark : e ? t[n] : null
}

function DLe(t, e, n, r) {
    var i = MLe(e, r, n);
    if (i != null) {
        if (!(isFinite(i) && Math.floor(i) === i) || i < 0) {
            var s = r ? n : "highWaterMark";
            throw new kLe(s, i)
        }
        return Math.floor(i)
    }
    return t.objectMode ? 16 : 16 * 1024
}
var Dse = {
        getHighWaterMark: DLe
    },
    $Le = LLe;

function LLe(t, e) {
    if (VO("noDeprecation")) return t;
    var n = !1;

    function r() {
        if (!n) {
            if (VO("throwDeprecation")) throw new Error(e);
            VO("traceDeprecation") ? console.trace(e) : console.warn(e), n = !0
        }
        return t.apply(this, arguments)
    }
    return r
}

function VO(t) {
    try {
        if (!st.localStorage) return !1
    } catch {
        return !1
    }
    var e = st.localStorage[t];
    return e == null ? !1 : String(e).toLowerCase() === "true"
}
var GO, eK;

function $se() {
    if (eK) return GO;
    eK = 1, GO = E;

    function t(X) {
        var q = this;
        this.next = null, this.entry = null, this.finish = function() {
            V(q, X)
        }
    }
    var e;
    E.WritableState = M;
    var n = {
            deprecate: $Le
        },
        r = Pse,
        i = M2.Buffer,
        s = (typeof st < "u" ? st : typeof window < "u" ? window : typeof self < "u" ? self : {}).Uint8Array || function() {};

    function o(X) {
        return i.from(X)
    }

    function a(X) {
        return i.isBuffer(X) || X instanceof s
    }
    var l = kse,
        c = Dse,
        u = c.getHighWaterMark,
        f = Ey.codes,
        h = f.ERR_INVALID_ARG_TYPE,
        g = f.ERR_METHOD_NOT_IMPLEMENTED,
        y = f.ERR_MULTIPLE_CALLBACK,
        _ = f.ERR_STREAM_CANNOT_PIPE,
        C = f.ERR_STREAM_DESTROYED,
        b = f.ERR_STREAM_NULL_VALUES,
        w = f.ERR_STREAM_WRITE_AFTER_END,
        S = f.ERR_UNKNOWN_ENCODING,
        I = l.errorOrDestroy;
    Wu(E, r);

    function P() {}

    function M(X, q, ne) {
        e = e || n2(), X = X || {}, typeof ne != "boolean" && (ne = q instanceof e), this.objectMode = !!X.objectMode, ne && (this.objectMode = this.objectMode || !!X.writableObjectMode), this.highWaterMark = u(this, X, "writableHighWaterMark", ne), this.finalCalled = !1, this.needDrain = !1, this.ending = !1, this.ended = !1, this.finished = !1, this.destroyed = !1;
        var ie = X.decodeStrings === !1;
        this.decodeStrings = !ie, this.defaultEncoding = X.defaultEncoding || "utf8", this.length = 0, this.writing = !1, this.corked = 0, this.sync = !0, this.bufferProcessing = !1, this.onwrite = function(k) {
            T(q, k)
        }, this.writecb = null, this.writelen = 0, this.bufferedRequest = null, this.lastBufferedRequest = null, this.pendingcb = 0, this.prefinished = !1, this.errorEmitted = !1, this.emitClose = X.emitClose !== !1, this.autoDestroy = !!X.autoDestroy, this.bufferedRequestCount = 0, this.corkedRequestsFree = new t(this)
    }
    M.prototype.getBuffer = function() {
            for (var q = this.bufferedRequest, ne = []; q;) ne.push(q), q = q.next;
            return ne
        },
        function() {
            try {
                Object.defineProperty(M.prototype, "buffer", {
                    get: n.deprecate(function() {
                        return this.getBuffer()
                    }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
                })
            } catch {}
        }();
    var A;
    typeof Symbol == "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] == "function" ? (A = Function.prototype[Symbol.hasInstance], Object.defineProperty(E, Symbol.hasInstance, {
        value: function(q) {
            return A.call(this, q) ? !0 : this !== E ? !1 : q && q._writableState instanceof M
        }
    })) : A = function(q) {
        return q instanceof this
    };

    function E(X) {
        e = e || n2();
        var q = this instanceof e;
        if (!q && !A.call(E, this)) return new E(X);
        this._writableState = new M(X, this, q), this.writable = !0, X && (typeof X.write == "function" && (this._write = X.write), typeof X.writev == "function" && (this._writev = X.writev), typeof X.destroy == "function" && (this._destroy = X.destroy), typeof X.final == "function" && (this._final = X.final)), r.call(this)
    }
    E.prototype.pipe = function() {
        I(this, new _)
    };

    function $(X, q) {
        var ne = new w;
        I(X, ne), process.nextTick(q, ne)
    }

    function H(X, q, ne, ie) {
        var k;
        return ne === null ? k = new b : typeof ne != "string" && !q.objectMode && (k = new h("chunk", ["string", "Buffer"], ne)), k ? (I(X, k), process.nextTick(ie, k), !1) : !0
    }
    E.prototype.write = function(X, q, ne) {
        var ie = this._writableState,
            k = !1,
            z = !ie.objectMode && a(X);
        return z && !i.isBuffer(X) && (X = o(X)), typeof q == "function" && (ne = q, q = null), z ? q = "buffer" : q || (q = ie.defaultEncoding), typeof ne != "function" && (ne = P), ie.ending ? $(this, ne) : (z || H(this, ie, X, ne)) && (ie.pendingcb++, k = te(this, ie, z, X, q, ne)), k
    }, E.prototype.cork = function() {
        this._writableState.corked++
    }, E.prototype.uncork = function() {
        var X = this._writableState;
        X.corked && (X.corked--, !X.writing && !X.corked && !X.bufferProcessing && X.bufferedRequest && L(this, X))
    }, E.prototype.setDefaultEncoding = function(q) {
        if (typeof q == "string" && (q = q.toLowerCase()), !(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((q + "").toLowerCase()) > -1)) throw new S(q);
        return this._writableState.defaultEncoding = q, this
    }, Object.defineProperty(E.prototype, "writableBuffer", {
        enumerable: !1,
        get: function() {
            return this._writableState && this._writableState.getBuffer()
        }
    });

    function K(X, q, ne) {
        return !X.objectMode && X.decodeStrings !== !1 && typeof q == "string" && (q = i.from(q, ne)), q
    }
    Object.defineProperty(E.prototype, "writableHighWaterMark", {
        enumerable: !1,
        get: function() {
            return this._writableState.highWaterMark
        }
    });

    function te(X, q, ne, ie, k, z) {
        if (!ne) {
            var Z = K(q, ie, k);
            ie !== Z && (ne = !0, k = "buffer", ie = Z)
        }
        var ge = q.objectMode ? 1 : ie.length;
        q.length += ge;
        var me = q.length < q.highWaterMark;
        if (me || (q.needDrain = !0), q.writing || q.corked) {
            var Re = q.lastBufferedRequest;
            q.lastBufferedRequest = {
                chunk: ie,
                encoding: k,
                isBuf: ne,
                callback: z,
                next: null
            }, Re ? Re.next = q.lastBufferedRequest : q.bufferedRequest = q.lastBufferedRequest, q.bufferedRequestCount += 1
        } else U(X, q, !1, ge, ie, k, z);
        return me
    }

    function U(X, q, ne, ie, k, z, Z) {
        q.writelen = ie, q.writecb = Z, q.writing = !0, q.sync = !0, q.destroyed ? q.onwrite(new C("write")) : ne ? X._writev(k, q.onwrite) : X._write(k, z, q.onwrite), q.sync = !1
    }

    function m(X, q, ne, ie, k) {
        --q.pendingcb, ne ? (process.nextTick(k, ie), process.nextTick(Y, X, q), X._writableState.errorEmitted = !0, I(X, ie)) : (k(ie), X._writableState.errorEmitted = !0, I(X, ie), Y(X, q))
    }

    function v(X) {
        X.writing = !1, X.writecb = null, X.length -= X.writelen, X.writelen = 0
    }

    function T(X, q) {
        var ne = X._writableState,
            ie = ne.sync,
            k = ne.writecb;
        if (typeof k != "function") throw new y;
        if (v(ne), q) m(X, ne, ie, q, k);
        else {
            var z = G(ne) || X.destroyed;
            !z && !ne.corked && !ne.bufferProcessing && ne.bufferedRequest && L(X, ne), ie ? process.nextTick(N, X, ne, z, k) : N(X, ne, z, k)
        }
    }

    function N(X, q, ne, ie) {
        ne || O(X, q), q.pendingcb--, ie(), Y(X, q)
    }

    function O(X, q) {
        q.length === 0 && q.needDrain && (q.needDrain = !1, X.emit("drain"))
    }

    function L(X, q) {
        q.bufferProcessing = !0;
        var ne = q.bufferedRequest;
        if (X._writev && ne && ne.next) {
            var ie = q.bufferedRequestCount,
                k = new Array(ie),
                z = q.corkedRequestsFree;
            z.entry = ne;
            for (var Z = 0, ge = !0; ne;) k[Z] = ne, ne.isBuf || (ge = !1), ne = ne.next, Z += 1;
            k.allBuffers = ge, U(X, q, !0, q.length, k, "", z.finish), q.pendingcb++, q.lastBufferedRequest = null, z.next ? (q.corkedRequestsFree = z.next, z.next = null) : q.corkedRequestsFree = new t(q), q.bufferedRequestCount = 0
        } else {
            for (; ne;) {
                var me = ne.chunk,
                    Re = ne.encoding,
                    He = ne.callback,
                    Be = q.objectMode ? 1 : me.length;
                if (U(X, q, !1, Be, me, Re, He), ne = ne.next, q.bufferedRequestCount--, q.writing) break
            }
            ne === null && (q.lastBufferedRequest = null)
        }
        q.bufferedRequest = ne, q.bufferProcessing = !1
    }
    E.prototype._write = function(X, q, ne) {
        ne(new g("_write()"))
    }, E.prototype._writev = null, E.prototype.end = function(X, q, ne) {
        var ie = this._writableState;
        return typeof X == "function" ? (ne = X, X = null, q = null) : typeof q == "function" && (ne = q, q = null), X != null && this.write(X, q), ie.corked && (ie.corked = 1, this.uncork()), ie.ending || ve(this, ie, ne), this
    }, Object.defineProperty(E.prototype, "writableLength", {
        enumerable: !1,
        get: function() {
            return this._writableState.length
        }
    });

    function G(X) {
        return X.ending && X.length === 0 && X.bufferedRequest === null && !X.finished && !X.writing
    }

    function j(X, q) {
        X._final(function(ne) {
            q.pendingcb--, ne && I(X, ne), q.prefinished = !0, X.emit("prefinish"), Y(X, q)
        })
    }

    function R(X, q) {
        !q.prefinished && !q.finalCalled && (typeof X._final == "function" && !q.destroyed ? (q.pendingcb++, q.finalCalled = !0, process.nextTick(j, X, q)) : (q.prefinished = !0, X.emit("prefinish")))
    }

    function Y(X, q) {
        var ne = G(q);
        if (ne && (R(X, q), q.pendingcb === 0 && (q.finished = !0, X.emit("finish"), q.autoDestroy))) {
            var ie = X._readableState;
            (!ie || ie.autoDestroy && ie.endEmitted) && X.destroy()
        }
        return ne
    }

    function ve(X, q, ne) {
        q.ending = !0, Y(X, q), ne && (q.finished ? process.nextTick(ne) : X.once("finish", ne)), q.ended = !0, X.writable = !1
    }

    function V(X, q, ne) {
        var ie = X.entry;
        for (X.entry = null; ie;) {
            var k = ie.callback;
            q.pendingcb--, k(ne), ie = ie.next
        }
        q.corkedRequestsFree.next = X
    }
    return Object.defineProperty(E.prototype, "destroyed", {
        enumerable: !1,
        get: function() {
            return this._writableState === void 0 ? !1 : this._writableState.destroyed
        },
        set: function(q) {
            this._writableState && (this._writableState.destroyed = q)
        }
    }), E.prototype.destroy = l.destroy, E.prototype._undestroy = l.undestroy, E.prototype._destroy = function(X, q) {
        q(X)
    }, GO
}
var qO, tK;

function n2() {
    if (tK) return qO;
    tK = 1;
    var t = Object.keys || function(c) {
        var u = [];
        for (var f in c) u.push(f);
        return u
    };
    qO = o;
    var e = Bse(),
        n = $se();
    Wu(o, e);
    for (var r = t(n.prototype), i = 0; i < r.length; i++) {
        var s = r[i];
        o.prototype[s] || (o.prototype[s] = n.prototype[s])
    }

    function o(c) {
        if (!(this instanceof o)) return new o(c);
        e.call(this, c), n.call(this, c), this.allowHalfOpen = !0, c && (c.readable === !1 && (this.readable = !1), c.writable === !1 && (this.writable = !1), c.allowHalfOpen === !1 && (this.allowHalfOpen = !1, this.once("end", a)))
    }
    Object.defineProperty(o.prototype, "writableHighWaterMark", {
        enumerable: !1,
        get: function() {
            return this._writableState.highWaterMark
        }
    }), Object.defineProperty(o.prototype, "writableBuffer", {
        enumerable: !1,
        get: function() {
            return this._writableState && this._writableState.getBuffer()
        }
    }), Object.defineProperty(o.prototype, "writableLength", {
        enumerable: !1,
        get: function() {
            return this._writableState.length
        }
    });

    function a() {
        this._writableState.ended || process.nextTick(l, this)
    }

    function l(c) {
        c.end()
    }
    return Object.defineProperty(o.prototype, "destroyed", {
        enumerable: !1,
        get: function() {
            return this._readableState === void 0 || this._writableState === void 0 ? !1 : this._readableState.destroyed && this._writableState.destroyed
        },
        set: function(u) {
            this._readableState === void 0 || this._writableState === void 0 || (this._readableState.destroyed = u, this._writableState.destroyed = u)
        }
    }), qO
}
var KO = {},
    nK;

function rK() {
    if (nK) return KO;
    nK = 1;
    var t = cg.Buffer,
        e = t.isEncoding || function(b) {
            switch (b = "" + b, b && b.toLowerCase()) {
                case "hex":
                case "utf8":
                case "utf-8":
                case "ascii":
                case "binary":
                case "base64":
                case "ucs2":
                case "ucs-2":
                case "utf16le":
                case "utf-16le":
                case "raw":
                    return !0;
                default:
                    return !1
            }
        };

    function n(b) {
        if (!b) return "utf8";
        for (var w;;) switch (b) {
            case "utf8":
            case "utf-8":
                return "utf8";
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
                return "utf16le";
            case "latin1":
            case "binary":
                return "latin1";
            case "base64":
            case "ascii":
            case "hex":
                return b;
            default:
                if (w) return;
                b = ("" + b).toLowerCase(), w = !0
        }
    }

    function r(b) {
        var w = n(b);
        if (typeof w != "string" && (t.isEncoding === e || !e(b))) throw new Error("Unknown encoding: " + b);
        return w || b
    }
    KO.StringDecoder = i;

    function i(b) {
        this.encoding = r(b);
        var w;
        switch (this.encoding) {
            case "utf16le":
                this.text = f, this.end = h, w = 4;
                break;
            case "utf8":
                this.fillLast = l, w = 4;
                break;
            case "base64":
                this.text = g, this.end = y, w = 3;
                break;
            default:
                this.write = _, this.end = C;
                return
        }
        this.lastNeed = 0, this.lastTotal = 0, this.lastChar = t.allocUnsafe(w)
    }
    i.prototype.write = function(b) {
        if (b.length === 0) return "";
        var w, S;
        if (this.lastNeed) {
            if (w = this.fillLast(b), w === void 0) return "";
            S = this.lastNeed, this.lastNeed = 0
        } else S = 0;
        return S < b.length ? w ? w + this.text(b, S) : this.text(b, S) : w || ""
    }, i.prototype.end = u, i.prototype.text = c, i.prototype.fillLast = function(b) {
        if (this.lastNeed <= b.length) return b.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal);
        b.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, b.length), this.lastNeed -= b.length
    };

    function s(b) {
        return b <= 127 ? 0 : b >> 5 === 6 ? 2 : b >> 4 === 14 ? 3 : b >> 3 === 30 ? 4 : b >> 6 === 2 ? -1 : -2
    }

    function o(b, w, S) {
        var I = w.length - 1;
        if (I < S) return 0;
        var P = s(w[I]);
        return P >= 0 ? (P > 0 && (b.lastNeed = P - 1), P) : --I < S || P === -2 ? 0 : (P = s(w[I]), P >= 0 ? (P > 0 && (b.lastNeed = P - 2), P) : --I < S || P === -2 ? 0 : (P = s(w[I]), P >= 0 ? (P > 0 && (P === 2 ? P = 0 : b.lastNeed = P - 3), P) : 0))
    }

    function a(b, w, S) {
        if ((w[0] & 192) !== 128) return b.lastNeed = 0, "";
        if (b.lastNeed > 1 && w.length > 1) {
            if ((w[1] & 192) !== 128) return b.lastNeed = 1, "";
            if (b.lastNeed > 2 && w.length > 2 && (w[2] & 192) !== 128) return b.lastNeed = 2, ""
        }
    }

    function l(b) {
        var w = this.lastTotal - this.lastNeed,
            S = a(this, b);
        if (S !== void 0) return S;
        if (this.lastNeed <= b.length) return b.copy(this.lastChar, w, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal);
        b.copy(this.lastChar, w, 0, b.length), this.lastNeed -= b.length
    }

    function c(b, w) {
        var S = o(this, b, w);
        if (!this.lastNeed) return b.toString("utf8", w);
        this.lastTotal = S;
        var I = b.length - (S - this.lastNeed);
        return b.copy(this.lastChar, 0, I), b.toString("utf8", w, I)
    }

    function u(b) {
        var w = b && b.length ? this.write(b) : "";
        return this.lastNeed ? w + "" : w
    }

    function f(b, w) {
        if ((b.length - w) % 2 === 0) {
            var S = b.toString("utf16le", w);
            if (S) {
                var I = S.charCodeAt(S.length - 1);
                if (I >= 55296 && I <= 56319) return this.lastNeed = 2, this.lastTotal = 4, this.lastChar[0] = b[b.length - 2], this.lastChar[1] = b[b.length - 1], S.slice(0, -1)
            }
            return S
        }
        return this.lastNeed = 1, this.lastTotal = 2, this.lastChar[0] = b[b.length - 1], b.toString("utf16le", w, b.length - 1)
    }

    function h(b) {
        var w = b && b.length ? this.write(b) : "";
        if (this.lastNeed) {
            var S = this.lastTotal - this.lastNeed;
            return w + this.lastChar.toString("utf16le", 0, S)
        }
        return w
    }

    function g(b, w) {
        var S = (b.length - w) % 3;
        return S === 0 ? b.toString("base64", w) : (this.lastNeed = 3 - S, this.lastTotal = 3, S === 1 ? this.lastChar[0] = b[b.length - 1] : (this.lastChar[0] = b[b.length - 2], this.lastChar[1] = b[b.length - 1]), b.toString("base64", w, b.length - S))
    }

    function y(b) {
        var w = b && b.length ? this.write(b) : "";
        return this.lastNeed ? w + this.lastChar.toString("base64", 0, 3 - this.lastNeed) : w
    }

    function _(b) {
        return b.toString(this.encoding)
    }

    function C(b) {
        return b && b.length ? this.write(b) : ""
    }
    return KO
}
var iK = Ey.codes.ERR_STREAM_PREMATURE_CLOSE;

function BLe(t) {
    var e = !1;
    return function() {
        if (!e) {
            e = !0;
            for (var n = arguments.length, r = new Array(n), i = 0; i < n; i++) r[i] = arguments[i];
            t.apply(this, r)
        }
    }
}

function FLe() {}

function ULe(t) {
    return t.setHeader && typeof t.abort == "function"
}

function Lse(t, e, n) {
    if (typeof e == "function") return Lse(t, null, e);
    e || (e = {}), n = BLe(n || FLe);
    var r = e.readable || e.readable !== !1 && t.readable,
        i = e.writable || e.writable !== !1 && t.writable,
        s = function() {
            t.writable || a()
        },
        o = t._writableState && t._writableState.finished,
        a = function() {
            i = !1, o = !0, r || n.call(t)
        },
        l = t._readableState && t._readableState.endEmitted,
        c = function() {
            r = !1, l = !0, i || n.call(t)
        },
        u = function(y) {
            n.call(t, y)
        },
        f = function() {
            var y;
            if (r && !l) return (!t._readableState || !t._readableState.ended) && (y = new iK), n.call(t, y);
            if (i && !o) return (!t._writableState || !t._writableState.ended) && (y = new iK), n.call(t, y)
        },
        h = function() {
            t.req.on("finish", a)
        };
    return ULe(t) ? (t.on("complete", a), t.on("abort", f), t.req ? h() : t.on("request", h)) : i && !t._writableState && (t.on("end", s), t.on("close", s)), t.on("end", c), t.on("finish", a), e.error !== !1 && t.on("error", u), t.on("close", f),
        function() {
            t.removeListener("complete", a), t.removeListener("abort", f), t.removeListener("request", h), t.req && t.req.removeListener("finish", a), t.removeListener("end", s), t.removeListener("close", s), t.removeListener("finish", a), t.removeListener("end", c), t.removeListener("error", u), t.removeListener("close", f)
        }
}
var sB = Lse,
    YO, sK;

function jLe() {
    if (sK) return YO;
    sK = 1;
    var t;

    function e(S, I, P) {
        return I = n(I), I in S ? Object.defineProperty(S, I, {
            value: P,
            enumerable: !0,
            configurable: !0,
            writable: !0
        }) : S[I] = P, S
    }

    function n(S) {
        var I = r(S, "string");
        return typeof I == "symbol" ? I : String(I)
    }

    function r(S, I) {
        if (typeof S != "object" || S === null) return S;
        var P = S[Symbol.toPrimitive];
        if (P !== void 0) {
            var M = P.call(S, I || "default");
            if (typeof M != "object") return M;
            throw new TypeError("@@toPrimitive must return a primitive value.")
        }
        return (I === "string" ? String : Number)(S)
    }
    var i = sB,
        s = Symbol("lastResolve"),
        o = Symbol("lastReject"),
        a = Symbol("error"),
        l = Symbol("ended"),
        c = Symbol("lastPromise"),
        u = Symbol("handlePromise"),
        f = Symbol("stream");

    function h(S, I) {
        return {
            value: S,
            done: I
        }
    }

    function g(S) {
        var I = S[s];
        if (I !== null) {
            var P = S[f].read();
            P !== null && (S[c] = null, S[s] = null, S[o] = null, I(h(P, !1)))
        }
    }

    function y(S) {
        process.nextTick(g, S)
    }

    function _(S, I) {
        return function(P, M) {
            S.then(function() {
                if (I[l]) {
                    P(h(void 0, !0));
                    return
                }
                I[u](P, M)
            }, M)
        }
    }
    var C = Object.getPrototypeOf(function() {}),
        b = Object.setPrototypeOf((t = {
            get stream() {
                return this[f]
            },
            next: function() {
                var I = this,
                    P = this[a];
                if (P !== null) return Promise.reject(P);
                if (this[l]) return Promise.resolve(h(void 0, !0));
                if (this[f].destroyed) return new Promise(function($, H) {
                    process.nextTick(function() {
                        I[a] ? H(I[a]) : $(h(void 0, !0))
                    })
                });
                var M = this[c],
                    A;
                if (M) A = new Promise(_(M, this));
                else {
                    var E = this[f].read();
                    if (E !== null) return Promise.resolve(h(E, !1));
                    A = new Promise(this[u])
                }
                return this[c] = A, A
            }
        }, e(t, Symbol.asyncIterator, function() {
            return this
        }), e(t, "return", function() {
            var I = this;
            return new Promise(function(P, M) {
                I[f].destroy(null, function(A) {
                    if (A) {
                        M(A);
                        return
                    }
                    P(h(void 0, !0))
                })
            })
        }), t), C),
        w = function(I) {
            var P, M = Object.create(b, (P = {}, e(P, f, {
                value: I,
                writable: !0
            }), e(P, s, {
                value: null,
                writable: !0
            }), e(P, o, {
                value: null,
                writable: !0
            }), e(P, a, {
                value: null,
                writable: !0
            }), e(P, l, {
                value: I._readableState.endEmitted,
                writable: !0
            }), e(P, u, {
                value: function(E, $) {
                    var H = M[f].read();
                    H ? (M[c] = null, M[s] = null, M[o] = null, E(h(H, !1))) : (M[s] = E, M[o] = $)
                },
                writable: !0
            }), P));
            return M[c] = null, i(I, function(A) {
                if (A && A.code !== "ERR_STREAM_PREMATURE_CLOSE") {
                    var E = M[o];
                    E !== null && (M[c] = null, M[s] = null, M[o] = null, E(A)), M[a] = A;
                    return
                }
                var $ = M[s];
                $ !== null && (M[c] = null, M[s] = null, M[o] = null, $(h(void 0, !0))), M[l] = !0
            }), I.on("readable", y.bind(null, M)), M
        };
    return YO = w, YO
}
var ZO, oK;

function HLe() {
    return oK || (oK = 1, ZO = function() {
        throw new Error("Readable.from is not available in the browser")
    }), ZO
}
var QO, aK;

function Bse() {
    if (aK) return QO;
    aK = 1, QO = $;
    var t;
    $.ReadableState = E, uo.EventEmitter;
    var e = function(Z, ge) {
            return Z.listeners(ge).length
        },
        n = Pse,
        r = M2.Buffer,
        i = (typeof st < "u" ? st : typeof window < "u" ? window : typeof self < "u" ? self : {}).Uint8Array || function() {};

    function s(z) {
        return r.from(z)
    }

    function o(z) {
        return r.isBuffer(z) || z instanceof i
    }
    var a = vE,
        l;
    a && a.debuglog ? l = a.debuglog("stream") : l = function() {};
    var c = CLe(),
        u = kse,
        f = Dse,
        h = f.getHighWaterMark,
        g = Ey.codes,
        y = g.ERR_INVALID_ARG_TYPE,
        _ = g.ERR_STREAM_PUSH_AFTER_EOF,
        C = g.ERR_METHOD_NOT_IMPLEMENTED,
        b = g.ERR_STREAM_UNSHIFT_AFTER_END_EVENT,
        w, S, I;
    Wu($, n);
    var P = u.errorOrDestroy,
        M = ["error", "close", "destroy", "pause", "resume"];

    function A(z, Z, ge) {
        if (typeof z.prependListener == "function") return z.prependListener(Z, ge);
        !z._events || !z._events[Z] ? z.on(Z, ge) : Array.isArray(z._events[Z]) ? z._events[Z].unshift(ge) : z._events[Z] = [ge, z._events[Z]]
    }

    function E(z, Z, ge) {
        t = t || n2(), z = z || {}, typeof ge != "boolean" && (ge = Z instanceof t), this.objectMode = !!z.objectMode, ge && (this.objectMode = this.objectMode || !!z.readableObjectMode), this.highWaterMark = h(this, z, "readableHighWaterMark", ge), this.buffer = new c, this.length = 0, this.pipes = null, this.pipesCount = 0, this.flowing = null, this.ended = !1, this.endEmitted = !1, this.reading = !1, this.sync = !0, this.needReadable = !1, this.emittedReadable = !1, this.readableListening = !1, this.resumeScheduled = !1, this.paused = !0, this.emitClose = z.emitClose !== !1, this.autoDestroy = !!z.autoDestroy, this.destroyed = !1, this.defaultEncoding = z.defaultEncoding || "utf8", this.awaitDrain = 0, this.readingMore = !1, this.decoder = null, this.encoding = null, z.encoding && (w || (w = rK().StringDecoder), this.decoder = new w(z.encoding), this.encoding = z.encoding)
    }

    function $(z) {
        if (t = t || n2(), !(this instanceof $)) return new $(z);
        var Z = this instanceof t;
        this._readableState = new E(z, this, Z), this.readable = !0, z && (typeof z.read == "function" && (this._read = z.read), typeof z.destroy == "function" && (this._destroy = z.destroy)), n.call(this)
    }
    Object.defineProperty($.prototype, "destroyed", {
        enumerable: !1,
        get: function() {
            return this._readableState === void 0 ? !1 : this._readableState.destroyed
        },
        set: function(Z) {
            this._readableState && (this._readableState.destroyed = Z)
        }
    }), $.prototype.destroy = u.destroy, $.prototype._undestroy = u.undestroy, $.prototype._destroy = function(z, Z) {
        Z(z)
    }, $.prototype.push = function(z, Z) {
        var ge = this._readableState,
            me;
        return ge.objectMode ? me = !0 : typeof z == "string" && (Z = Z || ge.defaultEncoding, Z !== ge.encoding && (z = r.from(z, Z), Z = ""), me = !0), H(this, z, Z, !1, me)
    }, $.prototype.unshift = function(z) {
        return H(this, z, null, !0, !1)
    };

    function H(z, Z, ge, me, Re) {
        l("readableAddChunk", Z);
        var He = z._readableState;
        if (Z === null) He.reading = !1, T(z, He);
        else {
            var Be;
            if (Re || (Be = te(He, Z)), Be) P(z, Be);
            else if (He.objectMode || Z && Z.length > 0)
                if (typeof Z != "string" && !He.objectMode && Object.getPrototypeOf(Z) !== r.prototype && (Z = s(Z)), me) He.endEmitted ? P(z, new b) : K(z, He, Z, !0);
                else if (He.ended) P(z, new _);
            else {
                if (He.destroyed) return !1;
                He.reading = !1, He.decoder && !ge ? (Z = He.decoder.write(Z), He.objectMode || Z.length !== 0 ? K(z, He, Z, !1) : L(z, He)) : K(z, He, Z, !1)
            } else me || (He.reading = !1, L(z, He))
        }
        return !He.ended && (He.length < He.highWaterMark || He.length === 0)
    }

    function K(z, Z, ge, me) {
        Z.flowing && Z.length === 0 && !Z.sync ? (Z.awaitDrain = 0, z.emit("data", ge)) : (Z.length += Z.objectMode ? 1 : ge.length, me ? Z.buffer.unshift(ge) : Z.buffer.push(ge), Z.needReadable && N(z)), L(z, Z)
    }

    function te(z, Z) {
        var ge;
        return !o(Z) && typeof Z != "string" && Z !== void 0 && !z.objectMode && (ge = new y("chunk", ["string", "Buffer", "Uint8Array"], Z)), ge
    }
    $.prototype.isPaused = function() {
        return this._readableState.flowing === !1
    }, $.prototype.setEncoding = function(z) {
        w || (w = rK().StringDecoder);
        var Z = new w(z);
        this._readableState.decoder = Z, this._readableState.encoding = this._readableState.decoder.encoding;
        for (var ge = this._readableState.buffer.head, me = ""; ge !== null;) me += Z.write(ge.data), ge = ge.next;
        return this._readableState.buffer.clear(), me !== "" && this._readableState.buffer.push(me), this._readableState.length = me.length, this
    };
    var U = 1073741824;

    function m(z) {
        return z >= U ? z = U : (z--, z |= z >>> 1, z |= z >>> 2, z |= z >>> 4, z |= z >>> 8, z |= z >>> 16, z++), z
    }

    function v(z, Z) {
        return z <= 0 || Z.length === 0 && Z.ended ? 0 : Z.objectMode ? 1 : z !== z ? Z.flowing && Z.length ? Z.buffer.head.data.length : Z.length : (z > Z.highWaterMark && (Z.highWaterMark = m(z)), z <= Z.length ? z : Z.ended ? Z.length : (Z.needReadable = !0, 0))
    }
    $.prototype.read = function(z) {
        l("read", z), z = parseInt(z, 10);
        var Z = this._readableState,
            ge = z;
        if (z !== 0 && (Z.emittedReadable = !1), z === 0 && Z.needReadable && ((Z.highWaterMark !== 0 ? Z.length >= Z.highWaterMark : Z.length > 0) || Z.ended)) return l("read: emitReadable", Z.length, Z.ended), Z.length === 0 && Z.ended ? ne(this) : N(this), null;
        if (z = v(z, Z), z === 0 && Z.ended) return Z.length === 0 && ne(this), null;
        var me = Z.needReadable;
        l("need readable", me), (Z.length === 0 || Z.length - z < Z.highWaterMark) && (me = !0, l("length less than watermark", me)), Z.ended || Z.reading ? (me = !1, l("reading or ended", me)) : me && (l("do read"), Z.reading = !0, Z.sync = !0, Z.length === 0 && (Z.needReadable = !0), this._read(Z.highWaterMark), Z.sync = !1, Z.reading || (z = v(ge, Z)));
        var Re;
        return z > 0 ? Re = q(z, Z) : Re = null, Re === null ? (Z.needReadable = Z.length <= Z.highWaterMark, z = 0) : (Z.length -= z, Z.awaitDrain = 0), Z.length === 0 && (Z.ended || (Z.needReadable = !0), ge !== z && Z.ended && ne(this)), Re !== null && this.emit("data", Re), Re
    };

    function T(z, Z) {
        if (l("onEofChunk"), !Z.ended) {
            if (Z.decoder) {
                var ge = Z.decoder.end();
                ge && ge.length && (Z.buffer.push(ge), Z.length += Z.objectMode ? 1 : ge.length)
            }
            Z.ended = !0, Z.sync ? N(z) : (Z.needReadable = !1, Z.emittedReadable || (Z.emittedReadable = !0, O(z)))
        }
    }

    function N(z) {
        var Z = z._readableState;
        l("emitReadable", Z.needReadable, Z.emittedReadable), Z.needReadable = !1, Z.emittedReadable || (l("emitReadable", Z.flowing), Z.emittedReadable = !0, process.nextTick(O, z))
    }

    function O(z) {
        var Z = z._readableState;
        l("emitReadable_", Z.destroyed, Z.length, Z.ended), !Z.destroyed && (Z.length || Z.ended) && (z.emit("readable"), Z.emittedReadable = !1), Z.needReadable = !Z.flowing && !Z.ended && Z.length <= Z.highWaterMark, X(z)
    }

    function L(z, Z) {
        Z.readingMore || (Z.readingMore = !0, process.nextTick(G, z, Z))
    }

    function G(z, Z) {
        for (; !Z.reading && !Z.ended && (Z.length < Z.highWaterMark || Z.flowing && Z.length === 0);) {
            var ge = Z.length;
            if (l("maybeReadMore read 0"), z.read(0), ge === Z.length) break
        }
        Z.readingMore = !1
    }
    $.prototype._read = function(z) {
        P(this, new C("_read()"))
    }, $.prototype.pipe = function(z, Z) {
        var ge = this,
            me = this._readableState;
        switch (me.pipesCount) {
            case 0:
                me.pipes = z;
                break;
            case 1:
                me.pipes = [me.pipes, z];
                break;
            default:
                me.pipes.push(z);
                break
        }
        me.pipesCount += 1, l("pipe count=%d opts=%j", me.pipesCount, Z);
        var Re = (!Z || Z.end !== !1) && z !== process.stdout && z !== process.stderr,
            He = Re ? bt : Xe;
        me.endEmitted ? process.nextTick(He) : ge.once("end", He), z.on("unpipe", Be);

        function Be(Q, D) {
            l("onunpipe"), Q === ge && D && D.hasUnpiped === !1 && (D.hasUnpiped = !0, tt())
        }

        function bt() {
            l("onend"), z.end()
        }
        var mn = j(ge);
        z.on("drain", mn);
        var at = !1;

        function tt() {
            l("cleanup"), z.removeListener("close", lt), z.removeListener("finish", wt), z.removeListener("drain", mn), z.removeListener("error", ot), z.removeListener("unpipe", Be), ge.removeListener("end", bt), ge.removeListener("end", Xe), ge.removeListener("data", _t), at = !0, me.awaitDrain && (!z._writableState || z._writableState.needDrain) && mn()
        }
        ge.on("data", _t);

        function _t(Q) {
            l("ondata");
            var D = z.write(Q);
            l("dest.write", D), D === !1 && ((me.pipesCount === 1 && me.pipes === z || me.pipesCount > 1 && k(me.pipes, z) !== -1) && !at && (l("false write response, pause", me.awaitDrain), me.awaitDrain++), ge.pause())
        }

        function ot(Q) {
            l("onerror", Q), Xe(), z.removeListener("error", ot), e(z, "error") === 0 && P(z, Q)
        }
        A(z, "error", ot);

        function lt() {
            z.removeListener("finish", wt), Xe()
        }
        z.once("close", lt);

        function wt() {
            l("onfinish"), z.removeListener("close", lt), Xe()
        }
        z.once("finish", wt);

        function Xe() {
            l("unpipe"), ge.unpipe(z)
        }
        return z.emit("pipe", ge), me.flowing || (l("pipe resume"), ge.resume()), z
    };

    function j(z) {
        return function() {
            var ge = z._readableState;
            l("pipeOnDrain", ge.awaitDrain), ge.awaitDrain && ge.awaitDrain--, ge.awaitDrain === 0 && e(z, "data") && (ge.flowing = !0, X(z))
        }
    }
    $.prototype.unpipe = function(z) {
        var Z = this._readableState,
            ge = {
                hasUnpiped: !1
            };
        if (Z.pipesCount === 0) return this;
        if (Z.pipesCount === 1) return z && z !== Z.pipes ? this : (z || (z = Z.pipes), Z.pipes = null, Z.pipesCount = 0, Z.flowing = !1, z && z.emit("unpipe", this, ge), this);
        if (!z) {
            var me = Z.pipes,
                Re = Z.pipesCount;
            Z.pipes = null, Z.pipesCount = 0, Z.flowing = !1;
            for (var He = 0; He < Re; He++) me[He].emit("unpipe", this, {
                hasUnpiped: !1
            });
            return this
        }
        var Be = k(Z.pipes, z);
        return Be === -1 ? this : (Z.pipes.splice(Be, 1), Z.pipesCount -= 1, Z.pipesCount === 1 && (Z.pipes = Z.pipes[0]), z.emit("unpipe", this, ge), this)
    }, $.prototype.on = function(z, Z) {
        var ge = n.prototype.on.call(this, z, Z),
            me = this._readableState;
        return z === "data" ? (me.readableListening = this.listenerCount("readable") > 0, me.flowing !== !1 && this.resume()) : z === "readable" && !me.endEmitted && !me.readableListening && (me.readableListening = me.needReadable = !0, me.flowing = !1, me.emittedReadable = !1, l("on readable", me.length, me.reading), me.length ? N(this) : me.reading || process.nextTick(Y, this)), ge
    }, $.prototype.addListener = $.prototype.on, $.prototype.removeListener = function(z, Z) {
        var ge = n.prototype.removeListener.call(this, z, Z);
        return z === "readable" && process.nextTick(R, this), ge
    }, $.prototype.removeAllListeners = function(z) {
        var Z = n.prototype.removeAllListeners.apply(this, arguments);
        return (z === "readable" || z === void 0) && process.nextTick(R, this), Z
    };

    function R(z) {
        var Z = z._readableState;
        Z.readableListening = z.listenerCount("readable") > 0, Z.resumeScheduled && !Z.paused ? Z.flowing = !0 : z.listenerCount("data") > 0 && z.resume()
    }

    function Y(z) {
        l("readable nexttick read 0"), z.read(0)
    }
    $.prototype.resume = function() {
        var z = this._readableState;
        return z.flowing || (l("resume"), z.flowing = !z.readableListening, ve(this, z)), z.paused = !1, this
    };

    function ve(z, Z) {
        Z.resumeScheduled || (Z.resumeScheduled = !0, process.nextTick(V, z, Z))
    }

    function V(z, Z) {
        l("resume", Z.reading), Z.reading || z.read(0), Z.resumeScheduled = !1, z.emit("resume"), X(z), Z.flowing && !Z.reading && z.read(0)
    }
    $.prototype.pause = function() {
        return l("call pause flowing=%j", this._readableState.flowing), this._readableState.flowing !== !1 && (l("pause"), this._readableState.flowing = !1, this.emit("pause")), this._readableState.paused = !0, this
    };

    function X(z) {
        var Z = z._readableState;
        for (l("flow", Z.flowing); Z.flowing && z.read() !== null;);
    }
    $.prototype.wrap = function(z) {
        var Z = this,
            ge = this._readableState,
            me = !1;
        z.on("end", function() {
            if (l("wrapped end"), ge.decoder && !ge.ended) {
                var Be = ge.decoder.end();
                Be && Be.length && Z.push(Be)
            }
            Z.push(null)
        }), z.on("data", function(Be) {
            if (l("wrapped data"), ge.decoder && (Be = ge.decoder.write(Be)), !(ge.objectMode && Be == null) && !(!ge.objectMode && (!Be || !Be.length))) {
                var bt = Z.push(Be);
                bt || (me = !0, z.pause())
            }
        });
        for (var Re in z) this[Re] === void 0 && typeof z[Re] == "function" && (this[Re] = function(bt) {
            return function() {
                return z[bt].apply(z, arguments)
            }
        }(Re));
        for (var He = 0; He < M.length; He++) z.on(M[He], this.emit.bind(this, M[He]));
        return this._read = function(Be) {
            l("wrapped _read", Be), me && (me = !1, z.resume())
        }, this
    }, typeof Symbol == "function" && ($.prototype[Symbol.asyncIterator] = function() {
        return S === void 0 && (S = jLe()), S(this)
    }), Object.defineProperty($.prototype, "readableHighWaterMark", {
        enumerable: !1,
        get: function() {
            return this._readableState.highWaterMark
        }
    }), Object.defineProperty($.prototype, "readableBuffer", {
        enumerable: !1,
        get: function() {
            return this._readableState && this._readableState.buffer
        }
    }), Object.defineProperty($.prototype, "readableFlowing", {
        enumerable: !1,
        get: function() {
            return this._readableState.flowing
        },
        set: function(Z) {
            this._readableState && (this._readableState.flowing = Z)
        }
    }), $._fromList = q, Object.defineProperty($.prototype, "readableLength", {
        enumerable: !1,
        get: function() {
            return this._readableState.length
        }
    });

    function q(z, Z) {
        if (Z.length === 0) return null;
        var ge;
        return Z.objectMode ? ge = Z.buffer.shift() : !z || z >= Z.length ? (Z.decoder ? ge = Z.buffer.join("") : Z.buffer.length === 1 ? ge = Z.buffer.first() : ge = Z.buffer.concat(Z.length), Z.buffer.clear()) : ge = Z.buffer.consume(z, Z.decoder), ge
    }

    function ne(z) {
        var Z = z._readableState;
        l("endReadable", Z.endEmitted), Z.endEmitted || (Z.ended = !0, process.nextTick(ie, Z, z))
    }

    function ie(z, Z) {
        if (l("endReadableNT", z.endEmitted, z.length), !z.endEmitted && z.length === 0 && (z.endEmitted = !0, Z.readable = !1, Z.emit("end"), z.autoDestroy)) {
            var ge = Z._writableState;
            (!ge || ge.autoDestroy && ge.finished) && Z.destroy()
        }
    }
    typeof Symbol == "function" && ($.from = function(z, Z) {
        return I === void 0 && (I = HLe()), I($, z, Z)
    });

    function k(z, Z) {
        for (var ge = 0, me = z.length; ge < me; ge++)
            if (z[ge] === Z) return ge;
        return -1
    }
    return QO
}
var Fse = Th,
    w9 = Ey.codes,
    zLe = w9.ERR_METHOD_NOT_IMPLEMENTED,
    WLe = w9.ERR_MULTIPLE_CALLBACK,
    VLe = w9.ERR_TRANSFORM_ALREADY_TRANSFORMING,
    GLe = w9.ERR_TRANSFORM_WITH_LENGTH_0,
    v9 = n2();
Wu(Th, v9);

function qLe(t, e) {
    var n = this._transformState;
    n.transforming = !1;
    var r = n.writecb;
    if (r === null) return this.emit("error", new WLe);
    n.writechunk = null, n.writecb = null, e != null && this.push(e), r(t);
    var i = this._readableState;
    i.reading = !1, (i.needReadable || i.length < i.highWaterMark) && this._read(i.highWaterMark)
}

function Th(t) {
    if (!(this instanceof Th)) return new Th(t);
    v9.call(this, t), this._transformState = {
        afterTransform: qLe.bind(this),
        needTransform: !1,
        transforming: !1,
        writecb: null,
        writechunk: null,
        writeencoding: null
    }, this._readableState.needReadable = !0, this._readableState.sync = !1, t && (typeof t.transform == "function" && (this._transform = t.transform), typeof t.flush == "function" && (this._flush = t.flush)), this.on("prefinish", KLe)
}

function KLe() {
    var t = this;
    typeof this._flush == "function" && !this._readableState.destroyed ? this._flush(function(e, n) {
        lK(t, e, n)
    }) : lK(this, null, null)
}
Th.prototype.push = function(t, e) {
    return this._transformState.needTransform = !1, v9.prototype.push.call(this, t, e)
};
Th.prototype._transform = function(t, e, n) {
    n(new zLe("_transform()"))
};
Th.prototype._write = function(t, e, n) {
    var r = this._transformState;
    if (r.writecb = n, r.writechunk = t, r.writeencoding = e, !r.transforming) {
        var i = this._readableState;
        (r.needTransform || i.needReadable || i.length < i.highWaterMark) && this._read(i.highWaterMark)
    }
};
Th.prototype._read = function(t) {
    var e = this._transformState;
    e.writechunk !== null && !e.transforming ? (e.transforming = !0, this._transform(e.writechunk, e.writeencoding, e.afterTransform)) : e.needTransform = !0
};
Th.prototype._destroy = function(t, e) {
    v9.prototype._destroy.call(this, t, function(n) {
        e(n)
    })
};

function lK(t, e, n) {
    if (e) return t.emit("error", e);
    if (n != null && t.push(n), t._writableState.length) throw new GLe;
    if (t._transformState.transforming) throw new VLe;
    return t.push(null)
}
var YLe = a6,
    Use = Fse;
Wu(a6, Use);

function a6(t) {
    if (!(this instanceof a6)) return new a6(t);
    Use.call(this, t)
}
a6.prototype._transform = function(t, e, n) {
    n(null, t)
};
var JO;

function ZLe(t) {
    var e = !1;
    return function() {
        e || (e = !0, t.apply(void 0, arguments))
    }
}
var jse = Ey.codes,
    QLe = jse.ERR_MISSING_ARGS,
    JLe = jse.ERR_STREAM_DESTROYED;

function cK(t) {
    if (t) throw t
}

function XLe(t) {
    return t.setHeader && typeof t.abort == "function"
}

function eBe(t, e, n, r) {
    r = ZLe(r);
    var i = !1;
    t.on("close", function() {
        i = !0
    }), JO === void 0 && (JO = sB), JO(t, {
        readable: e,
        writable: n
    }, function(o) {
        if (o) return r(o);
        i = !0, r()
    });
    var s = !1;
    return function(o) {
        if (!i && !s) {
            if (s = !0, XLe(t)) return t.abort();
            if (typeof t.destroy == "function") return t.destroy();
            r(o || new JLe("pipe"))
        }
    }
}

function uK(t) {
    t()
}

function tBe(t, e) {
    return t.pipe(e)
}

function nBe(t) {
    return !t.length || typeof t[t.length - 1] != "function" ? cK : t.pop()
}

function rBe() {
    for (var t = arguments.length, e = new Array(t), n = 0; n < t; n++) e[n] = arguments[n];
    var r = nBe(e);
    if (Array.isArray(e[0]) && (e = e[0]), e.length < 2) throw new QLe("streams");
    var i, s = e.map(function(o, a) {
        var l = a < e.length - 1,
            c = a > 0;
        return eBe(o, l, c, function(u) {
            i || (i = u), u && s.forEach(uK), !l && (s.forEach(uK), r(i))
        })
    });
    return e.reduce(tBe)
}
var iBe = rBe;
(function(t, e) {
    e = t.exports = Bse(), e.Stream = e, e.Readable = e, e.Writable = $se(), e.Duplex = n2(), e.Transform = Fse, e.PassThrough = YLe, e.finished = sB, e.pipeline = iBe
})(pM, pM.exports);
var Hse = pM.exports;
const {
    Transform: sBe
} = Hse;
var oBe = t => class zse extends sBe {
    constructor(n, r, i, s, o) {
        super(o), this._rate = n, this._capacity = r, this._delimitedSuffix = i, this._hashBitLength = s, this._options = o, this._state = new t, this._state.initialize(n, r), this._finalized = !1
    }
    _transform(n, r, i) {
        let s = null;
        try {
            this.update(n, r)
        } catch (o) {
            s = o
        }
        i(s)
    }
    _flush(n) {
        let r = null;
        try {
            this.push(this.digest())
        } catch (i) {
            r = i
        }
        n(r)
    }
    update(n, r) {
        if (!Buffer.isBuffer(n) && typeof n != "string") throw new TypeError("Data must be a string or a buffer");
        if (this._finalized) throw new Error("Digest already called");
        return Buffer.isBuffer(n) || (n = Buffer.from(n, r)), this._state.absorb(n), this
    }
    digest(n) {
        if (this._finalized) throw new Error("Digest already called");
        this._finalized = !0, this._delimitedSuffix && this._state.absorbLastFewBits(this._delimitedSuffix);
        let r = this._state.squeeze(this._hashBitLength / 8);
        return n !== void 0 && (r = r.toString(n)), this._resetState(), r
    }
    _resetState() {
        return this._state.initialize(this._rate, this._capacity), this
    }
    _clone() {
        const n = new zse(this._rate, this._capacity, this._delimitedSuffix, this._hashBitLength, this._options);
        return this._state.copy(n._state), n._finalized = this._finalized, n
    }
};
const {
    Transform: aBe
} = Hse;
var lBe = t => class Wse extends aBe {
    constructor(n, r, i, s) {
        super(s), this._rate = n, this._capacity = r, this._delimitedSuffix = i, this._options = s, this._state = new t, this._state.initialize(n, r), this._finalized = !1
    }
    _transform(n, r, i) {
        let s = null;
        try {
            this.update(n, r)
        } catch (o) {
            s = o
        }
        i(s)
    }
    _flush() {}
    _read(n) {
        this.push(this.squeeze(n))
    }
    update(n, r) {
        if (!Buffer.isBuffer(n) && typeof n != "string") throw new TypeError("Data must be a string or a buffer");
        if (this._finalized) throw new Error("Squeeze already called");
        return Buffer.isBuffer(n) || (n = Buffer.from(n, r)), this._state.absorb(n), this
    }
    squeeze(n, r) {
        this._finalized || (this._finalized = !0, this._state.absorbLastFewBits(this._delimitedSuffix));
        let i = this._state.squeeze(n);
        return r !== void 0 && (i = i.toString(r)), i
    }
    _resetState() {
        return this._state.initialize(this._rate, this._capacity), this
    }
    _clone() {
        const n = new Wse(this._rate, this._capacity, this._delimitedSuffix, this._options);
        return this._state.copy(n._state), n._finalized = this._finalized, n
    }
};
const cBe = oBe,
    uBe = lBe;
var fBe = function(t) {
        const e = cBe(t),
            n = uBe(t);
        return function(r, i) {
            switch (typeof r == "string" ? r.toLowerCase() : r) {
                case "keccak224":
                    return new e(1152, 448, null, 224, i);
                case "keccak256":
                    return new e(1088, 512, null, 256, i);
                case "keccak384":
                    return new e(832, 768, null, 384, i);
                case "keccak512":
                    return new e(576, 1024, null, 512, i);
                case "sha3-224":
                    return new e(1152, 448, 6, 224, i);
                case "sha3-256":
                    return new e(1088, 512, 6, 256, i);
                case "sha3-384":
                    return new e(832, 768, 6, 384, i);
                case "sha3-512":
                    return new e(576, 1024, 6, 512, i);
                case "shake128":
                    return new n(1344, 256, 31, i);
                case "shake256":
                    return new n(1088, 512, 31, i);
                default:
                    throw new Error("Invald algorithm: " + r)
            }
        }
    },
    Vse = {};
const fK = [1, 0, 32898, 0, 32906, 2147483648, 2147516416, 2147483648, 32907, 0, 2147483649, 0, 2147516545, 2147483648, 32777, 2147483648, 138, 0, 136, 0, 2147516425, 0, 2147483658, 0, 2147516555, 0, 139, 2147483648, 32905, 2147483648, 32771, 2147483648, 32770, 2147483648, 128, 2147483648, 32778, 0, 2147483658, 2147483648, 2147516545, 2147483648, 32896, 2147483648, 2147483649, 0, 2147516424, 2147483648];
Vse.p1600 = function(t) {
    for (let e = 0; e < 24; ++e) {
        const n = t[0] ^ t[10] ^ t[20] ^ t[30] ^ t[40],
            r = t[1] ^ t[11] ^ t[21] ^ t[31] ^ t[41],
            i = t[2] ^ t[12] ^ t[22] ^ t[32] ^ t[42],
            s = t[3] ^ t[13] ^ t[23] ^ t[33] ^ t[43],
            o = t[4] ^ t[14] ^ t[24] ^ t[34] ^ t[44],
            a = t[5] ^ t[15] ^ t[25] ^ t[35] ^ t[45],
            l = t[6] ^ t[16] ^ t[26] ^ t[36] ^ t[46],
            c = t[7] ^ t[17] ^ t[27] ^ t[37] ^ t[47],
            u = t[8] ^ t[18] ^ t[28] ^ t[38] ^ t[48],
            f = t[9] ^ t[19] ^ t[29] ^ t[39] ^ t[49];
        let h = u ^ (i << 1 | s >>> 31),
            g = f ^ (s << 1 | i >>> 31);
        const y = t[0] ^ h,
            _ = t[1] ^ g,
            C = t[10] ^ h,
            b = t[11] ^ g,
            w = t[20] ^ h,
            S = t[21] ^ g,
            I = t[30] ^ h,
            P = t[31] ^ g,
            M = t[40] ^ h,
            A = t[41] ^ g;
        h = n ^ (o << 1 | a >>> 31), g = r ^ (a << 1 | o >>> 31);
        const E = t[2] ^ h,
            $ = t[3] ^ g,
            H = t[12] ^ h,
            K = t[13] ^ g,
            te = t[22] ^ h,
            U = t[23] ^ g,
            m = t[32] ^ h,
            v = t[33] ^ g,
            T = t[42] ^ h,
            N = t[43] ^ g;
        h = i ^ (l << 1 | c >>> 31), g = s ^ (c << 1 | l >>> 31);
        const O = t[4] ^ h,
            L = t[5] ^ g,
            G = t[14] ^ h,
            j = t[15] ^ g,
            R = t[24] ^ h,
            Y = t[25] ^ g,
            ve = t[34] ^ h,
            V = t[35] ^ g,
            X = t[44] ^ h,
            q = t[45] ^ g;
        h = o ^ (u << 1 | f >>> 31), g = a ^ (f << 1 | u >>> 31);
        const ne = t[6] ^ h,
            ie = t[7] ^ g,
            k = t[16] ^ h,
            z = t[17] ^ g,
            Z = t[26] ^ h,
            ge = t[27] ^ g,
            me = t[36] ^ h,
            Re = t[37] ^ g,
            He = t[46] ^ h,
            Be = t[47] ^ g;
        h = l ^ (n << 1 | r >>> 31), g = c ^ (r << 1 | n >>> 31);
        const bt = t[8] ^ h,
            mn = t[9] ^ g,
            at = t[18] ^ h,
            tt = t[19] ^ g,
            _t = t[28] ^ h,
            ot = t[29] ^ g,
            lt = t[38] ^ h,
            wt = t[39] ^ g,
            Xe = t[48] ^ h,
            Q = t[49] ^ g,
            D = y,
            B = _,
            se = b << 4 | C >>> 28,
            de = C << 4 | b >>> 28,
            ye = w << 3 | S >>> 29,
            Se = S << 3 | w >>> 29,
            nt = P << 9 | I >>> 23,
            Ke = I << 9 | P >>> 23,
            mt = M << 18 | A >>> 14,
            en = A << 18 | M >>> 14,
            vt = E << 1 | $ >>> 31,
            hn = $ << 1 | E >>> 31,
            ui = K << 12 | H >>> 20,
            bn = H << 12 | K >>> 20,
            On = te << 10 | U >>> 22,
            Un = U << 10 | te >>> 22,
            Lt = v << 13 | m >>> 19,
            jt = m << 13 | v >>> 19,
            qn = T << 2 | N >>> 30,
            Ht = N << 2 | T >>> 30,
            zt = L << 30 | O >>> 2,
            Jn = O << 30 | L >>> 2,
            Vt = G << 6 | j >>> 26,
            Ft = j << 6 | G >>> 26,
            Xn = Y << 11 | R >>> 21,
            Kt = R << 11 | Y >>> 21,
            Qt = ve << 15 | V >>> 17,
            fe = V << 15 | ve >>> 17,
            he = q << 29 | X >>> 3,
            be = X << 29 | q >>> 3,
            Pe = ne << 28 | ie >>> 4,
            qe = ie << 28 | ne >>> 4,
            Je = z << 23 | k >>> 9,
            Mt = k << 23 | z >>> 9,
            Le = Z << 25 | ge >>> 7,
            rt = ge << 25 | Z >>> 7,
            ct = me << 21 | Re >>> 11,
            ft = Re << 21 | me >>> 11,
            an = Be << 24 | He >>> 8,
            pn = He << 24 | Be >>> 8,
            ln = bt << 27 | mn >>> 5,
            cn = mn << 27 | bt >>> 5,
            Er = at << 20 | tt >>> 12,
            er = tt << 20 | at >>> 12,
            Js = ot << 7 | _t >>> 25,
            Qi = _t << 7 | ot >>> 25,
            Ji = lt << 8 | wt >>> 24,
            Xi = wt << 8 | lt >>> 24,
            Xs = Xe << 14 | Q >>> 18,
            Tr = Q << 14 | Xe >>> 18;
        t[0] = D ^ ~ui & Xn, t[1] = B ^ ~bn & Kt, t[10] = Pe ^ ~Er & ye, t[11] = qe ^ ~er & Se, t[20] = vt ^ ~Vt & Le, t[21] = hn ^ ~Ft & rt, t[30] = ln ^ ~se & On, t[31] = cn ^ ~de & Un, t[40] = zt ^ ~Je & Js, t[41] = Jn ^ ~Mt & Qi, t[2] = ui ^ ~Xn & ct, t[3] = bn ^ ~Kt & ft, t[12] = Er ^ ~ye & Lt, t[13] = er ^ ~Se & jt, t[22] = Vt ^ ~Le & Ji, t[23] = Ft ^ ~rt & Xi, t[32] = se ^ ~On & Qt, t[33] = de ^ ~Un & fe, t[42] = Je ^ ~Js & nt, t[43] = Mt ^ ~Qi & Ke, t[4] = Xn ^ ~ct & Xs, t[5] = Kt ^ ~ft & Tr, t[14] = ye ^ ~Lt & he, t[15] = Se ^ ~jt & be, t[24] = Le ^ ~Ji & mt, t[25] = rt ^ ~Xi & en, t[34] = On ^ ~Qt & an, t[35] = Un ^ ~fe & pn, t[44] = Js ^ ~nt & qn, t[45] = Qi ^ ~Ke & Ht, t[6] = ct ^ ~Xs & D, t[7] = ft ^ ~Tr & B, t[16] = Lt ^ ~he & Pe, t[17] = jt ^ ~be & qe, t[26] = Ji ^ ~mt & vt, t[27] = Xi ^ ~en & hn, t[36] = Qt ^ ~an & ln, t[37] = fe ^ ~pn & cn, t[46] = nt ^ ~qn & zt, t[47] = Ke ^ ~Ht & Jn, t[8] = Xs ^ ~D & ui, t[9] = Tr ^ ~B & bn, t[18] = he ^ ~Pe & Er, t[19] = be ^ ~qe & er, t[28] = mt ^ ~vt & Vt, t[29] = en ^ ~hn & Ft, t[38] = an ^ ~ln & se, t[39] = pn ^ ~cn & de, t[48] = qn ^ ~zt & Je, t[49] = Ht ^ ~Jn & Mt, t[0] ^= fK[e * 2], t[1] ^= fK[e * 2 + 1]
    }
};
const ZC = Vse;

function j2() {
    this.state = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], this.blockSize = null, this.count = 0, this.squeezing = !1
}
j2.prototype.initialize = function(t, e) {
    for (let n = 0; n < 50; ++n) this.state[n] = 0;
    this.blockSize = t / 8, this.count = 0, this.squeezing = !1
};
j2.prototype.absorb = function(t) {
    for (let e = 0; e < t.length; ++e) this.state[~~(this.count / 4)] ^= t[e] << 8 * (this.count % 4), this.count += 1, this.count === this.blockSize && (ZC.p1600(this.state), this.count = 0)
};
j2.prototype.absorbLastFewBits = function(t) {
    this.state[~~(this.count / 4)] ^= t << 8 * (this.count % 4), t & 128 && this.count === this.blockSize - 1 && ZC.p1600(this.state), this.state[~~((this.blockSize - 1) / 4)] ^= 128 << 8 * ((this.blockSize - 1) % 4), ZC.p1600(this.state), this.count = 0, this.squeezing = !0
};
j2.prototype.squeeze = function(t) {
    this.squeezing || this.absorbLastFewBits(1);
    const e = Buffer.alloc(t);
    for (let n = 0; n < t; ++n) e[n] = this.state[~~(this.count / 4)] >>> 8 * (this.count % 4) & 255, this.count += 1, this.count === this.blockSize && (ZC.p1600(this.state), this.count = 0);
    return e
};
j2.prototype.copy = function(t) {
    for (let e = 0; e < 50; ++e) t.state[e] = this.state[e];
    t.blockSize = this.blockSize, t.count = this.count, t.squeezing = this.squeezing
};
var dBe = j2,
    hBe = fBe(dBe);
const pBe = hBe,
    gBe = ME;

function Gse(t) {
    return Buffer.allocUnsafe(t).fill(0)
}

function qse(t, e, n) {
    const r = Gse(e);
    return t = b9(t), n ? t.length < e ? (t.copy(r), r) : t.slice(0, e) : t.length < e ? (t.copy(r, e - t.length), r) : t.slice(-e)
}

function mBe(t, e) {
    return qse(t, e, !0)
}

function b9(t) {
    if (!Buffer.isBuffer(t))
        if (Array.isArray(t)) t = Buffer.from(t);
        else if (typeof t == "string") Kse(t) ? t = Buffer.from(vBe(Yse(t)), "hex") : t = Buffer.from(t);
    else if (typeof t == "number") t = intToBuffer(t);
    else if (t == null) t = Buffer.allocUnsafe(0);
    else if (gBe.isBN(t)) t = t.toArrayLike(Buffer);
    else if (t.toArray) t = Buffer.from(t.toArray());
    else throw new Error("invalid type");
    return t
}

function yBe(t) {
    return t = b9(t), "0x" + t.toString("hex")
}

function wBe(t, e) {
    return t = b9(t), e || (e = 256), pBe("keccak" + e).update(t).digest()
}

function vBe(t) {
    return t.length % 2 ? "0" + t : t
}

function Kse(t) {
    return typeof t == "string" && t.match(/^0x[0-9A-Fa-f]*$/)
}

function Yse(t) {
    return typeof t == "string" && t.startsWith("0x") ? t.slice(2) : t
}
var Zse = {
    zeros: Gse,
    setLength: qse,
    setLengthRight: mBe,
    isHexString: Kse,
    stripHexPrefix: Yse,
    toBuffer: b9,
    bufferToHex: yBe,
    keccak: wBe
};
const Um = Zse,
    g1 = ME;

function Qse(t) {
    return t.startsWith("int[") ? "int256" + t.slice(3) : t === "int" ? "int256" : t.startsWith("uint[") ? "uint256" + t.slice(4) : t === "uint" ? "uint256" : t.startsWith("fixed[") ? "fixed128x128" + t.slice(5) : t === "fixed" ? "fixed128x128" : t.startsWith("ufixed[") ? "ufixed128x128" + t.slice(6) : t === "ufixed" ? "ufixed128x128" : t
}

function uv(t) {
    return parseInt(/^\D+(\d+)$/.exec(t)[1], 10)
}

function dK(t) {
    var e = /^\D+(\d+)x(\d+)$/.exec(t);
    return [parseInt(e[1], 10), parseInt(e[2], 10)]
}

function Jse(t) {
    var e = t.match(/(.*)\[(.*?)\]$/);
    return e ? e[2] === "" ? "dynamic" : parseInt(e[2], 10) : null
}

function Xg(t) {
    var e = typeof t;
    if (e === "string") return Um.isHexString(t) ? new g1(Um.stripHexPrefix(t), 16) : new g1(t, 10);
    if (e === "number") return new g1(t);
    if (t.toArray) return t;
    throw new Error("Argument is not a number")
}

function hf(t, e) {
    var n, r, i, s;
    if (t === "address") return hf("uint160", Xg(e));
    if (t === "bool") return hf("uint8", e ? 1 : 0);
    if (t === "string") return hf("bytes", new Buffer(e, "utf8"));
    if (_Be(t)) {
        if (typeof e.length > "u") throw new Error("Not an array?");
        if (n = Jse(t), n !== "dynamic" && n !== 0 && e.length > n) throw new Error("Elements exceed array size: " + n);
        i = [], t = t.slice(0, t.lastIndexOf("[")), typeof e == "string" && (e = JSON.parse(e));
        for (s in e) i.push(hf(t, e[s]));
        if (n === "dynamic") {
            var o = hf("uint256", e.length);
            i.unshift(o)
        }
        return Buffer.concat(i)
    } else {
        if (t === "bytes") return e = new Buffer(e), i = Buffer.concat([hf("uint256", e.length), e]), e.length % 32 !== 0 && (i = Buffer.concat([i, Um.zeros(32 - e.length % 32)])), i;
        if (t.startsWith("bytes")) {
            if (n = uv(t), n < 1 || n > 32) throw new Error("Invalid bytes<N> width: " + n);
            return Um.setLengthRight(e, 32)
        } else if (t.startsWith("uint")) {
            if (n = uv(t), n % 8 || n < 8 || n > 256) throw new Error("Invalid uint<N> width: " + n);
            if (r = Xg(e), r.bitLength() > n) throw new Error("Supplied uint exceeds width: " + n + " vs " + r.bitLength());
            if (r < 0) throw new Error("Supplied uint is negative");
            return r.toArrayLike(Buffer, "be", 32)
        } else if (t.startsWith("int")) {
            if (n = uv(t), n % 8 || n < 8 || n > 256) throw new Error("Invalid int<N> width: " + n);
            if (r = Xg(e), r.bitLength() > n) throw new Error("Supplied int exceeds width: " + n + " vs " + r.bitLength());
            return r.toTwos(256).toArrayLike(Buffer, "be", 32)
        } else if (t.startsWith("ufixed")) {
            if (n = dK(t), r = Xg(e), r < 0) throw new Error("Supplied ufixed is negative");
            return hf("uint256", r.mul(new g1(2).pow(new g1(n[1]))))
        } else if (t.startsWith("fixed")) return n = dK(t), hf("int256", Xg(e).mul(new g1(2).pow(new g1(n[1]))))
    }
    throw new Error("Unsupported or invalid type: " + t)
}

function bBe(t) {
    return t === "string" || t === "bytes" || Jse(t) === "dynamic"
}

function _Be(t) {
    return t.lastIndexOf("]") === t.length - 1
}

function EBe(t, e) {
    var n = [],
        r = [],
        i = 32 * t.length;
    for (var s in t) {
        var o = Qse(t[s]),
            a = e[s],
            l = hf(o, a);
        bBe(o) ? (n.push(hf("uint256", i)), r.push(l), i += l.length) : n.push(l)
    }
    return Buffer.concat(n.concat(r))
}

function Xse(t, e) {
    if (t.length !== e.length) throw new Error("Number of types are not matching the values");
    for (var n, r, i = [], s = 0; s < t.length; s++) {
        var o = Qse(t[s]),
            a = e[s];
        if (o === "bytes") i.push(a);
        else if (o === "string") i.push(new Buffer(a, "utf8"));
        else if (o === "bool") i.push(new Buffer(a ? "01" : "00", "hex"));
        else if (o === "address") i.push(Um.setLength(a, 20));
        else if (o.startsWith("bytes")) {
            if (n = uv(o), n < 1 || n > 32) throw new Error("Invalid bytes<N> width: " + n);
            i.push(Um.setLengthRight(a, n))
        } else if (o.startsWith("uint")) {
            if (n = uv(o), n % 8 || n < 8 || n > 256) throw new Error("Invalid uint<N> width: " + n);
            if (r = Xg(a), r.bitLength() > n) throw new Error("Supplied uint exceeds width: " + n + " vs " + r.bitLength());
            i.push(r.toArrayLike(Buffer, "be", n / 8))
        } else if (o.startsWith("int")) {
            if (n = uv(o), n % 8 || n < 8 || n > 256) throw new Error("Invalid int<N> width: " + n);
            if (r = Xg(a), r.bitLength() > n) throw new Error("Supplied int exceeds width: " + n + " vs " + r.bitLength());
            i.push(r.toTwos(n).toArrayLike(Buffer, "be", n / 8))
        } else throw new Error("Unsupported or invalid type: " + o)
    }
    return Buffer.concat(i)
}

function xBe(t, e) {
    return Um.keccak(Xse(t, e))
}
var SBe = {
    rawEncode: EBe,
    solidityPack: Xse,
    soliditySHA3: xBe
};
const Jc = Zse,
    K3 = SBe,
    eoe = {
        type: "object",
        properties: {
            types: {
                type: "object",
                additionalProperties: {
                    type: "array",
                    items: {
                        type: "object",
                        properties: {
                            name: {
                                type: "string"
                            },
                            type: {
                                type: "string"
                            }
                        },
                        required: ["name", "type"]
                    }
                }
            },
            primaryType: {
                type: "string"
            },
            domain: {
                type: "object"
            },
            message: {
                type: "object"
            }
        },
        required: ["types", "primaryType", "domain", "message"]
    },
    XO = {
        encodeData(t, e, n, r = !0) {
            const i = ["bytes32"],
                s = [this.hashType(t, n)];
            if (r) {
                const o = (a, l, c) => {
                    if (n[l] !== void 0) return ["bytes32", c == null ? "0x0000000000000000000000000000000000000000000000000000000000000000" : Jc.keccak(this.encodeData(l, c, n, r))];
                    if (c === void 0) throw new Error(`missing value for field ${a} of type ${l}`);
                    if (l === "bytes") return ["bytes32", Jc.keccak(c)];
                    if (l === "string") return typeof c == "string" && (c = Buffer.from(c, "utf8")), ["bytes32", Jc.keccak(c)];
                    if (l.lastIndexOf("]") === l.length - 1) {
                        const u = l.slice(0, l.lastIndexOf("[")),
                            f = c.map(h => o(a, u, h));
                        return ["bytes32", Jc.keccak(K3.rawEncode(f.map(([h]) => h), f.map(([, h]) => h)))]
                    }
                    return [l, c]
                };
                for (const a of n[t]) {
                    const [l, c] = o(a.name, a.type, e[a.name]);
                    i.push(l), s.push(c)
                }
            } else
                for (const o of n[t]) {
                    let a = e[o.name];
                    if (a !== void 0)
                        if (o.type === "bytes") i.push("bytes32"), a = Jc.keccak(a), s.push(a);
                        else if (o.type === "string") i.push("bytes32"), typeof a == "string" && (a = Buffer.from(a, "utf8")), a = Jc.keccak(a), s.push(a);
                    else if (n[o.type] !== void 0) i.push("bytes32"), a = Jc.keccak(this.encodeData(o.type, a, n, r)), s.push(a);
                    else {
                        if (o.type.lastIndexOf("]") === o.type.length - 1) throw new Error("Arrays currently unimplemented in encodeData");
                        i.push(o.type), s.push(a)
                    }
                }
            return K3.rawEncode(i, s)
        },
        encodeType(t, e) {
            let n = "",
                r = this.findTypeDependencies(t, e).filter(i => i !== t);
            r = [t].concat(r.sort());
            for (const i of r) {
                if (!e[i]) throw new Error("No type definition specified: " + i);
                n += i + "(" + e[i].map(({
                    name: o,
                    type: a
                }) => a + " " + o).join(",") + ")"
            }
            return n
        },
        findTypeDependencies(t, e, n = []) {
            if (t = t.match(/^\w*/)[0], n.includes(t) || e[t] === void 0) return n;
            n.push(t);
            for (const r of e[t])
                for (const i of this.findTypeDependencies(r.type, e, n)) !n.includes(i) && n.push(i);
            return n
        },
        hashStruct(t, e, n, r = !0) {
            return Jc.keccak(this.encodeData(t, e, n, r))
        },
        hashType(t, e) {
            return Jc.keccak(this.encodeType(t, e))
        },
        sanitizeData(t) {
            const e = {};
            for (const n in eoe.properties) t[n] && (e[n] = t[n]);
            return e.types && (e.types = Object.assign({
                EIP712Domain: []
            }, e.types)), e
        },
        hash(t, e = !0) {
            const n = this.sanitizeData(t),
                r = [Buffer.from("1901", "hex")];
            return r.push(this.hashStruct("EIP712Domain", n.domain, n.types, e)), n.primaryType !== "EIP712Domain" && r.push(this.hashStruct(n.primaryType, n.message, n.types, e)), Jc.keccak(Buffer.concat(r))
        }
    };
var CBe = {
    TYPED_MESSAGE_SCHEMA: eoe,
    TypedDataUtils: XO,
    hashForSignTypedDataLegacy: function(t) {
        return ABe(t.data)
    },
    hashForSignTypedData_v3: function(t) {
        return XO.hash(t.data, !1)
    },
    hashForSignTypedData_v4: function(t) {
        return XO.hash(t.data)
    }
};

function ABe(t) {
    const e = new Error("Expect argument to be non-empty array");
    if (typeof t != "object" || !t.length) throw e;
    const n = t.map(function(s) {
            return s.type === "bytes" ? Jc.toBuffer(s.value) : s.value
        }),
        r = t.map(function(s) {
            return s.type
        }),
        i = t.map(function(s) {
            if (!s.name) throw e;
            return s.type + " " + s.name
        });
    return K3.soliditySHA3(["bytes32", "bytes32"], [K3.soliditySHA3(new Array(t.length).fill("string"), i), K3.soliditySHA3(r, n)])
}
var r2 = {};
Object.defineProperty(r2, "__esModule", {
    value: !0
});
r2.filterFromParam = r2.FilterPolyfill = void 0;
const Cw = HE,
    qo = Ut,
    TBe = 5 * 60 * 1e3,
    e1 = {
        jsonrpc: "2.0",
        id: 0
    };
class IBe {
    constructor(e) {
        this.logFilters = new Map, this.blockFilters = new Set, this.pendingTransactionFilters = new Set, this.cursors = new Map, this.timeouts = new Map, this.nextFilterId = (0, Cw.IntNumber)(1), this.provider = e
    }
    async newFilter(e) {
        const n = toe(e),
            r = this.makeFilterId(),
            i = await this.setInitialCursorPosition(r, n.fromBlock);
        return console.log(`Installing new log filter(${r}):`, n, "initial cursor position:", i), this.logFilters.set(r, n), this.setFilterTimeout(r), (0, qo.hexStringFromIntNumber)(r)
    }
    async newBlockFilter() {
        const e = this.makeFilterId(),
            n = await this.setInitialCursorPosition(e, "latest");
        return console.log(`Installing new block filter (${e}) with initial cursor position:`, n), this.blockFilters.add(e), this.setFilterTimeout(e), (0, qo.hexStringFromIntNumber)(e)
    }
    async newPendingTransactionFilter() {
        const e = this.makeFilterId(),
            n = await this.setInitialCursorPosition(e, "latest");
        return console.log(`Installing new block filter (${e}) with initial cursor position:`, n), this.pendingTransactionFilters.add(e), this.setFilterTimeout(e), (0, qo.hexStringFromIntNumber)(e)
    }
    uninstallFilter(e) {
        const n = (0, qo.intNumberFromHexString)(e);
        return console.log(`Uninstalling filter (${n})`), this.deleteFilter(n), !0
    }
    getFilterChanges(e) {
        const n = (0, qo.intNumberFromHexString)(e);
        return this.timeouts.has(n) && this.setFilterTimeout(n), this.logFilters.has(n) ? this.getLogFilterChanges(n) : this.blockFilters.has(n) ? this.getBlockFilterChanges(n) : this.pendingTransactionFilters.has(n) ? this.getPendingTransactionFilterChanges(n) : Promise.resolve(nS())
    }
    async getFilterLogs(e) {
        const n = (0, qo.intNumberFromHexString)(e),
            r = this.logFilters.get(n);
        return r ? this.sendAsyncPromise(Object.assign(Object.assign({}, e1), {
            method: "eth_getLogs",
            params: [hK(r)]
        })) : nS()
    }
    makeFilterId() {
        return (0, Cw.IntNumber)(++this.nextFilterId)
    }
    sendAsyncPromise(e) {
        return new Promise((n, r) => {
            this.provider.sendAsync(e, (i, s) => {
                if (i) return r(i);
                if (Array.isArray(s) || s == null) return r(new Error(`unexpected response received: ${JSON.stringify(s)}`));
                n(s)
            })
        })
    }
    deleteFilter(e) {
        console.log(`Deleting filter (${e})`), this.logFilters.delete(e), this.blockFilters.delete(e), this.pendingTransactionFilters.delete(e), this.cursors.delete(e), this.timeouts.delete(e)
    }
    async getLogFilterChanges(e) {
        const n = this.logFilters.get(e),
            r = this.cursors.get(e);
        if (!r || !n) return nS();
        const i = await this.getCurrentBlockHeight(),
            s = n.toBlock === "latest" ? i : n.toBlock;
        if (r > i || r > n.toBlock) return rS();
        console.log(`Fetching logs from ${r} to ${s} for filter ${e}`);
        const o = await this.sendAsyncPromise(Object.assign(Object.assign({}, e1), {
            method: "eth_getLogs",
            params: [hK(Object.assign(Object.assign({}, n), {
                fromBlock: r,
                toBlock: s
            }))]
        }));
        if (Array.isArray(o.result)) {
            const a = o.result.map(c => (0, qo.intNumberFromHexString)(c.blockNumber || "0x0")),
                l = Math.max(...a);
            if (l && l > r) {
                const c = (0, Cw.IntNumber)(l + 1);
                console.log(`Moving cursor position for filter (${e}) from ${r} to ${c}`), this.cursors.set(e, c)
            }
        }
        return o
    }
    async getBlockFilterChanges(e) {
        const n = this.cursors.get(e);
        if (!n) return nS();
        const r = await this.getCurrentBlockHeight();
        if (n > r) return rS();
        console.log(`Fetching blocks from ${n} to ${r} for filter (${e})`);
        const i = (await Promise.all((0, qo.range)(n, r + 1).map(o => this.getBlockHashByNumber((0, Cw.IntNumber)(o))))).filter(o => !!o),
            s = (0, Cw.IntNumber)(n + i.length);
        return console.log(`Moving cursor position for filter (${e}) from ${n} to ${s}`), this.cursors.set(e, s), Object.assign(Object.assign({}, e1), {
            result: i
        })
    }
    async getPendingTransactionFilterChanges(e) {
        return Promise.resolve(rS())
    }
    async setInitialCursorPosition(e, n) {
        const r = await this.getCurrentBlockHeight(),
            i = typeof n == "number" && n > r ? n : r;
        return this.cursors.set(e, i), i
    }
    setFilterTimeout(e) {
        const n = this.timeouts.get(e);
        n && window.clearTimeout(n);
        const r = window.setTimeout(() => {
            console.log(`Filter (${e}) timed out`), this.deleteFilter(e)
        }, TBe);
        this.timeouts.set(e, r)
    }
    async getCurrentBlockHeight() {
        const {
            result: e
        } = await this.sendAsyncPromise(Object.assign(Object.assign({}, e1), {
            method: "eth_blockNumber",
            params: []
        }));
        return (0, qo.intNumberFromHexString)((0, qo.ensureHexString)(e))
    }
    async getBlockHashByNumber(e) {
        const n = await this.sendAsyncPromise(Object.assign(Object.assign({}, e1), {
            method: "eth_getBlockByNumber",
            params: [(0, qo.hexStringFromIntNumber)(e), !1]
        }));
        return n.result && typeof n.result.hash == "string" ? (0, qo.ensureHexString)(n.result.hash) : null
    }
}
r2.FilterPolyfill = IBe;

function toe(t) {
    return {
        fromBlock: pK(t.fromBlock),
        toBlock: pK(t.toBlock),
        addresses: t.address === void 0 ? null : Array.isArray(t.address) ? t.address : [t.address],
        topics: t.topics || []
    }
}
r2.filterFromParam = toe;

function hK(t) {
    const e = {
        fromBlock: gK(t.fromBlock),
        toBlock: gK(t.toBlock),
        topics: t.topics
    };
    return t.addresses !== null && (e.address = t.addresses), e
}

function pK(t) {
    if (t === void 0 || t === "latest" || t === "pending") return "latest";
    if (t === "earliest") return (0, Cw.IntNumber)(0);
    if ((0, qo.isHexString)(t)) return (0, qo.intNumberFromHexString)(t);
    throw new Error(`Invalid block option: ${String(t)}`)
}

function gK(t) {
    return t === "latest" ? t : (0, qo.hexStringFromIntNumber)(t)
}

function nS() {
    return Object.assign(Object.assign({}, e1), {
        error: {
            code: -32e3,
            message: "filter not found"
        }
    })
}

function rS() {
    return Object.assign(Object.assign({}, e1), {
        result: []
    })
}
var noe = {};
(function(t) {
    Object.defineProperty(t, "__esModule", {
            value: !0
        }), t.JSONRPCMethod = void 0,
        function(e) {
            e.eth_accounts = "eth_accounts", e.eth_coinbase = "eth_coinbase", e.net_version = "net_version", e.eth_chainId = "eth_chainId", e.eth_uninstallFilter = "eth_uninstallFilter", e.eth_requestAccounts = "eth_requestAccounts", e.eth_sign = "eth_sign", e.eth_ecRecover = "eth_ecRecover", e.personal_sign = "personal_sign", e.personal_ecRecover = "personal_ecRecover", e.eth_signTransaction = "eth_signTransaction", e.eth_sendRawTransaction = "eth_sendRawTransaction", e.eth_sendTransaction = "eth_sendTransaction", e.eth_signTypedData_v1 = "eth_signTypedData_v1", e.eth_signTypedData_v2 = "eth_signTypedData_v2", e.eth_signTypedData_v3 = "eth_signTypedData_v3", e.eth_signTypedData_v4 = "eth_signTypedData_v4", e.eth_signTypedData = "eth_signTypedData", e.cbWallet_arbitrary = "walletlink_arbitrary", e.wallet_addEthereumChain = "wallet_addEthereumChain", e.wallet_switchEthereumChain = "wallet_switchEthereumChain", e.wallet_watchAsset = "wallet_watchAsset", e.eth_subscribe = "eth_subscribe", e.eth_unsubscribe = "eth_unsubscribe", e.eth_newFilter = "eth_newFilter", e.eth_newBlockFilter = "eth_newBlockFilter", e.eth_newPendingTransactionFilter = "eth_newPendingTransactionFilter", e.eth_getFilterChanges = "eth_getFilterChanges", e.eth_getFilterLogs = "eth_getFilterLogs"
        }(t.JSONRPCMethod || (t.JSONRPCMethod = {}))
})(noe);
var _9 = {},
    roe = {},
    E9 = {},
    oB = RBe;

function RBe(t) {
    t = t || {};
    var e = t.max || Number.MAX_SAFE_INTEGER,
        n = typeof t.start < "u" ? t.start : Math.floor(Math.random() * e);
    return function() {
        return n = n % e, n++
    }
}
const mK = (t, e) => function() {
    const n = e.promiseModule,
        r = new Array(arguments.length);
    for (let i = 0; i < arguments.length; i++) r[i] = arguments[i];
    return new n((i, s) => {
        e.errorFirst ? r.push(function(o, a) {
            if (e.multiArgs) {
                const l = new Array(arguments.length - 1);
                for (let c = 1; c < arguments.length; c++) l[c - 1] = arguments[c];
                o ? (l.unshift(o), s(l)) : i(l)
            } else o ? s(o) : i(a)
        }) : r.push(function(o) {
            if (e.multiArgs) {
                const a = new Array(arguments.length - 1);
                for (let l = 0; l < arguments.length; l++) a[l] = arguments[l];
                i(a)
            } else i(o)
        }), t.apply(this, r)
    })
};
var OBe = (t, e) => {
        e = Object.assign({
            exclude: [/.+(Sync|Stream)$/],
            errorFirst: !0,
            promiseModule: Promise
        }, e);
        const n = i => {
            const s = o => typeof o == "string" ? i === o : o.test(i);
            return e.include ? e.include.some(s) : !e.exclude.some(s)
        };
        let r;
        typeof t == "function" ? r = function() {
            return e.excludeMain ? t.apply(this, arguments) : mK(t, e).apply(this, arguments)
        } : r = Object.create(Object.getPrototypeOf(t));
        for (const i in t) {
            const s = t[i];
            r[i] = typeof s == "function" && n(i) ? mK(s, e) : s
        }
        return r
    },
    VE = {},
    NBe = st && st.__importDefault || function(t) {
        return t && t.__esModule ? t : {
            default: t
        }
    };
Object.defineProperty(VE, "__esModule", {
    value: !0
});
VE.BaseBlockTracker = void 0;
const PBe = NBe(vy),
    kBe = 1e3,
    MBe = (t, e) => t + e,
    yK = ["sync", "latest"];
class DBe extends PBe.default {
    constructor(e) {
        super(), this._blockResetDuration = e.blockResetDuration || 20 * kBe, this._currentBlock = null, this._isRunning = !1, this._onNewListener = this._onNewListener.bind(this), this._onRemoveListener = this._onRemoveListener.bind(this), this._resetCurrentBlock = this._resetCurrentBlock.bind(this), this._setupInternalEvents()
    }
    async destroy() {
        this._cancelBlockResetTimeout(), await this._maybeEnd(), super.removeAllListeners()
    }
    isRunning() {
        return this._isRunning
    }
    getCurrentBlock() {
        return this._currentBlock
    }
    async getLatestBlock() {
        return this._currentBlock ? this._currentBlock : await new Promise(n => this.once("latest", n))
    }
    removeAllListeners(e) {
        return e ? super.removeAllListeners(e) : super.removeAllListeners(), this._setupInternalEvents(), this._onRemoveListener(), this
    }
    _setupInternalEvents() {
        this.removeListener("newListener", this._onNewListener), this.removeListener("removeListener", this._onRemoveListener), this.on("newListener", this._onNewListener), this.on("removeListener", this._onRemoveListener)
    }
    _onNewListener(e) {
        yK.includes(e) && this._maybeStart()
    }
    _onRemoveListener() {
        this._getBlockTrackerEventCount() > 0 || this._maybeEnd()
    }
    async _maybeStart() {
        this._isRunning || (this._isRunning = !0, this._cancelBlockResetTimeout(), await this._start(), this.emit("_started"))
    }
    async _maybeEnd() {
        this._isRunning && (this._isRunning = !1, this._setupBlockResetTimeout(), await this._end(), this.emit("_ended"))
    }
    _getBlockTrackerEventCount() {
        return yK.map(e => this.listenerCount(e)).reduce(MBe)
    }
    _newPotentialLatest(e) {
        const n = this._currentBlock;
        n && wK(e) <= wK(n) || this._setCurrentBlock(e)
    }
    _setCurrentBlock(e) {
        const n = this._currentBlock;
        this._currentBlock = e, this.emit("latest", e), this.emit("sync", {
            oldBlock: n,
            newBlock: e
        })
    }
    _setupBlockResetTimeout() {
        this._cancelBlockResetTimeout(), this._blockResetTimeout = setTimeout(this._resetCurrentBlock, this._blockResetDuration), this._blockResetTimeout.unref && this._blockResetTimeout.unref()
    }
    _cancelBlockResetTimeout() {
        this._blockResetTimeout && clearTimeout(this._blockResetTimeout)
    }
    _resetCurrentBlock() {
        this._currentBlock = null
    }
}
VE.BaseBlockTracker = DBe;

function wK(t) {
    return Number.parseInt(t, 16)
}
var ioe = {},
    soe = {},
    oo = {};
class ooe extends TypeError {
    constructor(e, n) {
        let r;
        const {
            message: i,
            explanation: s,
            ...o
        } = e, {
            path: a
        } = e, l = a.length === 0 ? i : `At path: ${a.join(".")} -- ${i}`;
        super(s ? ? l), s != null && (this.cause = l), Object.assign(this, o), this.name = this.constructor.name, this.failures = () => r ? ? (r = [e, ...n()])
    }
}

function $Be(t) {
    return Cc(t) && typeof t[Symbol.iterator] == "function"
}

function Cc(t) {
    return typeof t == "object" && t != null
}

function vK(t) {
    if (Object.prototype.toString.call(t) !== "[object Object]") return !1;
    const e = Object.getPrototypeOf(t);
    return e === null || e === Object.prototype
}

function ks(t) {
    return typeof t == "symbol" ? t.toString() : typeof t == "string" ? JSON.stringify(t) : `${t}`
}

function LBe(t) {
    const {
        done: e,
        value: n
    } = t.next();
    return e ? void 0 : n
}

function BBe(t, e, n, r) {
    if (t === !0) return;
    t === !1 ? t = {} : typeof t == "string" && (t = {
        message: t
    });
    const {
        path: i,
        branch: s
    } = e, {
        type: o
    } = n, {
        refinement: a,
        message: l = `Expected a value of type \`${o}\`${a?` with refinement \`${a}\``:""}, but received: \`${ks(r)}\``
    } = t;
    return {
        value: r,
        type: o,
        refinement: a,
        key: i[i.length - 1],
        path: i,
        branch: s,
        ...t,
        message: l
    }
}

function* mM(t, e, n, r) {
    $Be(t) || (t = [t]);
    for (const i of t) {
        const s = BBe(i, e, n, r);
        s && (yield s)
    }
}

function* aB(t, e, n = {}) {
    const {
        path: r = [],
        branch: i = [t],
        coerce: s = !1,
        mask: o = !1
    } = n, a = {
        path: r,
        branch: i
    };
    if (s && (t = e.coercer(t, a), o && e.type !== "type" && Cc(e.schema) && Cc(t) && !Array.isArray(t)))
        for (const c in t) e.schema[c] === void 0 && delete t[c];
    let l = "valid";
    for (const c of e.validator(t, a)) c.explanation = n.message, l = "not_valid", yield [c, void 0];
    for (let [c, u, f] of e.entries(t, a)) {
        const h = aB(u, f, {
            path: c === void 0 ? r : [...r, c],
            branch: c === void 0 ? i : [...i, u],
            coerce: s,
            mask: o,
            message: n.message
        });
        for (const g of h) g[0] ? (l = g[0].refinement != null ? "not_refined" : "not_valid", yield [g[0], void 0]) : s && (u = g[1], c === void 0 ? t = u : t instanceof Map ? t.set(c, u) : t instanceof Set ? t.add(u) : Cc(t) && (u !== void 0 || c in t) && (t[c] = u))
    }
    if (l !== "not_valid")
        for (const c of e.refiner(t, a)) c.explanation = n.message, l = "not_refined", yield [c, void 0];
    l === "valid" && (yield [void 0, t])
}
class ds {
    constructor(e) {
        const {
            type: n,
            schema: r,
            validator: i,
            refiner: s,
            coercer: o = l => l,
            entries: a = function*() {}
        } = e;
        this.type = n, this.schema = r, this.entries = a, this.coercer = o, i ? this.validator = (l, c) => {
            const u = i(l, c);
            return mM(u, c, this, l)
        } : this.validator = () => [], s ? this.refiner = (l, c) => {
            const u = s(l, c);
            return mM(u, c, this, l)
        } : this.refiner = () => []
    }
    assert(e, n) {
        return aoe(e, this, n)
    }
    create(e, n) {
        return loe(e, this, n)
    }
    is(e) {
        return lB(e, this)
    }
    mask(e, n) {
        return coe(e, this, n)
    }
    validate(e, n = {}) {
        return H2(e, this, n)
    }
}

function aoe(t, e, n) {
    const r = H2(t, e, {
        message: n
    });
    if (r[0]) throw r[0]
}

function loe(t, e, n) {
    const r = H2(t, e, {
        coerce: !0,
        message: n
    });
    if (r[0]) throw r[0];
    return r[1]
}

function coe(t, e, n) {
    const r = H2(t, e, {
        coerce: !0,
        mask: !0,
        message: n
    });
    if (r[0]) throw r[0];
    return r[1]
}

function lB(t, e) {
    return !H2(t, e)[0]
}

function H2(t, e, n = {}) {
    const r = aB(t, e, n),
        i = LBe(r);
    return i[0] ? [new ooe(i[0], function*() {
        for (const o of r) o[0] && (yield o[0])
    }), void 0] : [void 0, i[1]]
}

function FBe(...t) {
    const e = t[0].type === "type",
        n = t.map(i => i.schema),
        r = Object.assign({}, ...n);
    return e ? qE(r) : GE(r)
}

function Xa(t, e) {
    return new ds({
        type: t,
        schema: null,
        validator: e
    })
}

function UBe(t, e) {
    return new ds({ ...t,
        refiner: (n, r) => n === void 0 || t.refiner(n, r),
        validator(n, r) {
            return n === void 0 ? !0 : (e(n, r), t.validator(n, r))
        }
    })
}

function jBe(t) {
    return new ds({
        type: "dynamic",
        schema: null,
        * entries(e, n) {
            yield* t(e, n).entries(e, n)
        },
        validator(e, n) {
            return t(e, n).validator(e, n)
        },
        coercer(e, n) {
            return t(e, n).coercer(e, n)
        },
        refiner(e, n) {
            return t(e, n).refiner(e, n)
        }
    })
}

function HBe(t) {
    let e;
    return new ds({
        type: "lazy",
        schema: null,
        * entries(n, r) {
            e ? ? (e = t()), yield* e.entries(n, r)
        },
        validator(n, r) {
            return e ? ? (e = t()), e.validator(n, r)
        },
        coercer(n, r) {
            return e ? ? (e = t()), e.coercer(n, r)
        },
        refiner(n, r) {
            return e ? ? (e = t()), e.refiner(n, r)
        }
    })
}

function zBe(t, e) {
    const {
        schema: n
    } = t, r = { ...n
    };
    for (const i of e) delete r[i];
    switch (t.type) {
        case "type":
            return qE(r);
        default:
            return GE(r)
    }
}

function WBe(t) {
    const e = t instanceof ds,
        n = e ? { ...t.schema
        } : { ...t
        };
    for (const r in n) n[r] = uoe(n[r]);
    return e && t.type === "type" ? qE(n) : GE(n)
}

function VBe(t, e) {
    const {
        schema: n
    } = t, r = {};
    for (const i of e) r[i] = n[i];
    switch (t.type) {
        case "type":
            return qE(r);
        default:
            return GE(r)
    }
}

function GBe(t, e) {
    return console.warn("superstruct@0.11 - The `struct` helper has been renamed to `define`."), Xa(t, e)
}

function qBe() {
    return Xa("any", () => !0)
}

function KBe(t) {
    return new ds({
        type: "array",
        schema: t,
        * entries(e) {
            if (t && Array.isArray(e))
                for (const [n, r] of e.entries()) yield [n, r, t]
        },
        coercer(e) {
            return Array.isArray(e) ? e.slice() : e
        },
        validator(e) {
            return Array.isArray(e) || `Expected an array value, but received: ${ks(e)}`
        }
    })
}

function YBe() {
    return Xa("bigint", t => typeof t == "bigint")
}

function ZBe() {
    return Xa("boolean", t => typeof t == "boolean")
}

function QBe() {
    return Xa("date", t => t instanceof Date && !isNaN(t.getTime()) || `Expected a valid \`Date\` object, but received: ${ks(t)}`)
}

function JBe(t) {
    const e = {},
        n = t.map(r => ks(r)).join();
    for (const r of t) e[r] = r;
    return new ds({
        type: "enums",
        schema: e,
        validator(r) {
            return t.includes(r) || `Expected one of \`${n}\`, but received: ${ks(r)}`
        }
    })
}

function XBe() {
    return Xa("func", t => typeof t == "function" || `Expected a function, but received: ${ks(t)}`)
}

function eFe(t) {
    return Xa("instance", e => e instanceof t || `Expected a \`${t.name}\` instance, but received: ${ks(e)}`)
}

function tFe() {
    return Xa("integer", t => typeof t == "number" && !isNaN(t) && Number.isInteger(t) || `Expected an integer, but received: ${ks(t)}`)
}

function nFe(t) {
    return new ds({
        type: "intersection",
        schema: null,
        * entries(e, n) {
            for (const r of t) yield* r.entries(e, n)
        },
        * validator(e, n) {
            for (const r of t) yield* r.validator(e, n)
        },
        * refiner(e, n) {
            for (const r of t) yield* r.refiner(e, n)
        }
    })
}

function rFe(t) {
    const e = ks(t),
        n = typeof t;
    return new ds({
        type: "literal",
        schema: n === "string" || n === "number" || n === "boolean" ? t : null,
        validator(r) {
            return r === t || `Expected the literal \`${e}\`, but received: ${ks(r)}`
        }
    })
}

function iFe(t, e) {
    return new ds({
        type: "map",
        schema: null,
        * entries(n) {
            if (t && e && n instanceof Map)
                for (const [r, i] of n.entries()) yield [r, r, t], yield [r, i, e]
        },
        coercer(n) {
            return n instanceof Map ? new Map(n) : n
        },
        validator(n) {
            return n instanceof Map || `Expected a \`Map\` object, but received: ${ks(n)}`
        }
    })
}

function cB() {
    return Xa("never", () => !1)
}

function sFe(t) {
    return new ds({ ...t,
        validator: (e, n) => e === null || t.validator(e, n),
        refiner: (e, n) => e === null || t.refiner(e, n)
    })
}

function oFe() {
    return Xa("number", t => typeof t == "number" && !isNaN(t) || `Expected a number, but received: ${ks(t)}`)
}

function GE(t) {
    const e = t ? Object.keys(t) : [],
        n = cB();
    return new ds({
        type: "object",
        schema: t || null,
        * entries(r) {
            if (t && Cc(r)) {
                const i = new Set(Object.keys(r));
                for (const s of e) i.delete(s), yield [s, r[s], t[s]];
                for (const s of i) yield [s, r[s], n]
            }
        },
        validator(r) {
            return Cc(r) || `Expected an object, but received: ${ks(r)}`
        },
        coercer(r) {
            return Cc(r) ? { ...r
            } : r
        }
    })
}

function uoe(t) {
    return new ds({ ...t,
        validator: (e, n) => e === void 0 || t.validator(e, n),
        refiner: (e, n) => e === void 0 || t.refiner(e, n)
    })
}

function aFe(t, e) {
    return new ds({
        type: "record",
        schema: null,
        * entries(n) {
            if (Cc(n))
                for (const r in n) {
                    const i = n[r];
                    yield [r, r, t], yield [r, i, e]
                }
        },
        validator(n) {
            return Cc(n) || `Expected an object, but received: ${ks(n)}`
        }
    })
}

function lFe() {
    return Xa("regexp", t => t instanceof RegExp)
}

function cFe(t) {
    return new ds({
        type: "set",
        schema: null,
        * entries(e) {
            if (t && e instanceof Set)
                for (const n of e) yield [n, n, t]
        },
        coercer(e) {
            return e instanceof Set ? new Set(e) : e
        },
        validator(e) {
            return e instanceof Set || `Expected a \`Set\` object, but received: ${ks(e)}`
        }
    })
}

function foe() {
    return Xa("string", t => typeof t == "string" || `Expected a string, but received: ${ks(t)}`)
}

function uFe(t) {
    const e = cB();
    return new ds({
        type: "tuple",
        schema: null,
        * entries(n) {
            if (Array.isArray(n)) {
                const r = Math.max(t.length, n.length);
                for (let i = 0; i < r; i++) yield [i, n[i], t[i] || e]
            }
        },
        validator(n) {
            return Array.isArray(n) || `Expected an array, but received: ${ks(n)}`
        }
    })
}

function qE(t) {
    const e = Object.keys(t);
    return new ds({
        type: "type",
        schema: t,
        * entries(n) {
            if (Cc(n))
                for (const r of e) yield [r, n[r], t[r]]
        },
        validator(n) {
            return Cc(n) || `Expected an object, but received: ${ks(n)}`
        },
        coercer(n) {
            return Cc(n) ? { ...n
            } : n
        }
    })
}

function fFe(t) {
    const e = t.map(n => n.type).join(" | ");
    return new ds({
        type: "union",
        schema: null,
        coercer(n) {
            for (const r of t) {
                const [i, s] = r.validate(n, {
                    coerce: !0
                });
                if (!i) return s
            }
            return n
        },
        validator(n, r) {
            const i = [];
            for (const s of t) {
                const [...o] = aB(n, s, r), [a] = o;
                if (a[0])
                    for (const [l] of o) l && i.push(l);
                else return []
            }
            return [`Expected the value to satisfy a union of \`${e}\`, but received: ${ks(n)}`, ...i]
        }
    })
}

function doe() {
    return Xa("unknown", () => !0)
}

function uB(t, e, n) {
    return new ds({ ...t,
        coercer: (r, i) => lB(r, e) ? t.coercer(n(r, i), i) : t.coercer(r, i)
    })
}

function dFe(t, e, n = {}) {
    return uB(t, doe(), r => {
        const i = typeof e == "function" ? e() : e;
        if (r === void 0) return i;
        if (!n.strict && vK(r) && vK(i)) {
            const s = { ...r
            };
            let o = !1;
            for (const a in i) s[a] === void 0 && (s[a] = i[a], o = !0);
            if (o) return s
        }
        return r
    })
}

function hFe(t) {
    return uB(t, foe(), e => e.trim())
}

function pFe(t) {
    return xy(t, "empty", e => {
        const n = hoe(e);
        return n === 0 || `Expected an empty ${t.type} but received one with a size of \`${n}\``
    })
}

function hoe(t) {
    return t instanceof Map || t instanceof Set ? t.size : t.length
}

function gFe(t, e, n = {}) {
    const {
        exclusive: r
    } = n;
    return xy(t, "max", i => r ? i < e : i <= e || `Expected a ${t.type} less than ${r?"":"or equal to "}${e} but received \`${i}\``)
}

function mFe(t, e, n = {}) {
    const {
        exclusive: r
    } = n;
    return xy(t, "min", i => r ? i > e : i >= e || `Expected a ${t.type} greater than ${r?"":"or equal to "}${e} but received \`${i}\``)
}

function yFe(t) {
    return xy(t, "nonempty", e => hoe(e) > 0 || `Expected a nonempty ${t.type} but received an empty one`)
}

function wFe(t, e) {
    return xy(t, "pattern", n => e.test(n) || `Expected a ${t.type} matching \`/${e.source}/\` but received "${n}"`)
}

function vFe(t, e, n = e) {
    const r = `Expected a ${t.type}`,
        i = e === n ? `of \`${e}\`` : `between \`${e}\` and \`${n}\``;
    return xy(t, "size", s => {
        if (typeof s == "number" || s instanceof Date) return e <= s && s <= n || `${r} ${i} but received \`${s}\``;
        if (s instanceof Map || s instanceof Set) {
            const {
                size: o
            } = s;
            return e <= o && o <= n || `${r} with a size ${i} but received one with a size of \`${o}\``
        } else {
            const {
                length: o
            } = s;
            return e <= o && o <= n || `${r} with a length ${i} but received one with a length of \`${o}\``
        }
    })
}

function xy(t, e, n) {
    return new ds({ ...t,
        * refiner(r, i) {
            yield* t.refiner(r, i);
            const s = n(r, i),
                o = mM(s, i, t, r);
            for (const a of o) yield { ...a,
                refinement: e
            }
        }
    })
}
const bFe = Object.freeze(Object.defineProperty({
        __proto__: null,
        Struct: ds,
        StructError: ooe,
        any: qBe,
        array: KBe,
        assert: aoe,
        assign: FBe,
        bigint: YBe,
        boolean: ZBe,
        coerce: uB,
        create: loe,
        date: QBe,
        defaulted: dFe,
        define: Xa,
        deprecated: UBe,
        dynamic: jBe,
        empty: pFe,
        enums: JBe,
        func: XBe,
        instance: eFe,
        integer: tFe,
        intersection: nFe,
        is: lB,
        lazy: HBe,
        literal: rFe,
        map: iFe,
        mask: coe,
        max: gFe,
        min: mFe,
        never: cB,
        nonempty: yFe,
        nullable: sFe,
        number: oFe,
        object: GE,
        omit: zBe,
        optional: uoe,
        partial: WBe,
        pattern: wFe,
        pick: VBe,
        record: aFe,
        refine: xy,
        regexp: lFe,
        set: cFe,
        size: vFe,
        string: foe,
        struct: GBe,
        trimmed: hFe,
        tuple: uFe,
        type: qE,
        union: fFe,
        unknown: doe,
        validate: H2
    }, Symbol.toStringTag, {
        value: "Module"
    })),
    Sy = Fu(bFe);
Object.defineProperty(oo, "__esModule", {
    value: !0
});
oo.assertExhaustive = oo.assertStruct = oo.assert = oo.AssertionError = void 0;
const _Fe = Sy;

function EFe(t) {
    return typeof t == "object" && t !== null && "message" in t
}

function xFe(t) {
    var e, n;
    return typeof((n = (e = t == null ? void 0 : t.prototype) === null || e === void 0 ? void 0 : e.constructor) === null || n === void 0 ? void 0 : n.name) == "string"
}

function SFe(t) {
    const e = EFe(t) ? t.message : String(t);
    return e.endsWith(".") ? e.slice(0, -1) : e
}

function poe(t, e) {
    return xFe(t) ? new t({
        message: e
    }) : t({
        message: e
    })
}
class fB extends Error {
    constructor(e) {
        super(e.message), this.code = "ERR_ASSERTION"
    }
}
oo.AssertionError = fB;

function CFe(t, e = "Assertion failed.", n = fB) {
    if (!t) throw e instanceof Error ? e : poe(n, e)
}
oo.assert = CFe;

function AFe(t, e, n = "Assertion failed", r = fB) {
    try {
        (0, _Fe.assert)(t, e)
    } catch (i) {
        throw poe(r, `${n}: ${SFe(i)}.`)
    }
}
oo.assertStruct = AFe;

function TFe(t) {
    throw new Error("Invalid branch reached. Should be detected during compilation.")
}
oo.assertExhaustive = TFe;
var KE = {};
Object.defineProperty(KE, "__esModule", {
    value: !0
});
KE.base64 = void 0;
const IFe = Sy,
    RFe = oo,
    OFe = (t, e = {}) => {
        var n, r;
        const i = (n = e.paddingRequired) !== null && n !== void 0 ? n : !1,
            s = (r = e.characterSet) !== null && r !== void 0 ? r : "base64";
        let o;
        s === "base64" ? o = String.raw `[A-Za-z0-9+\/]` : ((0, RFe.assert)(s === "base64url"), o = String.raw `[-_A-Za-z0-9]`);
        let a;
        return i ? a = new RegExp(`^(?:${o}{4})*(?:${o}{3}=|${o}{2}==)?$`, "u") : a = new RegExp(`^(?:${o}{4})*(?:${o}{2,3}|${o}{3}=|${o}{2}==)?$`, "u"), (0, IFe.pattern)(t, a)
    };
KE.base64 = OFe;
var cr = {},
    YE = {};
(function(t) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    }), t.remove0x = t.add0x = t.assertIsStrictHexString = t.assertIsHexString = t.isStrictHexString = t.isHexString = t.StrictHexStruct = t.HexStruct = void 0;
    const e = Sy,
        n = oo;
    t.HexStruct = (0, e.pattern)((0, e.string)(), /^(?:0x)?[0-9a-f]+$/iu), t.StrictHexStruct = (0, e.pattern)((0, e.string)(), /^0x[0-9a-f]+$/iu);

    function r(c) {
        return (0, e.is)(c, t.HexStruct)
    }
    t.isHexString = r;

    function i(c) {
        return (0, e.is)(c, t.StrictHexStruct)
    }
    t.isStrictHexString = i;

    function s(c) {
        (0, n.assert)(r(c), "Value must be a hexadecimal string.")
    }
    t.assertIsHexString = s;

    function o(c) {
        (0, n.assert)(i(c), 'Value must be a hexadecimal string, starting with "0x".')
    }
    t.assertIsStrictHexString = o;

    function a(c) {
        return c.startsWith("0x") ? c : c.startsWith("0X") ? `0x${c.substring(2)}` : `0x${c}`
    }
    t.add0x = a;

    function l(c) {
        return c.startsWith("0x") || c.startsWith("0X") ? c.substring(2) : c
    }
    t.remove0x = l
})(YE);
Object.defineProperty(cr, "__esModule", {
    value: !0
});
cr.createDataView = cr.concatBytes = cr.valueToBytes = cr.stringToBytes = cr.numberToBytes = cr.signedBigIntToBytes = cr.bigIntToBytes = cr.hexToBytes = cr.bytesToString = cr.bytesToNumber = cr.bytesToSignedBigInt = cr.bytesToBigInt = cr.bytesToHex = cr.assertIsBytes = cr.isBytes = void 0;
const xl = oo,
    yM = YE,
    bK = 48,
    _K = 58,
    EK = 87;

function NFe() {
    const t = [];
    return () => {
        if (t.length === 0)
            for (let e = 0; e < 256; e++) t.push(e.toString(16).padStart(2, "0"));
        return t
    }
}
const PFe = NFe();

function dB(t) {
    return t instanceof Uint8Array
}
cr.isBytes = dB;

function z2(t) {
    (0, xl.assert)(dB(t), "Value must be a Uint8Array.")
}
cr.assertIsBytes = z2;

function goe(t) {
    if (z2(t), t.length === 0) return "0x";
    const e = PFe(),
        n = new Array(t.length);
    for (let r = 0; r < t.length; r++) n[r] = e[t[r]];
    return (0, yM.add0x)(n.join(""))
}
cr.bytesToHex = goe;

function moe(t) {
    z2(t);
    const e = goe(t);
    return BigInt(e)
}
cr.bytesToBigInt = moe;

function kFe(t) {
    z2(t);
    let e = BigInt(0);
    for (const n of t) e = (e << BigInt(8)) + BigInt(n);
    return BigInt.asIntN(t.length * 8, e)
}
cr.bytesToSignedBigInt = kFe;

function MFe(t) {
    z2(t);
    const e = moe(t);
    return (0, xl.assert)(e <= BigInt(Number.MAX_SAFE_INTEGER), "Number is not a safe integer. Use `bytesToBigInt` instead."), Number(e)
}
cr.bytesToNumber = MFe;

function DFe(t) {
    return z2(t), new TextDecoder().decode(t)
}
cr.bytesToString = DFe;

function x9(t) {
    var e;
    if (((e = t == null ? void 0 : t.toLowerCase) === null || e === void 0 ? void 0 : e.call(t)) === "0x") return new Uint8Array;
    (0, yM.assertIsHexString)(t);
    const n = (0, yM.remove0x)(t).toLowerCase(),
        r = n.length % 2 === 0 ? n : `0${n}`,
        i = new Uint8Array(r.length / 2);
    for (let s = 0; s < i.length; s++) {
        const o = r.charCodeAt(s * 2),
            a = r.charCodeAt(s * 2 + 1),
            l = o - (o < _K ? bK : EK),
            c = a - (a < _K ? bK : EK);
        i[s] = l * 16 + c
    }
    return i
}
cr.hexToBytes = x9;

function yoe(t) {
    (0, xl.assert)(typeof t == "bigint", "Value must be a bigint."), (0, xl.assert)(t >= BigInt(0), "Value must be a non-negative bigint.");
    const e = t.toString(16);
    return x9(e)
}
cr.bigIntToBytes = yoe;

function $Fe(t, e) {
    (0, xl.assert)(e > 0);
    const n = t >> BigInt(31);
    return !((~t & n) + (t & ~n) >> BigInt(e * 8 + -1))
}

function LFe(t, e) {
    (0, xl.assert)(typeof t == "bigint", "Value must be a bigint."), (0, xl.assert)(typeof e == "number", "Byte length must be a number."), (0, xl.assert)(e > 0, "Byte length must be greater than 0."), (0, xl.assert)($Fe(t, e), "Byte length is too small to represent the given value.");
    let n = t;
    const r = new Uint8Array(e);
    for (let i = 0; i < r.length; i++) r[i] = Number(BigInt.asUintN(8, n)), n >>= BigInt(8);
    return r.reverse()
}
cr.signedBigIntToBytes = LFe;

function woe(t) {
    (0, xl.assert)(typeof t == "number", "Value must be a number."), (0, xl.assert)(t >= 0, "Value must be a non-negative number."), (0, xl.assert)(Number.isSafeInteger(t), "Value is not a safe integer. Use `bigIntToBytes` instead.");
    const e = t.toString(16);
    return x9(e)
}
cr.numberToBytes = woe;

function voe(t) {
    return (0, xl.assert)(typeof t == "string", "Value must be a string."), new TextEncoder().encode(t)
}
cr.stringToBytes = voe;

function boe(t) {
    if (typeof t == "bigint") return yoe(t);
    if (typeof t == "number") return woe(t);
    if (typeof t == "string") return t.startsWith("0x") ? x9(t) : voe(t);
    if (dB(t)) return t;
    throw new TypeError(`Unsupported value type: "${typeof t}".`)
}
cr.valueToBytes = boe;

function BFe(t) {
    const e = new Array(t.length);
    let n = 0;
    for (let i = 0; i < t.length; i++) {
        const s = boe(t[i]);
        e[i] = s, n += s.length
    }
    const r = new Uint8Array(n);
    for (let i = 0, s = 0; i < e.length; i++) r.set(e[i], s), s += e[i].length;
    return r
}
cr.concatBytes = BFe;

function FFe(t) {
    if (typeof Buffer < "u" && t instanceof Buffer) {
        const e = t.buffer.slice(t.byteOffset, t.byteOffset + t.byteLength);
        return new DataView(e)
    }
    return new DataView(t.buffer, t.byteOffset, t.byteLength)
}
cr.createDataView = FFe;
var S9 = {};
Object.defineProperty(S9, "__esModule", {
    value: !0
});
S9.ChecksumStruct = void 0;
const xK = Sy,
    UFe = KE;
S9.ChecksumStruct = (0, xK.size)((0, UFe.base64)((0, xK.string)(), {
    paddingRequired: !0
}), 44, 44);
var Ff = {};
Object.defineProperty(Ff, "__esModule", {
    value: !0
});
Ff.createHex = Ff.createBytes = Ff.createBigInt = Ff.createNumber = void 0;
const Oi = Sy,
    jFe = oo,
    _oe = cr,
    C9 = YE,
    Eoe = (0, Oi.union)([(0, Oi.number)(), (0, Oi.bigint)(), (0, Oi.string)(), C9.StrictHexStruct]),
    HFe = (0, Oi.coerce)((0, Oi.number)(), Eoe, Number),
    zFe = (0, Oi.coerce)((0, Oi.bigint)(), Eoe, BigInt);
(0, Oi.union)([C9.StrictHexStruct, (0, Oi.instance)(Uint8Array)]);
const WFe = (0, Oi.coerce)((0, Oi.instance)(Uint8Array), (0, Oi.union)([C9.StrictHexStruct]), _oe.hexToBytes),
    VFe = (0, Oi.coerce)(C9.StrictHexStruct, (0, Oi.instance)(Uint8Array), _oe.bytesToHex);

function GFe(t) {
    try {
        const e = (0, Oi.create)(t, HFe);
        return (0, jFe.assert)(Number.isFinite(e), `Expected a number-like value, got "${t}".`), e
    } catch (e) {
        throw e instanceof Oi.StructError ? new Error(`Expected a number-like value, got "${t}".`) : e
    }
}
Ff.createNumber = GFe;

function qFe(t) {
    try {
        return (0, Oi.create)(t, zFe)
    } catch (e) {
        throw e instanceof Oi.StructError ? new Error(`Expected a number-like value, got "${String(e.value)}".`) : e
    }
}
Ff.createBigInt = qFe;

function KFe(t) {
    if (typeof t == "string" && t.toLowerCase() === "0x") return new Uint8Array;
    try {
        return (0, Oi.create)(t, WFe)
    } catch (e) {
        throw e instanceof Oi.StructError ? new Error(`Expected a bytes-like value, got "${String(e.value)}".`) : e
    }
}
Ff.createBytes = KFe;

function YFe(t) {
    if (t instanceof Uint8Array && t.length === 0 || typeof t == "string" && t.toLowerCase() === "0x") return "0x";
    try {
        return (0, Oi.create)(t, VFe)
    } catch (e) {
        throw e instanceof Oi.StructError ? new Error(`Expected a bytes-like value, got "${String(e.value)}".`) : e
    }
}
Ff.createHex = YFe;
var i2 = {},
    xoe = st && st.__classPrivateFieldSet || function(t, e, n, r, i) {
        if (r === "m") throw new TypeError("Private method is not writable");
        if (r === "a" && !i) throw new TypeError("Private accessor was defined without a setter");
        if (typeof e == "function" ? t !== e || !i : !e.has(t)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
        return r === "a" ? i.call(t, n) : i ? i.value = n : e.set(t, n), n
    },
    ta = st && st.__classPrivateFieldGet || function(t, e, n, r) {
        if (n === "a" && !r) throw new TypeError("Private accessor was defined without a getter");
        if (typeof e == "function" ? t !== e || !r : !e.has(t)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
        return n === "m" ? r : n === "a" ? r.call(t) : r ? r.value : e.get(t)
    },
    Gc, af;
Object.defineProperty(i2, "__esModule", {
    value: !0
});
i2.FrozenSet = i2.FrozenMap = void 0;
class hB {
    constructor(e) {
        Gc.set(this, void 0), xoe(this, Gc, new Map(e), "f"), Object.freeze(this)
    }
    get size() {
        return ta(this, Gc, "f").size
    }[(Gc = new WeakMap, Symbol.iterator)]() {
        return ta(this, Gc, "f")[Symbol.iterator]()
    }
    entries() {
        return ta(this, Gc, "f").entries()
    }
    forEach(e, n) {
        return ta(this, Gc, "f").forEach((r, i, s) => e.call(n, r, i, this))
    }
    get(e) {
        return ta(this, Gc, "f").get(e)
    }
    has(e) {
        return ta(this, Gc, "f").has(e)
    }
    keys() {
        return ta(this, Gc, "f").keys()
    }
    values() {
        return ta(this, Gc, "f").values()
    }
    toString() {
        return `FrozenMap(${this.size}) {${this.size>0?` ${[...this.entries()].map(([e,n])=>`${String(e)} => ${String(n)}`).join(", ")} `:""}}`
    }
}
i2.FrozenMap = hB;
class pB {
    constructor(e) {
        af.set(this, void 0), xoe(this, af, new Set(e), "f"), Object.freeze(this)
    }
    get size() {
        return ta(this, af, "f").size
    }[(af = new WeakMap, Symbol.iterator)]() {
        return ta(this, af, "f")[Symbol.iterator]()
    }
    entries() {
        return ta(this, af, "f").entries()
    }
    forEach(e, n) {
        return ta(this, af, "f").forEach((r, i, s) => e.call(n, r, i, this))
    }
    has(e) {
        return ta(this, af, "f").has(e)
    }
    keys() {
        return ta(this, af, "f").keys()
    }
    values() {
        return ta(this, af, "f").values()
    }
    toString() {
        return `FrozenSet(${this.size}) {${this.size>0?` ${[...this.values()].map(e=>String(e)).join(", ")} `:""}}`
    }
}
i2.FrozenSet = pB;
Object.freeze(hB);
Object.freeze(hB.prototype);
Object.freeze(pB);
Object.freeze(pB.prototype);
var Soe = {},
    gB = {};
(function(t) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    }), t.calculateNumberSize = t.calculateStringSize = t.isASCII = t.isPlainObject = t.ESCAPE_CHARACTERS_REGEXP = t.JsonSize = t.hasProperty = t.isObject = t.isNullOrUndefined = t.isNonEmptyArray = void 0;

    function e(c) {
        return Array.isArray(c) && c.length > 0
    }
    t.isNonEmptyArray = e;

    function n(c) {
        return c == null
    }
    t.isNullOrUndefined = n;

    function r(c) {
        return !!c && typeof c == "object" && !Array.isArray(c)
    }
    t.isObject = r;
    const i = (c, u) => Object.hasOwnProperty.call(c, u);
    t.hasProperty = i,
        function(c) {
            c[c.Null = 4] = "Null", c[c.Comma = 1] = "Comma", c[c.Wrapper = 1] = "Wrapper", c[c.True = 4] = "True", c[c.False = 5] = "False", c[c.Quote = 1] = "Quote", c[c.Colon = 1] = "Colon", c[c.Date = 24] = "Date"
        }(t.JsonSize || (t.JsonSize = {})), t.ESCAPE_CHARACTERS_REGEXP = /"|\\|\n|\r|\t/gu;

    function s(c) {
        if (typeof c != "object" || c === null) return !1;
        try {
            let u = c;
            for (; Object.getPrototypeOf(u) !== null;) u = Object.getPrototypeOf(u);
            return Object.getPrototypeOf(c) === u
        } catch {
            return !1
        }
    }
    t.isPlainObject = s;

    function o(c) {
        return c.charCodeAt(0) <= 127
    }
    t.isASCII = o;

    function a(c) {
        var u;
        return c.split("").reduce((h, g) => o(g) ? h + 1 : h + 2, 0) + ((u = c.match(t.ESCAPE_CHARACTERS_REGEXP)) !== null && u !== void 0 ? u : []).length
    }
    t.calculateStringSize = a;

    function l(c) {
        return c.toString().length
    }
    t.calculateNumberSize = l
})(gB);
(function(t) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    }), t.validateJsonAndGetSize = t.getJsonRpcIdValidator = t.assertIsJsonRpcError = t.isJsonRpcError = t.assertIsJsonRpcFailure = t.isJsonRpcFailure = t.assertIsJsonRpcSuccess = t.isJsonRpcSuccess = t.assertIsJsonRpcResponse = t.isJsonRpcResponse = t.assertIsPendingJsonRpcResponse = t.isPendingJsonRpcResponse = t.JsonRpcResponseStruct = t.JsonRpcFailureStruct = t.JsonRpcSuccessStruct = t.PendingJsonRpcResponseStruct = t.assertIsJsonRpcRequest = t.isJsonRpcRequest = t.assertIsJsonRpcNotification = t.isJsonRpcNotification = t.JsonRpcNotificationStruct = t.JsonRpcRequestStruct = t.JsonRpcParamsStruct = t.JsonRpcErrorStruct = t.JsonRpcIdStruct = t.JsonRpcVersionStruct = t.jsonrpc2 = t.isValidJson = t.JsonStruct = void 0;
    const e = Sy,
        n = oo,
        r = gB;
    t.JsonStruct = (0, e.define)("Json", P => {
        const [M] = I(P, !0);
        return M ? !0 : "Expected a valid JSON-serializable value"
    });

    function i(P) {
        return (0, e.is)(P, t.JsonStruct)
    }
    t.isValidJson = i, t.jsonrpc2 = "2.0", t.JsonRpcVersionStruct = (0, e.literal)(t.jsonrpc2), t.JsonRpcIdStruct = (0, e.nullable)((0, e.union)([(0, e.number)(), (0, e.string)()])), t.JsonRpcErrorStruct = (0, e.object)({
        code: (0, e.integer)(),
        message: (0, e.string)(),
        data: (0, e.optional)(t.JsonStruct),
        stack: (0, e.optional)((0, e.string)())
    }), t.JsonRpcParamsStruct = (0, e.optional)((0, e.union)([(0, e.record)((0, e.string)(), t.JsonStruct), (0, e.array)(t.JsonStruct)])), t.JsonRpcRequestStruct = (0, e.object)({
        id: t.JsonRpcIdStruct,
        jsonrpc: t.JsonRpcVersionStruct,
        method: (0, e.string)(),
        params: t.JsonRpcParamsStruct
    }), t.JsonRpcNotificationStruct = (0, e.omit)(t.JsonRpcRequestStruct, ["id"]);

    function s(P) {
        return (0, e.is)(P, t.JsonRpcNotificationStruct)
    }
    t.isJsonRpcNotification = s;

    function o(P, M) {
        (0, n.assertStruct)(P, t.JsonRpcNotificationStruct, "Invalid JSON-RPC notification", M)
    }
    t.assertIsJsonRpcNotification = o;

    function a(P) {
        return (0, e.is)(P, t.JsonRpcRequestStruct)
    }
    t.isJsonRpcRequest = a;

    function l(P, M) {
        (0, n.assertStruct)(P, t.JsonRpcRequestStruct, "Invalid JSON-RPC request", M)
    }
    t.assertIsJsonRpcRequest = l, t.PendingJsonRpcResponseStruct = (0, e.object)({
        id: t.JsonRpcIdStruct,
        jsonrpc: t.JsonRpcVersionStruct,
        result: (0, e.optional)((0, e.unknown)()),
        error: (0, e.optional)(t.JsonRpcErrorStruct)
    }), t.JsonRpcSuccessStruct = (0, e.object)({
        id: t.JsonRpcIdStruct,
        jsonrpc: t.JsonRpcVersionStruct,
        result: t.JsonStruct
    }), t.JsonRpcFailureStruct = (0, e.object)({
        id: t.JsonRpcIdStruct,
        jsonrpc: t.JsonRpcVersionStruct,
        error: t.JsonRpcErrorStruct
    }), t.JsonRpcResponseStruct = (0, e.union)([t.JsonRpcSuccessStruct, t.JsonRpcFailureStruct]);

    function c(P) {
        return (0, e.is)(P, t.PendingJsonRpcResponseStruct)
    }
    t.isPendingJsonRpcResponse = c;

    function u(P, M) {
        (0, n.assertStruct)(P, t.PendingJsonRpcResponseStruct, "Invalid pending JSON-RPC response", M)
    }
    t.assertIsPendingJsonRpcResponse = u;

    function f(P) {
        return (0, e.is)(P, t.JsonRpcResponseStruct)
    }
    t.isJsonRpcResponse = f;

    function h(P, M) {
        (0, n.assertStruct)(P, t.JsonRpcResponseStruct, "Invalid JSON-RPC response", M)
    }
    t.assertIsJsonRpcResponse = h;

    function g(P) {
        return (0, e.is)(P, t.JsonRpcSuccessStruct)
    }
    t.isJsonRpcSuccess = g;

    function y(P, M) {
        (0, n.assertStruct)(P, t.JsonRpcSuccessStruct, "Invalid JSON-RPC success response", M)
    }
    t.assertIsJsonRpcSuccess = y;

    function _(P) {
        return (0, e.is)(P, t.JsonRpcFailureStruct)
    }
    t.isJsonRpcFailure = _;

    function C(P, M) {
        (0, n.assertStruct)(P, t.JsonRpcFailureStruct, "Invalid JSON-RPC failure response", M)
    }
    t.assertIsJsonRpcFailure = C;

    function b(P) {
        return (0, e.is)(P, t.JsonRpcErrorStruct)
    }
    t.isJsonRpcError = b;

    function w(P, M) {
        (0, n.assertStruct)(P, t.JsonRpcErrorStruct, "Invalid JSON-RPC error", M)
    }
    t.assertIsJsonRpcError = w;

    function S(P) {
        const {
            permitEmptyString: M,
            permitFractions: A,
            permitNull: E
        } = Object.assign({
            permitEmptyString: !0,
            permitFractions: !1,
            permitNull: !0
        }, P);
        return H => !!(typeof H == "number" && (A || Number.isInteger(H)) || typeof H == "string" && (M || H.length > 0) || E && H === null)
    }
    t.getJsonRpcIdValidator = S;

    function I(P, M = !1) {
        const A = new Set;

        function E($, H) {
            if ($ === void 0) return [!1, 0];
            if ($ === null) return [!0, H ? 0 : r.JsonSize.Null];
            const K = typeof $;
            try {
                if (K === "function") return [!1, 0];
                if (K === "string" || $ instanceof String) return [!0, H ? 0 : (0, r.calculateStringSize)($) + r.JsonSize.Quote * 2];
                if (K === "boolean" || $ instanceof Boolean) return H ? [!0, 0] : [!0, $ == !0 ? r.JsonSize.True : r.JsonSize.False];
                if (K === "number" || $ instanceof Number) return H ? [!0, 0] : [!0, (0, r.calculateNumberSize)($)];
                if ($ instanceof Date) return H ? [!0, 0] : [!0, isNaN($.getDate()) ? r.JsonSize.Null : r.JsonSize.Date + r.JsonSize.Quote * 2]
            } catch {
                return [!1, 0]
            }
            if (!(0, r.isPlainObject)($) && !Array.isArray($)) return [!1, 0];
            if (A.has($)) return [!1, 0];
            A.add($);
            try {
                return [!0, Object.entries($).reduce((te, [U, m], v, T) => {
                    let [N, O] = E(m, H);
                    if (!N) throw new Error("JSON validation did not pass. Validation process stopped.");
                    if (A.delete($), H) return 0;
                    const L = Array.isArray($) ? 0 : U.length + r.JsonSize.Comma + r.JsonSize.Colon * 2,
                        G = v < T.length - 1 ? r.JsonSize.Comma : 0;
                    return te + L + O + G
                }, H ? 0 : r.JsonSize.Wrapper * 2)]
            } catch {
                return [!1, 0]
            }
        }
        return E(P, M)
    }
    t.validateJsonAndGetSize = I
})(Soe);
var s2 = {},
    wM = {
        exports: {}
    },
    eN, SK;

function ZFe() {
    if (SK) return eN;
    SK = 1;
    var t = 1e3,
        e = t * 60,
        n = e * 60,
        r = n * 24,
        i = r * 7,
        s = r * 365.25;
    eN = function(u, f) {
        f = f || {};
        var h = typeof u;
        if (h === "string" && u.length > 0) return o(u);
        if (h === "number" && isFinite(u)) return f.long ? l(u) : a(u);
        throw new Error("val is not a non-empty string or a valid number. val=" + JSON.stringify(u))
    };

    function o(u) {
        if (u = String(u), !(u.length > 100)) {
            var f = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(u);
            if (f) {
                var h = parseFloat(f[1]),
                    g = (f[2] || "ms").toLowerCase();
                switch (g) {
                    case "years":
                    case "year":
                    case "yrs":
                    case "yr":
                    case "y":
                        return h * s;
                    case "weeks":
                    case "week":
                    case "w":
                        return h * i;
                    case "days":
                    case "day":
                    case "d":
                        return h * r;
                    case "hours":
                    case "hour":
                    case "hrs":
                    case "hr":
                    case "h":
                        return h * n;
                    case "minutes":
                    case "minute":
                    case "mins":
                    case "min":
                    case "m":
                        return h * e;
                    case "seconds":
                    case "second":
                    case "secs":
                    case "sec":
                    case "s":
                        return h * t;
                    case "milliseconds":
                    case "millisecond":
                    case "msecs":
                    case "msec":
                    case "ms":
                        return h;
                    default:
                        return
                }
            }
        }
    }

    function a(u) {
        var f = Math.abs(u);
        return f >= r ? Math.round(u / r) + "d" : f >= n ? Math.round(u / n) + "h" : f >= e ? Math.round(u / e) + "m" : f >= t ? Math.round(u / t) + "s" : u + "ms"
    }

    function l(u) {
        var f = Math.abs(u);
        return f >= r ? c(u, f, r, "day") : f >= n ? c(u, f, n, "hour") : f >= e ? c(u, f, e, "minute") : f >= t ? c(u, f, t, "second") : u + " ms"
    }

    function c(u, f, h, g) {
        var y = f >= h * 1.5;
        return Math.round(u / h) + " " + g + (y ? "s" : "")
    }
    return eN
}

function QFe(t) {
    n.debug = n, n.default = n, n.coerce = l, n.disable = s, n.enable = i, n.enabled = o, n.humanize = ZFe(), n.destroy = c, Object.keys(t).forEach(u => {
        n[u] = t[u]
    }), n.names = [], n.skips = [], n.formatters = {};

    function e(u) {
        let f = 0;
        for (let h = 0; h < u.length; h++) f = (f << 5) - f + u.charCodeAt(h), f |= 0;
        return n.colors[Math.abs(f) % n.colors.length]
    }
    n.selectColor = e;

    function n(u) {
        let f, h = null,
            g, y;

        function _(...C) {
            if (!_.enabled) return;
            const b = _,
                w = Number(new Date),
                S = w - (f || w);
            b.diff = S, b.prev = f, b.curr = w, f = w, C[0] = n.coerce(C[0]), typeof C[0] != "string" && C.unshift("%O");
            let I = 0;
            C[0] = C[0].replace(/%([a-zA-Z%])/g, (M, A) => {
                if (M === "%%") return "%";
                I++;
                const E = n.formatters[A];
                if (typeof E == "function") {
                    const $ = C[I];
                    M = E.call(b, $), C.splice(I, 1), I--
                }
                return M
            }), n.formatArgs.call(b, C), (b.log || n.log).apply(b, C)
        }
        return _.namespace = u, _.useColors = n.useColors(), _.color = n.selectColor(u), _.extend = r, _.destroy = n.destroy, Object.defineProperty(_, "enabled", {
            enumerable: !0,
            configurable: !1,
            get: () => h !== null ? h : (g !== n.namespaces && (g = n.namespaces, y = n.enabled(u)), y),
            set: C => {
                h = C
            }
        }), typeof n.init == "function" && n.init(_), _
    }

    function r(u, f) {
        const h = n(this.namespace + (typeof f > "u" ? ":" : f) + u);
        return h.log = this.log, h
    }

    function i(u) {
        n.save(u), n.namespaces = u, n.names = [], n.skips = [];
        let f;
        const h = (typeof u == "string" ? u : "").split(/[\s,]+/),
            g = h.length;
        for (f = 0; f < g; f++) h[f] && (u = h[f].replace(/\*/g, ".*?"), u[0] === "-" ? n.skips.push(new RegExp("^" + u.slice(1) + "$")) : n.names.push(new RegExp("^" + u + "$")))
    }

    function s() {
        const u = [...n.names.map(a), ...n.skips.map(a).map(f => "-" + f)].join(",");
        return n.enable(""), u
    }

    function o(u) {
        if (u[u.length - 1] === "*") return !0;
        let f, h;
        for (f = 0, h = n.skips.length; f < h; f++)
            if (n.skips[f].test(u)) return !1;
        for (f = 0, h = n.names.length; f < h; f++)
            if (n.names[f].test(u)) return !0;
        return !1
    }

    function a(u) {
        return u.toString().substring(2, u.toString().length - 2).replace(/\.\*\?$/, "*")
    }

    function l(u) {
        return u instanceof Error ? u.stack || u.message : u
    }

    function c() {
        console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.")
    }
    return n.enable(n.load()), n
}
var JFe = QFe;
(function(t, e) {
    var n = {};
    e.formatArgs = i, e.save = s, e.load = o, e.useColors = r, e.storage = a(), e.destroy = (() => {
        let c = !1;
        return () => {
            c || (c = !0, console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."))
        }
    })(), e.colors = ["#0000CC", "#0000FF", "#0033CC", "#0033FF", "#0066CC", "#0066FF", "#0099CC", "#0099FF", "#00CC00", "#00CC33", "#00CC66", "#00CC99", "#00CCCC", "#00CCFF", "#3300CC", "#3300FF", "#3333CC", "#3333FF", "#3366CC", "#3366FF", "#3399CC", "#3399FF", "#33CC00", "#33CC33", "#33CC66", "#33CC99", "#33CCCC", "#33CCFF", "#6600CC", "#6600FF", "#6633CC", "#6633FF", "#66CC00", "#66CC33", "#9900CC", "#9900FF", "#9933CC", "#9933FF", "#99CC00", "#99CC33", "#CC0000", "#CC0033", "#CC0066", "#CC0099", "#CC00CC", "#CC00FF", "#CC3300", "#CC3333", "#CC3366", "#CC3399", "#CC33CC", "#CC33FF", "#CC6600", "#CC6633", "#CC9900", "#CC9933", "#CCCC00", "#CCCC33", "#FF0000", "#FF0033", "#FF0066", "#FF0099", "#FF00CC", "#FF00FF", "#FF3300", "#FF3333", "#FF3366", "#FF3399", "#FF33CC", "#FF33FF", "#FF6600", "#FF6633", "#FF9900", "#FF9933", "#FFCC00", "#FFCC33"];

    function r() {
        if (typeof window < "u" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) return !0;
        if (typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) return !1;
        let c;
        return typeof document < "u" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || typeof window < "u" && window.console && (window.console.firebug || window.console.exception && window.console.table) || typeof navigator < "u" && navigator.userAgent && (c = navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)) && parseInt(c[1], 10) >= 31 || typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/)
    }

    function i(c) {
        if (c[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + c[0] + (this.useColors ? "%c " : " ") + "+" + t.exports.humanize(this.diff), !this.useColors) return;
        const u = "color: " + this.color;
        c.splice(1, 0, u, "color: inherit");
        let f = 0,
            h = 0;
        c[0].replace(/%[a-zA-Z%]/g, g => {
            g !== "%%" && (f++, g === "%c" && (h = f))
        }), c.splice(h, 0, u)
    }
    e.log = console.debug || console.log || (() => {});

    function s(c) {
        try {
            c ? e.storage.setItem("debug", c) : e.storage.removeItem("debug")
        } catch {}
    }

    function o() {
        let c;
        try {
            c = e.storage.getItem("debug")
        } catch {}
        return !c && typeof process < "u" && "env" in process && (c = n.DEBUG), c
    }

    function a() {
        try {
            return localStorage
        } catch {}
    }
    t.exports = JFe(e);
    const {
        formatters: l
    } = t.exports;
    l.j = function(c) {
        try {
            return JSON.stringify(c)
        } catch (u) {
            return "[UnexpectedJSONParseError]: " + u.message
        }
    }
})(wM, wM.exports);
var Coe = wM.exports;
const Ml = co(Coe);
var XFe = st && st.__importDefault || function(t) {
    return t && t.__esModule ? t : {
        default: t
    }
};
Object.defineProperty(s2, "__esModule", {
    value: !0
});
s2.createModuleLogger = s2.createProjectLogger = void 0;
const eUe = XFe(Coe),
    tUe = (0, eUe.default)("metamask");

function nUe(t) {
    return tUe.extend(t)
}
s2.createProjectLogger = nUe;

function rUe(t, e) {
    return t.extend(e)
}
s2.createModuleLogger = rUe;
var Uf = {};
Object.defineProperty(Uf, "__esModule", {
    value: !0
});
Uf.hexToBigInt = Uf.hexToNumber = Uf.bigIntToHex = Uf.numberToHex = void 0;
const fv = oo,
    l6 = YE,
    iUe = t => ((0, fv.assert)(typeof t == "number", "Value must be a number."), (0, fv.assert)(t >= 0, "Value must be a non-negative number."), (0, fv.assert)(Number.isSafeInteger(t), "Value is not a safe integer. Use `bigIntToHex` instead."), (0, l6.add0x)(t.toString(16)));
Uf.numberToHex = iUe;
const sUe = t => ((0, fv.assert)(typeof t == "bigint", "Value must be a bigint."), (0, fv.assert)(t >= 0, "Value must be a non-negative bigint."), (0, l6.add0x)(t.toString(16)));
Uf.bigIntToHex = sUe;
const oUe = t => {
    (0, l6.assertIsHexString)(t);
    const e = parseInt(t, 16);
    return (0, fv.assert)(Number.isSafeInteger(e), "Value is not a safe integer. Use `hexToBigInt` instead."), e
};
Uf.hexToNumber = oUe;
const aUe = t => ((0, l6.assertIsHexString)(t), BigInt((0, l6.add0x)(t)));
Uf.hexToBigInt = aUe;
var Aoe = {};
Object.defineProperty(Aoe, "__esModule", {
    value: !0
});
var Toe = {};
(function(t) {
    Object.defineProperty(t, "__esModule", {
            value: !0
        }), t.timeSince = t.inMilliseconds = t.Duration = void 0,
        function(s) {
            s[s.Millisecond = 1] = "Millisecond", s[s.Second = 1e3] = "Second", s[s.Minute = 6e4] = "Minute", s[s.Hour = 36e5] = "Hour", s[s.Day = 864e5] = "Day", s[s.Week = 6048e5] = "Week", s[s.Year = 31536e6] = "Year"
        }(t.Duration || (t.Duration = {}));
    const e = s => Number.isInteger(s) && s >= 0,
        n = (s, o) => {
            if (!e(s)) throw new Error(`"${o}" must be a non-negative integer. Received: "${s}".`)
        };

    function r(s, o) {
        return n(s, "count"), s * o
    }
    t.inMilliseconds = r;

    function i(s) {
        return n(s, "timestamp"), Date.now() - s
    }
    t.timeSince = i
})(Toe);
var Ioe = {},
    vM = {
        exports: {}
    };
const lUe = "2.0.0",
    Roe = 256,
    cUe = Number.MAX_SAFE_INTEGER || 9007199254740991,
    uUe = 16,
    fUe = Roe - 6,
    dUe = ["major", "premajor", "minor", "preminor", "patch", "prepatch", "prerelease"];
var A9 = {
        MAX_LENGTH: Roe,
        MAX_SAFE_COMPONENT_LENGTH: uUe,
        MAX_SAFE_BUILD_LENGTH: fUe,
        MAX_SAFE_INTEGER: cUe,
        RELEASE_TYPES: dUe,
        SEMVER_SPEC_VERSION: lUe,
        FLAG_INCLUDE_PRERELEASE: 1,
        FLAG_LOOSE: 2
    },
    tN = {};
const hUe = typeof process == "object" && tN && tN.NODE_DEBUG && /\bsemver\b/i.test(tN.NODE_DEBUG) ? (...t) => console.error("SEMVER", ...t) : () => {};
var T9 = hUe;
(function(t, e) {
    const {
        MAX_SAFE_COMPONENT_LENGTH: n,
        MAX_SAFE_BUILD_LENGTH: r,
        MAX_LENGTH: i
    } = A9, s = T9;
    e = t.exports = {};
    const o = e.re = [],
        a = e.safeRe = [],
        l = e.src = [],
        c = e.t = {};
    let u = 0;
    const f = "[a-zA-Z0-9-]",
        h = [
            ["\\s", 1],
            ["\\d", i],
            [f, r]
        ],
        g = _ => {
            for (const [C, b] of h) _ = _.split(`${C}*`).join(`${C}{0,${b}}`).split(`${C}+`).join(`${C}{1,${b}}`);
            return _
        },
        y = (_, C, b) => {
            const w = g(C),
                S = u++;
            s(_, S, C), c[_] = S, l[S] = C, o[S] = new RegExp(C, b ? "g" : void 0), a[S] = new RegExp(w, b ? "g" : void 0)
        };
    y("NUMERICIDENTIFIER", "0|[1-9]\\d*"), y("NUMERICIDENTIFIERLOOSE", "\\d+"), y("NONNUMERICIDENTIFIER", `\\d*[a-zA-Z-]${f}*`), y("MAINVERSION", `(${l[c.NUMERICIDENTIFIER]})\\.(${l[c.NUMERICIDENTIFIER]})\\.(${l[c.NUMERICIDENTIFIER]})`), y("MAINVERSIONLOOSE", `(${l[c.NUMERICIDENTIFIERLOOSE]})\\.(${l[c.NUMERICIDENTIFIERLOOSE]})\\.(${l[c.NUMERICIDENTIFIERLOOSE]})`), y("PRERELEASEIDENTIFIER", `(?:${l[c.NUMERICIDENTIFIER]}|${l[c.NONNUMERICIDENTIFIER]})`), y("PRERELEASEIDENTIFIERLOOSE", `(?:${l[c.NUMERICIDENTIFIERLOOSE]}|${l[c.NONNUMERICIDENTIFIER]})`), y("PRERELEASE", `(?:-(${l[c.PRERELEASEIDENTIFIER]}(?:\\.${l[c.PRERELEASEIDENTIFIER]})*))`), y("PRERELEASELOOSE", `(?:-?(${l[c.PRERELEASEIDENTIFIERLOOSE]}(?:\\.${l[c.PRERELEASEIDENTIFIERLOOSE]})*))`), y("BUILDIDENTIFIER", `${f}+`), y("BUILD", `(?:\\+(${l[c.BUILDIDENTIFIER]}(?:\\.${l[c.BUILDIDENTIFIER]})*))`), y("FULLPLAIN", `v?${l[c.MAINVERSION]}${l[c.PRERELEASE]}?${l[c.BUILD]}?`), y("FULL", `^${l[c.FULLPLAIN]}$`), y("LOOSEPLAIN", `[v=\\s]*${l[c.MAINVERSIONLOOSE]}${l[c.PRERELEASELOOSE]}?${l[c.BUILD]}?`), y("LOOSE", `^${l[c.LOOSEPLAIN]}$`), y("GTLT", "((?:<|>)?=?)"), y("XRANGEIDENTIFIERLOOSE", `${l[c.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`), y("XRANGEIDENTIFIER", `${l[c.NUMERICIDENTIFIER]}|x|X|\\*`), y("XRANGEPLAIN", `[v=\\s]*(${l[c.XRANGEIDENTIFIER]})(?:\\.(${l[c.XRANGEIDENTIFIER]})(?:\\.(${l[c.XRANGEIDENTIFIER]})(?:${l[c.PRERELEASE]})?${l[c.BUILD]}?)?)?`), y("XRANGEPLAINLOOSE", `[v=\\s]*(${l[c.XRANGEIDENTIFIERLOOSE]})(?:\\.(${l[c.XRANGEIDENTIFIERLOOSE]})(?:\\.(${l[c.XRANGEIDENTIFIERLOOSE]})(?:${l[c.PRERELEASELOOSE]})?${l[c.BUILD]}?)?)?`), y("XRANGE", `^${l[c.GTLT]}\\s*${l[c.XRANGEPLAIN]}$`), y("XRANGELOOSE", `^${l[c.GTLT]}\\s*${l[c.XRANGEPLAINLOOSE]}$`), y("COERCEPLAIN", `(^|[^\\d])(\\d{1,${n}})(?:\\.(\\d{1,${n}}))?(?:\\.(\\d{1,${n}}))?`), y("COERCE", `${l[c.COERCEPLAIN]}(?:$|[^\\d])`), y("COERCEFULL", l[c.COERCEPLAIN] + `(?:${l[c.PRERELEASE]})?(?:${l[c.BUILD]})?(?:$|[^\\d])`), y("COERCERTL", l[c.COERCE], !0), y("COERCERTLFULL", l[c.COERCEFULL], !0), y("LONETILDE", "(?:~>?)"), y("TILDETRIM", `(\\s*)${l[c.LONETILDE]}\\s+`, !0), e.tildeTrimReplace = "$1~", y("TILDE", `^${l[c.LONETILDE]}${l[c.XRANGEPLAIN]}$`), y("TILDELOOSE", `^${l[c.LONETILDE]}${l[c.XRANGEPLAINLOOSE]}$`), y("LONECARET", "(?:\\^)"), y("CARETTRIM", `(\\s*)${l[c.LONECARET]}\\s+`, !0), e.caretTrimReplace = "$1^", y("CARET", `^${l[c.LONECARET]}${l[c.XRANGEPLAIN]}$`), y("CARETLOOSE", `^${l[c.LONECARET]}${l[c.XRANGEPLAINLOOSE]}$`), y("COMPARATORLOOSE", `^${l[c.GTLT]}\\s*(${l[c.LOOSEPLAIN]})$|^$`), y("COMPARATOR", `^${l[c.GTLT]}\\s*(${l[c.FULLPLAIN]})$|^$`), y("COMPARATORTRIM", `(\\s*)${l[c.GTLT]}\\s*(${l[c.LOOSEPLAIN]}|${l[c.XRANGEPLAIN]})`, !0), e.comparatorTrimReplace = "$1$2$3", y("HYPHENRANGE", `^\\s*(${l[c.XRANGEPLAIN]})\\s+-\\s+(${l[c.XRANGEPLAIN]})\\s*$`), y("HYPHENRANGELOOSE", `^\\s*(${l[c.XRANGEPLAINLOOSE]})\\s+-\\s+(${l[c.XRANGEPLAINLOOSE]})\\s*$`), y("STAR", "(<|>)?=?\\s*\\*"), y("GTE0", "^\\s*>=\\s*0\\.0\\.0\\s*$"), y("GTE0PRE", "^\\s*>=\\s*0\\.0\\.0-0\\s*$")
})(vM, vM.exports);
var ZE = vM.exports;
const pUe = Object.freeze({
        loose: !0
    }),
    gUe = Object.freeze({}),
    mUe = t => t ? typeof t != "object" ? pUe : t : gUe;
var mB = mUe;
const CK = /^[0-9]+$/,
    Ooe = (t, e) => {
        const n = CK.test(t),
            r = CK.test(e);
        return n && r && (t = +t, e = +e), t === e ? 0 : n && !r ? -1 : r && !n ? 1 : t < e ? -1 : 1
    },
    yUe = (t, e) => Ooe(e, t);
var Noe = {
    compareIdentifiers: Ooe,
    rcompareIdentifiers: yUe
};
const iS = T9,
    {
        MAX_LENGTH: AK,
        MAX_SAFE_INTEGER: sS
    } = A9,
    {
        safeRe: TK,
        t: IK
    } = ZE,
    wUe = mB,
    {
        compareIdentifiers: aw
    } = Noe;
let vUe = class df {
    constructor(e, n) {
        if (n = wUe(n), e instanceof df) {
            if (e.loose === !!n.loose && e.includePrerelease === !!n.includePrerelease) return e;
            e = e.version
        } else if (typeof e != "string") throw new TypeError(`Invalid version. Must be a string. Got type "${typeof e}".`);
        if (e.length > AK) throw new TypeError(`version is longer than ${AK} characters`);
        iS("SemVer", e, n), this.options = n, this.loose = !!n.loose, this.includePrerelease = !!n.includePrerelease;
        const r = e.trim().match(n.loose ? TK[IK.LOOSE] : TK[IK.FULL]);
        if (!r) throw new TypeError(`Invalid Version: ${e}`);
        if (this.raw = e, this.major = +r[1], this.minor = +r[2], this.patch = +r[3], this.major > sS || this.major < 0) throw new TypeError("Invalid major version");
        if (this.minor > sS || this.minor < 0) throw new TypeError("Invalid minor version");
        if (this.patch > sS || this.patch < 0) throw new TypeError("Invalid patch version");
        r[4] ? this.prerelease = r[4].split(".").map(i => {
            if (/^[0-9]+$/.test(i)) {
                const s = +i;
                if (s >= 0 && s < sS) return s
            }
            return i
        }) : this.prerelease = [], this.build = r[5] ? r[5].split(".") : [], this.format()
    }
    format() {
        return this.version = `${this.major}.${this.minor}.${this.patch}`, this.prerelease.length && (this.version += `-${this.prerelease.join(".")}`), this.version
    }
    toString() {
        return this.version
    }
    compare(e) {
        if (iS("SemVer.compare", this.version, this.options, e), !(e instanceof df)) {
            if (typeof e == "string" && e === this.version) return 0;
            e = new df(e, this.options)
        }
        return e.version === this.version ? 0 : this.compareMain(e) || this.comparePre(e)
    }
    compareMain(e) {
        return e instanceof df || (e = new df(e, this.options)), aw(this.major, e.major) || aw(this.minor, e.minor) || aw(this.patch, e.patch)
    }
    comparePre(e) {
        if (e instanceof df || (e = new df(e, this.options)), this.prerelease.length && !e.prerelease.length) return -1;
        if (!this.prerelease.length && e.prerelease.length) return 1;
        if (!this.prerelease.length && !e.prerelease.length) return 0;
        let n = 0;
        do {
            const r = this.prerelease[n],
                i = e.prerelease[n];
            if (iS("prerelease compare", n, r, i), r === void 0 && i === void 0) return 0;
            if (i === void 0) return 1;
            if (r === void 0) return -1;
            if (r === i) continue;
            return aw(r, i)
        } while (++n)
    }
    compareBuild(e) {
        e instanceof df || (e = new df(e, this.options));
        let n = 0;
        do {
            const r = this.build[n],
                i = e.build[n];
            if (iS("build compare", n, r, i), r === void 0 && i === void 0) return 0;
            if (i === void 0) return 1;
            if (r === void 0) return -1;
            if (r === i) continue;
            return aw(r, i)
        } while (++n)
    }
    inc(e, n, r) {
        switch (e) {
            case "premajor":
                this.prerelease.length = 0, this.patch = 0, this.minor = 0, this.major++, this.inc("pre", n, r);
                break;
            case "preminor":
                this.prerelease.length = 0, this.patch = 0, this.minor++, this.inc("pre", n, r);
                break;
            case "prepatch":
                this.prerelease.length = 0, this.inc("patch", n, r), this.inc("pre", n, r);
                break;
            case "prerelease":
                this.prerelease.length === 0 && this.inc("patch", n, r), this.inc("pre", n, r);
                break;
            case "major":
                (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) && this.major++, this.minor = 0, this.patch = 0, this.prerelease = [];
                break;
            case "minor":
                (this.patch !== 0 || this.prerelease.length === 0) && this.minor++, this.patch = 0, this.prerelease = [];
                break;
            case "patch":
                this.prerelease.length === 0 && this.patch++, this.prerelease = [];
                break;
            case "pre":
                {
                    const i = Number(r) ? 1 : 0;
                    if (!n && r === !1) throw new Error("invalid increment argument: identifier is empty");
                    if (this.prerelease.length === 0) this.prerelease = [i];
                    else {
                        let s = this.prerelease.length;
                        for (; --s >= 0;) typeof this.prerelease[s] == "number" && (this.prerelease[s]++, s = -2);
                        if (s === -1) {
                            if (n === this.prerelease.join(".") && r === !1) throw new Error("invalid increment argument: identifier already exists");
                            this.prerelease.push(i)
                        }
                    }
                    if (n) {
                        let s = [n, i];
                        r === !1 && (s = [n]), aw(this.prerelease[0], n) === 0 ? isNaN(this.prerelease[1]) && (this.prerelease = s) : this.prerelease = s
                    }
                    break
                }
            default:
                throw new Error(`invalid increment argument: ${e}`)
        }
        return this.raw = this.format(), this.build.length && (this.raw += `+${this.build.join(".")}`), this
    }
};
var ya = vUe;
const RK = ya,
    bUe = (t, e, n = !1) => {
        if (t instanceof RK) return t;
        try {
            return new RK(t, e)
        } catch (r) {
            if (!n) return null;
            throw r
        }
    };
var W2 = bUe;
const _Ue = W2,
    EUe = (t, e) => {
        const n = _Ue(t, e);
        return n ? n.version : null
    };
var xUe = EUe;
const SUe = W2,
    CUe = (t, e) => {
        const n = SUe(t.trim().replace(/^[=v]+/, ""), e);
        return n ? n.version : null
    };
var AUe = CUe;
const OK = ya,
    TUe = (t, e, n, r, i) => {
        typeof n == "string" && (i = r, r = n, n = void 0);
        try {
            return new OK(t instanceof OK ? t.version : t, n).inc(e, r, i).version
        } catch {
            return null
        }
    };
var IUe = TUe;
const NK = W2,
    RUe = (t, e) => {
        const n = NK(t, null, !0),
            r = NK(e, null, !0),
            i = n.compare(r);
        if (i === 0) return null;
        const s = i > 0,
            o = s ? n : r,
            a = s ? r : n,
            l = !!o.prerelease.length;
        if (!!a.prerelease.length && !l) return !a.patch && !a.minor ? "major" : o.patch ? "patch" : o.minor ? "minor" : "major";
        const u = l ? "pre" : "";
        return n.major !== r.major ? u + "major" : n.minor !== r.minor ? u + "minor" : n.patch !== r.patch ? u + "patch" : "prerelease"
    };
var OUe = RUe;
const NUe = ya,
    PUe = (t, e) => new NUe(t, e).major;
var kUe = PUe;
const MUe = ya,
    DUe = (t, e) => new MUe(t, e).minor;
var $Ue = DUe;
const LUe = ya,
    BUe = (t, e) => new LUe(t, e).patch;
var FUe = BUe;
const UUe = W2,
    jUe = (t, e) => {
        const n = UUe(t, e);
        return n && n.prerelease.length ? n.prerelease : null
    };
var HUe = jUe;
const PK = ya,
    zUe = (t, e, n) => new PK(t, n).compare(new PK(e, n));
var Vu = zUe;
const WUe = Vu,
    VUe = (t, e, n) => WUe(e, t, n);
var GUe = VUe;
const qUe = Vu,
    KUe = (t, e) => qUe(t, e, !0);
var YUe = KUe;
const kK = ya,
    ZUe = (t, e, n) => {
        const r = new kK(t, n),
            i = new kK(e, n);
        return r.compare(i) || r.compareBuild(i)
    };
var yB = ZUe;
const QUe = yB,
    JUe = (t, e) => t.sort((n, r) => QUe(n, r, e));
var XUe = JUe;
const eje = yB,
    tje = (t, e) => t.sort((n, r) => eje(r, n, e));
var nje = tje;
const rje = Vu,
    ije = (t, e, n) => rje(t, e, n) > 0;
var I9 = ije;
const sje = Vu,
    oje = (t, e, n) => sje(t, e, n) < 0;
var wB = oje;
const aje = Vu,
    lje = (t, e, n) => aje(t, e, n) === 0;
var Poe = lje;
const cje = Vu,
    uje = (t, e, n) => cje(t, e, n) !== 0;
var koe = uje;
const fje = Vu,
    dje = (t, e, n) => fje(t, e, n) >= 0;
var vB = dje;
const hje = Vu,
    pje = (t, e, n) => hje(t, e, n) <= 0;
var bB = pje;
const gje = Poe,
    mje = koe,
    yje = I9,
    wje = vB,
    vje = wB,
    bje = bB,
    _je = (t, e, n, r) => {
        switch (e) {
            case "===":
                return typeof t == "object" && (t = t.version), typeof n == "object" && (n = n.version), t === n;
            case "!==":
                return typeof t == "object" && (t = t.version), typeof n == "object" && (n = n.version), t !== n;
            case "":
            case "=":
            case "==":
                return gje(t, n, r);
            case "!=":
                return mje(t, n, r);
            case ">":
                return yje(t, n, r);
            case ">=":
                return wje(t, n, r);
            case "<":
                return vje(t, n, r);
            case "<=":
                return bje(t, n, r);
            default:
                throw new TypeError(`Invalid operator: ${e}`)
        }
    };
var Moe = _je;
const Eje = ya,
    xje = W2,
    {
        safeRe: oS,
        t: aS
    } = ZE,
    Sje = (t, e) => {
        if (t instanceof Eje) return t;
        if (typeof t == "number" && (t = String(t)), typeof t != "string") return null;
        e = e || {};
        let n = null;
        if (!e.rtl) n = t.match(e.includePrerelease ? oS[aS.COERCEFULL] : oS[aS.COERCE]);
        else {
            const l = e.includePrerelease ? oS[aS.COERCERTLFULL] : oS[aS.COERCERTL];
            let c;
            for (;
                (c = l.exec(t)) && (!n || n.index + n[0].length !== t.length);)(!n || c.index + c[0].length !== n.index + n[0].length) && (n = c), l.lastIndex = c.index + c[1].length + c[2].length;
            l.lastIndex = -1
        }
        if (n === null) return null;
        const r = n[2],
            i = n[3] || "0",
            s = n[4] || "0",
            o = e.includePrerelease && n[5] ? `-${n[5]}` : "",
            a = e.includePrerelease && n[6] ? `+${n[6]}` : "";
        return xje(`${r}.${i}.${s}${o}${a}`, e)
    };
var Cje = Sje;
class Aje {
    constructor() {
        this.max = 1e3, this.map = new Map
    }
    get(e) {
        const n = this.map.get(e);
        if (n !== void 0) return this.map.delete(e), this.map.set(e, n), n
    }
    delete(e) {
        return this.map.delete(e)
    }
    set(e, n) {
        if (!this.delete(e) && n !== void 0) {
            if (this.map.size >= this.max) {
                const i = this.map.keys().next().value;
                this.delete(i)
            }
            this.map.set(e, n)
        }
        return this
    }
}
var Tje = Aje,
    nN, MK;

function Gu() {
    if (MK) return nN;
    MK = 1;
    const t = /\s+/g;
    class e {
        constructor(v, T) {
            if (T = i(T), v instanceof e) return v.loose === !!T.loose && v.includePrerelease === !!T.includePrerelease ? v : new e(v.raw, T);
            if (v instanceof s) return this.raw = v.value, this.set = [
                [v]
            ], this.formatted = void 0, this;
            if (this.options = T, this.loose = !!T.loose, this.includePrerelease = !!T.includePrerelease, this.raw = v.trim().replace(t, " "), this.set = this.raw.split("||").map(N => this.parseRange(N.trim())).filter(N => N.length), !this.set.length) throw new TypeError(`Invalid SemVer Range: ${this.raw}`);
            if (this.set.length > 1) {
                const N = this.set[0];
                if (this.set = this.set.filter(O => !_(O[0])), this.set.length === 0) this.set = [N];
                else if (this.set.length > 1) {
                    for (const O of this.set)
                        if (O.length === 1 && C(O[0])) {
                            this.set = [O];
                            break
                        }
                }
            }
            this.formatted = void 0
        }
        get range() {
            if (this.formatted === void 0) {
                this.formatted = "";
                for (let v = 0; v < this.set.length; v++) {
                    v > 0 && (this.formatted += "||");
                    const T = this.set[v];
                    for (let N = 0; N < T.length; N++) N > 0 && (this.formatted += " "), this.formatted += T[N].toString().trim()
                }
            }
            return this.formatted
        }
        format() {
            return this.range
        }
        toString() {
            return this.range
        }
        parseRange(v) {
            const N = ((this.options.includePrerelease && g) | (this.options.loose && y)) + ":" + v,
                O = r.get(N);
            if (O) return O;
            const L = this.options.loose,
                G = L ? l[c.HYPHENRANGELOOSE] : l[c.HYPHENRANGE];
            v = v.replace(G, te(this.options.includePrerelease)), o("hyphen replace", v), v = v.replace(l[c.COMPARATORTRIM], u), o("comparator trim", v), v = v.replace(l[c.TILDETRIM], f), o("tilde trim", v), v = v.replace(l[c.CARETTRIM], h), o("caret trim", v);
            let j = v.split(" ").map(V => w(V, this.options)).join(" ").split(/\s+/).map(V => K(V, this.options));
            L && (j = j.filter(V => (o("loose invalid filter", V, this.options), !!V.match(l[c.COMPARATORLOOSE])))), o("range list", j);
            const R = new Map,
                Y = j.map(V => new s(V, this.options));
            for (const V of Y) {
                if (_(V)) return [V];
                R.set(V.value, V)
            }
            R.size > 1 && R.has("") && R.delete("");
            const ve = [...R.values()];
            return r.set(N, ve), ve
        }
        intersects(v, T) {
            if (!(v instanceof e)) throw new TypeError("a Range is required");
            return this.set.some(N => b(N, T) && v.set.some(O => b(O, T) && N.every(L => O.every(G => L.intersects(G, T)))))
        }
        test(v) {
            if (!v) return !1;
            if (typeof v == "string") try {
                v = new a(v, this.options)
            } catch {
                return !1
            }
            for (let T = 0; T < this.set.length; T++)
                if (U(this.set[T], v, this.options)) return !0;
            return !1
        }
    }
    nN = e;
    const n = Tje,
        r = new n,
        i = mB,
        s = R9(),
        o = T9,
        a = ya,
        {
            safeRe: l,
            t: c,
            comparatorTrimReplace: u,
            tildeTrimReplace: f,
            caretTrimReplace: h
        } = ZE,
        {
            FLAG_INCLUDE_PRERELEASE: g,
            FLAG_LOOSE: y
        } = A9,
        _ = m => m.value === "<0.0.0-0",
        C = m => m.value === "",
        b = (m, v) => {
            let T = !0;
            const N = m.slice();
            let O = N.pop();
            for (; T && N.length;) T = N.every(L => O.intersects(L, v)), O = N.pop();
            return T
        },
        w = (m, v) => (o("comp", m, v), m = M(m, v), o("caret", m), m = I(m, v), o("tildes", m), m = E(m, v), o("xrange", m), m = H(m, v), o("stars", m), m),
        S = m => !m || m.toLowerCase() === "x" || m === "*",
        I = (m, v) => m.trim().split(/\s+/).map(T => P(T, v)).join(" "),
        P = (m, v) => {
            const T = v.loose ? l[c.TILDELOOSE] : l[c.TILDE];
            return m.replace(T, (N, O, L, G, j) => {
                o("tilde", m, N, O, L, G, j);
                let R;
                return S(O) ? R = "" : S(L) ? R = `>=${O}.0.0 <${+O+1}.0.0-0` : S(G) ? R = `>=${O}.${L}.0 <${O}.${+L+1}.0-0` : j ? (o("replaceTilde pr", j), R = `>=${O}.${L}.${G}-${j} <${O}.${+L+1}.0-0`) : R = `>=${O}.${L}.${G} <${O}.${+L+1}.0-0`, o("tilde return", R), R
            })
        },
        M = (m, v) => m.trim().split(/\s+/).map(T => A(T, v)).join(" "),
        A = (m, v) => {
            o("caret", m, v);
            const T = v.loose ? l[c.CARETLOOSE] : l[c.CARET],
                N = v.includePrerelease ? "-0" : "";
            return m.replace(T, (O, L, G, j, R) => {
                o("caret", m, O, L, G, j, R);
                let Y;
                return S(L) ? Y = "" : S(G) ? Y = `>=${L}.0.0${N} <${+L+1}.0.0-0` : S(j) ? L === "0" ? Y = `>=${L}.${G}.0${N} <${L}.${+G+1}.0-0` : Y = `>=${L}.${G}.0${N} <${+L+1}.0.0-0` : R ? (o("replaceCaret pr", R), L === "0" ? G === "0" ? Y = `>=${L}.${G}.${j}-${R} <${L}.${G}.${+j+1}-0` : Y = `>=${L}.${G}.${j}-${R} <${L}.${+G+1}.0-0` : Y = `>=${L}.${G}.${j}-${R} <${+L+1}.0.0-0`) : (o("no pr"), L === "0" ? G === "0" ? Y = `>=${L}.${G}.${j}${N} <${L}.${G}.${+j+1}-0` : Y = `>=${L}.${G}.${j}${N} <${L}.${+G+1}.0-0` : Y = `>=${L}.${G}.${j} <${+L+1}.0.0-0`), o("caret return", Y), Y
            })
        },
        E = (m, v) => (o("replaceXRanges", m, v), m.split(/\s+/).map(T => $(T, v)).join(" ")),
        $ = (m, v) => {
            m = m.trim();
            const T = v.loose ? l[c.XRANGELOOSE] : l[c.XRANGE];
            return m.replace(T, (N, O, L, G, j, R) => {
                o("xRange", m, N, O, L, G, j, R);
                const Y = S(L),
                    ve = Y || S(G),
                    V = ve || S(j),
                    X = V;
                return O === "=" && X && (O = ""), R = v.includePrerelease ? "-0" : "", Y ? O === ">" || O === "<" ? N = "<0.0.0-0" : N = "*" : O && X ? (ve && (G = 0), j = 0, O === ">" ? (O = ">=", ve ? (L = +L + 1, G = 0, j = 0) : (G = +G + 1, j = 0)) : O === "<=" && (O = "<", ve ? L = +L + 1 : G = +G + 1), O === "<" && (R = "-0"), N = `${O+L}.${G}.${j}${R}`) : ve ? N = `>=${L}.0.0${R} <${+L+1}.0.0-0` : V && (N = `>=${L}.${G}.0${R} <${L}.${+G+1}.0-0`), o("xRange return", N), N
            })
        },
        H = (m, v) => (o("replaceStars", m, v), m.trim().replace(l[c.STAR], "")),
        K = (m, v) => (o("replaceGTE0", m, v), m.trim().replace(l[v.includePrerelease ? c.GTE0PRE : c.GTE0], "")),
        te = m => (v, T, N, O, L, G, j, R, Y, ve, V, X) => (S(N) ? T = "" : S(O) ? T = `>=${N}.0.0${m?"-0":""}` : S(L) ? T = `>=${N}.${O}.0${m?"-0":""}` : G ? T = `>=${T}` : T = `>=${T}${m?"-0":""}`, S(Y) ? R = "" : S(ve) ? R = `<${+Y+1}.0.0-0` : S(V) ? R = `<${Y}.${+ve+1}.0-0` : X ? R = `<=${Y}.${ve}.${V}-${X}` : m ? R = `<${Y}.${ve}.${+V+1}-0` : R = `<=${R}`, `${T} ${R}`.trim()),
        U = (m, v, T) => {
            for (let N = 0; N < m.length; N++)
                if (!m[N].test(v)) return !1;
            if (v.prerelease.length && !T.includePrerelease) {
                for (let N = 0; N < m.length; N++)
                    if (o(m[N].semver), m[N].semver !== s.ANY && m[N].semver.prerelease.length > 0) {
                        const O = m[N].semver;
                        if (O.major === v.major && O.minor === v.minor && O.patch === v.patch) return !0
                    }
                return !1
            }
            return !0
        };
    return nN
}
var rN, DK;

function R9() {
    if (DK) return rN;
    DK = 1;
    const t = Symbol("SemVer ANY");
    class e {
        static get ANY() {
            return t
        }
        constructor(u, f) {
            if (f = n(f), u instanceof e) {
                if (u.loose === !!f.loose) return u;
                u = u.value
            }
            u = u.trim().split(/\s+/).join(" "), o("comparator", u, f), this.options = f, this.loose = !!f.loose, this.parse(u), this.semver === t ? this.value = "" : this.value = this.operator + this.semver.version, o("comp", this)
        }
        parse(u) {
            const f = this.options.loose ? r[i.COMPARATORLOOSE] : r[i.COMPARATOR],
                h = u.match(f);
            if (!h) throw new TypeError(`Invalid comparator: ${u}`);
            this.operator = h[1] !== void 0 ? h[1] : "", this.operator === "=" && (this.operator = ""), h[2] ? this.semver = new a(h[2], this.options.loose) : this.semver = t
        }
        toString() {
            return this.value
        }
        test(u) {
            if (o("Comparator.test", u, this.options.loose), this.semver === t || u === t) return !0;
            if (typeof u == "string") try {
                u = new a(u, this.options)
            } catch {
                return !1
            }
            return s(u, this.operator, this.semver, this.options)
        }
        intersects(u, f) {
            if (!(u instanceof e)) throw new TypeError("a Comparator is required");
            return this.operator === "" ? this.value === "" ? !0 : new l(u.value, f).test(this.value) : u.operator === "" ? u.value === "" ? !0 : new l(this.value, f).test(u.semver) : (f = n(f), f.includePrerelease && (this.value === "<0.0.0-0" || u.value === "<0.0.0-0") || !f.includePrerelease && (this.value.startsWith("<0.0.0") || u.value.startsWith("<0.0.0")) ? !1 : !!(this.operator.startsWith(">") && u.operator.startsWith(">") || this.operator.startsWith("<") && u.operator.startsWith("<") || this.semver.version === u.semver.version && this.operator.includes("=") && u.operator.includes("=") || s(this.semver, "<", u.semver, f) && this.operator.startsWith(">") && u.operator.startsWith("<") || s(this.semver, ">", u.semver, f) && this.operator.startsWith("<") && u.operator.startsWith(">")))
        }
    }
    rN = e;
    const n = mB,
        {
            safeRe: r,
            t: i
        } = ZE,
        s = Moe,
        o = T9,
        a = ya,
        l = Gu();
    return rN
}
const Ije = Gu(),
    Rje = (t, e, n) => {
        try {
            e = new Ije(e, n)
        } catch {
            return !1
        }
        return e.test(t)
    };
var O9 = Rje;
const Oje = Gu(),
    Nje = (t, e) => new Oje(t, e).set.map(n => n.map(r => r.value).join(" ").trim().split(" "));
var Pje = Nje;
const kje = ya,
    Mje = Gu(),
    Dje = (t, e, n) => {
        let r = null,
            i = null,
            s = null;
        try {
            s = new Mje(e, n)
        } catch {
            return null
        }
        return t.forEach(o => {
            s.test(o) && (!r || i.compare(o) === -1) && (r = o, i = new kje(r, n))
        }), r
    };
var $je = Dje;
const Lje = ya,
    Bje = Gu(),
    Fje = (t, e, n) => {
        let r = null,
            i = null,
            s = null;
        try {
            s = new Bje(e, n)
        } catch {
            return null
        }
        return t.forEach(o => {
            s.test(o) && (!r || i.compare(o) === 1) && (r = o, i = new Lje(r, n))
        }), r
    };
var Uje = Fje;
const iN = ya,
    jje = Gu(),
    $K = I9,
    Hje = (t, e) => {
        t = new jje(t, e);
        let n = new iN("0.0.0");
        if (t.test(n) || (n = new iN("0.0.0-0"), t.test(n))) return n;
        n = null;
        for (let r = 0; r < t.set.length; ++r) {
            const i = t.set[r];
            let s = null;
            i.forEach(o => {
                const a = new iN(o.semver.version);
                switch (o.operator) {
                    case ">":
                        a.prerelease.length === 0 ? a.patch++ : a.prerelease.push(0), a.raw = a.format();
                    case "":
                    case ">=":
                        (!s || $K(a, s)) && (s = a);
                        break;
                    case "<":
                    case "<=":
                        break;
                    default:
                        throw new Error(`Unexpected operation: ${o.operator}`)
                }
            }), s && (!n || $K(n, s)) && (n = s)
        }
        return n && t.test(n) ? n : null
    };
var zje = Hje;
const Wje = Gu(),
    Vje = (t, e) => {
        try {
            return new Wje(t, e).range || "*"
        } catch {
            return null
        }
    };
var Gje = Vje;
const qje = ya,
    Doe = R9(),
    {
        ANY: Kje
    } = Doe,
    Yje = Gu(),
    Zje = O9,
    LK = I9,
    BK = wB,
    Qje = bB,
    Jje = vB,
    Xje = (t, e, n, r) => {
        t = new qje(t, r), e = new Yje(e, r);
        let i, s, o, a, l;
        switch (n) {
            case ">":
                i = LK, s = Qje, o = BK, a = ">", l = ">=";
                break;
            case "<":
                i = BK, s = Jje, o = LK, a = "<", l = "<=";
                break;
            default:
                throw new TypeError('Must provide a hilo val of "<" or ">"')
        }
        if (Zje(t, e, r)) return !1;
        for (let c = 0; c < e.set.length; ++c) {
            const u = e.set[c];
            let f = null,
                h = null;
            if (u.forEach(g => {
                    g.semver === Kje && (g = new Doe(">=0.0.0")), f = f || g, h = h || g, i(g.semver, f.semver, r) ? f = g : o(g.semver, h.semver, r) && (h = g)
                }), f.operator === a || f.operator === l || (!h.operator || h.operator === a) && s(t, h.semver)) return !1;
            if (h.operator === l && o(t, h.semver)) return !1
        }
        return !0
    };
var _B = Xje;
const eHe = _B,
    tHe = (t, e, n) => eHe(t, e, ">", n);
var nHe = tHe;
const rHe = _B,
    iHe = (t, e, n) => rHe(t, e, "<", n);
var sHe = iHe;
const FK = Gu(),
    oHe = (t, e, n) => (t = new FK(t, n), e = new FK(e, n), t.intersects(e, n));
var aHe = oHe;
const lHe = O9,
    cHe = Vu;
var uHe = (t, e, n) => {
    const r = [];
    let i = null,
        s = null;
    const o = t.sort((u, f) => cHe(u, f, n));
    for (const u of o) lHe(u, e, n) ? (s = u, i || (i = u)) : (s && r.push([i, s]), s = null, i = null);
    i && r.push([i, null]);
    const a = [];
    for (const [u, f] of r) u === f ? a.push(u) : !f && u === o[0] ? a.push("*") : f ? u === o[0] ? a.push(`<=${f}`) : a.push(`${u} - ${f}`) : a.push(`>=${u}`);
    const l = a.join(" || "),
        c = typeof e.raw == "string" ? e.raw : String(e);
    return l.length < c.length ? l : e
};
const UK = Gu(),
    EB = R9(),
    {
        ANY: sN
    } = EB,
    K5 = O9,
    xB = Vu,
    fHe = (t, e, n = {}) => {
        if (t === e) return !0;
        t = new UK(t, n), e = new UK(e, n);
        let r = !1;
        e: for (const i of t.set) {
            for (const s of e.set) {
                const o = hHe(i, s, n);
                if (r = r || o !== null, o) continue e
            }
            if (r) return !1
        }
        return !0
    },
    dHe = [new EB(">=0.0.0-0")],
    jK = [new EB(">=0.0.0")],
    hHe = (t, e, n) => {
        if (t === e) return !0;
        if (t.length === 1 && t[0].semver === sN) {
            if (e.length === 1 && e[0].semver === sN) return !0;
            n.includePrerelease ? t = dHe : t = jK
        }
        if (e.length === 1 && e[0].semver === sN) {
            if (n.includePrerelease) return !0;
            e = jK
        }
        const r = new Set;
        let i, s;
        for (const g of t) g.operator === ">" || g.operator === ">=" ? i = HK(i, g, n) : g.operator === "<" || g.operator === "<=" ? s = zK(s, g, n) : r.add(g.semver);
        if (r.size > 1) return null;
        let o;
        if (i && s) {
            if (o = xB(i.semver, s.semver, n), o > 0) return null;
            if (o === 0 && (i.operator !== ">=" || s.operator !== "<=")) return null
        }
        for (const g of r) {
            if (i && !K5(g, String(i), n) || s && !K5(g, String(s), n)) return null;
            for (const y of e)
                if (!K5(g, String(y), n)) return !1;
            return !0
        }
        let a, l, c, u, f = s && !n.includePrerelease && s.semver.prerelease.length ? s.semver : !1,
            h = i && !n.includePrerelease && i.semver.prerelease.length ? i.semver : !1;
        f && f.prerelease.length === 1 && s.operator === "<" && f.prerelease[0] === 0 && (f = !1);
        for (const g of e) {
            if (u = u || g.operator === ">" || g.operator === ">=", c = c || g.operator === "<" || g.operator === "<=", i) {
                if (h && g.semver.prerelease && g.semver.prerelease.length && g.semver.major === h.major && g.semver.minor === h.minor && g.semver.patch === h.patch && (h = !1), g.operator === ">" || g.operator === ">=") {
                    if (a = HK(i, g, n), a === g && a !== i) return !1
                } else if (i.operator === ">=" && !K5(i.semver, String(g), n)) return !1
            }
            if (s) {
                if (f && g.semver.prerelease && g.semver.prerelease.length && g.semver.major === f.major && g.semver.minor === f.minor && g.semver.patch === f.patch && (f = !1), g.operator === "<" || g.operator === "<=") {
                    if (l = zK(s, g, n), l === g && l !== s) return !1
                } else if (s.operator === "<=" && !K5(s.semver, String(g), n)) return !1
            }
            if (!g.operator && (s || i) && o !== 0) return !1
        }
        return !(i && c && !s && o !== 0 || s && u && !i && o !== 0 || h || f)
    },
    HK = (t, e, n) => {
        if (!t) return e;
        const r = xB(t.semver, e.semver, n);
        return r > 0 ? t : r < 0 || e.operator === ">" && t.operator === ">=" ? e : t
    },
    zK = (t, e, n) => {
        if (!t) return e;
        const r = xB(t.semver, e.semver, n);
        return r < 0 ? t : r > 0 || e.operator === "<" && t.operator === "<=" ? e : t
    };
var pHe = fHe;
const oN = ZE,
    WK = A9,
    gHe = ya,
    VK = Noe,
    mHe = W2,
    yHe = xUe,
    wHe = AUe,
    vHe = IUe,
    bHe = OUe,
    _He = kUe,
    EHe = $Ue,
    xHe = FUe,
    SHe = HUe,
    CHe = Vu,
    AHe = GUe,
    THe = YUe,
    IHe = yB,
    RHe = XUe,
    OHe = nje,
    NHe = I9,
    PHe = wB,
    kHe = Poe,
    MHe = koe,
    DHe = vB,
    $He = bB,
    LHe = Moe,
    BHe = Cje,
    FHe = R9(),
    UHe = Gu(),
    jHe = O9,
    HHe = Pje,
    zHe = $je,
    WHe = Uje,
    VHe = zje,
    GHe = Gje,
    qHe = _B,
    KHe = nHe,
    YHe = sHe,
    ZHe = aHe,
    QHe = uHe,
    JHe = pHe;
var XHe = {
    parse: mHe,
    valid: yHe,
    clean: wHe,
    inc: vHe,
    diff: bHe,
    major: _He,
    minor: EHe,
    patch: xHe,
    prerelease: SHe,
    compare: CHe,
    rcompare: AHe,
    compareLoose: THe,
    compareBuild: IHe,
    sort: RHe,
    rsort: OHe,
    gt: NHe,
    lt: PHe,
    eq: kHe,
    neq: MHe,
    gte: DHe,
    lte: $He,
    cmp: LHe,
    coerce: BHe,
    Comparator: FHe,
    Range: UHe,
    satisfies: jHe,
    toComparators: HHe,
    maxSatisfying: zHe,
    minSatisfying: WHe,
    minVersion: VHe,
    validRange: GHe,
    outside: qHe,
    gtr: KHe,
    ltr: YHe,
    intersects: ZHe,
    simplifyRange: QHe,
    subset: JHe,
    SemVer: gHe,
    re: oN.re,
    src: oN.src,
    tokens: oN.t,
    SEMVER_SPEC_VERSION: WK.SEMVER_SPEC_VERSION,
    RELEASE_TYPES: WK.RELEASE_TYPES,
    compareIdentifiers: VK.compareIdentifiers,
    rcompareIdentifiers: VK.rcompareIdentifiers
};
(function(t) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    }), t.satisfiesVersionRange = t.gtRange = t.gtVersion = t.assertIsSemVerRange = t.assertIsSemVerVersion = t.isValidSemVerRange = t.isValidSemVerVersion = t.VersionRangeStruct = t.VersionStruct = void 0;
    const e = XHe,
        n = Sy,
        r = oo;
    t.VersionStruct = (0, n.refine)((0, n.string)(), "Version", f => (0, e.valid)(f) === null ? `Expected SemVer version, got "${f}"` : !0), t.VersionRangeStruct = (0, n.refine)((0, n.string)(), "Version range", f => (0, e.validRange)(f) === null ? `Expected SemVer range, got "${f}"` : !0);

    function i(f) {
        return (0, n.is)(f, t.VersionStruct)
    }
    t.isValidSemVerVersion = i;

    function s(f) {
        return (0, n.is)(f, t.VersionRangeStruct)
    }
    t.isValidSemVerRange = s;

    function o(f) {
        (0, r.assertStruct)(f, t.VersionStruct)
    }
    t.assertIsSemVerVersion = o;

    function a(f) {
        (0, r.assertStruct)(f, t.VersionRangeStruct)
    }
    t.assertIsSemVerRange = a;

    function l(f, h) {
        return (0, e.gt)(f, h)
    }
    t.gtVersion = l;

    function c(f, h) {
        return (0, e.gtr)(f, h)
    }
    t.gtRange = c;

    function u(f, h) {
        return (0, e.satisfies)(f, h, {
            includePrerelease: !0
        })
    }
    t.satisfiesVersionRange = u
})(Ioe);
(function(t) {
    var e = st && st.__createBinding || (Object.create ? function(r, i, s, o) {
            o === void 0 && (o = s);
            var a = Object.getOwnPropertyDescriptor(i, s);
            (!a || ("get" in a ? !i.__esModule : a.writable || a.configurable)) && (a = {
                enumerable: !0,
                get: function() {
                    return i[s]
                }
            }), Object.defineProperty(r, o, a)
        } : function(r, i, s, o) {
            o === void 0 && (o = s), r[o] = i[s]
        }),
        n = st && st.__exportStar || function(r, i) {
            for (var s in r) s !== "default" && !Object.prototype.hasOwnProperty.call(i, s) && e(i, r, s)
        };
    Object.defineProperty(t, "__esModule", {
        value: !0
    }), n(oo, t), n(KE, t), n(cr, t), n(S9, t), n(Ff, t), n(i2, t), n(YE, t), n(Soe, t), n(s2, t), n(gB, t), n(Uf, t), n(Aoe, t), n(Toe, t), n(Ioe, t)
})(soe);
(function(t) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    }), t.createModuleLogger = t.projectLogger = void 0;
    const e = soe;
    Object.defineProperty(t, "createModuleLogger", {
        enumerable: !0,
        get: function() {
            return e.createModuleLogger
        }
    }), t.projectLogger = (0, e.createProjectLogger)("eth-block-tracker")
})(ioe);
var $oe = st && st.__importDefault || function(t) {
    return t && t.__esModule ? t : {
        default: t
    }
};
Object.defineProperty(E9, "__esModule", {
    value: !0
});
E9.PollingBlockTracker = void 0;
const eze = $oe(oB),
    tze = $oe(OBe),
    nze = VE,
    GK = ioe,
    qK = (0, GK.createModuleLogger)(GK.projectLogger, "polling-block-tracker"),
    rze = (0, eze.default)(),
    ize = 1e3;
class sze extends nze.BaseBlockTracker {
    constructor(e = {}) {
        var n;
        if (!e.provider) throw new Error("PollingBlockTracker - no provider specified.");
        super({
            blockResetDuration: (n = e.blockResetDuration) !== null && n !== void 0 ? n : e.pollingInterval
        }), this._provider = e.provider, this._pollingInterval = e.pollingInterval || 20 * ize, this._retryTimeout = e.retryTimeout || this._pollingInterval / 10, this._keepEventLoopActive = e.keepEventLoopActive === void 0 ? !0 : e.keepEventLoopActive, this._setSkipCacheFlag = e.setSkipCacheFlag || !1
    }
    async checkForLatestBlock() {
        return await this._updateLatestBlock(), await this.getLatestBlock()
    }
    async _start() {
        this._synchronize()
    }
    async _end() {}
    async _synchronize() {
        for (var e; this._isRunning;) try {
            await this._updateLatestBlock();
            const n = KK(this._pollingInterval, !this._keepEventLoopActive);
            this.emit("_waitingForNextIteration"), await n
        } catch (n) {
            const r = new Error(`PollingBlockTracker - encountered an error while attempting to update latest block:
${(e=n.stack)!==null&&e!==void 0?e:n}`);
            try {
                this.emit("error", r)
            } catch {
                console.error(r)
            }
            const i = KK(this._retryTimeout, !this._keepEventLoopActive);
            this.emit("_waitingForNextIteration"), await i
        }
    }
    async _updateLatestBlock() {
        const e = await this._fetchLatestBlock();
        this._newPotentialLatest(e)
    }
    async _fetchLatestBlock() {
        const e = {
            jsonrpc: "2.0",
            id: rze(),
            method: "eth_blockNumber",
            params: []
        };
        this._setSkipCacheFlag && (e.skipCache = !0), qK("Making request", e);
        const n = await (0, tze.default)(r => this._provider.sendAsync(e, r))();
        if (qK("Got response", n), n.error) throw new Error(`PollingBlockTracker - encountered error fetching block:
${n.error.message}`);
        return n.result
    }
}
E9.PollingBlockTracker = sze;

function KK(t, e) {
    return new Promise(n => {
        const r = setTimeout(n, t);
        r.unref && e && r.unref()
    })
}
var N9 = {},
    oze = st && st.__importDefault || function(t) {
        return t && t.__esModule ? t : {
            default: t
        }
    };
Object.defineProperty(N9, "__esModule", {
    value: !0
});
N9.SubscribeBlockTracker = void 0;
const aze = oze(oB),
    lze = VE,
    cze = (0, aze.default)();
class uze extends lze.BaseBlockTracker {
    constructor(e = {}) {
        if (!e.provider) throw new Error("SubscribeBlockTracker - no provider specified.");
        super(e), this._provider = e.provider, this._subscriptionId = null
    }
    async checkForLatestBlock() {
        return await this.getLatestBlock()
    }
    async _start() {
        if (this._subscriptionId === void 0 || this._subscriptionId === null) try {
            const e = await this._call("eth_blockNumber");
            this._subscriptionId = await this._call("eth_subscribe", "newHeads"), this._provider.on("data", this._handleSubData.bind(this)), this._newPotentialLatest(e)
        } catch (e) {
            this.emit("error", e)
        }
    }
    async _end() {
        if (this._subscriptionId !== null && this._subscriptionId !== void 0) try {
            await this._call("eth_unsubscribe", this._subscriptionId), this._subscriptionId = null
        } catch (e) {
            this.emit("error", e)
        }
    }
    _call(e, ...n) {
        return new Promise((r, i) => {
            this._provider.sendAsync({
                id: cze(),
                method: e,
                params: n,
                jsonrpc: "2.0"
            }, (s, o) => {
                s ? i(s) : r(o.result)
            })
        })
    }
    _handleSubData(e, n) {
        var r;
        n.method === "eth_subscription" && ((r = n.params) === null || r === void 0 ? void 0 : r.subscription) === this._subscriptionId && this._newPotentialLatest(n.params.result.number)
    }
}
N9.SubscribeBlockTracker = uze;
var Loe = {};
Object.defineProperty(Loe, "__esModule", {
    value: !0
});
(function(t) {
    var e = st && st.__createBinding || (Object.create ? function(r, i, s, o) {
            o === void 0 && (o = s), Object.defineProperty(r, o, {
                enumerable: !0,
                get: function() {
                    return i[s]
                }
            })
        } : function(r, i, s, o) {
            o === void 0 && (o = s), r[o] = i[s]
        }),
        n = st && st.__exportStar || function(r, i) {
            for (var s in r) s !== "default" && !Object.prototype.hasOwnProperty.call(i, s) && e(i, r, s)
        };
    Object.defineProperty(t, "__esModule", {
        value: !0
    }), n(E9, t), n(N9, t), n(Loe, t)
})(roe);
var SB = {},
    P9 = {},
    QE = {};
Object.defineProperty(QE, "__esModule", {
    value: !0
});
QE.getUniqueId = void 0;
const Boe = 4294967295;
let aN = Math.floor(Math.random() * Boe);

function fze() {
    return aN = (aN + 1) % Boe, aN
}
QE.getUniqueId = fze;
Object.defineProperty(P9, "__esModule", {
    value: !0
});
P9.createIdRemapMiddleware = void 0;
const dze = QE;

function hze() {
    return (t, e, n, r) => {
        const i = t.id,
            s = dze.getUniqueId();
        t.id = s, e.id = s, n(o => {
            t.id = i, e.id = i, o()
        })
    }
}
P9.createIdRemapMiddleware = hze;
var k9 = {};
Object.defineProperty(k9, "__esModule", {
    value: !0
});
k9.createAsyncMiddleware = void 0;

function pze(t) {
    return async (e, n, r, i) => {
        let s;
        const o = new Promise(u => {
            s = u
        });
        let a = null,
            l = !1;
        const c = async () => {
            l = !0, r(u => {
                a = u, s()
            }), await o
        };
        try {
            await t(e, n, c), l ? (await o, a(null)) : i(null)
        } catch (u) {
            a ? a(u) : i(u)
        }
    }
}
k9.createAsyncMiddleware = pze;
var M9 = {};
Object.defineProperty(M9, "__esModule", {
    value: !0
});
M9.createScaffoldMiddleware = void 0;

function gze(t) {
    return (e, n, r, i) => {
        const s = t[e.method];
        return s === void 0 ? r() : typeof s == "function" ? s(e, n, r, i) : (n.result = s, i())
    }
}
M9.createScaffoldMiddleware = gze;
var JE = {},
    mze = st && st.__importDefault || function(t) {
        return t && t.__esModule ? t : {
            default: t
        }
    };
Object.defineProperty(JE, "__esModule", {
    value: !0
});
JE.JsonRpcEngine = void 0;
const yze = mze(vy),
    Jl = qL;
class Ud extends yze.default {
    constructor() {
        super(), this._middleware = []
    }
    push(e) {
        this._middleware.push(e)
    }
    handle(e, n) {
        if (n && typeof n != "function") throw new Error('"callback" must be a function if provided.');
        return Array.isArray(e) ? n ? this._handleBatch(e, n) : this._handleBatch(e) : n ? this._handle(e, n) : this._promiseHandle(e)
    }
    asMiddleware() {
        return async (e, n, r, i) => {
            try {
                const [s, o, a] = await Ud._runAllMiddleware(e, n, this._middleware);
                return o ? (await Ud._runReturnHandlers(a), i(s)) : r(async l => {
                    try {
                        await Ud._runReturnHandlers(a)
                    } catch (c) {
                        return l(c)
                    }
                    return l()
                })
            } catch (s) {
                return i(s)
            }
        }
    }
    async _handleBatch(e, n) {
        try {
            const r = await Promise.all(e.map(this._promiseHandle.bind(this)));
            return n ? n(null, r) : r
        } catch (r) {
            if (n) return n(r);
            throw r
        }
    }
    _promiseHandle(e) {
        return new Promise(n => {
            this._handle(e, (r, i) => {
                n(i)
            })
        })
    }
    async _handle(e, n) {
        if (!e || Array.isArray(e) || typeof e != "object") {
            const o = new Jl.EthereumRpcError(Jl.errorCodes.rpc.invalidRequest, `Requests must be plain objects. Received: ${typeof e}`, {
                request: e
            });
            return n(o, {
                id: void 0,
                jsonrpc: "2.0",
                error: o
            })
        }
        if (typeof e.method != "string") {
            const o = new Jl.EthereumRpcError(Jl.errorCodes.rpc.invalidRequest, `Must specify a string method. Received: ${typeof e.method}`, {
                request: e
            });
            return n(o, {
                id: e.id,
                jsonrpc: "2.0",
                error: o
            })
        }
        const r = Object.assign({}, e),
            i = {
                id: r.id,
                jsonrpc: r.jsonrpc
            };
        let s = null;
        try {
            await this._processRequest(r, i)
        } catch (o) {
            s = o
        }
        return s && (delete i.result, i.error || (i.error = Jl.serializeError(s))), n(s, i)
    }
    async _processRequest(e, n) {
        const [r, i, s] = await Ud._runAllMiddleware(e, n, this._middleware);
        if (Ud._checkForCompletion(e, n, i), await Ud._runReturnHandlers(s), r) throw r
    }
    static async _runAllMiddleware(e, n, r) {
        const i = [];
        let s = null,
            o = !1;
        for (const a of r)
            if ([s, o] = await Ud._runMiddleware(e, n, a, i), o) break;
        return [s, o, i.reverse()]
    }
    static _runMiddleware(e, n, r, i) {
        return new Promise(s => {
            const o = l => {
                    const c = l || n.error;
                    c && (n.error = Jl.serializeError(c)), s([c, !0])
                },
                a = l => {
                    n.error ? o(n.error) : (l && (typeof l != "function" && o(new Jl.EthereumRpcError(Jl.errorCodes.rpc.internal, `JsonRpcEngine: "next" return handlers must be functions. Received "${typeof l}" for request:
${lN(e)}`, {
                        request: e
                    })), i.push(l)), s([null, !1]))
                };
            try {
                r(e, n, a, o)
            } catch (l) {
                o(l)
            }
        })
    }
    static async _runReturnHandlers(e) {
        for (const n of e) await new Promise((r, i) => {
            n(s => s ? i(s) : r())
        })
    }
    static _checkForCompletion(e, n, r) {
        if (!("result" in n) && !("error" in n)) throw new Jl.EthereumRpcError(Jl.errorCodes.rpc.internal, `JsonRpcEngine: Response has no error or result for request:
${lN(e)}`, {
            request: e
        });
        if (!r) throw new Jl.EthereumRpcError(Jl.errorCodes.rpc.internal, `JsonRpcEngine: Nothing ended request:
${lN(e)}`, {
            request: e
        })
    }
}
JE.JsonRpcEngine = Ud;

function lN(t) {
    return JSON.stringify(t, null, 2)
}
var D9 = {};
Object.defineProperty(D9, "__esModule", {
    value: !0
});
D9.mergeMiddleware = void 0;
const wze = JE;

function vze(t) {
    const e = new wze.JsonRpcEngine;
    return t.forEach(n => e.push(n)), e.asMiddleware()
}
D9.mergeMiddleware = vze;
(function(t) {
    var e = st && st.__createBinding || (Object.create ? function(r, i, s, o) {
            o === void 0 && (o = s), Object.defineProperty(r, o, {
                enumerable: !0,
                get: function() {
                    return i[s]
                }
            })
        } : function(r, i, s, o) {
            o === void 0 && (o = s), r[o] = i[s]
        }),
        n = st && st.__exportStar || function(r, i) {
            for (var s in r) s !== "default" && !Object.prototype.hasOwnProperty.call(i, s) && e(i, r, s)
        };
    Object.defineProperty(t, "__esModule", {
        value: !0
    }), n(P9, t), n(k9, t), n(M9, t), n(QE, t), n(JE, t), n(D9, t)
})(SB);
var Foe = {},
    CB = {},
    bM = function(t, e) {
        return bM = Object.setPrototypeOf || {
            __proto__: []
        }
        instanceof Array && function(n, r) {
            n.__proto__ = r
        } || function(n, r) {
            for (var i in r) Object.prototype.hasOwnProperty.call(r, i) && (n[i] = r[i])
        }, bM(t, e)
    };

function Uoe(t, e) {
    if (typeof e != "function" && e !== null) throw new TypeError("Class extends value " + String(e) + " is not a constructor or null");
    bM(t, e);

    function n() {
        this.constructor = t
    }
    t.prototype = e === null ? Object.create(e) : (n.prototype = e.prototype, new n)
}
var QC = function() {
    return QC = Object.assign || function(e) {
        for (var n, r = 1, i = arguments.length; r < i; r++) {
            n = arguments[r];
            for (var s in n) Object.prototype.hasOwnProperty.call(n, s) && (e[s] = n[s])
        }
        return e
    }, QC.apply(this, arguments)
};

function joe(t, e) {
    var n = {};
    for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && e.indexOf(r) < 0 && (n[r] = t[r]);
    if (t != null && typeof Object.getOwnPropertySymbols == "function")
        for (var i = 0, r = Object.getOwnPropertySymbols(t); i < r.length; i++) e.indexOf(r[i]) < 0 && Object.prototype.propertyIsEnumerable.call(t, r[i]) && (n[r[i]] = t[r[i]]);
    return n
}

function Hoe(t, e, n, r) {
    var i = arguments.length,
        s = i < 3 ? e : r === null ? r = Object.getOwnPropertyDescriptor(e, n) : r,
        o;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function") s = Reflect.decorate(t, e, n, r);
    else
        for (var a = t.length - 1; a >= 0; a--)(o = t[a]) && (s = (i < 3 ? o(s) : i > 3 ? o(e, n, s) : o(e, n)) || s);
    return i > 3 && s && Object.defineProperty(e, n, s), s
}

function zoe(t, e) {
    return function(n, r) {
        e(n, r, t)
    }
}

function bze(t, e, n, r, i, s) {
    function o(b) {
        if (b !== void 0 && typeof b != "function") throw new TypeError("Function expected");
        return b
    }
    for (var a = r.kind, l = a === "getter" ? "get" : a === "setter" ? "set" : "value", c = !e && t ? r.static ? t : t.prototype : null, u = e || (c ? Object.getOwnPropertyDescriptor(c, r.name) : {}), f, h = !1, g = n.length - 1; g >= 0; g--) {
        var y = {};
        for (var _ in r) y[_] = _ === "access" ? {} : r[_];
        for (var _ in r.access) y.access[_] = r.access[_];
        y.addInitializer = function(b) {
            if (h) throw new TypeError("Cannot add initializers after decoration has completed");
            s.push(o(b || null))
        };
        var C = (0, n[g])(a === "accessor" ? {
            get: u.get,
            set: u.set
        } : u[l], y);
        if (a === "accessor") {
            if (C === void 0) continue;
            if (C === null || typeof C != "object") throw new TypeError("Object expected");
            (f = o(C.get)) && (u.get = f), (f = o(C.set)) && (u.set = f), (f = o(C.init)) && i.unshift(f)
        } else(f = o(C)) && (a === "field" ? i.unshift(f) : u[l] = f)
    }
    c && Object.defineProperty(c, r.name, u), h = !0
}

function _ze(t, e, n) {
    for (var r = arguments.length > 2, i = 0; i < e.length; i++) n = r ? e[i].call(t, n) : e[i].call(t);
    return r ? n : void 0
}

function Eze(t) {
    return typeof t == "symbol" ? t : "".concat(t)
}

function xze(t, e, n) {
    return typeof e == "symbol" && (e = e.description ? "[".concat(e.description, "]") : ""), Object.defineProperty(t, "name", {
        configurable: !0,
        value: n ? "".concat(n, " ", e) : e
    })
}

function Woe(t, e) {
    if (typeof Reflect == "object" && typeof Reflect.metadata == "function") return Reflect.metadata(t, e)
}

function Voe(t, e, n, r) {
    function i(s) {
        return s instanceof n ? s : new n(function(o) {
            o(s)
        })
    }
    return new(n || (n = Promise))(function(s, o) {
        function a(u) {
            try {
                c(r.next(u))
            } catch (f) {
                o(f)
            }
        }

        function l(u) {
            try {
                c(r.throw(u))
            } catch (f) {
                o(f)
            }
        }

        function c(u) {
            u.done ? s(u.value) : i(u.value).then(a, l)
        }
        c((r = r.apply(t, e || [])).next())
    })
}

function Goe(t, e) {
    var n = {
            label: 0,
            sent: function() {
                if (s[0] & 1) throw s[1];
                return s[1]
            },
            trys: [],
            ops: []
        },
        r, i, s, o = Object.create((typeof Iterator == "function" ? Iterator : Object).prototype);
    return o.next = a(0), o.throw = a(1), o.return = a(2), typeof Symbol == "function" && (o[Symbol.iterator] = function() {
        return this
    }), o;

    function a(c) {
        return function(u) {
            return l([c, u])
        }
    }

    function l(c) {
        if (r) throw new TypeError("Generator is already executing.");
        for (; o && (o = 0, c[0] && (n = 0)), n;) try {
            if (r = 1, i && (s = c[0] & 2 ? i.return : c[0] ? i.throw || ((s = i.return) && s.call(i), 0) : i.next) && !(s = s.call(i, c[1])).done) return s;
            switch (i = 0, s && (c = [c[0] & 2, s.value]), c[0]) {
                case 0:
                case 1:
                    s = c;
                    break;
                case 4:
                    return n.label++, {
                        value: c[1],
                        done: !1
                    };
                case 5:
                    n.label++, i = c[1], c = [0];
                    continue;
                case 7:
                    c = n.ops.pop(), n.trys.pop();
                    continue;
                default:
                    if (s = n.trys, !(s = s.length > 0 && s[s.length - 1]) && (c[0] === 6 || c[0] === 2)) {
                        n = 0;
                        continue
                    }
                    if (c[0] === 3 && (!s || c[1] > s[0] && c[1] < s[3])) {
                        n.label = c[1];
                        break
                    }
                    if (c[0] === 6 && n.label < s[1]) {
                        n.label = s[1], s = c;
                        break
                    }
                    if (s && n.label < s[2]) {
                        n.label = s[2], n.ops.push(c);
                        break
                    }
                    s[2] && n.ops.pop(), n.trys.pop();
                    continue
            }
            c = e.call(t, n)
        } catch (u) {
            c = [6, u], i = 0
        } finally {
            r = s = 0
        }
        if (c[0] & 5) throw c[1];
        return {
            value: c[0] ? c[1] : void 0,
            done: !0
        }
    }
}
var $9 = Object.create ? function(t, e, n, r) {
    r === void 0 && (r = n);
    var i = Object.getOwnPropertyDescriptor(e, n);
    (!i || ("get" in i ? !e.__esModule : i.writable || i.configurable)) && (i = {
        enumerable: !0,
        get: function() {
            return e[n]
        }
    }), Object.defineProperty(t, r, i)
} : function(t, e, n, r) {
    r === void 0 && (r = n), t[r] = e[n]
};

function qoe(t, e) {
    for (var n in t) n !== "default" && !Object.prototype.hasOwnProperty.call(e, n) && $9(e, t, n)
}

function JC(t) {
    var e = typeof Symbol == "function" && Symbol.iterator,
        n = e && t[e],
        r = 0;
    if (n) return n.call(t);
    if (t && typeof t.length == "number") return {
        next: function() {
            return t && r >= t.length && (t = void 0), {
                value: t && t[r++],
                done: !t
            }
        }
    };
    throw new TypeError(e ? "Object is not iterable." : "Symbol.iterator is not defined.")
}

function AB(t, e) {
    var n = typeof Symbol == "function" && t[Symbol.iterator];
    if (!n) return t;
    var r = n.call(t),
        i, s = [],
        o;
    try {
        for (;
            (e === void 0 || e-- > 0) && !(i = r.next()).done;) s.push(i.value)
    } catch (a) {
        o = {
            error: a
        }
    } finally {
        try {
            i && !i.done && (n = r.return) && n.call(r)
        } finally {
            if (o) throw o.error
        }
    }
    return s
}

function Koe() {
    for (var t = [], e = 0; e < arguments.length; e++) t = t.concat(AB(arguments[e]));
    return t
}

function Yoe() {
    for (var t = 0, e = 0, n = arguments.length; e < n; e++) t += arguments[e].length;
    for (var r = Array(t), i = 0, e = 0; e < n; e++)
        for (var s = arguments[e], o = 0, a = s.length; o < a; o++, i++) r[i] = s[o];
    return r
}

function Zoe(t, e, n) {
    if (n || arguments.length === 2)
        for (var r = 0, i = e.length, s; r < i; r++)(s || !(r in e)) && (s || (s = Array.prototype.slice.call(e, 0, r)), s[r] = e[r]);
    return t.concat(s || Array.prototype.slice.call(e))
}

function o2(t) {
    return this instanceof o2 ? (this.v = t, this) : new o2(t)
}

function Qoe(t, e, n) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var r = n.apply(t, e || []),
        i, s = [];
    return i = Object.create((typeof AsyncIterator == "function" ? AsyncIterator : Object).prototype), a("next"), a("throw"), a("return", o), i[Symbol.asyncIterator] = function() {
        return this
    }, i;

    function o(g) {
        return function(y) {
            return Promise.resolve(y).then(g, f)
        }
    }

    function a(g, y) {
        r[g] && (i[g] = function(_) {
            return new Promise(function(C, b) {
                s.push([g, _, C, b]) > 1 || l(g, _)
            })
        }, y && (i[g] = y(i[g])))
    }

    function l(g, y) {
        try {
            c(r[g](y))
        } catch (_) {
            h(s[0][3], _)
        }
    }

    function c(g) {
        g.value instanceof o2 ? Promise.resolve(g.value.v).then(u, f) : h(s[0][2], g)
    }

    function u(g) {
        l("next", g)
    }

    function f(g) {
        l("throw", g)
    }

    function h(g, y) {
        g(y), s.shift(), s.length && l(s[0][0], s[0][1])
    }
}

function Joe(t) {
    var e, n;
    return e = {}, r("next"), r("throw", function(i) {
        throw i
    }), r("return"), e[Symbol.iterator] = function() {
        return this
    }, e;

    function r(i, s) {
        e[i] = t[i] ? function(o) {
            return (n = !n) ? {
                value: o2(t[i](o)),
                done: !1
            } : s ? s(o) : o
        } : s
    }
}

function Xoe(t) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var e = t[Symbol.asyncIterator],
        n;
    return e ? e.call(t) : (t = typeof JC == "function" ? JC(t) : t[Symbol.iterator](), n = {}, r("next"), r("throw"), r("return"), n[Symbol.asyncIterator] = function() {
        return this
    }, n);

    function r(s) {
        n[s] = t[s] && function(o) {
            return new Promise(function(a, l) {
                o = t[s](o), i(a, l, o.done, o.value)
            })
        }
    }

    function i(s, o, a, l) {
        Promise.resolve(l).then(function(c) {
            s({
                value: c,
                done: a
            })
        }, o)
    }
}

function eae(t, e) {
    return Object.defineProperty ? Object.defineProperty(t, "raw", {
        value: e
    }) : t.raw = e, t
}
var Sze = Object.create ? function(t, e) {
    Object.defineProperty(t, "default", {
        enumerable: !0,
        value: e
    })
} : function(t, e) {
    t.default = e
};

function tae(t) {
    if (t && t.__esModule) return t;
    var e = {};
    if (t != null)
        for (var n in t) n !== "default" && Object.prototype.hasOwnProperty.call(t, n) && $9(e, t, n);
    return Sze(e, t), e
}

function nae(t) {
    return t && t.__esModule ? t : {
        default: t
    }
}

function rae(t, e, n, r) {
    if (n === "a" && !r) throw new TypeError("Private accessor was defined without a getter");
    if (typeof e == "function" ? t !== e || !r : !e.has(t)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return n === "m" ? r : n === "a" ? r.call(t) : r ? r.value : e.get(t)
}

function iae(t, e, n, r, i) {
    if (r === "m") throw new TypeError("Private method is not writable");
    if (r === "a" && !i) throw new TypeError("Private accessor was defined without a setter");
    if (typeof e == "function" ? t !== e || !i : !e.has(t)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return r === "a" ? i.call(t, n) : i ? i.value = n : e.set(t, n), n
}

function sae(t, e) {
    if (e === null || typeof e != "object" && typeof e != "function") throw new TypeError("Cannot use 'in' operator on non-object");
    return typeof t == "function" ? e === t : t.has(e)
}

function oae(t, e, n) {
    if (e != null) {
        if (typeof e != "object" && typeof e != "function") throw new TypeError("Object expected.");
        var r, i;
        if (n) {
            if (!Symbol.asyncDispose) throw new TypeError("Symbol.asyncDispose is not defined.");
            r = e[Symbol.asyncDispose]
        }
        if (r === void 0) {
            if (!Symbol.dispose) throw new TypeError("Symbol.dispose is not defined.");
            r = e[Symbol.dispose], n && (i = r)
        }
        if (typeof r != "function") throw new TypeError("Object not disposable.");
        i && (r = function() {
            try {
                i.call(this)
            } catch (s) {
                return Promise.reject(s)
            }
        }), t.stack.push({
            value: e,
            dispose: r,
            async: n
        })
    } else n && t.stack.push({
        async: !0
    });
    return e
}
var Cze = typeof SuppressedError == "function" ? SuppressedError : function(t, e, n) {
    var r = new Error(n);
    return r.name = "SuppressedError", r.error = t, r.suppressed = e, r
};

function aae(t) {
    function e(s) {
        t.error = t.hasError ? new Cze(s, t.error, "An error was suppressed during disposal.") : s, t.hasError = !0
    }
    var n, r = 0;

    function i() {
        for (; n = t.stack.pop();) try {
            if (!n.async && r === 1) return r = 0, t.stack.push(n), Promise.resolve().then(i);
            if (n.dispose) {
                var s = n.dispose.call(n.value);
                if (n.async) return r |= 2, Promise.resolve(s).then(i, function(o) {
                    return e(o), i()
                })
            } else r |= 1
        } catch (o) {
            e(o)
        }
        if (r === 1) return t.hasError ? Promise.reject(t.error) : Promise.resolve();
        if (t.hasError) throw t.error
    }
    return i()
}
const Aze = {
        __extends: Uoe,
        __assign: QC,
        __rest: joe,
        __decorate: Hoe,
        __param: zoe,
        __metadata: Woe,
        __awaiter: Voe,
        __generator: Goe,
        __createBinding: $9,
        __exportStar: qoe,
        __values: JC,
        __read: AB,
        __spread: Koe,
        __spreadArrays: Yoe,
        __spreadArray: Zoe,
        __await: o2,
        __asyncGenerator: Qoe,
        __asyncDelegator: Joe,
        __asyncValues: Xoe,
        __makeTemplateObject: eae,
        __importStar: tae,
        __importDefault: nae,
        __classPrivateFieldGet: rae,
        __classPrivateFieldSet: iae,
        __classPrivateFieldIn: sae,
        __addDisposableResource: oae,
        __disposeResources: aae
    },
    Tze = Object.freeze(Object.defineProperty({
        __proto__: null,
        __addDisposableResource: oae,
        get __assign() {
            return QC
        },
        __asyncDelegator: Joe,
        __asyncGenerator: Qoe,
        __asyncValues: Xoe,
        __await: o2,
        __awaiter: Voe,
        __classPrivateFieldGet: rae,
        __classPrivateFieldIn: sae,
        __classPrivateFieldSet: iae,
        __createBinding: $9,
        __decorate: Hoe,
        __disposeResources: aae,
        __esDecorate: bze,
        __exportStar: qoe,
        __extends: Uoe,
        __generator: Goe,
        __importDefault: nae,
        __importStar: tae,
        __makeTemplateObject: eae,
        __metadata: Woe,
        __param: zoe,
        __propKey: Eze,
        __read: AB,
        __rest: joe,
        __runInitializers: _ze,
        __setFunctionName: xze,
        __spread: Koe,
        __spreadArray: Zoe,
        __spreadArrays: Yoe,
        __values: JC,
        default: Aze
    }, Symbol.toStringTag, {
        value: "Module"
    })),
    TB = Fu(Tze);
var L9 = {};
Object.defineProperty(L9, "__esModule", {
    value: !0
});
var YK = TB,
    Ize = function() {
        function t(e) {
            if (this._maxConcurrency = e, this._queue = [], e <= 0) throw new Error("semaphore must be initialized to a positive value");
            this._value = e
        }
        return t.prototype.acquire = function() {
            var e = this,
                n = this.isLocked(),
                r = new Promise(function(i) {
                    return e._queue.push(i)
                });
            return n || this._dispatch(), r
        }, t.prototype.runExclusive = function(e) {
            return YK.__awaiter(this, void 0, void 0, function() {
                var n, r, i;
                return YK.__generator(this, function(s) {
                    switch (s.label) {
                        case 0:
                            return [4, this.acquire()];
                        case 1:
                            n = s.sent(), r = n[0], i = n[1], s.label = 2;
                        case 2:
                            return s.trys.push([2, , 4, 5]), [4, e(r)];
                        case 3:
                            return [2, s.sent()];
                        case 4:
                            return i(), [7];
                        case 5:
                            return [2]
                    }
                })
            })
        }, t.prototype.isLocked = function() {
            return this._value <= 0
        }, t.prototype.release = function() {
            if (this._maxConcurrency > 1) throw new Error("this method is unavailabel on semaphores with concurrency > 1; use the scoped release returned by acquire instead");
            if (this._currentReleaser) {
                var e = this._currentReleaser;
                this._currentReleaser = void 0, e()
            }
        }, t.prototype._dispatch = function() {
            var e = this,
                n = this._queue.shift();
            if (n) {
                var r = !1;
                this._currentReleaser = function() {
                    r || (r = !0, e._value++, e._dispatch())
                }, n([this._value--, this._currentReleaser])
            }
        }, t
    }();
L9.default = Ize;
Object.defineProperty(CB, "__esModule", {
    value: !0
});
var ZK = TB,
    Rze = L9,
    Oze = function() {
        function t() {
            this._semaphore = new Rze.default(1)
        }
        return t.prototype.acquire = function() {
            return ZK.__awaiter(this, void 0, void 0, function() {
                var e, n;
                return ZK.__generator(this, function(r) {
                    switch (r.label) {
                        case 0:
                            return [4, this._semaphore.acquire()];
                        case 1:
                            return e = r.sent(), n = e[1], [2, n]
                    }
                })
            })
        }, t.prototype.runExclusive = function(e) {
            return this._semaphore.runExclusive(function() {
                return e()
            })
        }, t.prototype.isLocked = function() {
            return this._semaphore.isLocked()
        }, t.prototype.release = function() {
            this._semaphore.release()
        }, t
    }();
CB.default = Oze;
var B9 = {};
Object.defineProperty(B9, "__esModule", {
    value: !0
});
B9.withTimeout = void 0;
var lS = TB;

function Nze(t, e, n) {
    var r = this;
    return n === void 0 && (n = new Error("timeout")), {
        acquire: function() {
            return new Promise(function(i, s) {
                return lS.__awaiter(r, void 0, void 0, function() {
                    var o, a, l;
                    return lS.__generator(this, function(c) {
                        switch (c.label) {
                            case 0:
                                return o = !1, setTimeout(function() {
                                    o = !0, s(n)
                                }, e), [4, t.acquire()];
                            case 1:
                                return a = c.sent(), o ? (l = Array.isArray(a) ? a[1] : a, l()) : i(a), [2]
                        }
                    })
                })
            })
        },
        runExclusive: function(i) {
            return lS.__awaiter(this, void 0, void 0, function() {
                var s, o;
                return lS.__generator(this, function(a) {
                    switch (a.label) {
                        case 0:
                            s = function() {}, a.label = 1;
                        case 1:
                            return a.trys.push([1, , 7, 8]), [4, this.acquire()];
                        case 2:
                            return o = a.sent(), Array.isArray(o) ? (s = o[1], [4, i(o[0])]) : [3, 4];
                        case 3:
                            return [2, a.sent()];
                        case 4:
                            return s = o, [4, i()];
                        case 5:
                            return [2, a.sent()];
                        case 6:
                            return [3, 8];
                        case 7:
                            return s(), [7];
                        case 8:
                            return [2]
                    }
                })
            })
        },
        release: function() {
            t.release()
        },
        isLocked: function() {
            return t.isLocked()
        }
    }
}
B9.withTimeout = Nze;
(function(t) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    }), t.withTimeout = t.Semaphore = t.Mutex = void 0;
    var e = CB;
    Object.defineProperty(t, "Mutex", {
        enumerable: !0,
        get: function() {
            return e.default
        }
    });
    var n = L9;
    Object.defineProperty(t, "Semaphore", {
        enumerable: !0,
        get: function() {
            return n.default
        }
    });
    var r = B9;
    Object.defineProperty(t, "withTimeout", {
        enumerable: !0,
        get: function() {
            return r.withTimeout
        }
    })
})(Foe);
var Pze = Mze,
    kze = Object.prototype.hasOwnProperty;

function Mze() {
    for (var t = {}, e = 0; e < arguments.length; e++) {
        var n = arguments[e];
        for (var r in n) kze.call(n, r) && (t[r] = n[r])
    }
    return t
}
const Dze = Pze,
    $ze = oB();
var Lze = gn;

function gn(t) {
    const e = this;
    e.currentProvider = t
}
gn.prototype.getBalance = XE(2, "eth_getBalance");
gn.prototype.getCode = XE(2, "eth_getCode");
gn.prototype.getTransactionCount = XE(2, "eth_getTransactionCount");
gn.prototype.getStorageAt = XE(3, "eth_getStorageAt");
gn.prototype.call = XE(2, "eth_call");
gn.prototype.protocolVersion = zn("eth_protocolVersion");
gn.prototype.syncing = zn("eth_syncing");
gn.prototype.coinbase = zn("eth_coinbase");
gn.prototype.mining = zn("eth_mining");
gn.prototype.hashrate = zn("eth_hashrate");
gn.prototype.gasPrice = zn("eth_gasPrice");
gn.prototype.accounts = zn("eth_accounts");
gn.prototype.blockNumber = zn("eth_blockNumber");
gn.prototype.getBlockTransactionCountByHash = zn("eth_getBlockTransactionCountByHash");
gn.prototype.getBlockTransactionCountByNumber = zn("eth_getBlockTransactionCountByNumber");
gn.prototype.getUncleCountByBlockHash = zn("eth_getUncleCountByBlockHash");
gn.prototype.getUncleCountByBlockNumber = zn("eth_getUncleCountByBlockNumber");
gn.prototype.sign = zn("eth_sign");
gn.prototype.sendTransaction = zn("eth_sendTransaction");
gn.prototype.sendRawTransaction = zn("eth_sendRawTransaction");
gn.prototype.estimateGas = zn("eth_estimateGas");
gn.prototype.getBlockByHash = zn("eth_getBlockByHash");
gn.prototype.getBlockByNumber = zn("eth_getBlockByNumber");
gn.prototype.getTransactionByHash = zn("eth_getTransactionByHash");
gn.prototype.getTransactionByBlockHashAndIndex = zn("eth_getTransactionByBlockHashAndIndex");
gn.prototype.getTransactionByBlockNumberAndIndex = zn("eth_getTransactionByBlockNumberAndIndex");
gn.prototype.getTransactionReceipt = zn("eth_getTransactionReceipt");
gn.prototype.getUncleByBlockHashAndIndex = zn("eth_getUncleByBlockHashAndIndex");
gn.prototype.getUncleByBlockNumberAndIndex = zn("eth_getUncleByBlockNumberAndIndex");
gn.prototype.getCompilers = zn("eth_getCompilers");
gn.prototype.compileLLL = zn("eth_compileLLL");
gn.prototype.compileSolidity = zn("eth_compileSolidity");
gn.prototype.compileSerpent = zn("eth_compileSerpent");
gn.prototype.newFilter = zn("eth_newFilter");
gn.prototype.newBlockFilter = zn("eth_newBlockFilter");
gn.prototype.newPendingTransactionFilter = zn("eth_newPendingTransactionFilter");
gn.prototype.uninstallFilter = zn("eth_uninstallFilter");
gn.prototype.getFilterChanges = zn("eth_getFilterChanges");
gn.prototype.getFilterLogs = zn("eth_getFilterLogs");
gn.prototype.getLogs = zn("eth_getLogs");
gn.prototype.getWork = zn("eth_getWork");
gn.prototype.submitWork = zn("eth_submitWork");
gn.prototype.submitHashrate = zn("eth_submitHashrate");
gn.prototype.sendAsync = function(t, e) {
    this.currentProvider.sendAsync(Bze(t), function(r, i) {
        if (!r && i.error && (r = new Error("EthQuery - RPC Error - " + i.error.message)), r) return e(r);
        e(null, i.result)
    })
};

function zn(t) {
    return function() {
        const e = this;
        var n = [].slice.call(arguments),
            r = n.pop();
        e.sendAsync({
            method: t,
            params: n
        }, r)
    }
}

function XE(t, e) {
    return function() {
        const n = this;
        var r = [].slice.call(arguments),
            i = r.pop();
        r.length < t && r.push("latest"), n.sendAsync({
            method: e,
            params: r
        }, i)
    }
}

function Bze(t) {
    return Dze({
        id: $ze(),
        jsonrpc: "2.0",
        params: []
    }, t)
}
const QK = (t, e, n, r) => function(...i) {
        const s = e.promiseModule;
        return new s((o, a) => {
            e.multiArgs ? i.push((...c) => {
                e.errorFirst ? c[0] ? a(c) : (c.shift(), o(c)) : o(c)
            }) : e.errorFirst ? i.push((c, u) => {
                c ? a(c) : o(u)
            }) : i.push(o), Reflect.apply(t, this === n ? r : this, i)
        })
    },
    JK = new WeakMap;
var Fze = (t, e) => {
    e = {
        exclude: [/.+(?:Sync|Stream)$/],
        errorFirst: !0,
        promiseModule: Promise,
        ...e
    };
    const n = typeof t;
    if (!(t !== null && (n === "object" || n === "function"))) throw new TypeError(`Expected \`input\` to be a \`Function\` or \`Object\`, got \`${t===null?"null":n}\``);
    const r = (o, a) => {
            let l = JK.get(o);
            if (l || (l = {}, JK.set(o, l)), a in l) return l[a];
            const c = y => typeof y == "string" || typeof a == "symbol" ? a === y : y.test(a),
                u = Reflect.getOwnPropertyDescriptor(o, a),
                f = u === void 0 || u.writable || u.configurable,
                g = (e.include ? e.include.some(c) : !e.exclude.some(c)) && f;
            return l[a] = g, g
        },
        i = new WeakMap,
        s = new Proxy(t, {
            apply(o, a, l) {
                const c = i.get(o);
                if (c) return Reflect.apply(c, a, l);
                const u = e.excludeMain ? o : QK(o, e, s, o);
                return i.set(o, u), Reflect.apply(u, a, l)
            },
            get(o, a) {
                const l = o[a];
                if (!r(o, a) || l === Function.prototype[a]) return l;
                const c = i.get(l);
                if (c) return c;
                if (typeof l == "function") {
                    const u = QK(l, e, s, o);
                    return i.set(l, u), u
                }
                return l
            }
        });
    return s
};
const Uze = vy.default;
let jze = class extends Uze {
    constructor() {
        super(), this.updates = []
    }
    async initialize() {}
    async update() {
        throw new Error("BaseFilter - no update method specified")
    }
    addResults(e) {
        this.updates = this.updates.concat(e), e.forEach(n => this.emit("update", n))
    }
    addInitialResults(e) {}
    getChangesAndClear() {
        const e = this.updates;
        return this.updates = [], e
    }
};
var IB = jze;
const Hze = IB;
let zze = class extends Hze {
    constructor() {
        super(), this.allResults = []
    }
    async update() {
        throw new Error("BaseFilterWithHistory - no update method specified")
    }
    addResults(e) {
        this.allResults = this.allResults.concat(e), super.addResults(e)
    }
    addInitialResults(e) {
        this.allResults = this.allResults.concat(e), super.addInitialResults(e)
    }
    getAllResults() {
        return this.allResults
    }
};
var Wze = zze,
    e4 = {
        minBlockRef: Vze,
        maxBlockRef: Gze,
        sortBlockRefs: RB,
        bnToHex: qze,
        blockRefIsNumber: Kze,
        hexToInt: XC,
        incrementHexInt: Yze,
        intToHex: lae,
        unsafeRandomBytes: Zze
    };

function Vze(...t) {
    return RB(t)[0]
}

function Gze(...t) {
    const e = RB(t);
    return e[e.length - 1]
}

function RB(t) {
    return t.sort((e, n) => e === "latest" || n === "earliest" ? 1 : n === "latest" || e === "earliest" ? -1 : XC(e) - XC(n))
}

function qze(t) {
    return "0x" + t.toString(16)
}

function Kze(t) {
    return t && !["earliest", "latest", "pending"].includes(t)
}

function XC(t) {
    return t == null ? t : Number.parseInt(t, 16)
}

function Yze(t) {
    if (t == null) return t;
    const e = XC(t);
    return lae(e + 1)
}

function lae(t) {
    if (t == null) return t;
    let e = t.toString(16);
    return e.length % 2 && (e = "0" + e), "0x" + e
}

function Zze(t) {
    let e = "0x";
    for (let n = 0; n < t; n++) e += XK(), e += XK();
    return e
}

function XK() {
    return Math.floor(Math.random() * 16).toString(16)
}
const Qze = Lze,
    Jze = Fze,
    Xze = Wze,
    {
        bnToHex: g3t,
        hexToInt: cS,
        incrementHexInt: eWe,
        minBlockRef: tWe,
        blockRefIsNumber: nWe
    } = e4;
let rWe = class extends Xze {
    constructor({
        provider: e,
        params: n
    }) {
        super(), this.type = "log", this.ethQuery = new Qze(e), this.params = Object.assign({
            fromBlock: "latest",
            toBlock: "latest",
            address: void 0,
            topics: []
        }, n), this.params.address && (Array.isArray(this.params.address) || (this.params.address = [this.params.address]), this.params.address = this.params.address.map(r => r.toLowerCase()))
    }
    async initialize({
        currentBlock: e
    }) {
        let n = this.params.fromBlock;
        ["latest", "pending"].includes(n) && (n = e), n === "earliest" && (n = "0x0"), this.params.fromBlock = n;
        const r = tWe(this.params.toBlock, e),
            i = Object.assign({}, this.params, {
                toBlock: r
            }),
            s = await this._fetchLogs(i);
        this.addInitialResults(s)
    }
    async update({
        oldBlock: e,
        newBlock: n
    }) {
        const r = n;
        let i;
        e ? i = eWe(e) : i = n;
        const s = Object.assign({}, this.params, {
                fromBlock: i,
                toBlock: r
            }),
            a = (await this._fetchLogs(s)).filter(l => this.matchLog(l));
        this.addResults(a)
    }
    async _fetchLogs(e) {
        return await Jze(r => this.ethQuery.getLogs(e, r))()
    }
    matchLog(e) {
        if (cS(this.params.fromBlock) >= cS(e.blockNumber) || nWe(this.params.toBlock) && cS(this.params.toBlock) <= cS(e.blockNumber)) return !1;
        const n = e.address && e.address.toLowerCase();
        return this.params.address && n && !this.params.address.includes(n) ? !1 : this.params.topics.every((i, s) => {
            let o = e.topics[s];
            if (!o) return !1;
            o = o.toLowerCase();
            let a = Array.isArray(i) ? i : [i];
            return a.includes(null) ? !0 : (a = a.map(u => u.toLowerCase()), a.includes(o))
        })
    }
};
var iWe = rWe,
    OB = sWe;
async function sWe({
    provider: t,
    fromBlock: e,
    toBlock: n
}) {
    e || (e = n);
    const r = eY(e),
        s = eY(n) - r + 1,
        o = Array(s).fill().map((l, c) => r + c).map(oWe);
    return await Promise.all(o.map(l => lWe(t, "eth_getBlockByNumber", [l, !1])))
}

function eY(t) {
    return t == null ? t : Number.parseInt(t, 16)
}

function oWe(t) {
    return t == null ? t : "0x" + t.toString(16)
}

function aWe(t, e) {
    return new Promise((n, r) => {
        t.sendAsync(e, (i, s) => {
            i ? r(i) : s.error ? r(s.error) : s.result ? n(s.result) : r(new Error("Result was empty"))
        })
    })
}
async function lWe(t, e, n) {
    for (let r = 0; r < 3; r++) try {
        return await aWe(t, {
            id: 1,
            jsonrpc: "2.0",
            method: e,
            params: n
        })
    } catch (i) {
        console.error(`provider.sendAsync failed: ${i.stack||i.message||i}`)
    }
    throw new Error(`Block not found for params: ${JSON.stringify(n)}`)
}
const cWe = IB,
    uWe = OB,
    {
        incrementHexInt: fWe
    } = e4;
let dWe = class extends cWe {
    constructor({
        provider: e,
        params: n
    }) {
        super(), this.type = "block", this.provider = e
    }
    async update({
        oldBlock: e,
        newBlock: n
    }) {
        const r = n,
            i = fWe(e),
            o = (await uWe({
                provider: this.provider,
                fromBlock: i,
                toBlock: r
            })).map(a => a.hash);
        this.addResults(o)
    }
};
var hWe = dWe;
const pWe = IB,
    gWe = OB,
    {
        incrementHexInt: mWe
    } = e4;
let yWe = class extends pWe {
    constructor({
        provider: e
    }) {
        super(), this.type = "tx", this.provider = e
    }
    async update({
        oldBlock: e
    }) {
        const n = e,
            r = mWe(e),
            i = await gWe({
                provider: this.provider,
                fromBlock: r,
                toBlock: n
            }),
            s = [];
        for (const o of i) s.push(...o.transactions);
        this.addResults(s)
    }
};
var wWe = yWe;
const vWe = Foe.Mutex,
    {
        createAsyncMiddleware: bWe,
        createScaffoldMiddleware: _We
    } = SB,
    EWe = iWe,
    xWe = hWe,
    SWe = wWe,
    {
        intToHex: cae,
        hexToInt: cN
    } = e4;
var CWe = AWe;

function AWe({
    blockTracker: t,
    provider: e
}) {
    let n = 0,
        r = {};
    const i = new vWe,
        s = TWe({
            mutex: i
        }),
        o = _We({
            eth_newFilter: s(uN(l)),
            eth_newBlockFilter: s(uN(c)),
            eth_newPendingTransactionFilter: s(uN(u)),
            eth_uninstallFilter: s(g8(g)),
            eth_getFilterChanges: s(g8(f)),
            eth_getFilterLogs: s(g8(h))
        }),
        a = async ({
            oldBlock: w,
            newBlock: S
        }) => {
            if (r.length === 0) return;
            const I = await i.acquire();
            try {
                await Promise.all(lw(r).map(async P => {
                    try {
                        await P.update({
                            oldBlock: w,
                            newBlock: S
                        })
                    } catch (M) {
                        console.error(M)
                    }
                }))
            } catch (P) {
                console.error(P)
            }
            I()
        };
    return o.newLogFilter = l, o.newBlockFilter = c, o.newPendingTransactionFilter = u, o.uninstallFilter = g, o.getFilterChanges = f, o.getFilterLogs = h, o.destroy = () => {
        C()
    }, o;
    async function l(w) {
        const S = new EWe({
            provider: e,
            params: w
        });
        return await y(S), S
    }
    async function c() {
        const w = new xWe({
            provider: e
        });
        return await y(w), w
    }
    async function u() {
        const w = new SWe({
            provider: e
        });
        return await y(w), w
    }
    async function f(w) {
        const S = cN(w),
            I = r[S];
        if (!I) throw new Error(`No filter for index "${S}"`);
        return I.getChangesAndClear()
    }
    async function h(w) {
        const S = cN(w),
            I = r[S];
        if (!I) throw new Error(`No filter for index "${S}"`);
        let P = [];
        return I.type === "log" && (P = I.getAllResults()), P
    }
    async function g(w) {
        const S = cN(w),
            P = !!r[S];
        return P && await _(S), P
    }
    async function y(w) {
        const S = lw(r).length,
            I = await t.getLatestBlock();
        await w.initialize({
            currentBlock: I
        }), n++, r[n] = w, w.id = n, w.idHex = cae(n);
        const P = lw(r).length;
        return b({
            prevFilterCount: S,
            newFilterCount: P
        }), n
    }
    async function _(w) {
        const S = lw(r).length;
        delete r[w];
        const I = lw(r).length;
        b({
            prevFilterCount: S,
            newFilterCount: I
        })
    }
    async function C() {
        const w = lw(r).length;
        r = {}, b({
            prevFilterCount: w,
            newFilterCount: 0
        })
    }

    function b({
        prevFilterCount: w,
        newFilterCount: S
    }) {
        if (w === 0 && S > 0) {
            t.on("sync", a);
            return
        }
        if (w > 0 && S === 0) {
            t.removeListener("sync", a);
            return
        }
    }
}

function uN(t) {
    return g8(async (...e) => {
        const n = await t(...e);
        return cae(n.id)
    })
}

function g8(t) {
    return bWe(async (e, n) => {
        const r = await t.apply(null, e.params);
        n.result = r
    })
}

function TWe({
    mutex: t
}) {
    return e => async (n, r, i, s) => {
        (await t.acquire())(), e(n, r, i, s)
    }
}

function lw(t, e) {
    const n = [];
    for (let r in t) n.push(t[r]);
    return n
}
const IWe = vy.default,
    {
        createAsyncMiddleware: tY,
        createScaffoldMiddleware: RWe
    } = SB,
    OWe = CWe,
    {
        unsafeRandomBytes: NWe,
        incrementHexInt: PWe
    } = e4,
    kWe = OB;
var MWe = DWe;

function DWe({
    blockTracker: t,
    provider: e
}) {
    const n = {},
        r = OWe({
            blockTracker: t,
            provider: e
        });
    let i = !1;
    const s = new IWe,
        o = RWe({
            eth_subscribe: tY(a),
            eth_unsubscribe: tY(l)
        });
    return o.destroy = u, {
        events: s,
        middleware: o
    };
    async function a(f, h) {
        if (i) throw new Error("SubscriptionManager - attempting to use after destroying");
        const g = f.params[0],
            y = NWe(16);
        let _;
        switch (g) {
            case "newHeads":
                _ = C({
                    subId: y
                });
                break;
            case "logs":
                const w = f.params[1],
                    S = await r.newLogFilter(w);
                _ = b({
                    subId: y,
                    filter: S
                });
                break;
            default:
                throw new Error(`SubscriptionManager - unsupported subscription type "${g}"`)
        }
        n[y] = _, h.result = y;
        return;

        function C({
            subId: w
        }) {
            const S = {
                type: g,
                destroy: async () => {
                    t.removeListener("sync", S.update)
                },
                update: async ({
                    oldBlock: I,
                    newBlock: P
                }) => {
                    const M = P,
                        A = PWe(I);
                    (await kWe({
                        provider: e,
                        fromBlock: A,
                        toBlock: M
                    })).map($We).filter(H => H !== null).forEach(H => {
                        c(w, H)
                    })
                }
            };
            return t.on("sync", S.update), S
        }

        function b({
            subId: w,
            filter: S
        }) {
            return S.on("update", P => c(w, P)), {
                type: g,
                destroy: async () => await r.uninstallFilter(S.idHex)
            }
        }
    }
    async function l(f, h) {
        if (i) throw new Error("SubscriptionManager - attempting to use after destroying");
        const g = f.params[0],
            y = n[g];
        if (!y) {
            h.result = !1;
            return
        }
        delete n[g], await y.destroy(), h.result = !0
    }

    function c(f, h) {
        s.emit("notification", {
            jsonrpc: "2.0",
            method: "eth_subscription",
            params: {
                subscription: f,
                result: h
            }
        })
    }

    function u() {
        s.removeAllListeners();
        for (const f in n) n[f].destroy(), delete n[f];
        i = !0
    }
}

function $We(t) {
    return t == null ? null : {
        hash: t.hash,
        parentHash: t.parentHash,
        sha3Uncles: t.sha3Uncles,
        miner: t.miner,
        stateRoot: t.stateRoot,
        transactionsRoot: t.transactionsRoot,
        receiptsRoot: t.receiptsRoot,
        logsBloom: t.logsBloom,
        difficulty: t.difficulty,
        number: t.number,
        gasLimit: t.gasLimit,
        gasUsed: t.gasUsed,
        nonce: t.nonce,
        mixHash: t.mixHash,
        timestamp: t.timestamp,
        extraData: t.extraData
    }
}
Object.defineProperty(_9, "__esModule", {
    value: !0
});
_9.SubscriptionManager = void 0;
const LWe = roe,
    BWe = MWe,
    nY = () => {};
class FWe {
    constructor(e) {
        const n = new LWe.PollingBlockTracker({
                provider: e,
                pollingInterval: 15e3,
                setSkipCacheFlag: !0
            }),
            {
                events: r,
                middleware: i
            } = BWe({
                blockTracker: n,
                provider: e
            });
        this.events = r, this.subscriptionMiddleware = i
    }
    async handleRequest(e) {
        const n = {};
        return await this.subscriptionMiddleware(e, n, nY, nY), n
    }
    destroy() {
        this.subscriptionMiddleware.destroy()
    }
}
_9.SubscriptionManager = FWe;
var NB = st && st.__importDefault || function(t) {
    return t && t.__esModule ? t : {
        default: t
    }
};
Object.defineProperty(Jb, "__esModule", {
    value: !0
});
Jb.CoinbaseWalletProvider = void 0;
const UWe = NB(vy),
    jWe = NB(ME),
    fN = D2,
    Hr = DE,
    rY = L2,
    iY = _u,
    dN = h9,
    HWe = Kr,
    Bn = Ut,
    hN = NB(CBe),
    zWe = r2,
    Cr = noe,
    WWe = _9,
    sY = "DefaultChainId",
    oY = "DefaultJsonRpcUrl";
class VWe extends UWe.default {
    constructor(e) {
        var n, r;
        super(), this._filterPolyfill = new zWe.FilterPolyfill(this), this._subscriptionManager = new WWe.SubscriptionManager(this), this._relay = null, this._addresses = [], this.hasMadeFirstChainChangedEmission = !1, this.setProviderInfo = this.setProviderInfo.bind(this), this.updateProviderInfo = this.updateProviderInfo.bind(this), this.getChainId = this.getChainId.bind(this), this.setAppInfo = this.setAppInfo.bind(this), this.enable = this.enable.bind(this), this.close = this.close.bind(this), this.send = this.send.bind(this), this.sendAsync = this.sendAsync.bind(this), this.request = this.request.bind(this), this._setAddresses = this._setAddresses.bind(this), this.scanQRCode = this.scanQRCode.bind(this), this.genericRequest = this.genericRequest.bind(this), this._chainIdFromOpts = e.chainId, this._jsonRpcUrlFromOpts = e.jsonRpcUrl, this._overrideIsMetaMask = e.overrideIsMetaMask, this._relayProvider = e.relayProvider, this._storage = e.storage, this._relayEventManager = e.relayEventManager, this.diagnostic = e.diagnosticLogger, this.reloadOnDisconnect = !0, this.isCoinbaseWallet = (n = e.overrideIsCoinbaseWallet) !== null && n !== void 0 ? n : !0, this.isCoinbaseBrowser = (r = e.overrideIsCoinbaseBrowser) !== null && r !== void 0 ? r : !1, this.qrUrl = e.qrUrl;
        const i = this.getChainId(),
            s = (0, Bn.prepend0x)(i.toString(16));
        this.emit("connect", {
            chainIdStr: s
        });
        const o = this._storage.getItem(iY.LOCAL_STORAGE_ADDRESSES_KEY);
        if (o) {
            const a = o.split(" ");
            a[0] !== "" && (this._addresses = a.map(l => (0, Bn.ensureAddressString)(l)), this.emit("accountsChanged", a))
        }
        this._subscriptionManager.events.on("notification", a => {
            this.emit("message", {
                type: a.method,
                data: a.params
            })
        }), this._isAuthorized() && this.initializeRelay(), window.addEventListener("message", a => {
            var l;
            if (!(a.origin !== location.origin || a.source !== window) && a.data.type === "walletLinkMessage") {
                if (a.data.data.action === "dappChainSwitched") {
                    const c = a.data.data.chainId,
                        u = (l = a.data.data.jsonRpcUrl) !== null && l !== void 0 ? l : this.jsonRpcUrl;
                    this.updateProviderInfo(u, Number(c))
                }
                a.data.data.action === "addressChanged" && this._setAddresses([a.data.data.address])
            }
        })
    }
    get selectedAddress() {
        return this._addresses[0] || void 0
    }
    get networkVersion() {
        return this.getChainId().toString(10)
    }
    get chainId() {
        return (0, Bn.prepend0x)(this.getChainId().toString(16))
    }
    get isWalletLink() {
        return !0
    }
    get isMetaMask() {
        return this._overrideIsMetaMask
    }
    get host() {
        return this.jsonRpcUrl
    }
    get connected() {
        return !0
    }
    isConnected() {
        return !0
    }
    get jsonRpcUrl() {
        var e;
        return (e = this._storage.getItem(oY)) !== null && e !== void 0 ? e : this._jsonRpcUrlFromOpts
    }
    set jsonRpcUrl(e) {
        this._storage.setItem(oY, e)
    }
    disableReloadOnDisconnect() {
        this.reloadOnDisconnect = !1
    }
    setProviderInfo(e, n) {
        this.isCoinbaseBrowser || (this._chainIdFromOpts = n, this._jsonRpcUrlFromOpts = e), this.updateProviderInfo(this.jsonRpcUrl, this.getChainId())
    }
    updateProviderInfo(e, n) {
        this.jsonRpcUrl = e;
        const r = this.getChainId();
        this._storage.setItem(sY, n.toString(10)), ((0, Bn.ensureIntNumber)(n) !== r || !this.hasMadeFirstChainChangedEmission) && (this.emit("chainChanged", this.getChainId()), this.hasMadeFirstChainChangedEmission = !0)
    }
    async watchAsset(e, n, r, i, s, o) {
        return !!(await (await this.initializeRelay()).watchAsset(e, n, r, i, s, o == null ? void 0 : o.toString()).promise).result
    }
    async addEthereumChain(e, n, r, i, s, o) {
        var a, l;
        if ((0, Bn.ensureIntNumber)(e) === this.getChainId()) return !1;
        const c = await this.initializeRelay(),
            u = c.inlineAddEthereumChain(e.toString());
        !this._isAuthorized() && !u && await c.requestEthereumAccounts().promise;
        const f = await c.addEthereumChain(e.toString(), n, s, r, i, o).promise;
        return ((a = f.result) === null || a === void 0 ? void 0 : a.isApproved) === !0 && this.updateProviderInfo(n[0], e), ((l = f.result) === null || l === void 0 ? void 0 : l.isApproved) === !0
    }
    async switchEthereumChain(e) {
        const r = await (await this.initializeRelay()).switchEthereumChain(e.toString(10), this.selectedAddress || void 0).promise;
        if ((0, HWe.isErrorResponse)(r) && r.errorCode) throw r.errorCode === Hr.standardErrorCodes.provider.unsupportedChain ? Hr.standardErrors.provider.unsupportedChain(e) : Hr.standardErrors.provider.custom({
            message: r.errorMessage,
            code: r.errorCode
        });
        const i = r.result;
        i.isApproved && i.rpcUrl.length > 0 && this.updateProviderInfo(i.rpcUrl, e)
    }
    setAppInfo(e, n) {
        this.initializeRelay().then(r => r.setAppInfo(e, n))
    }
    async enable() {
        var e;
        return (e = this.diagnostic) === null || e === void 0 || e.log(fN.EVENTS.ETH_ACCOUNTS_STATE, {
            method: "provider::enable",
            addresses_length: this._addresses.length,
            sessionIdHash: this._relay ? rY.Session.hash(this._relay.session.id) : void 0
        }), this._isAuthorized() ? [...this._addresses] : await this.send(Cr.JSONRPCMethod.eth_requestAccounts)
    }
    async close() {
        (await this.initializeRelay()).resetAndReload()
    }
    send(e, n) {
        try {
            const r = this._send(e, n);
            if (r instanceof Promise) return r.catch(i => {
                throw (0, Hr.serializeError)(i, e)
            })
        } catch (r) {
            throw (0, Hr.serializeError)(r, e)
        }
    }
    _send(e, n) {
        if (typeof e == "string") {
            const i = e,
                s = Array.isArray(n) ? n : n !== void 0 ? [n] : [],
                o = {
                    jsonrpc: "2.0",
                    id: 0,
                    method: i,
                    params: s
                };
            return this._sendRequestAsync(o).then(a => a.result)
        }
        if (typeof n == "function") {
            const i = e,
                s = n;
            return this._sendAsync(i, s)
        }
        if (Array.isArray(e)) return e.map(s => this._sendRequest(s));
        const r = e;
        return this._sendRequest(r)
    }
    async sendAsync(e, n) {
        try {
            return this._sendAsync(e, n).catch(r => {
                throw (0, Hr.serializeError)(r, e)
            })
        } catch (r) {
            return Promise.reject((0, Hr.serializeError)(r, e))
        }
    }
    async _sendAsync(e, n) {
        if (typeof n != "function") throw new Error("callback is required");
        if (Array.isArray(e)) {
            const i = n;
            this._sendMultipleRequestsAsync(e).then(s => i(null, s)).catch(s => i(s, null));
            return
        }
        const r = n;
        return this._sendRequestAsync(e).then(i => r(null, i)).catch(i => r(i, null))
    }
    async request(e) {
        try {
            return this._request(e).catch(n => {
                throw (0, Hr.serializeError)(n, e.method)
            })
        } catch (n) {
            return Promise.reject((0, Hr.serializeError)(n, e.method))
        }
    }
    async _request(e) {
        if (!e || typeof e != "object" || Array.isArray(e)) throw Hr.standardErrors.rpc.invalidRequest({
            message: "Expected a single, non-array, object argument.",
            data: e
        });
        const {
            method: n,
            params: r
        } = e;
        if (typeof n != "string" || n.length === 0) throw Hr.standardErrors.rpc.invalidRequest({
            message: "'args.method' must be a non-empty string.",
            data: e
        });
        if (r !== void 0 && !Array.isArray(r) && (typeof r != "object" || r === null)) throw Hr.standardErrors.rpc.invalidRequest({
            message: "'args.params' must be an object or array if provided.",
            data: e
        });
        const i = r === void 0 ? [] : r,
            s = this._relayEventManager.makeRequestId();
        return (await this._sendRequestAsync({
            method: n,
            params: i,
            jsonrpc: "2.0",
            id: s
        })).result
    }
    async scanQRCode(e) {
        var n;
        const i = await (await this.initializeRelay()).scanQRCode((0, Bn.ensureRegExpString)(e)).promise;
        if (typeof i.result != "string") throw (0, Hr.serializeError)((n = i.errorMessage) !== null && n !== void 0 ? n : "result was not a string", dN.Web3Method.scanQRCode);
        return i.result
    }
    async genericRequest(e, n) {
        var r;
        const s = await (await this.initializeRelay()).genericRequest(e, n).promise;
        if (typeof s.result != "string") throw (0, Hr.serializeError)((r = s.errorMessage) !== null && r !== void 0 ? r : "result was not a string", dN.Web3Method.generic);
        return s.result
    }
    async selectProvider(e) {
        var n;
        const i = await (await this.initializeRelay()).selectProvider(e).promise;
        if (typeof i.result != "string") throw (0, Hr.serializeError)((n = i.errorMessage) !== null && n !== void 0 ? n : "result was not a string", dN.Web3Method.selectProvider);
        return i.result
    }
    supportsSubscriptions() {
        return !1
    }
    subscribe() {
        throw new Error("Subscriptions are not supported")
    }
    unsubscribe() {
        throw new Error("Subscriptions are not supported")
    }
    disconnect() {
        return !0
    }
    _sendRequest(e) {
        const n = {
                jsonrpc: "2.0",
                id: e.id
            },
            {
                method: r
            } = e;
        if (n.result = this._handleSynchronousMethods(e), n.result === void 0) throw new Error(`Coinbase Wallet does not support calling ${r} synchronously without a callback. Please provide a callback parameter to call ${r} asynchronously.`);
        return n
    }
    _setAddresses(e, n) {
        if (!Array.isArray(e)) throw new Error("addresses is not an array");
        const r = e.map(i => (0, Bn.ensureAddressString)(i));
        JSON.stringify(r) !== JSON.stringify(this._addresses) && (this._addresses = r, this.emit("accountsChanged", this._addresses), this._storage.setItem(iY.LOCAL_STORAGE_ADDRESSES_KEY, r.join(" ")))
    }
    _sendRequestAsync(e) {
        return new Promise((n, r) => {
            try {
                const i = this._handleSynchronousMethods(e);
                if (i !== void 0) return n({
                    jsonrpc: "2.0",
                    id: e.id,
                    result: i
                });
                const s = this._handleAsynchronousFilterMethods(e);
                if (s !== void 0) {
                    s.then(a => n(Object.assign(Object.assign({}, a), {
                        id: e.id
                    }))).catch(a => r(a));
                    return
                }
                const o = this._handleSubscriptionMethods(e);
                if (o !== void 0) {
                    o.then(a => n({
                        jsonrpc: "2.0",
                        id: e.id,
                        result: a.result
                    })).catch(a => r(a));
                    return
                }
            } catch (i) {
                return r(i)
            }
            this._handleAsynchronousMethods(e).then(i => i && n(Object.assign(Object.assign({}, i), {
                id: e.id
            }))).catch(i => r(i))
        })
    }
    _sendMultipleRequestsAsync(e) {
        return Promise.all(e.map(n => this._sendRequestAsync(n)))
    }
    _handleSynchronousMethods(e) {
        const {
            method: n
        } = e, r = e.params || [];
        switch (n) {
            case Cr.JSONRPCMethod.eth_accounts:
                return this._eth_accounts();
            case Cr.JSONRPCMethod.eth_coinbase:
                return this._eth_coinbase();
            case Cr.JSONRPCMethod.eth_uninstallFilter:
                return this._eth_uninstallFilter(r);
            case Cr.JSONRPCMethod.net_version:
                return this._net_version();
            case Cr.JSONRPCMethod.eth_chainId:
                return this._eth_chainId();
            default:
                return
        }
    }
    async _handleAsynchronousMethods(e) {
        const {
            method: n
        } = e, r = e.params || [];
        switch (n) {
            case Cr.JSONRPCMethod.eth_requestAccounts:
                return this._eth_requestAccounts();
            case Cr.JSONRPCMethod.eth_sign:
                return this._eth_sign(r);
            case Cr.JSONRPCMethod.eth_ecRecover:
                return this._eth_ecRecover(r);
            case Cr.JSONRPCMethod.personal_sign:
                return this._personal_sign(r);
            case Cr.JSONRPCMethod.personal_ecRecover:
                return this._personal_ecRecover(r);
            case Cr.JSONRPCMethod.eth_signTransaction:
                return this._eth_signTransaction(r);
            case Cr.JSONRPCMethod.eth_sendRawTransaction:
                return this._eth_sendRawTransaction(r);
            case Cr.JSONRPCMethod.eth_sendTransaction:
                return this._eth_sendTransaction(r);
            case Cr.JSONRPCMethod.eth_signTypedData_v1:
                return this._eth_signTypedData_v1(r);
            case Cr.JSONRPCMethod.eth_signTypedData_v2:
                return this._throwUnsupportedMethodError();
            case Cr.JSONRPCMethod.eth_signTypedData_v3:
                return this._eth_signTypedData_v3(r);
            case Cr.JSONRPCMethod.eth_signTypedData_v4:
            case Cr.JSONRPCMethod.eth_signTypedData:
                return this._eth_signTypedData_v4(r);
            case Cr.JSONRPCMethod.cbWallet_arbitrary:
                return this._cbwallet_arbitrary(r);
            case Cr.JSONRPCMethod.wallet_addEthereumChain:
                return this._wallet_addEthereumChain(r);
            case Cr.JSONRPCMethod.wallet_switchEthereumChain:
                return this._wallet_switchEthereumChain(r);
            case Cr.JSONRPCMethod.wallet_watchAsset:
                return this._wallet_watchAsset(r)
        }
        return (await this.initializeRelay()).makeEthereumJSONRPCRequest(e, this.jsonRpcUrl)
    }
    _handleAsynchronousFilterMethods(e) {
        const {
            method: n
        } = e, r = e.params || [];
        switch (n) {
            case Cr.JSONRPCMethod.eth_newFilter:
                return this._eth_newFilter(r);
            case Cr.JSONRPCMethod.eth_newBlockFilter:
                return this._eth_newBlockFilter();
            case Cr.JSONRPCMethod.eth_newPendingTransactionFilter:
                return this._eth_newPendingTransactionFilter();
            case Cr.JSONRPCMethod.eth_getFilterChanges:
                return this._eth_getFilterChanges(r);
            case Cr.JSONRPCMethod.eth_getFilterLogs:
                return this._eth_getFilterLogs(r)
        }
    }
    _handleSubscriptionMethods(e) {
        switch (e.method) {
            case Cr.JSONRPCMethod.eth_subscribe:
            case Cr.JSONRPCMethod.eth_unsubscribe:
                return this._subscriptionManager.handleRequest(e)
        }
    }
    _isKnownAddress(e) {
        try {
            const n = (0, Bn.ensureAddressString)(e);
            return this._addresses.map(i => (0, Bn.ensureAddressString)(i)).includes(n)
        } catch {}
        return !1
    }
    _ensureKnownAddress(e) {
        var n;
        if (!this._isKnownAddress(e)) throw (n = this.diagnostic) === null || n === void 0 || n.log(fN.EVENTS.UNKNOWN_ADDRESS_ENCOUNTERED), new Error("Unknown Ethereum address")
    }
    _prepareTransactionParams(e) {
        const n = e.from ? (0, Bn.ensureAddressString)(e.from) : this.selectedAddress;
        if (!n) throw new Error("Ethereum address is unavailable");
        this._ensureKnownAddress(n);
        const r = e.to ? (0, Bn.ensureAddressString)(e.to) : null,
            i = e.value != null ? (0, Bn.ensureBN)(e.value) : new jWe.default(0),
            s = e.data ? (0, Bn.ensureBuffer)(e.data) : Buffer.alloc(0),
            o = e.nonce != null ? (0, Bn.ensureIntNumber)(e.nonce) : null,
            a = e.gasPrice != null ? (0, Bn.ensureBN)(e.gasPrice) : null,
            l = e.maxFeePerGas != null ? (0, Bn.ensureBN)(e.maxFeePerGas) : null,
            c = e.maxPriorityFeePerGas != null ? (0, Bn.ensureBN)(e.maxPriorityFeePerGas) : null,
            u = e.gas != null ? (0, Bn.ensureBN)(e.gas) : null,
            f = this.getChainId();
        return {
            fromAddress: n,
            toAddress: r,
            weiValue: i,
            data: s,
            nonce: o,
            gasPriceInWei: a,
            maxFeePerGas: l,
            maxPriorityFeePerGas: c,
            gasLimit: u,
            chainId: f
        }
    }
    _isAuthorized() {
        return this._addresses.length > 0
    }
    _requireAuthorization() {
        if (!this._isAuthorized()) throw Hr.standardErrors.provider.unauthorized({})
    }
    _throwUnsupportedMethodError() {
        throw Hr.standardErrors.provider.unsupportedMethod({})
    }
    async _signEthereumMessage(e, n, r, i) {
        this._ensureKnownAddress(n);
        try {
            return {
                jsonrpc: "2.0",
                id: 0,
                result: (await (await this.initializeRelay()).signEthereumMessage(e, n, r, i).promise).result
            }
        } catch (s) {
            throw typeof s.message == "string" && s.message.match(/(denied|rejected)/i) ? Hr.standardErrors.provider.userRejectedRequest("User denied message signature") : s
        }
    }
    async _ethereumAddressFromSignedMessage(e, n, r) {
        return {
            jsonrpc: "2.0",
            id: 0,
            result: (await (await this.initializeRelay()).ethereumAddressFromSignedMessage(e, n, r).promise).result
        }
    }
    _eth_accounts() {
        return [...this._addresses]
    }
    _eth_coinbase() {
        return this.selectedAddress || null
    }
    _net_version() {
        return this.getChainId().toString(10)
    }
    _eth_chainId() {
        return (0, Bn.hexStringFromIntNumber)(this.getChainId())
    }
    getChainId() {
        const e = this._storage.getItem(sY);
        if (!e) return (0, Bn.ensureIntNumber)(this._chainIdFromOpts);
        const n = parseInt(e, 10);
        return (0, Bn.ensureIntNumber)(n)
    }
    async _eth_requestAccounts() {
        var e;
        if ((e = this.diagnostic) === null || e === void 0 || e.log(fN.EVENTS.ETH_ACCOUNTS_STATE, {
                method: "provider::_eth_requestAccounts",
                addresses_length: this._addresses.length,
                sessionIdHash: this._relay ? rY.Session.hash(this._relay.session.id) : void 0
            }), this._isAuthorized()) return Promise.resolve({
            jsonrpc: "2.0",
            id: 0,
            result: this._addresses
        });
        let n;
        try {
            n = await (await this.initializeRelay()).requestEthereumAccounts().promise
        } catch (r) {
            throw typeof r.message == "string" && r.message.match(/(denied|rejected)/i) ? Hr.standardErrors.provider.userRejectedRequest("User denied account authorization") : r
        }
        if (!n.result) throw new Error("accounts received is empty");
        return this._setAddresses(n.result), this.isCoinbaseBrowser || await this.switchEthereumChain(this.getChainId()), {
            jsonrpc: "2.0",
            id: 0,
            result: this._addresses
        }
    }
    _eth_sign(e) {
        this._requireAuthorization();
        const n = (0, Bn.ensureAddressString)(e[0]),
            r = (0, Bn.ensureBuffer)(e[1]);
        return this._signEthereumMessage(r, n, !1)
    }
    _eth_ecRecover(e) {
        const n = (0, Bn.ensureBuffer)(e[0]),
            r = (0, Bn.ensureBuffer)(e[1]);
        return this._ethereumAddressFromSignedMessage(n, r, !1)
    }
    _personal_sign(e) {
        this._requireAuthorization();
        const n = (0, Bn.ensureBuffer)(e[0]),
            r = (0, Bn.ensureAddressString)(e[1]);
        return this._signEthereumMessage(n, r, !0)
    }
    _personal_ecRecover(e) {
        const n = (0, Bn.ensureBuffer)(e[0]),
            r = (0, Bn.ensureBuffer)(e[1]);
        return this._ethereumAddressFromSignedMessage(n, r, !0)
    }
    async _eth_signTransaction(e) {
        this._requireAuthorization();
        const n = this._prepareTransactionParams(e[0] || {});
        try {
            return {
                jsonrpc: "2.0",
                id: 0,
                result: (await (await this.initializeRelay()).signEthereumTransaction(n).promise).result
            }
        } catch (r) {
            throw typeof r.message == "string" && r.message.match(/(denied|rejected)/i) ? Hr.standardErrors.provider.userRejectedRequest("User denied transaction signature") : r
        }
    }
    async _eth_sendRawTransaction(e) {
        const n = (0, Bn.ensureBuffer)(e[0]);
        return {
            jsonrpc: "2.0",
            id: 0,
            result: (await (await this.initializeRelay()).submitEthereumTransaction(n, this.getChainId()).promise).result
        }
    }
    async _eth_sendTransaction(e) {
        this._requireAuthorization();
        const n = this._prepareTransactionParams(e[0] || {});
        try {
            return {
                jsonrpc: "2.0",
                id: 0,
                result: (await (await this.initializeRelay()).signAndSubmitEthereumTransaction(n).promise).result
            }
        } catch (r) {
            throw typeof r.message == "string" && r.message.match(/(denied|rejected)/i) ? Hr.standardErrors.provider.userRejectedRequest("User denied transaction signature") : r
        }
    }
    async _eth_signTypedData_v1(e) {
        this._requireAuthorization();
        const n = (0, Bn.ensureParsedJSONObject)(e[0]),
            r = (0, Bn.ensureAddressString)(e[1]);
        this._ensureKnownAddress(r);
        const i = hN.default.hashForSignTypedDataLegacy({
                data: n
            }),
            s = JSON.stringify(n, null, 2);
        return this._signEthereumMessage(i, r, !1, s)
    }
    async _eth_signTypedData_v3(e) {
        this._requireAuthorization();
        const n = (0, Bn.ensureAddressString)(e[0]),
            r = (0, Bn.ensureParsedJSONObject)(e[1]);
        this._ensureKnownAddress(n);
        const i = hN.default.hashForSignTypedData_v3({
                data: r
            }),
            s = JSON.stringify(r, null, 2);
        return this._signEthereumMessage(i, n, !1, s)
    }
    async _eth_signTypedData_v4(e) {
        this._requireAuthorization();
        const n = (0, Bn.ensureAddressString)(e[0]),
            r = (0, Bn.ensureParsedJSONObject)(e[1]);
        this._ensureKnownAddress(n);
        const i = hN.default.hashForSignTypedData_v4({
                data: r
            }),
            s = JSON.stringify(r, null, 2);
        return this._signEthereumMessage(i, n, !1, s)
    }
    async _cbwallet_arbitrary(e) {
        const n = e[0],
            r = e[1];
        if (typeof r != "string") throw new Error("parameter must be a string");
        if (typeof n != "object" || n === null) throw new Error("parameter must be an object");
        return {
            jsonrpc: "2.0",
            id: 0,
            result: await this.genericRequest(n, r)
        }
    }
    async _wallet_addEthereumChain(e) {
        var n, r, i, s;
        const o = e[0];
        if (((n = o.rpcUrls) === null || n === void 0 ? void 0 : n.length) === 0) return {
            jsonrpc: "2.0",
            id: 0,
            error: {
                code: 2,
                message: "please pass in at least 1 rpcUrl"
            }
        };
        if (!o.chainName || o.chainName.trim() === "") throw Hr.standardErrors.rpc.invalidParams("chainName is a required field");
        if (!o.nativeCurrency) throw Hr.standardErrors.rpc.invalidParams("nativeCurrency is a required field");
        const a = parseInt(o.chainId, 16);
        return await this.addEthereumChain(a, (r = o.rpcUrls) !== null && r !== void 0 ? r : [], (i = o.blockExplorerUrls) !== null && i !== void 0 ? i : [], o.chainName, (s = o.iconUrls) !== null && s !== void 0 ? s : [], o.nativeCurrency) ? {
            jsonrpc: "2.0",
            id: 0,
            result: null
        } : {
            jsonrpc: "2.0",
            id: 0,
            error: {
                code: 2,
                message: "unable to add ethereum chain"
            }
        }
    }
    async _wallet_switchEthereumChain(e) {
        const n = e[0];
        return await this.switchEthereumChain(parseInt(n.chainId, 16)), {
            jsonrpc: "2.0",
            id: 0,
            result: null
        }
    }
    async _wallet_watchAsset(e) {
        const n = Array.isArray(e) ? e[0] : e;
        if (!n.type) throw Hr.standardErrors.rpc.invalidParams("Type is required");
        if ((n == null ? void 0 : n.type) !== "ERC20") throw Hr.standardErrors.rpc.invalidParams(`Asset of type '${n.type}' is not supported`);
        if (!(n != null && n.options)) throw Hr.standardErrors.rpc.invalidParams("Options are required");
        if (!(n != null && n.options.address)) throw Hr.standardErrors.rpc.invalidParams("Address is required");
        const r = this.getChainId(),
            {
                address: i,
                symbol: s,
                image: o,
                decimals: a
            } = n.options;
        return {
            jsonrpc: "2.0",
            id: 0,
            result: await this.watchAsset(n.type, i, s, a, o, r)
        }
    }
    _eth_uninstallFilter(e) {
        const n = (0, Bn.ensureHexString)(e[0]);
        return this._filterPolyfill.uninstallFilter(n)
    }
    async _eth_newFilter(e) {
        const n = e[0];
        return {
            jsonrpc: "2.0",
            id: 0,
            result: await this._filterPolyfill.newFilter(n)
        }
    }
    async _eth_newBlockFilter() {
        return {
            jsonrpc: "2.0",
            id: 0,
            result: await this._filterPolyfill.newBlockFilter()
        }
    }
    async _eth_newPendingTransactionFilter() {
        return {
            jsonrpc: "2.0",
            id: 0,
            result: await this._filterPolyfill.newPendingTransactionFilter()
        }
    }
    _eth_getFilterChanges(e) {
        const n = (0, Bn.ensureHexString)(e[0]);
        return this._filterPolyfill.getFilterChanges(n)
    }
    _eth_getFilterLogs(e) {
        const n = (0, Bn.ensureHexString)(e[0]);
        return this._filterPolyfill.getFilterLogs(n)
    }
    initializeRelay() {
        return this._relay ? Promise.resolve(this._relay) : this._relayProvider().then(e => (e.setAccountsCallback((n, r) => this._setAddresses(n, r)), e.setChainCallback((n, r) => {
            this.updateProviderInfo(r, parseInt(n, 10))
        }), e.setDappDefaultChainCallback(this._chainIdFromOpts), this._relay = e, e))
    }
}
Jb.CoinbaseWalletProvider = VWe;
var F9 = {},
    U9 = {},
    t4, Jr, uae, fae, t1, aY, dae, _M, PB, EM, xM, hae, c6 = {},
    pae = [],
    GWe = /acit|ex(?:s|g|n|p|$)|rph|grid|ows|mnc|ntw|ine[ch]|zoo|^ord|itera/i,
    j9 = Array.isArray;

function ch(t, e) {
    for (var n in e) t[n] = e[n];
    return t
}

function gae(t) {
    t && t.parentNode && t.parentNode.removeChild(t)
}

function SM(t, e, n) {
    var r, i, s, o = {};
    for (s in e) s == "key" ? r = e[s] : s == "ref" ? i = e[s] : o[s] = e[s];
    if (arguments.length > 2 && (o.children = arguments.length > 3 ? t4.call(arguments, 2) : n), typeof t == "function" && t.defaultProps != null)
        for (s in t.defaultProps) o[s] === void 0 && (o[s] = t.defaultProps[s]);
    return Y3(t, o, r, i, null)
}

function Y3(t, e, n, r, i) {
    var s = {
        type: t,
        props: e,
        key: n,
        ref: r,
        __k: null,
        __: null,
        __b: 0,
        __e: null,
        __d: void 0,
        __c: null,
        constructor: void 0,
        __v: i ? ? ++uae,
        __i: -1,
        __u: 0
    };
    return i == null && Jr.vnode != null && Jr.vnode(s), s
}

function qWe() {
    return {
        current: null
    }
}

function n4(t) {
    return t.children
}

function Z3(t, e) {
    this.props = t, this.context = e
}

function a2(t, e) {
    if (e == null) return t.__ ? a2(t.__, t.__i + 1) : null;
    for (var n; e < t.__k.length; e++)
        if ((n = t.__k[e]) != null && n.__e != null) return n.__e;
    return typeof t.type == "function" ? a2(t) : null
}

function mae(t) {
    var e, n;
    if ((t = t.__) != null && t.__c != null) {
        for (t.__e = t.__c.base = null, e = 0; e < t.__k.length; e++)
            if ((n = t.__k[e]) != null && n.__e != null) {
                t.__e = t.__c.base = n.__e;
                break
            }
        return mae(t)
    }
}

function CM(t) {
    (!t.__d && (t.__d = !0) && t1.push(t) && !eA.__r++ || aY !== Jr.debounceRendering) && ((aY = Jr.debounceRendering) || dae)(eA)
}

function eA() {
    var t, e, n, r, i, s, o, a;
    for (t1.sort(_M); t = t1.shift();) t.__d && (e = t1.length, r = void 0, s = (i = (n = t).__v).__e, o = [], a = [], n.__P && ((r = ch({}, i)).__v = i.__v + 1, Jr.vnode && Jr.vnode(r), kB(n.__P, r, i, n.__n, n.__P.namespaceURI, 32 & i.__u ? [s] : null, o, s ? ? a2(i), !!(32 & i.__u), a), r.__v = i.__v, r.__.__k[r.__i] = r, bae(o, r, a), r.__e != s && mae(r)), t1.length > e && t1.sort(_M));
    eA.__r = 0
}

function yae(t, e, n, r, i, s, o, a, l, c, u) {
    var f, h, g, y, _, C = r && r.__k || pae,
        b = e.length;
    for (n.__d = l, KWe(n, e, C), l = n.__d, f = 0; f < b; f++)(g = n.__k[f]) != null && (h = g.__i === -1 ? c6 : C[g.__i] || c6, g.__i = f, kB(t, g, h, i, s, o, a, l, c, u), y = g.__e, g.ref && h.ref != g.ref && (h.ref && MB(h.ref, null, g), u.push(g.ref, g.__c || y, g)), _ == null && y != null && (_ = y), 65536 & g.__u || h.__k === g.__k ? l = wae(g, l, t) : typeof g.type == "function" && g.__d !== void 0 ? l = g.__d : y && (l = y.nextSibling), g.__d = void 0, g.__u &= -196609);
    n.__d = l, n.__e = _
}

function KWe(t, e, n) {
    var r, i, s, o, a, l = e.length,
        c = n.length,
        u = c,
        f = 0;
    for (t.__k = [], r = 0; r < l; r++)(i = e[r]) != null && typeof i != "boolean" && typeof i != "function" ? (o = r + f, (i = t.__k[r] = typeof i == "string" || typeof i == "number" || typeof i == "bigint" || i.constructor == String ? Y3(null, i, null, null, null) : j9(i) ? Y3(n4, {
        children: i
    }, null, null, null) : i.constructor === void 0 && i.__b > 0 ? Y3(i.type, i.props, i.key, i.ref ? i.ref : null, i.__v) : i).__ = t, i.__b = t.__b + 1, s = null, (a = i.__i = YWe(i, n, o, u)) !== -1 && (u--, (s = n[a]) && (s.__u |= 131072)), s == null || s.__v === null ? (a == -1 && f--, typeof i.type != "function" && (i.__u |= 65536)) : a !== o && (a == o - 1 ? f-- : a == o + 1 ? f++ : (a > o ? f-- : f++, i.__u |= 65536))) : i = t.__k[r] = null;
    if (u)
        for (r = 0; r < c; r++)(s = n[r]) != null && !(131072 & s.__u) && (s.__e == t.__d && (t.__d = a2(s)), _ae(s, s))
}

function wae(t, e, n) {
    var r, i;
    if (typeof t.type == "function") {
        for (r = t.__k, i = 0; r && i < r.length; i++) r[i] && (r[i].__ = t, e = wae(r[i], e, n));
        return e
    }
    t.__e != e && (e && t.type && !n.contains(e) && (e = a2(t)), n.insertBefore(t.__e, e || null), e = t.__e);
    do e = e && e.nextSibling; while (e != null && e.nodeType === 8);
    return e
}

function vae(t, e) {
    return e = e || [], t == null || typeof t == "boolean" || (j9(t) ? t.some(function(n) {
        vae(n, e)
    }) : e.push(t)), e
}

function YWe(t, e, n, r) {
    var i = t.key,
        s = t.type,
        o = n - 1,
        a = n + 1,
        l = e[n];
    if (l === null || l && i == l.key && s === l.type && !(131072 & l.__u)) return n;
    if (r > (l != null && !(131072 & l.__u) ? 1 : 0))
        for (; o >= 0 || a < e.length;) {
            if (o >= 0) {
                if ((l = e[o]) && !(131072 & l.__u) && i == l.key && s === l.type) return o;
                o--
            }
            if (a < e.length) {
                if ((l = e[a]) && !(131072 & l.__u) && i == l.key && s === l.type) return a;
                a++
            }
        }
    return -1
}

function lY(t, e, n) {
    e[0] === "-" ? t.setProperty(e, n ? ? "") : t[e] = n == null ? "" : typeof n != "number" || GWe.test(e) ? n : n + "px"
}

function uS(t, e, n, r, i) {
    var s;
    e: if (e === "style")
        if (typeof n == "string") t.style.cssText = n;
        else {
            if (typeof r == "string" && (t.style.cssText = r = ""), r)
                for (e in r) n && e in n || lY(t.style, e, "");
            if (n)
                for (e in n) r && n[e] === r[e] || lY(t.style, e, n[e])
        }
    else if (e[0] === "o" && e[1] === "n") s = e !== (e = e.replace(/(PointerCapture)$|Capture$/i, "$1")), e = e.toLowerCase() in t || e === "onFocusOut" || e === "onFocusIn" ? e.toLowerCase().slice(2) : e.slice(2), t.l || (t.l = {}), t.l[e + s] = n, n ? r ? n.u = r.u : (n.u = PB, t.addEventListener(e, s ? xM : EM, s)) : t.removeEventListener(e, s ? xM : EM, s);
    else {
        if (i == "http://www.w3.org/2000/svg") e = e.replace(/xlink(H|:h)/, "h").replace(/sName$/, "s");
        else if (e != "width" && e != "height" && e != "href" && e != "list" && e != "form" && e != "tabIndex" && e != "download" && e != "rowSpan" && e != "colSpan" && e != "role" && e != "popover" && e in t) try {
            t[e] = n ? ? "";
            break e
        } catch {}
        typeof n == "function" || (n == null || n === !1 && e[4] !== "-" ? t.removeAttribute(e) : t.setAttribute(e, e == "popover" && n == 1 ? "" : n))
    }
}

function cY(t) {
    return function(e) {
        if (this.l) {
            var n = this.l[e.type + t];
            if (e.t == null) e.t = PB++;
            else if (e.t < n.u) return;
            return n(Jr.event ? Jr.event(e) : e)
        }
    }
}

function kB(t, e, n, r, i, s, o, a, l, c) {
    var u, f, h, g, y, _, C, b, w, S, I, P, M, A, E, $, H = e.type;
    if (e.constructor !== void 0) return null;
    128 & n.__u && (l = !!(32 & n.__u), s = [a = e.__e = n.__e]), (u = Jr.__b) && u(e);
    e: if (typeof H == "function") try {
        if (b = e.props, w = "prototype" in H && H.prototype.render, S = (u = H.contextType) && r[u.__c], I = u ? S ? S.props.value : u.__ : r, n.__c ? C = (f = e.__c = n.__c).__ = f.__E : (w ? e.__c = f = new H(b, I) : (e.__c = f = new Z3(b, I), f.constructor = H, f.render = QWe), S && S.sub(f), f.props = b, f.state || (f.state = {}), f.context = I, f.__n = r, h = f.__d = !0, f.__h = [], f._sb = []), w && f.__s == null && (f.__s = f.state), w && H.getDerivedStateFromProps != null && (f.__s == f.state && (f.__s = ch({}, f.__s)), ch(f.__s, H.getDerivedStateFromProps(b, f.__s))), g = f.props, y = f.state, f.__v = e, h) w && H.getDerivedStateFromProps == null && f.componentWillMount != null && f.componentWillMount(), w && f.componentDidMount != null && f.__h.push(f.componentDidMount);
        else {
            if (w && H.getDerivedStateFromProps == null && b !== g && f.componentWillReceiveProps != null && f.componentWillReceiveProps(b, I), !f.__e && (f.shouldComponentUpdate != null && f.shouldComponentUpdate(b, f.__s, I) === !1 || e.__v === n.__v)) {
                for (e.__v !== n.__v && (f.props = b, f.state = f.__s, f.__d = !1), e.__e = n.__e, e.__k = n.__k, e.__k.some(function(K) {
                        K && (K.__ = e)
                    }), P = 0; P < f._sb.length; P++) f.__h.push(f._sb[P]);
                f._sb = [], f.__h.length && o.push(f);
                break e
            }
            f.componentWillUpdate != null && f.componentWillUpdate(b, f.__s, I), w && f.componentDidUpdate != null && f.__h.push(function() {
                f.componentDidUpdate(g, y, _)
            })
        }
        if (f.context = I, f.props = b, f.__P = t, f.__e = !1, M = Jr.__r, A = 0, w) {
            for (f.state = f.__s, f.__d = !1, M && M(e), u = f.render(f.props, f.state, f.context), E = 0; E < f._sb.length; E++) f.__h.push(f._sb[E]);
            f._sb = []
        } else
            do f.__d = !1, M && M(e), u = f.render(f.props, f.state, f.context), f.state = f.__s; while (f.__d && ++A < 25);
        f.state = f.__s, f.getChildContext != null && (r = ch(ch({}, r), f.getChildContext())), w && !h && f.getSnapshotBeforeUpdate != null && (_ = f.getSnapshotBeforeUpdate(g, y)), yae(t, j9($ = u != null && u.type === n4 && u.key == null ? u.props.children : u) ? $ : [$], e, n, r, i, s, o, a, l, c), f.base = e.__e, e.__u &= -161, f.__h.length && o.push(f), C && (f.__E = f.__ = null)
    } catch (K) {
        if (e.__v = null, l || s != null) {
            for (e.__u |= l ? 160 : 32; a && a.nodeType === 8 && a.nextSibling;) a = a.nextSibling;
            s[s.indexOf(a)] = null, e.__e = a
        } else e.__e = n.__e, e.__k = n.__k;
        Jr.__e(K, e, n)
    } else s == null && e.__v === n.__v ? (e.__k = n.__k, e.__e = n.__e) : e.__e = ZWe(n.__e, e, n, r, i, s, o, l, c);
    (u = Jr.diffed) && u(e)
}

function bae(t, e, n) {
    e.__d = void 0;
    for (var r = 0; r < n.length; r++) MB(n[r], n[++r], n[++r]);
    Jr.__c && Jr.__c(e, t), t.some(function(i) {
        try {
            t = i.__h, i.__h = [], t.some(function(s) {
                s.call(i)
            })
        } catch (s) {
            Jr.__e(s, i.__v)
        }
    })
}

function ZWe(t, e, n, r, i, s, o, a, l) {
    var c, u, f, h, g, y, _, C = n.props,
        b = e.props,
        w = e.type;
    if (w === "svg" ? i = "http://www.w3.org/2000/svg" : w === "math" ? i = "http://www.w3.org/1998/Math/MathML" : i || (i = "http://www.w3.org/1999/xhtml"), s != null) {
        for (c = 0; c < s.length; c++)
            if ((g = s[c]) && "setAttribute" in g == !!w && (w ? g.localName === w : g.nodeType === 3)) {
                t = g, s[c] = null;
                break
            }
    }
    if (t == null) {
        if (w === null) return document.createTextNode(b);
        t = document.createElementNS(i, w, b.is && b), a && (Jr.__m && Jr.__m(e, s), a = !1), s = null
    }
    if (w === null) C === b || a && t.data === b || (t.data = b);
    else {
        if (s = s && t4.call(t.childNodes), C = n.props || c6, !a && s != null)
            for (C = {}, c = 0; c < t.attributes.length; c++) C[(g = t.attributes[c]).name] = g.value;
        for (c in C)
            if (g = C[c], c != "children") {
                if (c == "dangerouslySetInnerHTML") f = g;
                else if (!(c in b)) {
                    if (c == "value" && "defaultValue" in b || c == "checked" && "defaultChecked" in b) continue;
                    uS(t, c, null, g, i)
                }
            }
        for (c in b) g = b[c], c == "children" ? h = g : c == "dangerouslySetInnerHTML" ? u = g : c == "value" ? y = g : c == "checked" ? _ = g : a && typeof g != "function" || C[c] === g || uS(t, c, g, C[c], i);
        if (u) a || f && (u.__html === f.__html || u.__html === t.innerHTML) || (t.innerHTML = u.__html), e.__k = [];
        else if (f && (t.innerHTML = ""), yae(t, j9(h) ? h : [h], e, n, r, w === "foreignObject" ? "http://www.w3.org/1999/xhtml" : i, s, o, s ? s[0] : n.__k && a2(n, 0), a, l), s != null)
            for (c = s.length; c--;) gae(s[c]);
        a || (c = "value", w === "progress" && y == null ? t.removeAttribute("value") : y !== void 0 && (y !== t[c] || w === "progress" && !y || w === "option" && y !== C[c]) && uS(t, c, y, C[c], i), c = "checked", _ !== void 0 && _ !== t[c] && uS(t, c, _, C[c], i))
    }
    return t
}

function MB(t, e, n) {
    try {
        if (typeof t == "function") {
            var r = typeof t.__u == "function";
            r && t.__u(), r && e == null || (t.__u = t(e))
        } else t.current = e
    } catch (i) {
        Jr.__e(i, n)
    }
}

function _ae(t, e, n) {
    var r, i;
    if (Jr.unmount && Jr.unmount(t), (r = t.ref) && (r.current && r.current !== t.__e || MB(r, null, e)), (r = t.__c) != null) {
        if (r.componentWillUnmount) try {
            r.componentWillUnmount()
        } catch (s) {
            Jr.__e(s, e)
        }
        r.base = r.__P = null
    }
    if (r = t.__k)
        for (i = 0; i < r.length; i++) r[i] && _ae(r[i], e, n || typeof t.type != "function");
    n || gae(t.__e), t.__c = t.__ = t.__e = t.__d = void 0
}

function QWe(t, e, n) {
    return this.constructor(t, n)
}

function Eae(t, e, n) {
    var r, i, s, o;
    Jr.__ && Jr.__(t, e), i = (r = typeof n == "function") ? null : n && n.__k || e.__k, s = [], o = [], kB(e, t = (!r && n || e).__k = SM(n4, null, [t]), i || c6, c6, e.namespaceURI, !r && n ? [n] : i ? null : e.firstChild ? t4.call(e.childNodes) : null, s, !r && n ? n : i ? i.__e : e.firstChild, r, o), bae(s, t, o)
}

function xae(t, e) {
    Eae(t, e, xae)
}

function JWe(t, e, n) {
    var r, i, s, o, a = ch({}, t.props);
    for (s in t.type && t.type.defaultProps && (o = t.type.defaultProps), e) s == "key" ? r = e[s] : s == "ref" ? i = e[s] : a[s] = e[s] === void 0 && o !== void 0 ? o[s] : e[s];
    return arguments.length > 2 && (a.children = arguments.length > 3 ? t4.call(arguments, 2) : n), Y3(t.type, a, r || t.key, i || t.ref, null)
}

function XWe(t, e) {
    var n = {
        __c: e = "__cC" + hae++,
        __: t,
        Consumer: function(r, i) {
            return r.children(i)
        },
        Provider: function(r) {
            var i, s;
            return this.getChildContext || (i = [], (s = {})[e] = this, this.getChildContext = function() {
                return s
            }, this.componentWillUnmount = function() {
                i = null
            }, this.shouldComponentUpdate = function(o) {
                this.props.value !== o.value && i.some(function(a) {
                    a.__e = !0, CM(a)
                })
            }, this.sub = function(o) {
                i.push(o);
                var a = o.componentWillUnmount;
                o.componentWillUnmount = function() {
                    i && i.splice(i.indexOf(o), 1), a && a.call(o)
                }
            }), r.children
        }
    };
    return n.Provider.__ = n.Consumer.contextType = n
}
t4 = pae.slice, Jr = {
    __e: function(t, e, n, r) {
        for (var i, s, o; e = e.__;)
            if ((i = e.__c) && !i.__) try {
                if ((s = i.constructor) && s.getDerivedStateFromError != null && (i.setState(s.getDerivedStateFromError(t)), o = i.__d), i.componentDidCatch != null && (i.componentDidCatch(t, r || {}), o = i.__d), o) return i.__E = i
            } catch (a) {
                t = a
            }
        throw t
    }
}, uae = 0, fae = function(t) {
    return t != null && t.constructor == null
}, Z3.prototype.setState = function(t, e) {
    var n;
    n = this.__s != null && this.__s !== this.state ? this.__s : this.__s = ch({}, this.state), typeof t == "function" && (t = t(ch({}, n), this.props)), t && ch(n, t), t != null && this.__v && (e && this._sb.push(e), CM(this))
}, Z3.prototype.forceUpdate = function(t) {
    this.__v && (this.__e = !0, t && this.__h.push(t), CM(this))
}, Z3.prototype.render = n4, t1 = [], dae = typeof Promise == "function" ? Promise.prototype.then.bind(Promise.resolve()) : setTimeout, _M = function(t, e) {
    return t.__v.__b - e.__v.__b
}, eA.__r = 0, PB = 0, EM = cY(!1), xM = cY(!0), hae = 0;
const eVe = Object.freeze(Object.defineProperty({
        __proto__: null,
        Component: Z3,
        Fragment: n4,
        cloneElement: JWe,
        createContext: XWe,
        createElement: SM,
        createRef: qWe,
        h: SM,
        hydrate: xae,
        get isValidElement() {
            return fae
        },
        get options() {
            return Jr
        },
        render: Eae,
        toChildArray: vae
    }, Symbol.toStringTag, {
        value: "Module"
    })),
    Dl = Fu(eVe);

function l2(t) {
    return typeof t == "function"
}
var uY = !1,
    mc = {
        Promise: void 0,
        set useDeprecatedSynchronousErrorHandling(t) {
            if (t) {
                var e = new Error;
                "" + e.stack
            }
            uY = t
        },
        get useDeprecatedSynchronousErrorHandling() {
            return uY
        }
    };

function Pw(t) {
    setTimeout(function() {
        throw t
    }, 0)
}
var tA = {
        closed: !0,
        next: function(t) {},
        error: function(t) {
            if (mc.useDeprecatedSynchronousErrorHandling) throw t;
            Pw(t)
        },
        complete: function() {}
    },
    pa = function() {
        return Array.isArray || function(t) {
            return t && typeof t.length == "number"
        }
    }();

function DB(t) {
    return t !== null && typeof t == "object"
}
var tVe = function() {
        function t(e) {
            return Error.call(this), this.message = e ? e.length + ` errors occurred during unsubscription:
` + e.map(function(n, r) {
                return r + 1 + ") " + n.toString()
            }).join(`
  `) : "", this.name = "UnsubscriptionError", this.errors = e, this
        }
        return t.prototype = Object.create(Error.prototype), t
    }(),
    Q3 = tVe,
    ki = function() {
        function t(e) {
            this.closed = !1, this._parentOrParents = null, this._subscriptions = null, e && (this._ctorUnsubscribe = !0, this._unsubscribe = e)
        }
        return t.prototype.unsubscribe = function() {
            var e;
            if (!this.closed) {
                var n = this,
                    r = n._parentOrParents,
                    i = n._ctorUnsubscribe,
                    s = n._unsubscribe,
                    o = n._subscriptions;
                if (this.closed = !0, this._parentOrParents = null, this._subscriptions = null, r instanceof t) r.remove(this);
                else if (r !== null)
                    for (var a = 0; a < r.length; ++a) {
                        var l = r[a];
                        l.remove(this)
                    }
                if (l2(s)) {
                    i && (this._unsubscribe = void 0);
                    try {
                        s.call(this)
                    } catch (f) {
                        e = f instanceof Q3 ? fY(f.errors) : [f]
                    }
                }
                if (pa(o))
                    for (var a = -1, c = o.length; ++a < c;) {
                        var u = o[a];
                        if (DB(u)) try {
                            u.unsubscribe()
                        } catch (h) {
                            e = e || [], h instanceof Q3 ? e = e.concat(fY(h.errors)) : e.push(h)
                        }
                    }
                if (e) throw new Q3(e)
            }
        }, t.prototype.add = function(e) {
            var n = e;
            if (!e) return t.EMPTY;
            switch (typeof e) {
                case "function":
                    n = new t(e);
                case "object":
                    if (n === this || n.closed || typeof n.unsubscribe != "function") return n;
                    if (this.closed) return n.unsubscribe(), n;
                    if (!(n instanceof t)) {
                        var r = n;
                        n = new t, n._subscriptions = [r]
                    }
                    break;
                default:
                    throw new Error("unrecognized teardown " + e + " added to Subscription.")
            }
            var i = n._parentOrParents;
            if (i === null) n._parentOrParents = this;
            else if (i instanceof t) {
                if (i === this) return n;
                n._parentOrParents = [i, this]
            } else if (i.indexOf(this) === -1) i.push(this);
            else return n;
            var s = this._subscriptions;
            return s === null ? this._subscriptions = [n] : s.push(n), n
        }, t.prototype.remove = function(e) {
            var n = this._subscriptions;
            if (n) {
                var r = n.indexOf(e);
                r !== -1 && n.splice(r, 1)
            }
        }, t.EMPTY = function(e) {
            return e.closed = !0, e
        }(new t), t
    }();

function fY(t) {
    return t.reduce(function(e, n) {
        return e.concat(n instanceof Q3 ? n.errors : n)
    }, [])
}
var nA = function() {
        return typeof Symbol == "function" ? Symbol("rxSubscriber") : "@@rxSubscriber_" + Math.random()
    }(),
    Gt = function(t) {
        Ve(e, t);

        function e(n, r, i) {
            var s = t.call(this) || this;
            switch (s.syncErrorValue = null, s.syncErrorThrown = !1, s.syncErrorThrowable = !1, s.isStopped = !1, arguments.length) {
                case 0:
                    s.destination = tA;
                    break;
                case 1:
                    if (!n) {
                        s.destination = tA;
                        break
                    }
                    if (typeof n == "object") {
                        n instanceof e ? (s.syncErrorThrowable = n.syncErrorThrowable, s.destination = n, n.add(s)) : (s.syncErrorThrowable = !0, s.destination = new dY(s, n));
                        break
                    }
                default:
                    s.syncErrorThrowable = !0, s.destination = new dY(s, n, r, i);
                    break
            }
            return s
        }
        return e.prototype[nA] = function() {
            return this
        }, e.create = function(n, r, i) {
            var s = new e(n, r, i);
            return s.syncErrorThrowable = !1, s
        }, e.prototype.next = function(n) {
            this.isStopped || this._next(n)
        }, e.prototype.error = function(n) {
            this.isStopped || (this.isStopped = !0, this._error(n))
        }, e.prototype.complete = function() {
            this.isStopped || (this.isStopped = !0, this._complete())
        }, e.prototype.unsubscribe = function() {
            this.closed || (this.isStopped = !0, t.prototype.unsubscribe.call(this))
        }, e.prototype._next = function(n) {
            this.destination.next(n)
        }, e.prototype._error = function(n) {
            this.destination.error(n), this.unsubscribe()
        }, e.prototype._complete = function() {
            this.destination.complete(), this.unsubscribe()
        }, e.prototype._unsubscribeAndRecycle = function() {
            var n = this._parentOrParents;
            return this._parentOrParents = null, this.unsubscribe(), this.closed = !1, this.isStopped = !1, this._parentOrParents = n, this
        }, e
    }(ki),
    dY = function(t) {
        Ve(e, t);

        function e(n, r, i, s) {
            var o = t.call(this) || this;
            o._parentSubscriber = n;
            var a, l = o;
            return l2(r) ? a = r : r && (a = r.next, i = r.error, s = r.complete, r !== tA && (l = Object.create(r), l2(l.unsubscribe) && o.add(l.unsubscribe.bind(l)), l.unsubscribe = o.unsubscribe.bind(o))), o._context = l, o._next = a, o._error = i, o._complete = s, o
        }
        return e.prototype.next = function(n) {
            if (!this.isStopped && this._next) {
                var r = this._parentSubscriber;
                !mc.useDeprecatedSynchronousErrorHandling || !r.syncErrorThrowable ? this.__tryOrUnsub(this._next, n) : this.__tryOrSetError(r, this._next, n) && this.unsubscribe()
            }
        }, e.prototype.error = function(n) {
            if (!this.isStopped) {
                var r = this._parentSubscriber,
                    i = mc.useDeprecatedSynchronousErrorHandling;
                if (this._error) !i || !r.syncErrorThrowable ? (this.__tryOrUnsub(this._error, n), this.unsubscribe()) : (this.__tryOrSetError(r, this._error, n), this.unsubscribe());
                else if (r.syncErrorThrowable) i ? (r.syncErrorValue = n, r.syncErrorThrown = !0) : Pw(n), this.unsubscribe();
                else {
                    if (this.unsubscribe(), i) throw n;
                    Pw(n)
                }
            }
        }, e.prototype.complete = function() {
            var n = this;
            if (!this.isStopped) {
                var r = this._parentSubscriber;
                if (this._complete) {
                    var i = function() {
                        return n._complete.call(n._context)
                    };
                    !mc.useDeprecatedSynchronousErrorHandling || !r.syncErrorThrowable ? (this.__tryOrUnsub(i), this.unsubscribe()) : (this.__tryOrSetError(r, i), this.unsubscribe())
                } else this.unsubscribe()
            }
        }, e.prototype.__tryOrUnsub = function(n, r) {
            try {
                n.call(this._context, r)
            } catch (i) {
                if (this.unsubscribe(), mc.useDeprecatedSynchronousErrorHandling) throw i;
                Pw(i)
            }
        }, e.prototype.__tryOrSetError = function(n, r, i) {
            if (!mc.useDeprecatedSynchronousErrorHandling) throw new Error("bad call");
            try {
                r.call(this._context, i)
            } catch (s) {
                return mc.useDeprecatedSynchronousErrorHandling ? (n.syncErrorValue = s, n.syncErrorThrown = !0, !0) : (Pw(s), !0)
            }
            return !1
        }, e.prototype._unsubscribe = function() {
            var n = this._parentSubscriber;
            this._context = null, this._parentSubscriber = null, n.unsubscribe()
        }, e
    }(Gt);

function $B(t) {
    for (; t;) {
        var e = t,
            n = e.closed,
            r = e.destination,
            i = e.isStopped;
        if (n || i) return !1;
        r && r instanceof Gt ? t = r : t = null
    }
    return !0
}

function nVe(t, e, n) {
    if (t) {
        if (t instanceof Gt) return t;
        if (t[nA]) return t[nA]()
    }
    return !t && !e && !n ? new Gt(tA) : new Gt(t, e, n)
}
var V2 = function() {
    return typeof Symbol == "function" && Symbol.observable || "@@observable"
}();

function qp(t) {
    return t
}

function AM() {
    for (var t = [], e = 0; e < arguments.length; e++) t[e] = arguments[e];
    return Sae(t)
}

function Sae(t) {
    return t.length === 0 ? qp : t.length === 1 ? t[0] : function(n) {
        return t.reduce(function(r, i) {
            return i(r)
        }, n)
    }
}
var Fn = function() {
    function t(e) {
        this._isScalar = !1, e && (this._subscribe = e)
    }
    return t.prototype.lift = function(e) {
        var n = new t;
        return n.source = this, n.operator = e, n
    }, t.prototype.subscribe = function(e, n, r) {
        var i = this.operator,
            s = nVe(e, n, r);
        if (i ? s.add(i.call(s, this.source)) : s.add(this.source || mc.useDeprecatedSynchronousErrorHandling && !s.syncErrorThrowable ? this._subscribe(s) : this._trySubscribe(s)), mc.useDeprecatedSynchronousErrorHandling && s.syncErrorThrowable && (s.syncErrorThrowable = !1, s.syncErrorThrown)) throw s.syncErrorValue;
        return s
    }, t.prototype._trySubscribe = function(e) {
        try {
            return this._subscribe(e)
        } catch (n) {
            mc.useDeprecatedSynchronousErrorHandling && (e.syncErrorThrown = !0, e.syncErrorValue = n), $B(e) ? e.error(n) : console.warn(n)
        }
    }, t.prototype.forEach = function(e, n) {
        var r = this;
        return n = hY(n), new n(function(i, s) {
            var o;
            o = r.subscribe(function(a) {
                try {
                    e(a)
                } catch (l) {
                    s(l), o && o.unsubscribe()
                }
            }, s, i)
        })
    }, t.prototype._subscribe = function(e) {
        var n = this.source;
        return n && n.subscribe(e)
    }, t.prototype[V2] = function() {
        return this
    }, t.prototype.pipe = function() {
        for (var e = [], n = 0; n < arguments.length; n++) e[n] = arguments[n];
        return e.length === 0 ? this : Sae(e)(this)
    }, t.prototype.toPromise = function(e) {
        var n = this;
        return e = hY(e), new e(function(r, i) {
            var s;
            n.subscribe(function(o) {
                return s = o
            }, function(o) {
                return i(o)
            }, function() {
                return r(s)
            })
        })
    }, t.create = function(e) {
        return new t(e)
    }, t
}();

function hY(t) {
    if (t || (t = mc.Promise || Promise), !t) throw new Error("no Promise impl found");
    return t
}
var rVe = function() {
        function t() {
            return Error.call(this), this.message = "object unsubscribed", this.name = "ObjectUnsubscribedError", this
        }
        return t.prototype = Object.create(Error.prototype), t
    }(),
    M0 = rVe,
    Cae = function(t) {
        Ve(e, t);

        function e(n, r) {
            var i = t.call(this) || this;
            return i.subject = n, i.subscriber = r, i.closed = !1, i
        }
        return e.prototype.unsubscribe = function() {
            if (!this.closed) {
                this.closed = !0;
                var n = this.subject,
                    r = n.observers;
                if (this.subject = null, !(!r || r.length === 0 || n.isStopped || n.closed)) {
                    var i = r.indexOf(this.subscriber);
                    i !== -1 && r.splice(i, 1)
                }
            }
        }, e
    }(ki),
    Aae = function(t) {
        Ve(e, t);

        function e(n) {
            var r = t.call(this, n) || this;
            return r.destination = n, r
        }
        return e
    }(Gt),
    Qs = function(t) {
        Ve(e, t);

        function e() {
            var n = t.call(this) || this;
            return n.observers = [], n.closed = !1, n.isStopped = !1, n.hasError = !1, n.thrownError = null, n
        }
        return e.prototype[nA] = function() {
            return new Aae(this)
        }, e.prototype.lift = function(n) {
            var r = new pY(this, this);
            return r.operator = n, r
        }, e.prototype.next = function(n) {
            if (this.closed) throw new M0;
            if (!this.isStopped)
                for (var r = this.observers, i = r.length, s = r.slice(), o = 0; o < i; o++) s[o].next(n)
        }, e.prototype.error = function(n) {
            if (this.closed) throw new M0;
            this.hasError = !0, this.thrownError = n, this.isStopped = !0;
            for (var r = this.observers, i = r.length, s = r.slice(), o = 0; o < i; o++) s[o].error(n);
            this.observers.length = 0
        }, e.prototype.complete = function() {
            if (this.closed) throw new M0;
            this.isStopped = !0;
            for (var n = this.observers, r = n.length, i = n.slice(), s = 0; s < r; s++) i[s].complete();
            this.observers.length = 0
        }, e.prototype.unsubscribe = function() {
            this.isStopped = !0, this.closed = !0, this.observers = null
        }, e.prototype._trySubscribe = function(n) {
            if (this.closed) throw new M0;
            return t.prototype._trySubscribe.call(this, n)
        }, e.prototype._subscribe = function(n) {
            if (this.closed) throw new M0;
            return this.hasError ? (n.error(this.thrownError), ki.EMPTY) : this.isStopped ? (n.complete(), ki.EMPTY) : (this.observers.push(n), new Cae(this, n))
        }, e.prototype.asObservable = function() {
            var n = new Fn;
            return n.source = this, n
        }, e.create = function(n, r) {
            return new pY(n, r)
        }, e
    }(Fn),
    pY = function(t) {
        Ve(e, t);

        function e(n, r) {
            var i = t.call(this) || this;
            return i.destination = n, i.source = r, i
        }
        return e.prototype.next = function(n) {
            var r = this.destination;
            r && r.next && r.next(n)
        }, e.prototype.error = function(n) {
            var r = this.destination;
            r && r.error && this.destination.error(n)
        }, e.prototype.complete = function() {
            var n = this.destination;
            n && n.complete && this.destination.complete()
        }, e.prototype._subscribe = function(n) {
            var r = this.source;
            return r ? this.source.subscribe(n) : ki.EMPTY
        }, e
    }(Qs);

function LB() {
    return function(e) {
        return e.lift(new iVe(e))
    }
}
var iVe = function() {
        function t(e) {
            this.connectable = e
        }
        return t.prototype.call = function(e, n) {
            var r = this.connectable;
            r._refCount++;
            var i = new sVe(e, r),
                s = n.subscribe(i);
            return i.closed || (i.connection = r.connect()), s
        }, t
    }(),
    sVe = function(t) {
        Ve(e, t);

        function e(n, r) {
            var i = t.call(this, n) || this;
            return i.connectable = r, i
        }
        return e.prototype._unsubscribe = function() {
            var n = this.connectable;
            if (!n) {
                this.connection = null;
                return
            }
            this.connectable = null;
            var r = n._refCount;
            if (r <= 0) {
                this.connection = null;
                return
            }
            if (n._refCount = r - 1, r > 1) {
                this.connection = null;
                return
            }
            var i = this.connection,
                s = n._connection;
            this.connection = null, s && (!i || s === i) && s.unsubscribe()
        }, e
    }(Gt),
    Tae = function(t) {
        Ve(e, t);

        function e(n, r) {
            var i = t.call(this) || this;
            return i.source = n, i.subjectFactory = r, i._refCount = 0, i._isComplete = !1, i
        }
        return e.prototype._subscribe = function(n) {
            return this.getSubject().subscribe(n)
        }, e.prototype.getSubject = function() {
            var n = this._subject;
            return (!n || n.isStopped) && (this._subject = this.subjectFactory()), this._subject
        }, e.prototype.connect = function() {
            var n = this._connection;
            return n || (this._isComplete = !1, n = this._connection = new ki, n.add(this.source.subscribe(new aVe(this.getSubject(), this))), n.closed && (this._connection = null, n = ki.EMPTY)), n
        }, e.prototype.refCount = function() {
            return LB()(this)
        }, e
    }(Fn),
    oVe = function() {
        var t = Tae.prototype;
        return {
            operator: {
                value: null
            },
            _refCount: {
                value: 0,
                writable: !0
            },
            _subject: {
                value: null,
                writable: !0
            },
            _connection: {
                value: null,
                writable: !0
            },
            _subscribe: {
                value: t._subscribe
            },
            _isComplete: {
                value: t._isComplete,
                writable: !0
            },
            getSubject: {
                value: t.getSubject
            },
            connect: {
                value: t.connect
            },
            refCount: {
                value: t.refCount
            }
        }
    }(),
    aVe = function(t) {
        Ve(e, t);

        function e(n, r) {
            var i = t.call(this, n) || this;
            return i.connectable = r, i
        }
        return e.prototype._error = function(n) {
            this._unsubscribe(), t.prototype._error.call(this, n)
        }, e.prototype._complete = function() {
            this.connectable._isComplete = !0, this._unsubscribe(), t.prototype._complete.call(this)
        }, e.prototype._unsubscribe = function() {
            var n = this.connectable;
            if (n) {
                this.connectable = null;
                var r = n._connection;
                n._refCount = 0, n._subject = null, n._connection = null, r && r.unsubscribe()
            }
        }, e
    }(Aae);

function lVe(t, e, n, r) {
    return function(i) {
        return i.lift(new cVe(t, e, n, r))
    }
}
var cVe = function() {
        function t(e, n, r, i) {
            this.keySelector = e, this.elementSelector = n, this.durationSelector = r, this.subjectSelector = i
        }
        return t.prototype.call = function(e, n) {
            return n.subscribe(new uVe(e, this.keySelector, this.elementSelector, this.durationSelector, this.subjectSelector))
        }, t
    }(),
    uVe = function(t) {
        Ve(e, t);

        function e(n, r, i, s, o) {
            var a = t.call(this, n) || this;
            return a.keySelector = r, a.elementSelector = i, a.durationSelector = s, a.subjectSelector = o, a.groups = null, a.attemptedToUnsubscribe = !1, a.count = 0, a
        }
        return e.prototype._next = function(n) {
            var r;
            try {
                r = this.keySelector(n)
            } catch (i) {
                this.error(i);
                return
            }
            this._group(n, r)
        }, e.prototype._group = function(n, r) {
            var i = this.groups;
            i || (i = this.groups = new Map);
            var s = i.get(r),
                o;
            if (this.elementSelector) try {
                o = this.elementSelector(n)
            } catch (c) {
                this.error(c)
            } else o = n;
            if (!s) {
                s = this.subjectSelector ? this.subjectSelector() : new Qs, i.set(r, s);
                var a = new TM(r, s, this);
                if (this.destination.next(a), this.durationSelector) {
                    var l = void 0;
                    try {
                        l = this.durationSelector(new TM(r, s))
                    } catch (c) {
                        this.error(c);
                        return
                    }
                    this.add(l.subscribe(new fVe(r, s, this)))
                }
            }
            s.closed || s.next(o)
        }, e.prototype._error = function(n) {
            var r = this.groups;
            r && (r.forEach(function(i, s) {
                i.error(n)
            }), r.clear()), this.destination.error(n)
        }, e.prototype._complete = function() {
            var n = this.groups;
            n && (n.forEach(function(r, i) {
                r.complete()
            }), n.clear()), this.destination.complete()
        }, e.prototype.removeGroup = function(n) {
            this.groups.delete(n)
        }, e.prototype.unsubscribe = function() {
            this.closed || (this.attemptedToUnsubscribe = !0, this.count === 0 && t.prototype.unsubscribe.call(this))
        }, e
    }(Gt),
    fVe = function(t) {
        Ve(e, t);

        function e(n, r, i) {
            var s = t.call(this, r) || this;
            return s.key = n, s.group = r, s.parent = i, s
        }
        return e.prototype._next = function(n) {
            this.complete()
        }, e.prototype._unsubscribe = function() {
            var n = this,
                r = n.parent,
                i = n.key;
            this.key = this.parent = null, r && r.removeGroup(i)
        }, e
    }(Gt),
    TM = function(t) {
        Ve(e, t);

        function e(n, r, i) {
            var s = t.call(this) || this;
            return s.key = n, s.groupSubject = r, s.refCountSubscription = i, s
        }
        return e.prototype._subscribe = function(n) {
            var r = new ki,
                i = this,
                s = i.refCountSubscription,
                o = i.groupSubject;
            return s && !s.closed && r.add(new dVe(s)), r.add(o.subscribe(n)), r
        }, e
    }(Fn),
    dVe = function(t) {
        Ve(e, t);

        function e(n) {
            var r = t.call(this) || this;
            return r.parent = n, n.count++, r
        }
        return e.prototype.unsubscribe = function() {
            var n = this.parent;
            !n.closed && !this.closed && (t.prototype.unsubscribe.call(this), n.count -= 1, n.count === 0 && n.attemptedToUnsubscribe && n.unsubscribe())
        }, e
    }(ki),
    Iae = function(t) {
        Ve(e, t);

        function e(n) {
            var r = t.call(this) || this;
            return r._value = n, r
        }
        return Object.defineProperty(e.prototype, "value", {
            get: function() {
                return this.getValue()
            },
            enumerable: !0,
            configurable: !0
        }), e.prototype._subscribe = function(n) {
            var r = t.prototype._subscribe.call(this, n);
            return r && !r.closed && n.next(this._value), r
        }, e.prototype.getValue = function() {
            if (this.hasError) throw this.thrownError;
            if (this.closed) throw new M0;
            return this._value
        }, e.prototype.next = function(n) {
            t.prototype.next.call(this, this._value = n)
        }, e
    }(Qs),
    hVe = function(t) {
        Ve(e, t);

        function e(n, r) {
            return t.call(this) || this
        }
        return e.prototype.schedule = function(n, r) {
            return this
        }, e
    }(ki),
    r4 = function(t) {
        Ve(e, t);

        function e(n, r) {
            var i = t.call(this, n, r) || this;
            return i.scheduler = n, i.work = r, i.pending = !1, i
        }
        return e.prototype.schedule = function(n, r) {
            if (r === void 0 && (r = 0), this.closed) return this;
            this.state = n;
            var i = this.id,
                s = this.scheduler;
            return i != null && (this.id = this.recycleAsyncId(s, i, r)), this.pending = !0, this.delay = r, this.id = this.id || this.requestAsyncId(s, this.id, r), this
        }, e.prototype.requestAsyncId = function(n, r, i) {
            return i === void 0 && (i = 0), setInterval(n.flush.bind(n, this), i)
        }, e.prototype.recycleAsyncId = function(n, r, i) {
            if (i === void 0 && (i = 0), i !== null && this.delay === i && this.pending === !1) return r;
            clearInterval(r)
        }, e.prototype.execute = function(n, r) {
            if (this.closed) return new Error("executing a cancelled action");
            this.pending = !1;
            var i = this._execute(n, r);
            if (i) return i;
            this.pending === !1 && this.id != null && (this.id = this.recycleAsyncId(this.scheduler, this.id, null))
        }, e.prototype._execute = function(n, r) {
            var i = !1,
                s = void 0;
            try {
                this.work(n)
            } catch (o) {
                i = !0, s = !!o && o || new Error(o)
            }
            if (i) return this.unsubscribe(), s
        }, e.prototype._unsubscribe = function() {
            var n = this.id,
                r = this.scheduler,
                i = r.actions,
                s = i.indexOf(this);
            this.work = null, this.state = null, this.pending = !1, this.scheduler = null, s !== -1 && i.splice(s, 1), n != null && (this.id = this.recycleAsyncId(r, n, null)), this.delay = null
        }, e
    }(hVe),
    pVe = function(t) {
        Ve(e, t);

        function e(n, r) {
            var i = t.call(this, n, r) || this;
            return i.scheduler = n, i.work = r, i
        }
        return e.prototype.schedule = function(n, r) {
            return r === void 0 && (r = 0), r > 0 ? t.prototype.schedule.call(this, n, r) : (this.delay = r, this.state = n, this.scheduler.flush(this), this)
        }, e.prototype.execute = function(n, r) {
            return r > 0 || this.closed ? t.prototype.execute.call(this, n, r) : this._execute(n, r)
        }, e.prototype.requestAsyncId = function(n, r, i) {
            return i === void 0 && (i = 0), i !== null && i > 0 || i === null && this.delay > 0 ? t.prototype.requestAsyncId.call(this, n, r, i) : n.flush(this)
        }, e
    }(r4),
    IM = function() {
        function t(e, n) {
            n === void 0 && (n = t.now), this.SchedulerAction = e, this.now = n
        }
        return t.prototype.schedule = function(e, n, r) {
            return n === void 0 && (n = 0), new this.SchedulerAction(this, e).schedule(r, n)
        }, t.now = function() {
            return Date.now()
        }, t
    }(),
    i4 = function(t) {
        Ve(e, t);

        function e(n, r) {
            r === void 0 && (r = IM.now);
            var i = t.call(this, n, function() {
                return e.delegate && e.delegate !== i ? e.delegate.now() : r()
            }) || this;
            return i.actions = [], i.active = !1, i.scheduled = void 0, i
        }
        return e.prototype.schedule = function(n, r, i) {
            return r === void 0 && (r = 0), e.delegate && e.delegate !== this ? e.delegate.schedule(n, r, i) : t.prototype.schedule.call(this, n, r, i)
        }, e.prototype.flush = function(n) {
            var r = this.actions;
            if (this.active) {
                r.push(n);
                return
            }
            var i;
            this.active = !0;
            do
                if (i = n.execute(n.state, n.delay)) break; while (n = r.shift());
            if (this.active = !1, i) {
                for (; n = r.shift();) n.unsubscribe();
                throw i
            }
        }, e
    }(IM),
    gVe = function(t) {
        Ve(e, t);

        function e() {
            return t !== null && t.apply(this, arguments) || this
        }
        return e
    }(i4),
    Rae = new gVe(pVe),
    Oae = Rae,
    c2 = new Fn(function(t) {
        return t.complete()
    });

function G2(t) {
    return t ? mVe(t) : c2
}

function mVe(t) {
    return new Fn(function(e) {
        return t.schedule(function() {
            return e.complete()
        })
    })
}

function Al(t) {
    return t && typeof t.schedule == "function"
}
var Nae = function(t) {
    return function(e) {
        for (var n = 0, r = t.length; n < r && !e.closed; n++) e.next(t[n]);
        e.complete()
    }
};

function BB(t, e) {
    return new Fn(function(n) {
        var r = new ki,
            i = 0;
        return r.add(e.schedule(function() {
            if (i === t.length) {
                n.complete();
                return
            }
            n.next(t[i++]), n.closed || r.add(this.schedule())
        })), r
    })
}

function s4(t, e) {
    return e ? BB(t, e) : new Fn(Nae(t))
}

function H9() {
    for (var t = [], e = 0; e < arguments.length; e++) t[e] = arguments[e];
    var n = t[t.length - 1];
    return Al(n) ? (t.pop(), BB(t, n)) : s4(t)
}

function FB(t, e) {
    return e ? new Fn(function(n) {
        return e.schedule(yVe, 0, {
            error: t,
            subscriber: n
        })
    }) : new Fn(function(n) {
        return n.error(t)
    })
}

function yVe(t) {
    var e = t.error,
        n = t.subscriber;
    n.error(e)
}
var RM;
RM || (RM = {});
var mh = function() {
    function t(e, n, r) {
        this.kind = e, this.value = n, this.error = r, this.hasValue = e === "N"
    }
    return t.prototype.observe = function(e) {
        switch (this.kind) {
            case "N":
                return e.next && e.next(this.value);
            case "E":
                return e.error && e.error(this.error);
            case "C":
                return e.complete && e.complete()
        }
    }, t.prototype.do = function(e, n, r) {
        var i = this.kind;
        switch (i) {
            case "N":
                return e && e(this.value);
            case "E":
                return n && n(this.error);
            case "C":
                return r && r()
        }
    }, t.prototype.accept = function(e, n, r) {
        return e && typeof e.next == "function" ? this.observe(e) : this.do(e, n, r)
    }, t.prototype.toObservable = function() {
        var e = this.kind;
        switch (e) {
            case "N":
                return H9(this.value);
            case "E":
                return FB(this.error);
            case "C":
                return G2()
        }
        throw new Error("unexpected notification kind value")
    }, t.createNext = function(e) {
        return typeof e < "u" ? new t("N", e) : t.undefinedValueNotification
    }, t.createError = function(e) {
        return new t("E", void 0, e)
    }, t.createComplete = function() {
        return t.completeNotification
    }, t.completeNotification = new t("C"), t.undefinedValueNotification = new t("N", void 0), t
}();

function wVe(t, e) {
    return e === void 0 && (e = 0),
        function(r) {
            return r.lift(new vVe(t, e))
        }
}
var vVe = function() {
        function t(e, n) {
            n === void 0 && (n = 0), this.scheduler = e, this.delay = n
        }
        return t.prototype.call = function(e, n) {
            return n.subscribe(new Pae(e, this.scheduler, this.delay))
        }, t
    }(),
    Pae = function(t) {
        Ve(e, t);

        function e(n, r, i) {
            i === void 0 && (i = 0);
            var s = t.call(this, n) || this;
            return s.scheduler = r, s.delay = i, s
        }
        return e.dispatch = function(n) {
            var r = n.notification,
                i = n.destination;
            r.observe(i), this.unsubscribe()
        }, e.prototype.scheduleMessage = function(n) {
            var r = this.destination;
            r.add(this.scheduler.schedule(e.dispatch, this.delay, new bVe(n, this.destination)))
        }, e.prototype._next = function(n) {
            this.scheduleMessage(mh.createNext(n))
        }, e.prototype._error = function(n) {
            this.scheduleMessage(mh.createError(n)), this.unsubscribe()
        }, e.prototype._complete = function() {
            this.scheduleMessage(mh.createComplete()), this.unsubscribe()
        }, e
    }(Gt),
    bVe = function() {
        function t(e, n) {
            this.notification = e, this.destination = n
        }
        return t
    }(),
    UB = function(t) {
        Ve(e, t);

        function e(n, r, i) {
            n === void 0 && (n = Number.POSITIVE_INFINITY), r === void 0 && (r = Number.POSITIVE_INFINITY);
            var s = t.call(this) || this;
            return s.scheduler = i, s._events = [], s._infiniteTimeWindow = !1, s._bufferSize = n < 1 ? 1 : n, s._windowTime = r < 1 ? 1 : r, r === Number.POSITIVE_INFINITY ? (s._infiniteTimeWindow = !0, s.next = s.nextInfiniteTimeWindow) : s.next = s.nextTimeWindow, s
        }
        return e.prototype.nextInfiniteTimeWindow = function(n) {
            if (!this.isStopped) {
                var r = this._events;
                r.push(n), r.length > this._bufferSize && r.shift()
            }
            t.prototype.next.call(this, n)
        }, e.prototype.nextTimeWindow = function(n) {
            this.isStopped || (this._events.push(new _Ve(this._getNow(), n)), this._trimBufferThenGetEvents()), t.prototype.next.call(this, n)
        }, e.prototype._subscribe = function(n) {
            var r = this._infiniteTimeWindow,
                i = r ? this._events : this._trimBufferThenGetEvents(),
                s = this.scheduler,
                o = i.length,
                a;
            if (this.closed) throw new M0;
            if (this.isStopped || this.hasError ? a = ki.EMPTY : (this.observers.push(n), a = new Cae(this, n)), s && n.add(n = new Pae(n, s)), r)
                for (var l = 0; l < o && !n.closed; l++) n.next(i[l]);
            else
                for (var l = 0; l < o && !n.closed; l++) n.next(i[l].value);
            return this.hasError ? n.error(this.thrownError) : this.isStopped && n.complete(), a
        }, e.prototype._getNow = function() {
            return (this.scheduler || Oae).now()
        }, e.prototype._trimBufferThenGetEvents = function() {
            for (var n = this._getNow(), r = this._bufferSize, i = this._windowTime, s = this._events, o = s.length, a = 0; a < o && !(n - s[a].time < i);) a++;
            return o > r && (a = Math.max(a, o - r)), a > 0 && s.splice(0, a), s
        }, e
    }(Qs),
    _Ve = function() {
        function t(e, n) {
            this.time = e, this.value = n
        }
        return t
    }(),
    q2 = function(t) {
        Ve(e, t);

        function e() {
            var n = t !== null && t.apply(this, arguments) || this;
            return n.value = null, n.hasNext = !1, n.hasCompleted = !1, n
        }
        return e.prototype._subscribe = function(n) {
            return this.hasError ? (n.error(this.thrownError), ki.EMPTY) : this.hasCompleted && this.hasNext ? (n.next(this.value), n.complete(), ki.EMPTY) : t.prototype._subscribe.call(this, n)
        }, e.prototype.next = function(n) {
            this.hasCompleted || (this.value = n, this.hasNext = !0)
        }, e.prototype.error = function(n) {
            this.hasCompleted || t.prototype.error.call(this, n)
        }, e.prototype.complete = function() {
            this.hasCompleted = !0, this.hasNext && t.prototype.next.call(this, this.value), t.prototype.complete.call(this)
        }, e
    }(Qs),
    EVe = 1,
    xVe = function() {
        return Promise.resolve()
    }(),
    OM = {};

function gY(t) {
    return t in OM ? (delete OM[t], !0) : !1
}
var mY = {
        setImmediate: function(t) {
            var e = EVe++;
            return OM[e] = !0, xVe.then(function() {
                return gY(e) && t()
            }), e
        },
        clearImmediate: function(t) {
            gY(t)
        }
    },
    SVe = function(t) {
        Ve(e, t);

        function e(n, r) {
            var i = t.call(this, n, r) || this;
            return i.scheduler = n, i.work = r, i
        }
        return e.prototype.requestAsyncId = function(n, r, i) {
            return i === void 0 && (i = 0), i !== null && i > 0 ? t.prototype.requestAsyncId.call(this, n, r, i) : (n.actions.push(this), n.scheduled || (n.scheduled = mY.setImmediate(n.flush.bind(n, null))))
        }, e.prototype.recycleAsyncId = function(n, r, i) {
            if (i === void 0 && (i = 0), i !== null && i > 0 || i === null && this.delay > 0) return t.prototype.recycleAsyncId.call(this, n, r, i);
            n.actions.length === 0 && (mY.clearImmediate(r), n.scheduled = void 0)
        }, e
    }(r4),
    CVe = function(t) {
        Ve(e, t);

        function e() {
            return t !== null && t.apply(this, arguments) || this
        }
        return e.prototype.flush = function(n) {
            this.active = !0, this.scheduled = void 0;
            var r = this.actions,
                i, s = -1,
                o = r.length;
            n = n || r.shift();
            do
                if (i = n.execute(n.state, n.delay)) break; while (++s < o && (n = r.shift()));
            if (this.active = !1, i) {
                for (; ++s < o && (n = r.shift());) n.unsubscribe();
                throw i
            }
        }, e
    }(i4),
    kae = new CVe(SVe),
    m8 = kae,
    Mae = new i4(r4),
    ga = Mae,
    AVe = function(t) {
        Ve(e, t);

        function e(n, r) {
            var i = t.call(this, n, r) || this;
            return i.scheduler = n, i.work = r, i
        }
        return e.prototype.requestAsyncId = function(n, r, i) {
            return i === void 0 && (i = 0), i !== null && i > 0 ? t.prototype.requestAsyncId.call(this, n, r, i) : (n.actions.push(this), n.scheduled || (n.scheduled = requestAnimationFrame(function() {
                return n.flush(null)
            })))
        }, e.prototype.recycleAsyncId = function(n, r, i) {
            if (i === void 0 && (i = 0), i !== null && i > 0 || i === null && this.delay > 0) return t.prototype.recycleAsyncId.call(this, n, r, i);
            n.actions.length === 0 && (cancelAnimationFrame(r), n.scheduled = void 0)
        }, e
    }(r4),
    TVe = function(t) {
        Ve(e, t);

        function e() {
            return t !== null && t.apply(this, arguments) || this
        }
        return e.prototype.flush = function(n) {
            this.active = !0, this.scheduled = void 0;
            var r = this.actions,
                i, s = -1,
                o = r.length;
            n = n || r.shift();
            do
                if (i = n.execute(n.state, n.delay)) break; while (++s < o && (n = r.shift()));
            if (this.active = !1, i) {
                for (; ++s < o && (n = r.shift());) n.unsubscribe();
                throw i
            }
        }, e
    }(i4),
    Dae = new TVe(AVe),
    IVe = Dae,
    RVe = function(t) {
        Ve(e, t);

        function e(n, r) {
            n === void 0 && (n = $ae), r === void 0 && (r = Number.POSITIVE_INFINITY);
            var i = t.call(this, n, function() {
                return i.frame
            }) || this;
            return i.maxFrames = r, i.frame = 0, i.index = -1, i
        }
        return e.prototype.flush = function() {
            for (var n = this, r = n.actions, i = n.maxFrames, s, o;
                (o = r[0]) && o.delay <= i && (r.shift(), this.frame = o.delay, !(s = o.execute(o.state, o.delay))););
            if (s) {
                for (; o = r.shift();) o.unsubscribe();
                throw s
            }
        }, e.frameTimeFactor = 10, e
    }(i4),
    $ae = function(t) {
        Ve(e, t);

        function e(n, r, i) {
            i === void 0 && (i = n.index += 1);
            var s = t.call(this, n, r) || this;
            return s.scheduler = n, s.work = r, s.index = i, s.active = !0, s.index = n.index = i, s
        }
        return e.prototype.schedule = function(n, r) {
            if (r === void 0 && (r = 0), !this.id) return t.prototype.schedule.call(this, n, r);
            this.active = !1;
            var i = new e(this.scheduler, this.work);
            return this.add(i), i.schedule(n, r)
        }, e.prototype.requestAsyncId = function(n, r, i) {
            i === void 0 && (i = 0), this.delay = n.frame + i;
            var s = n.actions;
            return s.push(this), s.sort(e.sortActions), !0
        }, e.prototype.recycleAsyncId = function(n, r, i) {}, e.prototype._execute = function(n, r) {
            if (this.active === !0) return t.prototype._execute.call(this, n, r)
        }, e.sortActions = function(n, r) {
            return n.delay === r.delay ? n.index === r.index ? 0 : n.index > r.index ? 1 : -1 : n.delay > r.delay ? 1 : -1
        }, e
    }(r4);

function pf() {}

function OVe(t) {
    return !!t && (t instanceof Fn || typeof t.lift == "function" && typeof t.subscribe == "function")
}
var NVe = function() {
        function t() {
            return Error.call(this), this.message = "argument out of range", this.name = "ArgumentOutOfRangeError", this
        }
        return t.prototype = Object.create(Error.prototype), t
    }(),
    u2 = NVe,
    PVe = function() {
        function t() {
            return Error.call(this), this.message = "no elements in sequence", this.name = "EmptyError", this
        }
        return t.prototype = Object.create(Error.prototype), t
    }(),
    o4 = PVe,
    kVe = function() {
        function t() {
            return Error.call(this), this.message = "Timeout has occurred", this.name = "TimeoutError", this
        }
        return t.prototype = Object.create(Error.prototype), t
    }(),
    Lae = kVe;

function Bc(t, e) {
    return function(r) {
        if (typeof t != "function") throw new TypeError("argument is not a function. Are you looking for `mapTo()`?");
        return r.lift(new MVe(t, e))
    }
}
var MVe = function() {
        function t(e, n) {
            this.project = e, this.thisArg = n
        }
        return t.prototype.call = function(e, n) {
            return n.subscribe(new DVe(e, this.project, this.thisArg))
        }, t
    }(),
    DVe = function(t) {
        Ve(e, t);

        function e(n, r, i) {
            var s = t.call(this, n) || this;
            return s.project = r, s.count = 0, s.thisArg = i || s, s
        }
        return e.prototype._next = function(n) {
            var r;
            try {
                r = this.project.call(this.thisArg, n, this.count++)
            } catch (i) {
                this.destination.error(i);
                return
            }
            this.destination.next(r)
        }, e
    }(Gt);

function Bae(t, e, n) {
    if (e)
        if (Al(e)) n = e;
        else return function() {
            for (var r = [], i = 0; i < arguments.length; i++) r[i] = arguments[i];
            return Bae(t, n).apply(void 0, r).pipe(Bc(function(s) {
                return pa(s) ? e.apply(void 0, s) : e(s)
            }))
        };
    return function() {
        for (var r = [], i = 0; i < arguments.length; i++) r[i] = arguments[i];
        var s = this,
            o, a = {
                context: s,
                subject: o,
                callbackFunc: t,
                scheduler: n
            };
        return new Fn(function(l) {
            if (n) {
                var u = {
                    args: r,
                    subscriber: l,
                    params: a
                };
                return n.schedule($Ve, 0, u)
            } else {
                if (!o) {
                    o = new q2;
                    var c = function() {
                        for (var f = [], h = 0; h < arguments.length; h++) f[h] = arguments[h];
                        o.next(f.length <= 1 ? f[0] : f), o.complete()
                    };
                    try {
                        t.apply(s, r.concat([c]))
                    } catch (f) {
                        $B(o) ? o.error(f) : console.warn(f)
                    }
                }
                return o.subscribe(l)
            }
        })
    }
}

function $Ve(t) {
    var e = this,
        n = t.args,
        r = t.subscriber,
        i = t.params,
        s = i.callbackFunc,
        o = i.context,
        a = i.scheduler,
        l = i.subject;
    if (!l) {
        l = i.subject = new q2;
        var c = function() {
            for (var u = [], f = 0; f < arguments.length; f++) u[f] = arguments[f];
            var h = u.length <= 1 ? u[0] : u;
            e.add(a.schedule(LVe, 0, {
                value: h,
                subject: l
            }))
        };
        try {
            s.apply(o, n.concat([c]))
        } catch (u) {
            l.error(u)
        }
    }
    this.add(l.subscribe(r))
}

function LVe(t) {
    var e = t.value,
        n = t.subject;
    n.next(e), n.complete()
}

function Fae(t, e, n) {
    if (e)
        if (Al(e)) n = e;
        else return function() {
            for (var r = [], i = 0; i < arguments.length; i++) r[i] = arguments[i];
            return Fae(t, n).apply(void 0, r).pipe(Bc(function(s) {
                return pa(s) ? e.apply(void 0, s) : e(s)
            }))
        };
    return function() {
        for (var r = [], i = 0; i < arguments.length; i++) r[i] = arguments[i];
        var s = {
            subject: void 0,
            args: r,
            callbackFunc: t,
            scheduler: n,
            context: this
        };
        return new Fn(function(o) {
            var a = s.context,
                l = s.subject;
            if (n) return n.schedule(BVe, 0, {
                params: s,
                subscriber: o,
                context: a
            });
            if (!l) {
                l = s.subject = new q2;
                var c = function() {
                    for (var u = [], f = 0; f < arguments.length; f++) u[f] = arguments[f];
                    var h = u.shift();
                    if (h) {
                        l.error(h);
                        return
                    }
                    l.next(u.length <= 1 ? u[0] : u), l.complete()
                };
                try {
                    t.apply(a, r.concat([c]))
                } catch (u) {
                    $B(l) ? l.error(u) : console.warn(u)
                }
            }
            return l.subscribe(o)
        })
    }
}

function BVe(t) {
    var e = this,
        n = t.params,
        r = t.subscriber,
        i = t.context,
        s = n.callbackFunc,
        o = n.args,
        a = n.scheduler,
        l = n.subject;
    if (!l) {
        l = n.subject = new q2;
        var c = function() {
            for (var u = [], f = 0; f < arguments.length; f++) u[f] = arguments[f];
            var h = u.shift();
            if (h) e.add(a.schedule(yY, 0, {
                err: h,
                subject: l
            }));
            else {
                var g = u.length <= 1 ? u[0] : u;
                e.add(a.schedule(FVe, 0, {
                    value: g,
                    subject: l
                }))
            }
        };
        try {
            s.apply(i, o.concat([c]))
        } catch (u) {
            this.add(a.schedule(yY, 0, {
                err: u,
                subject: l
            }))
        }
    }
    this.add(l.subscribe(r))
}

function FVe(t) {
    var e = t.value,
        n = t.subject;
    n.next(e), n.complete()
}

function yY(t) {
    var e = t.err,
        n = t.subject;
    n.error(e)
}
var Cy = function(t) {
        Ve(e, t);

        function e() {
            return t !== null && t.apply(this, arguments) || this
        }
        return e.prototype.notifyNext = function(n, r, i, s, o) {
            this.destination.next(r)
        }, e.prototype.notifyError = function(n, r) {
            this.destination.error(n)
        }, e.prototype.notifyComplete = function(n) {
            this.destination.complete()
        }, e
    }(Gt),
    UVe = function(t) {
        Ve(e, t);

        function e(n, r, i) {
            var s = t.call(this) || this;
            return s.parent = n, s.outerValue = r, s.outerIndex = i, s.index = 0, s
        }
        return e.prototype._next = function(n) {
            this.parent.notifyNext(this.outerValue, n, this.outerIndex, this.index++, this)
        }, e.prototype._error = function(n) {
            this.parent.notifyError(n, this), this.unsubscribe()
        }, e.prototype._complete = function() {
            this.parent.notifyComplete(this), this.unsubscribe()
        }, e
    }(Gt),
    jVe = function(t) {
        return function(e) {
            return t.then(function(n) {
                e.closed || (e.next(n), e.complete())
            }, function(n) {
                return e.error(n)
            }).then(null, Pw), e
        }
    };

function HVe() {
    return typeof Symbol != "function" || !Symbol.iterator ? "@@iterator" : Symbol.iterator
}
var Kp = HVe(),
    zVe = function(t) {
        return function(e) {
            var n = t[Kp]();
            do {
                var r = void 0;
                try {
                    r = n.next()
                } catch (i) {
                    return e.error(i), e
                }
                if (r.done) {
                    e.complete();
                    break
                }
                if (e.next(r.value), e.closed) break
            } while (!0);
            return typeof n.return == "function" && e.add(function() {
                n.return && n.return()
            }), e
        }
    },
    WVe = function(t) {
        return function(e) {
            var n = t[V2]();
            if (typeof n.subscribe != "function") throw new TypeError("Provided object does not correctly implement Symbol.observable");
            return n.subscribe(e)
        }
    },
    Uae = function(t) {
        return t && typeof t.length == "number" && typeof t != "function"
    };

function jae(t) {
    return !!t && typeof t.subscribe != "function" && typeof t.then == "function"
}
var u6 = function(t) {
    if (t && typeof t[V2] == "function") return WVe(t);
    if (Uae(t)) return Nae(t);
    if (jae(t)) return jVe(t);
    if (t && typeof t[Kp] == "function") return zVe(t);
    var e = DB(t) ? "an invalid object" : "'" + t + "'",
        n = "You provided " + e + " where a stream was expected. You can provide an Observable, Promise, Array, or Iterable.";
    throw new TypeError(n)
};

function Ih(t, e, n, r, i) {
    if (i === void 0 && (i = new UVe(t, n, r)), !i.closed) return e instanceof Fn ? e.subscribe(i) : u6(e)(i)
}
var wY = {};

function VVe() {
    for (var t = [], e = 0; e < arguments.length; e++) t[e] = arguments[e];
    var n = void 0,
        r = void 0;
    return Al(t[t.length - 1]) && (r = t.pop()), typeof t[t.length - 1] == "function" && (n = t.pop()), t.length === 1 && pa(t[0]) && (t = t[0]), s4(t, r).lift(new jB(n))
}
var jB = function() {
        function t(e) {
            this.resultSelector = e
        }
        return t.prototype.call = function(e, n) {
            return n.subscribe(new GVe(e, this.resultSelector))
        }, t
    }(),
    GVe = function(t) {
        Ve(e, t);

        function e(n, r) {
            var i = t.call(this, n) || this;
            return i.resultSelector = r, i.active = 0, i.values = [], i.observables = [], i
        }
        return e.prototype._next = function(n) {
            this.values.push(wY), this.observables.push(n)
        }, e.prototype._complete = function() {
            var n = this.observables,
                r = n.length;
            if (r === 0) this.destination.complete();
            else {
                this.active = r, this.toRespond = r;
                for (var i = 0; i < r; i++) {
                    var s = n[i];
                    this.add(Ih(this, s, void 0, i))
                }
            }
        }, e.prototype.notifyComplete = function(n) {
            (this.active -= 1) === 0 && this.destination.complete()
        }, e.prototype.notifyNext = function(n, r, i) {
            var s = this.values,
                o = s[i],
                a = this.toRespond ? o === wY ? --this.toRespond : this.toRespond : 0;
            s[i] = r, a === 0 && (this.resultSelector ? this._tryResultSelector(s) : this.destination.next(s.slice()))
        }, e.prototype._tryResultSelector = function(n) {
            var r;
            try {
                r = this.resultSelector.apply(this, n)
            } catch (i) {
                this.destination.error(i);
                return
            }
            this.destination.next(r)
        }, e
    }(Cy);

function qVe(t, e) {
    return new Fn(function(n) {
        var r = new ki;
        return r.add(e.schedule(function() {
            var i = t[V2]();
            r.add(i.subscribe({
                next: function(s) {
                    r.add(e.schedule(function() {
                        return n.next(s)
                    }))
                },
                error: function(s) {
                    r.add(e.schedule(function() {
                        return n.error(s)
                    }))
                },
                complete: function() {
                    r.add(e.schedule(function() {
                        return n.complete()
                    }))
                }
            }))
        })), r
    })
}

function KVe(t, e) {
    return new Fn(function(n) {
        var r = new ki;
        return r.add(e.schedule(function() {
            return t.then(function(i) {
                r.add(e.schedule(function() {
                    n.next(i), r.add(e.schedule(function() {
                        return n.complete()
                    }))
                }))
            }, function(i) {
                r.add(e.schedule(function() {
                    return n.error(i)
                }))
            })
        })), r
    })
}

function YVe(t, e) {
    if (!t) throw new Error("Iterable cannot be null");
    return new Fn(function(n) {
        var r = new ki,
            i;
        return r.add(function() {
            i && typeof i.return == "function" && i.return()
        }), r.add(e.schedule(function() {
            i = t[Kp](), r.add(e.schedule(function() {
                if (!n.closed) {
                    var s, o;
                    try {
                        var a = i.next();
                        s = a.value, o = a.done
                    } catch (l) {
                        n.error(l);
                        return
                    }
                    o ? n.complete() : (n.next(s), this.schedule())
                }
            }))
        })), r
    })
}

function ZVe(t) {
    return t && typeof t[V2] == "function"
}

function QVe(t) {
    return t && typeof t[Kp] == "function"
}

function Hae(t, e) {
    if (t != null) {
        if (ZVe(t)) return qVe(t, e);
        if (jae(t)) return KVe(t, e);
        if (Uae(t)) return BB(t, e);
        if (QVe(t) || typeof t == "string") return YVe(t, e)
    }
    throw new TypeError((t !== null && typeof t || t) + " is not observable")
}

function zh(t, e) {
    return e ? Hae(t, e) : t instanceof Fn ? t : new Fn(u6(t))
}
var Ki = function(t) {
        Ve(e, t);

        function e(n) {
            var r = t.call(this) || this;
            return r.parent = n, r
        }
        return e.prototype._next = function(n) {
            this.parent.notifyNext(n)
        }, e.prototype._error = function(n) {
            this.parent.notifyError(n), this.unsubscribe()
        }, e.prototype._complete = function() {
            this.parent.notifyComplete(), this.unsubscribe()
        }, e
    }(Gt),
    Yi = function(t) {
        Ve(e, t);

        function e() {
            return t !== null && t.apply(this, arguments) || this
        }
        return e.prototype.notifyNext = function(n) {
            this.destination.next(n)
        }, e.prototype.notifyError = function(n) {
            this.destination.error(n)
        }, e.prototype.notifyComplete = function() {
            this.destination.complete()
        }, e
    }(Gt);

function Zi(t, e) {
    if (!e.closed) {
        if (t instanceof Fn) return t.subscribe(e);
        var n;
        try {
            n = u6(t)(e)
        } catch (r) {
            e.error(r)
        }
        return n
    }
}

function jm(t, e, n) {
    return n === void 0 && (n = Number.POSITIVE_INFINITY), typeof e == "function" ? function(r) {
        return r.pipe(jm(function(i, s) {
            return zh(t(i, s)).pipe(Bc(function(o, a) {
                return e(i, o, s, a)
            }))
        }, n))
    } : (typeof e == "number" && (n = e), function(r) {
        return r.lift(new JVe(t, n))
    })
}
var JVe = function() {
        function t(e, n) {
            n === void 0 && (n = Number.POSITIVE_INFINITY), this.project = e, this.concurrent = n
        }
        return t.prototype.call = function(e, n) {
            return n.subscribe(new XVe(e, this.project, this.concurrent))
        }, t
    }(),
    XVe = function(t) {
        Ve(e, t);

        function e(n, r, i) {
            i === void 0 && (i = Number.POSITIVE_INFINITY);
            var s = t.call(this, n) || this;
            return s.project = r, s.concurrent = i, s.hasCompleted = !1, s.buffer = [], s.active = 0, s.index = 0, s
        }
        return e.prototype._next = function(n) {
            this.active < this.concurrent ? this._tryNext(n) : this.buffer.push(n)
        }, e.prototype._tryNext = function(n) {
            var r, i = this.index++;
            try {
                r = this.project(n, i)
            } catch (s) {
                this.destination.error(s);
                return
            }
            this.active++, this._innerSub(r)
        }, e.prototype._innerSub = function(n) {
            var r = new Ki(this),
                i = this.destination;
            i.add(r);
            var s = Zi(n, r);
            s !== r && i.add(s)
        }, e.prototype._complete = function() {
            this.hasCompleted = !0, this.active === 0 && this.buffer.length === 0 && this.destination.complete(), this.unsubscribe()
        }, e.prototype.notifyNext = function(n) {
            this.destination.next(n)
        }, e.prototype.notifyComplete = function() {
            var n = this.buffer;
            this.active--, n.length > 0 ? this._next(n.shift()) : this.active === 0 && this.hasCompleted && this.destination.complete()
        }, e
    }(Yi),
    eGe = jm;

function HB(t) {
    return t === void 0 && (t = Number.POSITIVE_INFINITY), jm(qp, t)
}

function zae() {
    return HB(1)
}

function f6() {
    for (var t = [], e = 0; e < arguments.length; e++) t[e] = arguments[e];
    return zae()(H9.apply(void 0, t))
}

function zB(t) {
    return new Fn(function(e) {
        var n;
        try {
            n = t()
        } catch (i) {
            e.error(i);
            return
        }
        var r = n ? zh(n) : G2();
        return r.subscribe(e)
    })
}

function tGe() {
    for (var t = [], e = 0; e < arguments.length; e++) t[e] = arguments[e];
    if (t.length === 1) {
        var n = t[0];
        if (pa(n)) return fS(n, null);
        if (DB(n) && Object.getPrototypeOf(n) === Object.prototype) {
            var r = Object.keys(n);
            return fS(r.map(function(s) {
                return n[s]
            }), r)
        }
    }
    if (typeof t[t.length - 1] == "function") {
        var i = t.pop();
        return t = t.length === 1 && pa(t[0]) ? t[0] : t, fS(t, null).pipe(Bc(function(s) {
            return i.apply(void 0, s)
        }))
    }
    return fS(t, null)
}

function fS(t, e) {
    return new Fn(function(n) {
        var r = t.length;
        if (r === 0) {
            n.complete();
            return
        }
        for (var i = new Array(r), s = 0, o = 0, a = function(c) {
                var u = zh(t[c]),
                    f = !1;
                n.add(u.subscribe({
                    next: function(h) {
                        f || (f = !0, o++), i[c] = h
                    },
                    error: function(h) {
                        return n.error(h)
                    },
                    complete: function() {
                        s++, (s === r || !f) && (o === r && n.next(e ? e.reduce(function(h, g, y) {
                            return h[g] = i[y], h
                        }, {}) : i), n.complete())
                    }
                }))
            }, l = 0; l < r; l++) a(l)
    })
}

function Wae(t, e, n, r) {
    return l2(n) && (r = n, n = void 0), r ? Wae(t, e, n).pipe(Bc(function(i) {
        return pa(i) ? r.apply(void 0, i) : r(i)
    })) : new Fn(function(i) {
        function s(o) {
            arguments.length > 1 ? i.next(Array.prototype.slice.call(arguments)) : i.next(o)
        }
        Vae(t, e, s, i, n)
    })
}

function Vae(t, e, n, r, i) {
    var s;
    if (iGe(t)) {
        var o = t;
        t.addEventListener(e, n, i), s = function() {
            return o.removeEventListener(e, n, i)
        }
    } else if (rGe(t)) {
        var a = t;
        t.on(e, n), s = function() {
            return a.off(e, n)
        }
    } else if (nGe(t)) {
        var l = t;
        t.addListener(e, n), s = function() {
            return l.removeListener(e, n)
        }
    } else if (t && t.length)
        for (var c = 0, u = t.length; c < u; c++) Vae(t[c], e, n, r, i);
    else throw new TypeError("Invalid event target");
    r.add(s)
}

function nGe(t) {
    return t && typeof t.addListener == "function" && typeof t.removeListener == "function"
}

function rGe(t) {
    return t && typeof t.on == "function" && typeof t.off == "function"
}

function iGe(t) {
    return t && typeof t.addEventListener == "function" && typeof t.removeEventListener == "function"
}

function Gae(t, e, n) {
    return n ? Gae(t, e).pipe(Bc(function(r) {
        return pa(r) ? n.apply(void 0, r) : n(r)
    })) : new Fn(function(r) {
        var i = function() {
                for (var o = [], a = 0; a < arguments.length; a++) o[a] = arguments[a];
                return r.next(o.length === 1 ? o[0] : o)
            },
            s;
        try {
            s = t(i)
        } catch (o) {
            r.error(o);
            return
        }
        if (l2(e)) return function() {
            return e(i, s)
        }
    })
}

function sGe(t, e, n, r, i) {
    var s, o;
    if (arguments.length == 1) {
        var a = t;
        o = a.initialState, e = a.condition, n = a.iterate, s = a.resultSelector || qp, i = a.scheduler
    } else r === void 0 || Al(r) ? (o = t, s = qp, i = r) : (o = t, s = r);
    return new Fn(function(l) {
        var c = o;
        if (i) return i.schedule(oGe, 0, {
            subscriber: l,
            iterate: n,
            condition: e,
            resultSelector: s,
            state: c
        });
        do {
            if (e) {
                var u = void 0;
                try {
                    u = e(c)
                } catch (h) {
                    l.error(h);
                    return
                }
                if (!u) {
                    l.complete();
                    break
                }
            }
            var f = void 0;
            try {
                f = s(c)
            } catch (h) {
                l.error(h);
                return
            }
            if (l.next(f), l.closed) break;
            try {
                c = n(c)
            } catch (h) {
                l.error(h);
                return
            }
        } while (!0)
    })
}

function oGe(t) {
    var e = t.subscriber,
        n = t.condition;
    if (!e.closed) {
        if (t.needIterate) try {
            t.state = t.iterate(t.state)
        } catch (s) {
            e.error(s);
            return
        } else t.needIterate = !0;
        if (n) {
            var r = void 0;
            try {
                r = n(t.state)
            } catch (s) {
                e.error(s);
                return
            }
            if (!r) {
                e.complete();
                return
            }
            if (e.closed) return
        }
        var i;
        try {
            i = t.resultSelector(t.state)
        } catch (s) {
            e.error(s);
            return
        }
        if (!e.closed && (e.next(i), !e.closed)) return this.schedule(t)
    }
}

function aGe(t, e, n) {
    return e === void 0 && (e = c2), n === void 0 && (n = c2), zB(function() {
        return t() ? e : n
    })
}

function f2(t) {
    return !pa(t) && t - parseFloat(t) + 1 >= 0
}

function lGe(t, e) {
    return t === void 0 && (t = 0), e === void 0 && (e = ga), (!f2(t) || t < 0) && (t = 0), (!e || typeof e.schedule != "function") && (e = ga), new Fn(function(n) {
        return n.add(e.schedule(cGe, t, {
            subscriber: n,
            counter: 0,
            period: t
        })), n
    })
}

function cGe(t) {
    var e = t.subscriber,
        n = t.counter,
        r = t.period;
    e.next(n), this.schedule({
        subscriber: e,
        counter: n + 1,
        period: r
    }, r)
}

function qae() {
    for (var t = [], e = 0; e < arguments.length; e++) t[e] = arguments[e];
    var n = Number.POSITIVE_INFINITY,
        r = null,
        i = t[t.length - 1];
    return Al(i) ? (r = t.pop(), t.length > 1 && typeof t[t.length - 1] == "number" && (n = t.pop())) : typeof i == "number" && (n = t.pop()), r === null && t.length === 1 && t[0] instanceof Fn ? t[0] : HB(n)(s4(t, r))
}
var Kae = new Fn(pf);

function uGe() {
    return Kae
}

function NM() {
    for (var t = [], e = 0; e < arguments.length; e++) t[e] = arguments[e];
    if (t.length === 0) return c2;
    var n = t[0],
        r = t.slice(1);
    return t.length === 1 && pa(n) ? NM.apply(void 0, n) : new Fn(function(i) {
        var s = function() {
            return i.add(NM.apply(void 0, r).subscribe(i))
        };
        return zh(n).subscribe({
            next: function(o) {
                i.next(o)
            },
            error: s,
            complete: s
        })
    })
}

function fGe(t, e) {
    return e ? new Fn(function(n) {
        var r = Object.keys(t),
            i = new ki;
        return i.add(e.schedule(dGe, 0, {
            keys: r,
            index: 0,
            subscriber: n,
            subscription: i,
            obj: t
        })), i
    }) : new Fn(function(n) {
        for (var r = Object.keys(t), i = 0; i < r.length && !n.closed; i++) {
            var s = r[i];
            t.hasOwnProperty(s) && n.next([s, t[s]])
        }
        n.complete()
    })
}

function dGe(t) {
    var e = t.keys,
        n = t.index,
        r = t.subscriber,
        i = t.subscription,
        s = t.obj;
    if (!r.closed)
        if (n < e.length) {
            var o = e[n];
            r.next([o, s[o]]), i.add(this.schedule({
                keys: e,
                index: n + 1,
                subscriber: r,
                subscription: i,
                obj: s
            }))
        } else r.complete()
}

function Yae(t, e) {
    function n() {
        return !n.pred.apply(n.thisArg, arguments)
    }
    return n.pred = t, n.thisArg = e, n
}

function Yp(t, e) {
    return function(r) {
        return r.lift(new hGe(t, e))
    }
}
var hGe = function() {
        function t(e, n) {
            this.predicate = e, this.thisArg = n
        }
        return t.prototype.call = function(e, n) {
            return n.subscribe(new pGe(e, this.predicate, this.thisArg))
        }, t
    }(),
    pGe = function(t) {
        Ve(e, t);

        function e(n, r, i) {
            var s = t.call(this, n) || this;
            return s.predicate = r, s.thisArg = i, s.count = 0, s
        }
        return e.prototype._next = function(n) {
            var r;
            try {
                r = this.predicate.call(this.thisArg, n, this.count++)
            } catch (i) {
                this.destination.error(i);
                return
            }
            r && this.destination.next(n)
        }, e
    }(Gt);

function gGe(t, e, n) {
    return [Yp(e, n)(new Fn(u6(t))), Yp(Yae(e, n))(new Fn(u6(t)))]
}

function Zae() {
    for (var t = [], e = 0; e < arguments.length; e++) t[e] = arguments[e];
    if (t.length === 1)
        if (pa(t[0])) t = t[0];
        else return t[0];
    return s4(t, void 0).lift(new mGe)
}
var mGe = function() {
        function t() {}
        return t.prototype.call = function(e, n) {
            return n.subscribe(new yGe(e))
        }, t
    }(),
    yGe = function(t) {
        Ve(e, t);

        function e(n) {
            var r = t.call(this, n) || this;
            return r.hasFirst = !1, r.observables = [], r.subscriptions = [], r
        }
        return e.prototype._next = function(n) {
            this.observables.push(n)
        }, e.prototype._complete = function() {
            var n = this.observables,
                r = n.length;
            if (r === 0) this.destination.complete();
            else {
                for (var i = 0; i < r && !this.hasFirst; i++) {
                    var s = n[i],
                        o = Ih(this, s, void 0, i);
                    this.subscriptions && this.subscriptions.push(o), this.add(o)
                }
                this.observables = null
            }
        }, e.prototype.notifyNext = function(n, r, i) {
            if (!this.hasFirst) {
                this.hasFirst = !0;
                for (var s = 0; s < this.subscriptions.length; s++)
                    if (s !== i) {
                        var o = this.subscriptions[s];
                        o.unsubscribe(), this.remove(o)
                    }
                this.subscriptions = null
            }
            this.destination.next(r)
        }, e
    }(Cy);

function wGe(t, e, n) {
    return t === void 0 && (t = 0), new Fn(function(r) {
        e === void 0 && (e = t, t = 0);
        var i = 0,
            s = t;
        if (n) return n.schedule(vGe, 0, {
            index: i,
            count: e,
            start: t,
            subscriber: r
        });
        do {
            if (i++ >= e) {
                r.complete();
                break
            }
            if (r.next(s++), r.closed) break
        } while (!0)
    })
}

function vGe(t) {
    var e = t.start,
        n = t.index,
        r = t.count,
        i = t.subscriber;
    if (n >= r) {
        i.complete();
        return
    }
    i.next(e), !i.closed && (t.index = n + 1, t.start = e + 1, this.schedule(t))
}

function Qae(t, e, n) {
    t === void 0 && (t = 0);
    var r = -1;
    return f2(e) ? r = Number(e) < 1 && 1 || Number(e) : Al(e) && (n = e), Al(n) || (n = ga), new Fn(function(i) {
        var s = f2(t) ? t : +t - n.now();
        return n.schedule(bGe, s, {
            index: 0,
            period: r,
            subscriber: i
        })
    })
}

function bGe(t) {
    var e = t.index,
        n = t.period,
        r = t.subscriber;
    if (r.next(e), !r.closed) {
        if (n === -1) return r.complete();
        t.index = e + 1, this.schedule(t, n)
    }
}

function _Ge(t, e) {
    return new Fn(function(n) {
        var r;
        try {
            r = t()
        } catch (a) {
            n.error(a);
            return
        }
        var i;
        try {
            i = e(r)
        } catch (a) {
            n.error(a);
            return
        }
        var s = i ? zh(i) : c2,
            o = s.subscribe(n);
        return function() {
            o.unsubscribe(), r && r.unsubscribe()
        }
    })
}

function Jae() {
    for (var t = [], e = 0; e < arguments.length; e++) t[e] = arguments[e];
    var n = t[t.length - 1];
    return typeof n == "function" && t.pop(), s4(t, void 0).lift(new Xae(n))
}
var Xae = function() {
        function t(e) {
            this.resultSelector = e
        }
        return t.prototype.call = function(e, n) {
            return n.subscribe(new EGe(e, this.resultSelector))
        }, t
    }(),
    EGe = function(t) {
        Ve(e, t);

        function e(n, r, i) {
            var s = t.call(this, n) || this;
            return s.resultSelector = r, s.iterators = [], s.active = 0, s.resultSelector = typeof r == "function" ? r : void 0, s
        }
        return e.prototype._next = function(n) {
            var r = this.iterators;
            pa(n) ? r.push(new SGe(n)) : typeof n[Kp] == "function" ? r.push(new xGe(n[Kp]())) : r.push(new CGe(this.destination, this, n))
        }, e.prototype._complete = function() {
            var n = this.iterators,
                r = n.length;
            if (this.unsubscribe(), r === 0) {
                this.destination.complete();
                return
            }
            this.active = r;
            for (var i = 0; i < r; i++) {
                var s = n[i];
                if (s.stillUnsubscribed) {
                    var o = this.destination;
                    o.add(s.subscribe())
                } else this.active--
            }
        }, e.prototype.notifyInactive = function() {
            this.active--, this.active === 0 && this.destination.complete()
        }, e.prototype.checkIterators = function() {
            for (var n = this.iterators, r = n.length, i = this.destination, s = 0; s < r; s++) {
                var o = n[s];
                if (typeof o.hasValue == "function" && !o.hasValue()) return
            }
            for (var a = !1, l = [], s = 0; s < r; s++) {
                var o = n[s],
                    c = o.next();
                if (o.hasCompleted() && (a = !0), c.done) {
                    i.complete();
                    return
                }
                l.push(c.value)
            }
            this.resultSelector ? this._tryresultSelector(l) : i.next(l), a && i.complete()
        }, e.prototype._tryresultSelector = function(n) {
            var r;
            try {
                r = this.resultSelector.apply(this, n)
            } catch (i) {
                this.destination.error(i);
                return
            }
            this.destination.next(r)
        }, e
    }(Gt),
    xGe = function() {
        function t(e) {
            this.iterator = e, this.nextResult = e.next()
        }
        return t.prototype.hasValue = function() {
            return !0
        }, t.prototype.next = function() {
            var e = this.nextResult;
            return this.nextResult = this.iterator.next(), e
        }, t.prototype.hasCompleted = function() {
            var e = this.nextResult;
            return !!(e && e.done)
        }, t
    }(),
    SGe = function() {
        function t(e) {
            this.array = e, this.index = 0, this.length = 0, this.length = e.length
        }
        return t.prototype[Kp] = function() {
            return this
        }, t.prototype.next = function(e) {
            var n = this.index++,
                r = this.array;
            return n < this.length ? {
                value: r[n],
                done: !1
            } : {
                value: null,
                done: !0
            }
        }, t.prototype.hasValue = function() {
            return this.array.length > this.index
        }, t.prototype.hasCompleted = function() {
            return this.array.length === this.index
        }, t
    }(),
    CGe = function(t) {
        Ve(e, t);

        function e(n, r, i) {
            var s = t.call(this, n) || this;
            return s.parent = r, s.observable = i, s.stillUnsubscribed = !0, s.buffer = [], s.isComplete = !1, s
        }
        return e.prototype[Kp] = function() {
            return this
        }, e.prototype.next = function() {
            var n = this.buffer;
            return n.length === 0 && this.isComplete ? {
                value: null,
                done: !0
            } : {
                value: n.shift(),
                done: !1
            }
        }, e.prototype.hasValue = function() {
            return this.buffer.length > 0
        }, e.prototype.hasCompleted = function() {
            return this.buffer.length === 0 && this.isComplete
        }, e.prototype.notifyComplete = function() {
            this.buffer.length > 0 ? (this.isComplete = !0, this.parent.notifyInactive()) : this.destination.complete()
        }, e.prototype.notifyNext = function(n) {
            this.buffer.push(n), this.parent.checkIterators()
        }, e.prototype.subscribe = function() {
            return Zi(this.observable, new Ki(this))
        }, e
    }(Yi);
const AGe = Object.freeze(Object.defineProperty({
        __proto__: null,
        ArgumentOutOfRangeError: u2,
        AsyncSubject: q2,
        BehaviorSubject: Iae,
        ConnectableObservable: Tae,
        EMPTY: c2,
        EmptyError: o4,
        GroupedObservable: TM,
        NEVER: Kae,
        Notification: mh,
        get NotificationKind() {
            return RM
        },
        ObjectUnsubscribedError: M0,
        Observable: Fn,
        ReplaySubject: UB,
        Scheduler: IM,
        Subject: Qs,
        Subscriber: Gt,
        Subscription: ki,
        TimeoutError: Lae,
        UnsubscriptionError: Q3,
        VirtualAction: $ae,
        VirtualTimeScheduler: RVe,
        animationFrame: IVe,
        animationFrameScheduler: Dae,
        asap: m8,
        asapScheduler: kae,
        async: ga,
        asyncScheduler: Mae,
        bindCallback: Bae,
        bindNodeCallback: Fae,
        combineLatest: VVe,
        concat: f6,
        config: mc,
        defer: zB,
        empty: G2,
        forkJoin: tGe,
        from: zh,
        fromEvent: Wae,
        fromEventPattern: Gae,
        generate: sGe,
        identity: qp,
        iif: aGe,
        interval: lGe,
        isObservable: OVe,
        merge: qae,
        never: uGe,
        noop: pf,
        observable: V2,
        of: H9,
        onErrorResumeNext: NM,
        pairs: fGe,
        partition: gGe,
        pipe: AM,
        queue: Oae,
        queueScheduler: Rae,
        race: Zae,
        range: wGe,
        scheduled: Hae,
        throwError: FB,
        timer: Qae,
        using: _Ge,
        zip: Jae
    }, Symbol.toStringTag, {
        value: "Module"
    })),
    z9 = Fu(AGe);
var W9 = {};

function ele(t) {
    var e, n, r = "";
    if (typeof t == "string" || typeof t == "number") r += t;
    else if (typeof t == "object")
        if (Array.isArray(t))
            for (e = 0; e < t.length; e++) t[e] && (n = ele(t[e])) && (r && (r += " "), r += n);
        else
            for (e in t) t[e] && (r && (r += " "), r += e);
    return r
}

function vY() {
    for (var t, e, n = 0, r = ""; n < arguments.length;)(t = arguments[n++]) && (e = ele(t)) && (r && (r += " "), r += e);
    return r
}
const TGe = Object.freeze(Object.defineProperty({
        __proto__: null,
        clsx: vY,
        default: vY
    }, Symbol.toStringTag, {
        value: "Module"
    })),
    V9 = Fu(TGe);
var Rh, zr, pN, bY, d2 = 0,
    tle = [],
    Ai = Jr,
    _Y = Ai.__b,
    EY = Ai.__r,
    xY = Ai.diffed,
    SY = Ai.__c,
    CY = Ai.unmount,
    AY = Ai.__;

function Ay(t, e) {
    Ai.__h && Ai.__h(zr, t, d2 || e), d2 = 0;
    var n = zr.__H || (zr.__H = {
        __: [],
        __h: []
    });
    return t >= n.__.length && n.__.push({}), n.__[t]
}

function nle(t) {
    return d2 = 1, rle(sle, t)
}

function rle(t, e, n) {
    var r = Ay(Rh++, 2);
    if (r.t = t, !r.__c && (r.__ = [n ? n(e) : sle(void 0, e), function(a) {
            var l = r.__N ? r.__N[0] : r.__[0],
                c = r.t(l, a);
            l !== c && (r.__N = [c, r.__[1]], r.__c.setState({}))
        }], r.__c = zr, !zr.u)) {
        var i = function(a, l, c) {
            if (!r.__c.__H) return !0;
            var u = r.__c.__H.__.filter(function(h) {
                return !!h.__c
            });
            if (u.every(function(h) {
                    return !h.__N
                })) return !s || s.call(this, a, l, c);
            var f = !1;
            return u.forEach(function(h) {
                if (h.__N) {
                    var g = h.__[0];
                    h.__ = h.__N, h.__N = void 0, g !== h.__[0] && (f = !0)
                }
            }), !(!f && r.__c.props === a) && (!s || s.call(this, a, l, c))
        };
        zr.u = !0;
        var s = zr.shouldComponentUpdate,
            o = zr.componentWillUpdate;
        zr.componentWillUpdate = function(a, l, c) {
            if (this.__e) {
                var u = s;
                s = void 0, i(a, l, c), s = u
            }
            o && o.call(this, a, l, c)
        }, zr.shouldComponentUpdate = i
    }
    return r.__N || r.__
}

function IGe(t, e) {
    var n = Ay(Rh++, 3);
    !Ai.__s && VB(n.__H, e) && (n.__ = t, n.i = e, zr.__H.__h.push(n))
}

function ile(t, e) {
    var n = Ay(Rh++, 4);
    !Ai.__s && VB(n.__H, e) && (n.__ = t, n.i = e, zr.__h.push(n))
}

function RGe(t) {
    return d2 = 5, WB(function() {
        return {
            current: t
        }
    }, [])
}

function OGe(t, e, n) {
    d2 = 6, ile(function() {
        return typeof t == "function" ? (t(e()), function() {
            return t(null)
        }) : t ? (t.current = e(), function() {
            return t.current = null
        }) : void 0
    }, n == null ? n : n.concat(t))
}

function WB(t, e) {
    var n = Ay(Rh++, 7);
    return VB(n.__H, e) && (n.__ = t(), n.__H = e, n.__h = t), n.__
}

function NGe(t, e) {
    return d2 = 8, WB(function() {
        return t
    }, e)
}

function PGe(t) {
    var e = zr.context[t.__c],
        n = Ay(Rh++, 9);
    return n.c = t, e ? (n.__ == null && (n.__ = !0, e.sub(zr)), e.props.value) : t.__
}

function kGe(t, e) {
    Ai.useDebugValue && Ai.useDebugValue(e ? e(t) : t)
}

function MGe(t) {
    var e = Ay(Rh++, 10),
        n = nle();
    return e.__ = t, zr.componentDidCatch || (zr.componentDidCatch = function(r, i) {
        e.__ && e.__(r, i), n[1](r)
    }), [n[0], function() {
        n[1](void 0)
    }]
}

function DGe() {
    var t = Ay(Rh++, 11);
    if (!t.__) {
        for (var e = zr.__v; e !== null && !e.__m && e.__ !== null;) e = e.__;
        var n = e.__m || (e.__m = [0, 0]);
        t.__ = "P" + n[0] + "-" + n[1]++
    }
    return t.__
}

function $Ge() {
    for (var t; t = tle.shift();)
        if (t.__P && t.__H) try {
            t.__H.__h.forEach(y8), t.__H.__h.forEach(PM), t.__H.__h = []
        } catch (e) {
            t.__H.__h = [], Ai.__e(e, t.__v)
        }
}
Ai.__b = function(t) {
    zr = null, _Y && _Y(t)
}, Ai.__ = function(t, e) {
    t && e.__k && e.__k.__m && (t.__m = e.__k.__m), AY && AY(t, e)
}, Ai.__r = function(t) {
    EY && EY(t), Rh = 0;
    var e = (zr = t.__c).__H;
    e && (pN === zr ? (e.__h = [], zr.__h = [], e.__.forEach(function(n) {
        n.__N && (n.__ = n.__N), n.i = n.__N = void 0
    })) : (e.__h.forEach(y8), e.__h.forEach(PM), e.__h = [], Rh = 0)), pN = zr
}, Ai.diffed = function(t) {
    xY && xY(t);
    var e = t.__c;
    e && e.__H && (e.__H.__h.length && (tle.push(e) !== 1 && bY === Ai.requestAnimationFrame || ((bY = Ai.requestAnimationFrame) || LGe)($Ge)), e.__H.__.forEach(function(n) {
        n.i && (n.__H = n.i), n.i = void 0
    })), pN = zr = null
}, Ai.__c = function(t, e) {
    e.some(function(n) {
        try {
            n.__h.forEach(y8), n.__h = n.__h.filter(function(r) {
                return !r.__ || PM(r)
            })
        } catch (r) {
            e.some(function(i) {
                i.__h && (i.__h = [])
            }), e = [], Ai.__e(r, n.__v)
        }
    }), SY && SY(t, e)
}, Ai.unmount = function(t) {
    CY && CY(t);
    var e, n = t.__c;
    n && n.__H && (n.__H.__.forEach(function(r) {
        try {
            y8(r)
        } catch (i) {
            e = i
        }
    }), n.__H = void 0, e && Ai.__e(e, n.__v))
};
var TY = typeof requestAnimationFrame == "function";

function LGe(t) {
    var e, n = function() {
            clearTimeout(r), TY && cancelAnimationFrame(e), setTimeout(t)
        },
        r = setTimeout(n, 100);
    TY && (e = requestAnimationFrame(n))
}

function y8(t) {
    var e = zr,
        n = t.__c;
    typeof n == "function" && (t.__c = void 0, n()), zr = e
}

function PM(t) {
    var e = zr;
    t.__c = t.__(), zr = e
}

function VB(t, e) {
    return !t || t.length !== e.length || e.some(function(n, r) {
        return n !== t[r]
    })
}

function sle(t, e) {
    return typeof e == "function" ? e(t) : e
}
const BGe = Object.freeze(Object.defineProperty({
        __proto__: null,
        useCallback: NGe,
        useContext: PGe,
        useDebugValue: kGe,
        useEffect: IGe,
        useErrorBoundary: MGe,
        useId: DGe,
        useImperativeHandle: OGe,
        useLayoutEffect: ile,
        useMemo: WB,
        useReducer: rle,
        useRef: RGe,
        useState: nle
    }, Symbol.toStringTag, {
        value: "Module"
    })),
    a4 = Fu(BGe);
var jf = {},
    G9 = {};
Object.defineProperty(G9, "__esModule", {
    value: !0
});
G9.CloseIcon = void 0;
const IY = Dl;

function FGe(t) {
    return (0, IY.h)("svg", Object.assign({
        width: "40",
        height: "40",
        viewBox: "0 0 40 40",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg"
    }, t), (0, IY.h)("path", {
        d: "M13.7677 13L12.3535 14.4142L18.3535 20.4142L12.3535 26.4142L13.7677 27.8284L19.7677 21.8284L25.7677 27.8284L27.1819 26.4142L21.1819 20.4142L27.1819 14.4142L25.7677 13L19.7677 19L13.7677 13Z"
    }))
}
G9.CloseIcon = FGe;
var GB = {};
Object.defineProperty(GB, "__esModule", {
    value: !0
});
GB.default = "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjgiIGhlaWdodD0iMjgiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PGNpcmNsZSBjeD0iMTQiIGN5PSIxNCIgcj0iMTQiIGZpbGw9IiMwMDUyRkYiLz48cGF0aCBkPSJNMTQuMDM3IDE4LjkyNmMtMi43NSAwLTQuOTA3LTIuMjA1LTQuOTA3LTQuOTI2IDAtMi43MiAyLjIzLTQuOTI2IDQuOTA3LTQuOTI2YTQuODY2IDQuODY2IDAgMCAxIDQuODMzIDQuMTE4aDQuOTgyYy0uNDQ2LTUuMDczLTQuNjg0LTkuMDQ0LTkuODE1LTkuMDQ0QzguNjEgNC4xNDggNC4xNDkgOC41NiA0LjE0OSAxNHM0LjM4NyA5Ljg1MiA5Ljg5IDkuODUyYzUuMjA0IDAgOS4zNjgtMy45NyA5LjgxNC05LjA0M0gxOC44N2E0Ljg2NiA0Ljg2NiAwIDAgMS00LjgzMyA0LjExN1oiIGZpbGw9IiNmZmYiLz48L3N2Zz4=";
var qB = {};
Object.defineProperty(qB, "__esModule", {
    value: !0
});
qB.default = "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjgiIGhlaWdodD0iMjgiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PGNpcmNsZSBjeD0iMTQiIGN5PSIxNCIgcj0iMTQiIGZpbGw9IiMwMDUyRkYiLz48cGF0aCBkPSJNMjMuODUyIDE0QTkuODM0IDkuODM0IDAgMCAxIDE0IDIzLjg1MiA5LjgzNCA5LjgzNCAwIDAgMSA0LjE0OCAxNCA5LjgzNCA5LjgzNCAwIDAgMSAxNCA0LjE0OCA5LjgzNCA5LjgzNCAwIDAgMSAyMy44NTIgMTRaIiBmaWxsPSIjZmZmIi8+PHBhdGggZD0iTTExLjE4NSAxMi41MDRjMC0uNDU2IDAtLjcxLjA5OC0uODYyLjA5OC0uMTUyLjE5Ni0uMzA0LjM0My0uMzU1LjE5Ni0uMTAyLjM5Mi0uMTAyLjg4MS0uMTAyaDIuOTg2Yy40OSAwIC42ODYgMCAuODgyLjEwMi4xNDYuMTAxLjI5My4yMDMuMzQyLjM1NS4wOTguMjAzLjA5OC40MDYuMDk4Ljg2MnYyLjk5MmMwIC40NTcgMCAuNzEtLjA5OC44NjMtLjA5OC4xNTItLjE5NS4zMDQtLjM0Mi4zNTUtLjE5Ni4xMDEtLjM5Mi4xMDEtLjg4Mi4xMDFoLTIuOTg2Yy0uNDkgMC0uNjg1IDAtLjg4LS4xMDEtLjE0OC0uMTAyLS4yOTUtLjIwMy0uMzQ0LS4zNTUtLjA5OC0uMjAzLS4wOTgtLjQwNi0uMDk4LS44NjN2LTIuOTkyWiIgZmlsbD0iIzAwNTJGRiIvPjwvc3ZnPg==";
var q9 = {};
Object.defineProperty(q9, "__esModule", {
    value: !0
});
q9.QRCodeIcon = void 0;
const lf = Dl;

function UGe(t) {
    return (0, lf.h)("svg", Object.assign({
        width: "10",
        height: "10",
        viewBox: "0 0 10 10",
        xmlns: "http://www.w3.org/2000/svg"
    }, t), (0, lf.h)("path", {
        d: "M8.2271 1.77124L7.0271 1.77124V2.97124H8.2271V1.77124Z"
    }), (0, lf.h)("path", {
        d: "M5.44922 0.199219L5.44922 4.54922L9.79922 4.54922V0.199219L5.44922 0.199219ZM8.89922 3.64922L6.34922 3.64922L6.34922 1.09922L8.89922 1.09922V3.64922Z"
    }), (0, lf.h)("path", {
        d: "M2.97124 1.77124L1.77124 1.77124L1.77124 2.97124H2.97124V1.77124Z"
    }), (0, lf.h)("path", {
        d: "M0.199219 4.54922L4.54922 4.54922L4.54922 0.199219L0.199219 0.199219L0.199219 4.54922ZM1.09922 1.09922L3.64922 1.09922L3.64922 3.64922L1.09922 3.64922L1.09922 1.09922Z"
    }), (0, lf.h)("path", {
        d: "M2.97124 7.0271H1.77124L1.77124 8.2271H2.97124V7.0271Z"
    }), (0, lf.h)("path", {
        d: "M0.199219 9.79922H4.54922L4.54922 5.44922L0.199219 5.44922L0.199219 9.79922ZM1.09922 6.34922L3.64922 6.34922L3.64922 8.89922H1.09922L1.09922 6.34922Z"
    }), (0, lf.h)("path", {
        d: "M8.89922 7.39912H7.99922V5.40112H5.44922L5.44922 9.79912H6.34922L6.34922 6.30112H7.09922V8.29912H9.79922V5.40112H8.89922V7.39912Z"
    }), (0, lf.h)("path", {
        d: "M7.99912 8.89917H7.09912V9.79917H7.99912V8.89917Z"
    }), (0, lf.h)("path", {
        d: "M9.79917 8.89917H8.89917V9.79917H9.79917V8.89917Z"
    }))
}
q9.QRCodeIcon = UGe;
var KB = {};
Object.defineProperty(KB, "__esModule", {
    value: !0
});
const jGe = `
    <svg width="100" height="100" viewBox="0 0 100 100" fill="none" xmlns="http://www.w3.org/2000/svg">
        <path d="M50 100C77.6142 100 100 77.6142 100 50C100 22.3858 77.6142 0 50 0C22.3858 0 0 22.3858 0 50C0 77.6142 22.3858 100 50 100Z" fill="white"/>
        <path d="M50.512 94C74.2907 94 93.5673 74.5244 93.5673 50.5C93.5673 26.4756 74.2907 7 50.512 7C26.7332 7 7.45667 26.4756 7.45667 50.5C7.45667 74.5244 26.7332 94 50.512 94Z" fill="#0052FF"/>
        <path d="M50.6248 65.4335C42.3697 65.4335 35.8996 58.7469 35.8996 50.5C35.8996 42.2531 42.5928 35.5664 50.6248 35.5664C57.9873 35.5664 64.0111 40.9157 65.1267 48.0481H80.0749C78.7363 32.6688 66.0191 20.6328 50.6248 20.6328C34.3379 20.6328 20.9514 34.0062 20.9514 50.5C20.9514 66.9936 34.1148 80.3671 50.6248 80.3671C66.2422 80.3671 78.7363 68.331 80.0749 52.9516H65.1267C64.0111 60.0841 57.9873 65.4335 50.6248 65.4335Z" fill="white"/>
    </svg>
`;
KB.default = jGe;
var YB = {};
Object.defineProperty(YB, "__esModule", {
    value: !0
});
YB.default = `
    <svg width="100" height="100" viewBox="0 0 100 100" fill="none" xmlns="http://www.w3.org/2000/svg">
        <circle cx="50" cy="50" r="50" fill="white"/>
        <circle cx="49.9996" cy="49.9996" r="43.6363" fill="#1B53E4"/>
        <circle cx="49.9996" cy="49.9996" r="43.6363" stroke="white"/>
        <path fill-rule="evenodd" clip-rule="evenodd" d="M19.3379 49.9484C19.3379 66.8508 33.04 80.553 49.9425 80.553C66.8449 80.553 80.5471 66.8508 80.5471 49.9484C80.5471 33.0459 66.8449 19.3438 49.9425 19.3438C33.04 19.3438 19.3379 33.0459 19.3379 49.9484ZM44.0817 40.0799C41.8725 40.0799 40.0817 41.8708 40.0817 44.0799V55.8029C40.0817 58.012 41.8725 59.8029 44.0817 59.8029H55.8046C58.0138 59.8029 59.8046 58.012 59.8046 55.8029V44.0799C59.8046 41.8708 58.0138 40.0799 55.8046 40.0799H44.0817Z" fill="white"/>
    </svg>
`;
var K9 = {};
Object.defineProperty(K9, "__esModule", {
    value: !0
});
K9.StatusDotIcon = void 0;
const RY = Dl;

function HGe(t) {
    return (0, RY.h)("svg", Object.assign({
        width: "10",
        height: "10",
        viewBox: "0 0 10 10",
        xmlns: "http://www.w3.org/2000/svg"
    }, t), (0, RY.h)("path", {
        "fill-rule": "evenodd",
        "clip-rule": "evenodd",
        d: "M2.29995 4.99995C2.29995 5.57985 1.82985 6.04995 1.24995 6.04995C0.670052 6.04995 0.199951 5.57985 0.199951 4.99995C0.199951 4.42005 0.670052 3.94995 1.24995 3.94995C1.82985 3.94995 2.29995 4.42005 2.29995 4.99995ZM4.99995 6.04995C5.57985 6.04995 6.04995 5.57985 6.04995 4.99995C6.04995 4.42005 5.57985 3.94995 4.99995 3.94995C4.42005 3.94995 3.94995 4.42005 3.94995 4.99995C3.94995 5.57985 4.42005 6.04995 4.99995 6.04995ZM8.74995 6.04995C9.32985 6.04995 9.79995 5.57985 9.79995 4.99995C9.79995 4.42005 9.32985 3.94995 8.74995 3.94995C8.17005 3.94995 7.69995 4.42005 7.69995 4.99995C7.69995 5.57985 8.17005 6.04995 8.74995 6.04995Z"
    }))
}
K9.StatusDotIcon = HGe;
var Y9 = {};

function ole(t) {
    this.mode = fl.MODE_8BIT_BYTE, this.data = t, this.parsedData = [];
    for (var e = 0, n = this.data.length; e < n; e++) {
        var r = [],
            i = this.data.charCodeAt(e);
        i > 65536 ? (r[0] = 240 | (i & 1835008) >>> 18, r[1] = 128 | (i & 258048) >>> 12, r[2] = 128 | (i & 4032) >>> 6, r[3] = 128 | i & 63) : i > 2048 ? (r[0] = 224 | (i & 61440) >>> 12, r[1] = 128 | (i & 4032) >>> 6, r[2] = 128 | i & 63) : i > 128 ? (r[0] = 192 | (i & 1984) >>> 6, r[1] = 128 | i & 63) : r[0] = i, this.parsedData.push(r)
    }
    this.parsedData = Array.prototype.concat.apply([], this.parsedData), this.parsedData.length != this.data.length && (this.parsedData.unshift(191), this.parsedData.unshift(187), this.parsedData.unshift(239))
}
ole.prototype = {
    getLength: function(t) {
        return this.parsedData.length
    },
    write: function(t) {
        for (var e = 0, n = this.parsedData.length; e < n; e++) t.put(this.parsedData[e], 8)
    }
};

function Hf(t, e) {
    this.typeNumber = t, this.errorCorrectLevel = e, this.modules = null, this.moduleCount = 0, this.dataCache = null, this.dataList = []
}
Hf.prototype = {
    addData: function(t) {
        var e = new ole(t);
        this.dataList.push(e), this.dataCache = null
    },
    isDark: function(t, e) {
        if (t < 0 || this.moduleCount <= t || e < 0 || this.moduleCount <= e) throw new Error(t + "," + e);
        return this.modules[t][e]
    },
    getModuleCount: function() {
        return this.moduleCount
    },
    make: function() {
        this.makeImpl(!1, this.getBestMaskPattern())
    },
    makeImpl: function(t, e) {
        this.moduleCount = this.typeNumber * 4 + 17, this.modules = new Array(this.moduleCount);
        for (var n = 0; n < this.moduleCount; n++) {
            this.modules[n] = new Array(this.moduleCount);
            for (var r = 0; r < this.moduleCount; r++) this.modules[n][r] = null
        }
        this.setupPositionProbePattern(0, 0), this.setupPositionProbePattern(this.moduleCount - 7, 0), this.setupPositionProbePattern(0, this.moduleCount - 7), this.setupPositionAdjustPattern(), this.setupTimingPattern(), this.setupTypeInfo(t, e), this.typeNumber >= 7 && this.setupTypeNumber(t), this.dataCache == null && (this.dataCache = Hf.createData(this.typeNumber, this.errorCorrectLevel, this.dataList)), this.mapData(this.dataCache, e)
    },
    setupPositionProbePattern: function(t, e) {
        for (var n = -1; n <= 7; n++)
            if (!(t + n <= -1 || this.moduleCount <= t + n))
                for (var r = -1; r <= 7; r++) e + r <= -1 || this.moduleCount <= e + r || (0 <= n && n <= 6 && (r == 0 || r == 6) || 0 <= r && r <= 6 && (n == 0 || n == 6) || 2 <= n && n <= 4 && 2 <= r && r <= 4 ? this.modules[t + n][e + r] = !0 : this.modules[t + n][e + r] = !1)
    },
    getBestMaskPattern: function() {
        for (var t = 0, e = 0, n = 0; n < 8; n++) {
            this.makeImpl(!0, n);
            var r = Si.getLostPoint(this);
            (n == 0 || t > r) && (t = r, e = n)
        }
        return e
    },
    createMovieClip: function(t, e, n) {
        var r = t.createEmptyMovieClip(e, n),
            i = 1;
        this.make();
        for (var s = 0; s < this.modules.length; s++)
            for (var o = s * i, a = 0; a < this.modules[s].length; a++) {
                var l = a * i,
                    c = this.modules[s][a];
                c && (r.beginFill(0, 100), r.moveTo(l, o), r.lineTo(l + i, o), r.lineTo(l + i, o + i), r.lineTo(l, o + i), r.endFill())
            }
        return r
    },
    setupTimingPattern: function() {
        for (var t = 8; t < this.moduleCount - 8; t++) this.modules[t][6] == null && (this.modules[t][6] = t % 2 == 0);
        for (var e = 8; e < this.moduleCount - 8; e++) this.modules[6][e] == null && (this.modules[6][e] = e % 2 == 0)
    },
    setupPositionAdjustPattern: function() {
        for (var t = Si.getPatternPosition(this.typeNumber), e = 0; e < t.length; e++)
            for (var n = 0; n < t.length; n++) {
                var r = t[e],
                    i = t[n];
                if (this.modules[r][i] == null)
                    for (var s = -2; s <= 2; s++)
                        for (var o = -2; o <= 2; o++) s == -2 || s == 2 || o == -2 || o == 2 || s == 0 && o == 0 ? this.modules[r + s][i + o] = !0 : this.modules[r + s][i + o] = !1
            }
    },
    setupTypeNumber: function(t) {
        for (var e = Si.getBCHTypeNumber(this.typeNumber), n = 0; n < 18; n++) {
            var r = !t && (e >> n & 1) == 1;
            this.modules[Math.floor(n / 3)][n % 3 + this.moduleCount - 8 - 3] = r
        }
        for (var n = 0; n < 18; n++) {
            var r = !t && (e >> n & 1) == 1;
            this.modules[n % 3 + this.moduleCount - 8 - 3][Math.floor(n / 3)] = r
        }
    },
    setupTypeInfo: function(t, e) {
        for (var n = this.errorCorrectLevel << 3 | e, r = Si.getBCHTypeInfo(n), i = 0; i < 15; i++) {
            var s = !t && (r >> i & 1) == 1;
            i < 6 ? this.modules[i][8] = s : i < 8 ? this.modules[i + 1][8] = s : this.modules[this.moduleCount - 15 + i][8] = s
        }
        for (var i = 0; i < 15; i++) {
            var s = !t && (r >> i & 1) == 1;
            i < 8 ? this.modules[8][this.moduleCount - i - 1] = s : i < 9 ? this.modules[8][15 - i - 1 + 1] = s : this.modules[8][15 - i - 1] = s
        }
        this.modules[this.moduleCount - 8][8] = !t
    },
    mapData: function(t, e) {
        for (var n = -1, r = this.moduleCount - 1, i = 7, s = 0, o = this.moduleCount - 1; o > 0; o -= 2)
            for (o == 6 && o--;;) {
                for (var a = 0; a < 2; a++)
                    if (this.modules[r][o - a] == null) {
                        var l = !1;
                        s < t.length && (l = (t[s] >>> i & 1) == 1);
                        var c = Si.getMask(e, r, o - a);
                        c && (l = !l), this.modules[r][o - a] = l, i--, i == -1 && (s++, i = 7)
                    }
                if (r += n, r < 0 || this.moduleCount <= r) {
                    r -= n, n = -n;
                    break
                }
            }
    }
};
Hf.PAD0 = 236;
Hf.PAD1 = 17;
Hf.createData = function(t, e, n) {
    for (var r = Df.getRSBlocks(t, e), i = new ale, s = 0; s < n.length; s++) {
        var o = n[s];
        i.put(o.mode, 4), i.put(o.getLength(), Si.getLengthInBits(o.mode, t)), o.write(i)
    }
    for (var a = 0, s = 0; s < r.length; s++) a += r[s].dataCount;
    if (i.getLengthInBits() > a * 8) throw new Error("code length overflow. (" + i.getLengthInBits() + ">" + a * 8 + ")");
    for (i.getLengthInBits() + 4 <= a * 8 && i.put(0, 4); i.getLengthInBits() % 8 != 0;) i.putBit(!1);
    for (; !(i.getLengthInBits() >= a * 8 || (i.put(Hf.PAD0, 8), i.getLengthInBits() >= a * 8));) i.put(Hf.PAD1, 8);
    return Hf.createBytes(i, r)
};
Hf.createBytes = function(t, e) {
    for (var n = 0, r = 0, i = 0, s = new Array(e.length), o = new Array(e.length), a = 0; a < e.length; a++) {
        var l = e[a].dataCount,
            c = e[a].totalCount - l;
        r = Math.max(r, l), i = Math.max(i, c), s[a] = new Array(l);
        for (var u = 0; u < s[a].length; u++) s[a][u] = 255 & t.buffer[u + n];
        n += l;
        var f = Si.getErrorCorrectPolynomial(c),
            h = new dv(s[a], f.getLength() - 1),
            g = h.mod(f);
        o[a] = new Array(f.getLength() - 1);
        for (var u = 0; u < o[a].length; u++) {
            var y = u + g.getLength() - o[a].length;
            o[a][u] = y >= 0 ? g.get(y) : 0
        }
    }
    for (var _ = 0, u = 0; u < e.length; u++) _ += e[u].totalCount;
    for (var C = new Array(_), b = 0, u = 0; u < r; u++)
        for (var a = 0; a < e.length; a++) u < s[a].length && (C[b++] = s[a][u]);
    for (var u = 0; u < i; u++)
        for (var a = 0; a < e.length; a++) u < o[a].length && (C[b++] = o[a][u]);
    return C
};
var fl = {
        MODE_NUMBER: 1,
        MODE_ALPHA_NUM: 2,
        MODE_8BIT_BYTE: 4,
        MODE_KANJI: 8
    },
    dp = {
        L: 1,
        M: 0,
        Q: 3,
        H: 2
    },
    f0 = {
        PATTERN000: 0,
        PATTERN001: 1,
        PATTERN010: 2,
        PATTERN011: 3,
        PATTERN100: 4,
        PATTERN101: 5,
        PATTERN110: 6,
        PATTERN111: 7
    },
    Si = {
        PATTERN_POSITION_TABLE: [
            [],
            [6, 18],
            [6, 22],
            [6, 26],
            [6, 30],
            [6, 34],
            [6, 22, 38],
            [6, 24, 42],
            [6, 26, 46],
            [6, 28, 50],
            [6, 30, 54],
            [6, 32, 58],
            [6, 34, 62],
            [6, 26, 46, 66],
            [6, 26, 48, 70],
            [6, 26, 50, 74],
            [6, 30, 54, 78],
            [6, 30, 56, 82],
            [6, 30, 58, 86],
            [6, 34, 62, 90],
            [6, 28, 50, 72, 94],
            [6, 26, 50, 74, 98],
            [6, 30, 54, 78, 102],
            [6, 28, 54, 80, 106],
            [6, 32, 58, 84, 110],
            [6, 30, 58, 86, 114],
            [6, 34, 62, 90, 118],
            [6, 26, 50, 74, 98, 122],
            [6, 30, 54, 78, 102, 126],
            [6, 26, 52, 78, 104, 130],
            [6, 30, 56, 82, 108, 134],
            [6, 34, 60, 86, 112, 138],
            [6, 30, 58, 86, 114, 142],
            [6, 34, 62, 90, 118, 146],
            [6, 30, 54, 78, 102, 126, 150],
            [6, 24, 50, 76, 102, 128, 154],
            [6, 28, 54, 80, 106, 132, 158],
            [6, 32, 58, 84, 110, 136, 162],
            [6, 26, 54, 82, 110, 138, 166],
            [6, 30, 58, 86, 114, 142, 170]
        ],
        G15: 1335,
        G18: 7973,
        G15_MASK: 21522,
        getBCHTypeInfo: function(t) {
            for (var e = t << 10; Si.getBCHDigit(e) - Si.getBCHDigit(Si.G15) >= 0;) e ^= Si.G15 << Si.getBCHDigit(e) - Si.getBCHDigit(Si.G15);
            return (t << 10 | e) ^ Si.G15_MASK
        },
        getBCHTypeNumber: function(t) {
            for (var e = t << 12; Si.getBCHDigit(e) - Si.getBCHDigit(Si.G18) >= 0;) e ^= Si.G18 << Si.getBCHDigit(e) - Si.getBCHDigit(Si.G18);
            return t << 12 | e
        },
        getBCHDigit: function(t) {
            for (var e = 0; t != 0;) e++, t >>>= 1;
            return e
        },
        getPatternPosition: function(t) {
            return Si.PATTERN_POSITION_TABLE[t - 1]
        },
        getMask: function(t, e, n) {
            switch (t) {
                case f0.PATTERN000:
                    return (e + n) % 2 == 0;
                case f0.PATTERN001:
                    return e % 2 == 0;
                case f0.PATTERN010:
                    return n % 3 == 0;
                case f0.PATTERN011:
                    return (e + n) % 3 == 0;
                case f0.PATTERN100:
                    return (Math.floor(e / 2) + Math.floor(n / 3)) % 2 == 0;
                case f0.PATTERN101:
                    return e * n % 2 + e * n % 3 == 0;
                case f0.PATTERN110:
                    return (e * n % 2 + e * n % 3) % 2 == 0;
                case f0.PATTERN111:
                    return (e * n % 3 + (e + n) % 2) % 2 == 0;
                default:
                    throw new Error("bad maskPattern:" + t)
            }
        },
        getErrorCorrectPolynomial: function(t) {
            for (var e = new dv([1], 0), n = 0; n < t; n++) e = e.multiply(new dv([1, qs.gexp(n)], 0));
            return e
        },
        getLengthInBits: function(t, e) {
            if (1 <= e && e < 10) switch (t) {
                case fl.MODE_NUMBER:
                    return 10;
                case fl.MODE_ALPHA_NUM:
                    return 9;
                case fl.MODE_8BIT_BYTE:
                    return 8;
                case fl.MODE_KANJI:
                    return 8;
                default:
                    throw new Error("mode:" + t)
            } else if (e < 27) switch (t) {
                case fl.MODE_NUMBER:
                    return 12;
                case fl.MODE_ALPHA_NUM:
                    return 11;
                case fl.MODE_8BIT_BYTE:
                    return 16;
                case fl.MODE_KANJI:
                    return 10;
                default:
                    throw new Error("mode:" + t)
            } else if (e < 41) switch (t) {
                case fl.MODE_NUMBER:
                    return 14;
                case fl.MODE_ALPHA_NUM:
                    return 13;
                case fl.MODE_8BIT_BYTE:
                    return 16;
                case fl.MODE_KANJI:
                    return 12;
                default:
                    throw new Error("mode:" + t)
            } else throw new Error("type:" + e)
        },
        getLostPoint: function(t) {
            for (var e = t.getModuleCount(), n = 0, r = 0; r < e; r++)
                for (var i = 0; i < e; i++) {
                    for (var s = 0, o = t.isDark(r, i), a = -1; a <= 1; a++)
                        if (!(r + a < 0 || e <= r + a))
                            for (var l = -1; l <= 1; l++) i + l < 0 || e <= i + l || a == 0 && l == 0 || o == t.isDark(r + a, i + l) && s++;
                    s > 5 && (n += 3 + s - 5)
                }
            for (var r = 0; r < e - 1; r++)
                for (var i = 0; i < e - 1; i++) {
                    var c = 0;
                    t.isDark(r, i) && c++, t.isDark(r + 1, i) && c++, t.isDark(r, i + 1) && c++, t.isDark(r + 1, i + 1) && c++, (c == 0 || c == 4) && (n += 3)
                }
            for (var r = 0; r < e; r++)
                for (var i = 0; i < e - 6; i++) t.isDark(r, i) && !t.isDark(r, i + 1) && t.isDark(r, i + 2) && t.isDark(r, i + 3) && t.isDark(r, i + 4) && !t.isDark(r, i + 5) && t.isDark(r, i + 6) && (n += 40);
            for (var i = 0; i < e; i++)
                for (var r = 0; r < e - 6; r++) t.isDark(r, i) && !t.isDark(r + 1, i) && t.isDark(r + 2, i) && t.isDark(r + 3, i) && t.isDark(r + 4, i) && !t.isDark(r + 5, i) && t.isDark(r + 6, i) && (n += 40);
            for (var u = 0, i = 0; i < e; i++)
                for (var r = 0; r < e; r++) t.isDark(r, i) && u++;
            var f = Math.abs(100 * u / e / e - 50) / 5;
            return n += f * 10, n
        }
    },
    qs = {
        glog: function(t) {
            if (t < 1) throw new Error("glog(" + t + ")");
            return qs.LOG_TABLE[t]
        },
        gexp: function(t) {
            for (; t < 0;) t += 255;
            for (; t >= 256;) t -= 255;
            return qs.EXP_TABLE[t]
        },
        EXP_TABLE: new Array(256),
        LOG_TABLE: new Array(256)
    };
for (var io = 0; io < 8; io++) qs.EXP_TABLE[io] = 1 << io;
for (var io = 8; io < 256; io++) qs.EXP_TABLE[io] = qs.EXP_TABLE[io - 4] ^ qs.EXP_TABLE[io - 5] ^ qs.EXP_TABLE[io - 6] ^ qs.EXP_TABLE[io - 8];
for (var io = 0; io < 255; io++) qs.LOG_TABLE[qs.EXP_TABLE[io]] = io;

function dv(t, e) {
    if (t.length == null) throw new Error(t.length + "/" + e);
    for (var n = 0; n < t.length && t[n] == 0;) n++;
    this.num = new Array(t.length - n + e);
    for (var r = 0; r < t.length - n; r++) this.num[r] = t[r + n]
}
dv.prototype = {
    get: function(t) {
        return this.num[t]
    },
    getLength: function() {
        return this.num.length
    },
    multiply: function(t) {
        for (var e = new Array(this.getLength() + t.getLength() - 1), n = 0; n < this.getLength(); n++)
            for (var r = 0; r < t.getLength(); r++) e[n + r] ^= qs.gexp(qs.glog(this.get(n)) + qs.glog(t.get(r)));
        return new dv(e, 0)
    },
    mod: function(t) {
        if (this.getLength() - t.getLength() < 0) return this;
        for (var e = qs.glog(this.get(0)) - qs.glog(t.get(0)), n = new Array(this.getLength()), r = 0; r < this.getLength(); r++) n[r] = this.get(r);
        for (var r = 0; r < t.getLength(); r++) n[r] ^= qs.gexp(qs.glog(t.get(r)) + e);
        return new dv(n, 0).mod(t)
    }
};

function Df(t, e) {
    this.totalCount = t, this.dataCount = e
}
Df.RS_BLOCK_TABLE = [
    [1, 26, 19],
    [1, 26, 16],
    [1, 26, 13],
    [1, 26, 9],
    [1, 44, 34],
    [1, 44, 28],
    [1, 44, 22],
    [1, 44, 16],
    [1, 70, 55],
    [1, 70, 44],
    [2, 35, 17],
    [2, 35, 13],
    [1, 100, 80],
    [2, 50, 32],
    [2, 50, 24],
    [4, 25, 9],
    [1, 134, 108],
    [2, 67, 43],
    [2, 33, 15, 2, 34, 16],
    [2, 33, 11, 2, 34, 12],
    [2, 86, 68],
    [4, 43, 27],
    [4, 43, 19],
    [4, 43, 15],
    [2, 98, 78],
    [4, 49, 31],
    [2, 32, 14, 4, 33, 15],
    [4, 39, 13, 1, 40, 14],
    [2, 121, 97],
    [2, 60, 38, 2, 61, 39],
    [4, 40, 18, 2, 41, 19],
    [4, 40, 14, 2, 41, 15],
    [2, 146, 116],
    [3, 58, 36, 2, 59, 37],
    [4, 36, 16, 4, 37, 17],
    [4, 36, 12, 4, 37, 13],
    [2, 86, 68, 2, 87, 69],
    [4, 69, 43, 1, 70, 44],
    [6, 43, 19, 2, 44, 20],
    [6, 43, 15, 2, 44, 16],
    [4, 101, 81],
    [1, 80, 50, 4, 81, 51],
    [4, 50, 22, 4, 51, 23],
    [3, 36, 12, 8, 37, 13],
    [2, 116, 92, 2, 117, 93],
    [6, 58, 36, 2, 59, 37],
    [4, 46, 20, 6, 47, 21],
    [7, 42, 14, 4, 43, 15],
    [4, 133, 107],
    [8, 59, 37, 1, 60, 38],
    [8, 44, 20, 4, 45, 21],
    [12, 33, 11, 4, 34, 12],
    [3, 145, 115, 1, 146, 116],
    [4, 64, 40, 5, 65, 41],
    [11, 36, 16, 5, 37, 17],
    [11, 36, 12, 5, 37, 13],
    [5, 109, 87, 1, 110, 88],
    [5, 65, 41, 5, 66, 42],
    [5, 54, 24, 7, 55, 25],
    [11, 36, 12],
    [5, 122, 98, 1, 123, 99],
    [7, 73, 45, 3, 74, 46],
    [15, 43, 19, 2, 44, 20],
    [3, 45, 15, 13, 46, 16],
    [1, 135, 107, 5, 136, 108],
    [10, 74, 46, 1, 75, 47],
    [1, 50, 22, 15, 51, 23],
    [2, 42, 14, 17, 43, 15],
    [5, 150, 120, 1, 151, 121],
    [9, 69, 43, 4, 70, 44],
    [17, 50, 22, 1, 51, 23],
    [2, 42, 14, 19, 43, 15],
    [3, 141, 113, 4, 142, 114],
    [3, 70, 44, 11, 71, 45],
    [17, 47, 21, 4, 48, 22],
    [9, 39, 13, 16, 40, 14],
    [3, 135, 107, 5, 136, 108],
    [3, 67, 41, 13, 68, 42],
    [15, 54, 24, 5, 55, 25],
    [15, 43, 15, 10, 44, 16],
    [4, 144, 116, 4, 145, 117],
    [17, 68, 42],
    [17, 50, 22, 6, 51, 23],
    [19, 46, 16, 6, 47, 17],
    [2, 139, 111, 7, 140, 112],
    [17, 74, 46],
    [7, 54, 24, 16, 55, 25],
    [34, 37, 13],
    [4, 151, 121, 5, 152, 122],
    [4, 75, 47, 14, 76, 48],
    [11, 54, 24, 14, 55, 25],
    [16, 45, 15, 14, 46, 16],
    [6, 147, 117, 4, 148, 118],
    [6, 73, 45, 14, 74, 46],
    [11, 54, 24, 16, 55, 25],
    [30, 46, 16, 2, 47, 17],
    [8, 132, 106, 4, 133, 107],
    [8, 75, 47, 13, 76, 48],
    [7, 54, 24, 22, 55, 25],
    [22, 45, 15, 13, 46, 16],
    [10, 142, 114, 2, 143, 115],
    [19, 74, 46, 4, 75, 47],
    [28, 50, 22, 6, 51, 23],
    [33, 46, 16, 4, 47, 17],
    [8, 152, 122, 4, 153, 123],
    [22, 73, 45, 3, 74, 46],
    [8, 53, 23, 26, 54, 24],
    [12, 45, 15, 28, 46, 16],
    [3, 147, 117, 10, 148, 118],
    [3, 73, 45, 23, 74, 46],
    [4, 54, 24, 31, 55, 25],
    [11, 45, 15, 31, 46, 16],
    [7, 146, 116, 7, 147, 117],
    [21, 73, 45, 7, 74, 46],
    [1, 53, 23, 37, 54, 24],
    [19, 45, 15, 26, 46, 16],
    [5, 145, 115, 10, 146, 116],
    [19, 75, 47, 10, 76, 48],
    [15, 54, 24, 25, 55, 25],
    [23, 45, 15, 25, 46, 16],
    [13, 145, 115, 3, 146, 116],
    [2, 74, 46, 29, 75, 47],
    [42, 54, 24, 1, 55, 25],
    [23, 45, 15, 28, 46, 16],
    [17, 145, 115],
    [10, 74, 46, 23, 75, 47],
    [10, 54, 24, 35, 55, 25],
    [19, 45, 15, 35, 46, 16],
    [17, 145, 115, 1, 146, 116],
    [14, 74, 46, 21, 75, 47],
    [29, 54, 24, 19, 55, 25],
    [11, 45, 15, 46, 46, 16],
    [13, 145, 115, 6, 146, 116],
    [14, 74, 46, 23, 75, 47],
    [44, 54, 24, 7, 55, 25],
    [59, 46, 16, 1, 47, 17],
    [12, 151, 121, 7, 152, 122],
    [12, 75, 47, 26, 76, 48],
    [39, 54, 24, 14, 55, 25],
    [22, 45, 15, 41, 46, 16],
    [6, 151, 121, 14, 152, 122],
    [6, 75, 47, 34, 76, 48],
    [46, 54, 24, 10, 55, 25],
    [2, 45, 15, 64, 46, 16],
    [17, 152, 122, 4, 153, 123],
    [29, 74, 46, 14, 75, 47],
    [49, 54, 24, 10, 55, 25],
    [24, 45, 15, 46, 46, 16],
    [4, 152, 122, 18, 153, 123],
    [13, 74, 46, 32, 75, 47],
    [48, 54, 24, 14, 55, 25],
    [42, 45, 15, 32, 46, 16],
    [20, 147, 117, 4, 148, 118],
    [40, 75, 47, 7, 76, 48],
    [43, 54, 24, 22, 55, 25],
    [10, 45, 15, 67, 46, 16],
    [19, 148, 118, 6, 149, 119],
    [18, 75, 47, 31, 76, 48],
    [34, 54, 24, 34, 55, 25],
    [20, 45, 15, 61, 46, 16]
];
Df.getRSBlocks = function(t, e) {
    var n = Df.getRsBlockTable(t, e);
    if (n == null) throw new Error("bad rs block @ typeNumber:" + t + "/errorCorrectLevel:" + e);
    for (var r = n.length / 3, i = [], s = 0; s < r; s++)
        for (var o = n[s * 3 + 0], a = n[s * 3 + 1], l = n[s * 3 + 2], c = 0; c < o; c++) i.push(new Df(a, l));
    return i
};
Df.getRsBlockTable = function(t, e) {
    switch (e) {
        case dp.L:
            return Df.RS_BLOCK_TABLE[(t - 1) * 4 + 0];
        case dp.M:
            return Df.RS_BLOCK_TABLE[(t - 1) * 4 + 1];
        case dp.Q:
            return Df.RS_BLOCK_TABLE[(t - 1) * 4 + 2];
        case dp.H:
            return Df.RS_BLOCK_TABLE[(t - 1) * 4 + 3];
        default:
            return
    }
};

function ale() {
    this.buffer = [], this.length = 0
}
ale.prototype = {
    get: function(t) {
        var e = Math.floor(t / 8);
        return (this.buffer[e] >>> 7 - t % 8 & 1) == 1
    },
    put: function(t, e) {
        for (var n = 0; n < e; n++) this.putBit((t >>> e - n - 1 & 1) == 1)
    },
    getLengthInBits: function() {
        return this.length
    },
    putBit: function(t) {
        var e = Math.floor(this.length / 8);
        this.buffer.length <= e && this.buffer.push(0), t && (this.buffer[e] |= 128 >>> this.length % 8), this.length++
    }
};
var gN = [
    [17, 14, 11, 7],
    [32, 26, 20, 14],
    [53, 42, 32, 24],
    [78, 62, 46, 34],
    [106, 84, 60, 44],
    [134, 106, 74, 58],
    [154, 122, 86, 64],
    [192, 152, 108, 84],
    [230, 180, 130, 98],
    [271, 213, 151, 119],
    [321, 251, 177, 137],
    [367, 287, 203, 155],
    [425, 331, 241, 177],
    [458, 362, 258, 194],
    [520, 412, 292, 220],
    [586, 450, 322, 250],
    [644, 504, 364, 280],
    [718, 560, 394, 310],
    [792, 624, 442, 338],
    [858, 666, 482, 382],
    [929, 711, 509, 403],
    [1003, 779, 565, 439],
    [1091, 857, 611, 461],
    [1171, 911, 661, 511],
    [1273, 997, 715, 535],
    [1367, 1059, 751, 593],
    [1465, 1125, 805, 625],
    [1528, 1190, 868, 658],
    [1628, 1264, 908, 698],
    [1732, 1370, 982, 742],
    [1840, 1452, 1030, 790],
    [1952, 1538, 1112, 842],
    [2068, 1628, 1168, 898],
    [2188, 1722, 1228, 958],
    [2303, 1809, 1283, 983],
    [2431, 1911, 1351, 1051],
    [2563, 1989, 1423, 1093],
    [2699, 2099, 1499, 1139],
    [2809, 2213, 1579, 1219],
    [2953, 2331, 1663, 1273]
];

function lle(t) {
    if (this.options = {
            padding: 4,
            width: 256,
            height: 256,
            typeNumber: 4,
            color: "#000000",
            background: "#ffffff",
            ecl: "M",
            image: {
                svg: "",
                width: 0,
                height: 0
            }
        }, typeof t == "string" && (t = {
            content: t
        }), t)
        for (var e in t) this.options[e] = t[e];
    if (typeof this.options.content != "string") throw new Error("Expected 'content' as string!");
    if (this.options.content.length === 0) throw new Error("Expected 'content' to be non-empty!");
    if (!(this.options.padding >= 0)) throw new Error("Expected 'padding' value to be non-negative!");
    if (!(this.options.width > 0) || !(this.options.height > 0)) throw new Error("Expected 'width' or 'height' value to be higher than zero!");

    function n(l) {
        switch (l) {
            case "L":
                return dp.L;
            case "M":
                return dp.M;
            case "Q":
                return dp.Q;
            case "H":
                return dp.H;
            default:
                throw new Error("Unknwon error correction level: " + l)
        }
    }

    function r(l, c) {
        for (var u = i(l), f = 1, h = 0, g = 0, y = gN.length; g <= y; g++) {
            var _ = gN[g];
            if (!_) throw new Error("Content too long: expected " + h + " but got " + u);
            switch (c) {
                case "L":
                    h = _[0];
                    break;
                case "M":
                    h = _[1];
                    break;
                case "Q":
                    h = _[2];
                    break;
                case "H":
                    h = _[3];
                    break;
                default:
                    throw new Error("Unknwon error correction level: " + c)
            }
            if (u <= h) break;
            f++
        }
        if (f > gN.length) throw new Error("Content too long");
        return f
    }

    function i(l) {
        var c = encodeURI(l).toString().replace(/\%[0-9a-fA-F]{2}/g, "a");
        return c.length + (c.length != l ? 3 : 0)
    }
    var s = this.options.content,
        o = r(s, this.options.ecl),
        a = n(this.options.ecl);
    this.qrcode = new Hf(o, a), this.qrcode.addData(s), this.qrcode.make()
}
lle.prototype.svg = function(t) {
    var e = this.options || {},
        n = this.qrcode.modules;
    typeof t > "u" && (t = {
        container: e.container || "svg"
    });
    for (var r = typeof e.pretty < "u" ? !!e.pretty : !0, i = r ? "  " : "", s = r ? `\r
` : "", o = e.width, a = e.height, l = n.length, c = o / (l + 2 * e.padding), u = a / (l + 2 * e.padding), f = typeof e.join < "u" ? !!e.join : !1, h = typeof e.swap < "u" ? !!e.swap : !1, g = typeof e.xmlDeclaration < "u" ? !!e.xmlDeclaration : !0, y = typeof e.predefined < "u" ? !!e.predefined : !1, _ = y ? i + '<defs><path id="qrmodule" d="M0 0 h' + u + " v" + c + ' H0 z" style="fill:' + e.color + ';shape-rendering:crispEdges;" /></defs>' + s : "", C = i + '<rect x="0" y="0" width="' + o + '" height="' + a + '" style="fill:' + e.background + ';shape-rendering:crispEdges;"/>' + s, b = "", w = "", S = 0; S < l; S++)
        for (var I = 0; I < l; I++) {
            var P = n[I][S];
            if (P) {
                var M = I * c + e.padding * c,
                    A = S * u + e.padding * u;
                if (h) {
                    var E = M;
                    M = A, A = E
                }
                if (f) {
                    var $ = c + M,
                        H = u + A;
                    M = Number.isInteger(M) ? Number(M) : M.toFixed(2), A = Number.isInteger(A) ? Number(A) : A.toFixed(2), $ = Number.isInteger($) ? Number($) : $.toFixed(2), H = Number.isInteger(H) ? Number(H) : H.toFixed(2), w += "M" + M + "," + A + " V" + H + " H" + $ + " V" + A + " H" + M + " Z "
                } else y ? b += i + '<use x="' + M.toString() + '" y="' + A.toString() + '" href="#qrmodule" />' + s : b += i + '<rect x="' + M.toString() + '" y="' + A.toString() + '" width="' + c + '" height="' + u + '" style="fill:' + e.color + ';shape-rendering:crispEdges;"/>' + s
            }
        }
    f && (b = i + '<path x="0" y="0" style="fill:' + e.color + ';shape-rendering:crispEdges;" d="' + w + '" />');
    let K = "";
    if (this.options.image !== void 0 && this.options.image.svg) {
        const U = o * this.options.image.width / 100,
            m = a * this.options.image.height / 100,
            v = o / 2 - U / 2,
            T = a / 2 - m / 2;
        K += `<svg x="${v}" y="${T}" width="${U}" height="${m}" viewBox="0 0 100 100" preserveAspectRatio="xMinYMin meet">`, K += this.options.image.svg + s, K += "</svg>"
    }
    var te = "";
    switch (t.container) {
        case "svg":
            g && (te += '<?xml version="1.0" standalone="yes"?>' + s), te += '<svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="' + o + '" height="' + a + '">' + s, te += _ + C + b, te += K, te += "</svg>";
            break;
        case "svg-viewbox":
            g && (te += '<?xml version="1.0" standalone="yes"?>' + s), te += '<svg xmlns="http://www.w3.org/2000/svg" version="1.1" viewBox="0 0 ' + o + " " + a + '">' + s, te += _ + C + b, te += K, te += "</svg>";
            break;
        case "g":
            te += '<g width="' + o + '" height="' + a + '">' + s, te += _ + C + b, te += K, te += "</g>";
            break;
        default:
            te += (_ + C + b + K).replace(/^\s+/, "");
            break
    }
    return te
};
var zGe = lle,
    WGe = st && st.__importDefault || function(t) {
        return t && t.__esModule ? t : {
            default: t
        }
    };
Object.defineProperty(Y9, "__esModule", {
    value: !0
});
Y9.QRCode = void 0;
const VGe = Dl,
    OY = a4,
    GGe = WGe(zGe),
    qGe = t => {
        const [e, n] = (0, OY.useState)("");
        return (0, OY.useEffect)(() => {
            var r, i;
            const s = new GGe.default({
                    content: t.content,
                    background: t.bgColor || "#ffffff",
                    color: t.fgColor || "#000000",
                    container: "svg",
                    ecl: "M",
                    width: (r = t.width) !== null && r !== void 0 ? r : 256,
                    height: (i = t.height) !== null && i !== void 0 ? i : 256,
                    padding: 0,
                    image: t.image
                }),
                o = Buffer.from(s.svg(), "utf8").toString("base64");
            n(`data:image/svg+xml;base64,${o}`)
        }), e ? (0, VGe.h)("img", {
            src: e,
            alt: "QR Code"
        }) : null
    };
Y9.QRCode = qGe;
var Z9 = {},
    ZB = {};
Object.defineProperty(ZB, "__esModule", {
    value: !0
});
ZB.default = ".-cbwsdk-css-reset .-cbwsdk-spinner{display:inline-block}.-cbwsdk-css-reset .-cbwsdk-spinner svg{display:inline-block;animation:2s linear infinite -cbwsdk-spinner-svg}.-cbwsdk-css-reset .-cbwsdk-spinner svg circle{animation:1.9s ease-in-out infinite both -cbwsdk-spinner-circle;display:block;fill:rgba(0,0,0,0);stroke-dasharray:283;stroke-dashoffset:280;stroke-linecap:round;stroke-width:10px;transform-origin:50% 50%}@keyframes -cbwsdk-spinner-svg{0%{transform:rotateZ(0deg)}100%{transform:rotateZ(360deg)}}@keyframes -cbwsdk-spinner-circle{0%,25%{stroke-dashoffset:280;transform:rotate(0)}50%,75%{stroke-dashoffset:75;transform:rotate(45deg)}100%{stroke-dashoffset:280;transform:rotate(360deg)}}";
var KGe = st && st.__importDefault || function(t) {
    return t && t.__esModule ? t : {
        default: t
    }
};
Object.defineProperty(Z9, "__esModule", {
    value: !0
});
Z9.Spinner = void 0;
const dS = Dl,
    YGe = KGe(ZB),
    ZGe = t => {
        var e;
        const n = (e = t.size) !== null && e !== void 0 ? e : 64,
            r = t.color || "#000";
        return (0, dS.h)("div", {
            class: "-cbwsdk-spinner"
        }, (0, dS.h)("style", null, YGe.default), (0, dS.h)("svg", {
            viewBox: "0 0 100 100",
            xmlns: "http://www.w3.org/2000/svg",
            style: {
                width: n,
                height: n
            }
        }, (0, dS.h)("circle", {
            style: {
                cx: 50,
                cy: 50,
                r: 45,
                stroke: r
            }
        })))
    };
Z9.Spinner = ZGe;
var QB = {};
Object.defineProperty(QB, "__esModule", {
    value: !0
});
QB.default = ".-cbwsdk-css-reset .-cbwsdk-connect-content{height:430px;width:700px;border-radius:12px;padding:30px}.-cbwsdk-css-reset .-cbwsdk-connect-content.light{background:#fff}.-cbwsdk-css-reset .-cbwsdk-connect-content.dark{background:#0a0b0d}.-cbwsdk-css-reset .-cbwsdk-connect-content-header{display:flex;align-items:center;justify-content:space-between;margin:0 0 30px}.-cbwsdk-css-reset .-cbwsdk-connect-content-heading{font-style:normal;font-weight:500;font-size:28px;line-height:36px;margin:0}.-cbwsdk-css-reset .-cbwsdk-connect-content-heading.light{color:#0a0b0d}.-cbwsdk-css-reset .-cbwsdk-connect-content-heading.dark{color:#fff}.-cbwsdk-css-reset .-cbwsdk-connect-content-layout{display:flex;flex-direction:row}.-cbwsdk-css-reset .-cbwsdk-connect-content-column-left{margin-right:30px;display:flex;flex-direction:column;justify-content:space-between}.-cbwsdk-css-reset .-cbwsdk-connect-content-column-right{flex:25%;margin-right:34px}.-cbwsdk-css-reset .-cbwsdk-connect-content-qr-wrapper{width:220px;height:220px;border-radius:12px;display:flex;justify-content:center;align-items:center;background:#fff}.-cbwsdk-css-reset .-cbwsdk-connect-content-qr-connecting{position:absolute;top:0;bottom:0;left:0;right:0;display:flex;flex-direction:column;align-items:center;justify-content:center}.-cbwsdk-css-reset .-cbwsdk-connect-content-qr-connecting.light{background-color:rgba(255,255,255,.95)}.-cbwsdk-css-reset .-cbwsdk-connect-content-qr-connecting.light>p{color:#0a0b0d}.-cbwsdk-css-reset .-cbwsdk-connect-content-qr-connecting.dark{background-color:rgba(10,11,13,.9)}.-cbwsdk-css-reset .-cbwsdk-connect-content-qr-connecting.dark>p{color:#fff}.-cbwsdk-css-reset .-cbwsdk-connect-content-qr-connecting>p{font-size:12px;font-weight:bold;margin-top:16px}.-cbwsdk-css-reset .-cbwsdk-connect-content-update-app{border-radius:8px;font-size:14px;line-height:20px;padding:12px;width:339px}.-cbwsdk-css-reset .-cbwsdk-connect-content-update-app.light{background:#eef0f3;color:#5b636e}.-cbwsdk-css-reset .-cbwsdk-connect-content-update-app.dark{background:#1e2025;color:#8a919e}.-cbwsdk-css-reset .-cbwsdk-cancel-button{-webkit-appearance:none;border:none;background:none;cursor:pointer;padding:0;margin:0}.-cbwsdk-css-reset .-cbwsdk-cancel-button-x{position:relative;display:block;cursor:pointer}.-cbwsdk-css-reset .-cbwsdk-wallet-steps{padding:0 0 0 16px;margin:0;width:100%;list-style:decimal}.-cbwsdk-css-reset .-cbwsdk-wallet-steps-item{list-style-type:decimal;display:list-item;font-style:normal;font-weight:400;font-size:16px;line-height:24px;margin-top:20px}.-cbwsdk-css-reset .-cbwsdk-wallet-steps-item.light{color:#0a0b0d}.-cbwsdk-css-reset .-cbwsdk-wallet-steps-item.dark{color:#fff}.-cbwsdk-css-reset .-cbwsdk-wallet-steps-item-wrapper{display:flex;align-items:center}.-cbwsdk-css-reset .-cbwsdk-wallet-steps-pad-left{margin-left:6px}.-cbwsdk-css-reset .-cbwsdk-wallet-steps-icon{display:flex;border-radius:50%;height:24px;width:24px}.-cbwsdk-css-reset .-cbwsdk-wallet-steps-icon svg{margin:auto;display:block}.-cbwsdk-css-reset .-cbwsdk-wallet-steps-icon.light{background:#0052ff}.-cbwsdk-css-reset .-cbwsdk-wallet-steps-icon.dark{background:#588af5}.-cbwsdk-css-reset .-cbwsdk-connect-item{align-items:center;display:flex;flex-direction:row;padding:16px 24px;gap:12px;cursor:pointer}.-cbwsdk-css-reset .-cbwsdk-connect-item.light{color:#0a0b0d}.-cbwsdk-css-reset .-cbwsdk-connect-item.light.selected{background:#f5f8ff;color:#0052ff}.-cbwsdk-css-reset .-cbwsdk-connect-item.dark{color:#fff}.-cbwsdk-css-reset .-cbwsdk-connect-item.dark.selected{background:#001033;color:#588af5}.-cbwsdk-css-reset .-cbwsdk-connect-item.selected{border-radius:100px;font-weight:600}.-cbwsdk-css-reset .-cbwsdk-connect-item-copy-wrapper{margin:0 4px 0 8px}.-cbwsdk-css-reset .-cbwsdk-connect-item-title{margin:0 0 0;font-size:16px;line-height:24px;font-weight:500}.-cbwsdk-css-reset .-cbwsdk-connect-item-description{font-weight:400;font-size:14px;line-height:20px;margin:0}";
var K2 = st && st.__importDefault || function(t) {
    return t && t.__esModule ? t : {
        default: t
    }
};
Object.defineProperty(jf, "__esModule", {
    value: !0
});
jf.CoinbaseAppSteps = jf.CoinbaseWalletSteps = jf.ConnectItem = jf.ConnectContent = void 0;
const _c = K2(V9),
    sn = Dl,
    NY = a4,
    QGe = Ut,
    JGe = $2,
    XGe = G9,
    eqe = K2(GB),
    tqe = K2(qB),
    cle = q9,
    nqe = K2(KB),
    rqe = K2(YB),
    iqe = K9,
    sqe = Y9,
    oqe = Z9,
    aqe = K2(QB),
    PY = {
        "coinbase-wallet-app": {
            title: "Coinbase Wallet app",
            description: "Connect with your self-custody wallet",
            icon: tqe.default,
            steps: fle
        },
        "coinbase-app": {
            title: "Coinbase app",
            description: "Connect with your Coinbase account",
            icon: eqe.default,
            steps: dle
        }
    },
    lqe = t => {
        switch (t) {
            case "coinbase-app":
                return nqe.default;
            case "coinbase-wallet-app":
            default:
                return rqe.default
        }
    },
    kM = t => t === "light" ? "#FFFFFF" : "#0A0B0D";

function cqe(t) {
    const {
        theme: e
    } = t, [n, r] = (0, NY.useState)("coinbase-wallet-app"), i = (0, NY.useCallback)(c => {
        r(c)
    }, []), s = (0, QGe.createQrUrl)(t.sessionId, t.sessionSecret, t.linkAPIUrl, t.isParentConnection, t.version, t.chainId), o = PY[n];
    if (!n) return null;
    const a = o.steps,
        l = n === "coinbase-app";
    return (0, sn.h)("div", {
        "data-testid": "connect-content",
        class: (0, _c.default)("-cbwsdk-connect-content", e)
    }, (0, sn.h)("style", null, aqe.default), (0, sn.h)("div", {
        class: "-cbwsdk-connect-content-header"
    }, (0, sn.h)("h2", {
        class: (0, _c.default)("-cbwsdk-connect-content-heading", e)
    }, "Scan to connect with one of our mobile apps"), t.onCancel && (0, sn.h)("button", {
        type: "button",
        class: "-cbwsdk-cancel-button",
        onClick: t.onCancel
    }, (0, sn.h)(XGe.CloseIcon, {
        fill: e === "light" ? "#0A0B0D" : "#FFFFFF"
    }))), (0, sn.h)("div", {
        class: "-cbwsdk-connect-content-layout"
    }, (0, sn.h)("div", {
        class: "-cbwsdk-connect-content-column-left"
    }, (0, sn.h)("div", null, Object.entries(PY).map(([c, u]) => (0, sn.h)(ule, {
        key: c,
        title: u.title,
        description: u.description,
        icon: u.icon,
        selected: n === c,
        onClick: () => i(c),
        theme: e
    }))), l && (0, sn.h)("div", {
        class: (0, _c.default)("-cbwsdk-connect-content-update-app", e)
    }, "Dont see a ", (0, sn.h)("strong", null, "Scan"), " option? Update your Coinbase app to the latest version and try again.")), (0, sn.h)("div", {
        class: "-cbwsdk-connect-content-column-right"
    }, (0, sn.h)("div", {
        class: "-cbwsdk-connect-content-qr-wrapper"
    }, (0, sn.h)(sqe.QRCode, {
        content: s,
        width: 200,
        height: 200,
        fgColor: "#000",
        bgColor: "transparent",
        image: {
            svg: lqe(n),
            width: 25,
            height: 25
        }
    }), (0, sn.h)("input", {
        type: "hidden",
        name: "cbw-cbwsdk-version",
        value: JGe.LIB_VERSION
    }), (0, sn.h)("input", {
        type: "hidden",
        value: s
    })), (0, sn.h)(a, {
        theme: e
    }), !t.isConnected && (0, sn.h)("div", {
        "data-testid": "connecting-spinner",
        class: (0, _c.default)("-cbwsdk-connect-content-qr-connecting", e)
    }, (0, sn.h)(oqe.Spinner, {
        size: 36,
        color: e === "dark" ? "#FFF" : "#000"
    }), (0, sn.h)("p", null, "Connecting...")))))
}
jf.ConnectContent = cqe;

function ule({
    title: t,
    description: e,
    icon: n,
    selected: r,
    theme: i,
    onClick: s
}) {
    return (0, sn.h)("div", {
        onClick: s,
        class: (0, _c.default)("-cbwsdk-connect-item", i, {
            selected: r
        })
    }, (0, sn.h)("div", null, (0, sn.h)("img", {
        src: n,
        alt: t
    })), (0, sn.h)("div", {
        class: "-cbwsdk-connect-item-copy-wrapper"
    }, (0, sn.h)("h3", {
        class: "-cbwsdk-connect-item-title"
    }, t), (0, sn.h)("p", {
        class: "-cbwsdk-connect-item-description"
    }, e)))
}
jf.ConnectItem = ule;

function fle({
    theme: t
}) {
    return (0, sn.h)("ol", {
        class: "-cbwsdk-wallet-steps"
    }, (0, sn.h)("li", {
        class: (0, _c.default)("-cbwsdk-wallet-steps-item", t)
    }, (0, sn.h)("div", {
        class: "-cbwsdk-wallet-steps-item-wrapper"
    }, "Open Coinbase Wallet app")), (0, sn.h)("li", {
        class: (0, _c.default)("-cbwsdk-wallet-steps-item", t)
    }, (0, sn.h)("div", {
        class: "-cbwsdk-wallet-steps-item-wrapper"
    }, (0, sn.h)("span", null, "Tap ", (0, sn.h)("strong", null, "Scan"), " "), (0, sn.h)("span", {
        class: (0, _c.default)("-cbwsdk-wallet-steps-pad-left", "-cbwsdk-wallet-steps-icon", t)
    }, (0, sn.h)(cle.QRCodeIcon, {
        fill: kM(t)
    })))))
}
jf.CoinbaseWalletSteps = fle;

function dle({
    theme: t
}) {
    return (0, sn.h)("ol", {
        class: "-cbwsdk-wallet-steps"
    }, (0, sn.h)("li", {
        class: (0, _c.default)("-cbwsdk-wallet-steps-item", t)
    }, (0, sn.h)("div", {
        class: "-cbwsdk-wallet-steps-item-wrapper"
    }, "Open Coinbase app")), (0, sn.h)("li", {
        class: (0, _c.default)("-cbwsdk-wallet-steps-item", t)
    }, (0, sn.h)("div", {
        class: "-cbwsdk-wallet-steps-item-wrapper"
    }, (0, sn.h)("span", null, "Tap ", (0, sn.h)("strong", null, "More")), (0, sn.h)("span", {
        class: (0, _c.default)("-cbwsdk-wallet-steps-pad-left", "-cbwsdk-wallet-steps-icon", t)
    }, (0, sn.h)(iqe.StatusDotIcon, {
        fill: kM(t)
    })), (0, sn.h)("span", {
        class: "-cbwsdk-wallet-steps-pad-left"
    }, "then ", (0, sn.h)("strong", null, "Scan")), (0, sn.h)("span", {
        class: (0, _c.default)("-cbwsdk-wallet-steps-pad-left", "-cbwsdk-wallet-steps-icon", t)
    }, (0, sn.h)(cle.QRCodeIcon, {
        fill: kM(t)
    })))))
}
jf.CoinbaseAppSteps = dle;
var Q9 = {},
    J9 = {};
Object.defineProperty(J9, "__esModule", {
    value: !0
});
J9.ArrowLeftIcon = void 0;
const kY = Dl;

function uqe(t) {
    return (0, kY.h)("svg", Object.assign({
        width: "16",
        height: "16",
        viewBox: "0 0 16 16",
        xmlns: "http://www.w3.org/2000/svg"
    }, t), (0, kY.h)("path", {
        d: "M8.60675 0.155884L7.37816 1.28209L12.7723 7.16662H0V8.83328H12.6548L6.82149 14.6666L8 15.8451L15.8201 8.02501L8.60675 0.155884Z"
    }))
}
J9.ArrowLeftIcon = uqe;
var X9 = {};
Object.defineProperty(X9, "__esModule", {
    value: !0
});
X9.LaptopIcon = void 0;
const mN = Dl;

function fqe(t) {
    return (0, mN.h)("svg", Object.assign({
        width: "14",
        height: "14",
        viewBox: "0 0 14 14",
        xmlns: "http://www.w3.org/2000/svg"
    }, t), (0, mN.h)("path", {
        d: "M1.8001 2.2002H12.2001V9.40019H1.8001V2.2002ZM3.4001 3.8002V7.80019H10.6001V3.8002H3.4001Z"
    }), (0, mN.h)("path", {
        d: "M13.4001 10.2002H0.600098C0.600098 11.0838 1.31644 11.8002 2.2001 11.8002H11.8001C12.6838 11.8002 13.4001 11.0838 13.4001 10.2002Z"
    }))
}
X9.LaptopIcon = fqe;
var e7 = {};
Object.defineProperty(e7, "__esModule", {
    value: !0
});
e7.SafeIcon = void 0;
const MY = Dl;

function dqe(t) {
    return (0, MY.h)("svg", Object.assign({
        width: "14",
        height: "14",
        viewBox: "0 0 14 14",
        xmlns: "http://www.w3.org/2000/svg"
    }, t), (0, MY.h)("path", {
        "fill-rule": "evenodd",
        "clip-rule": "evenodd",
        d: "M0.600098 0.600098V11.8001H13.4001V0.600098H0.600098ZM7.0001 9.2001C5.3441 9.2001 4.0001 7.8561 4.0001 6.2001C4.0001 4.5441 5.3441 3.2001 7.0001 3.2001C8.6561 3.2001 10.0001 4.5441 10.0001 6.2001C10.0001 7.8561 8.6561 9.2001 7.0001 9.2001ZM0.600098 12.6001H3.8001V13.4001H0.600098V12.6001ZM10.2001 12.6001H13.4001V13.4001H10.2001V12.6001ZM8.8001 6.2001C8.8001 7.19421 7.99421 8.0001 7.0001 8.0001C6.00598 8.0001 5.2001 7.19421 5.2001 6.2001C5.2001 5.20598 6.00598 4.4001 7.0001 4.4001C7.99421 4.4001 8.8001 5.20598 8.8001 6.2001Z"
    }))
}
e7.SafeIcon = dqe;
var JB = {};
Object.defineProperty(JB, "__esModule", {
    value: !0
});
JB.default = ".-cbwsdk-css-reset .-cbwsdk-try-extension{display:flex;margin-top:12px;height:202px;width:700px;border-radius:12px;padding:30px}.-cbwsdk-css-reset .-cbwsdk-try-extension.light{background:#fff}.-cbwsdk-css-reset .-cbwsdk-try-extension.dark{background:#0a0b0d}.-cbwsdk-css-reset .-cbwsdk-try-extension-column-half{flex:50%}.-cbwsdk-css-reset .-cbwsdk-try-extension-heading{font-style:normal;font-weight:500;font-size:25px;line-height:32px;margin:0;max-width:204px}.-cbwsdk-css-reset .-cbwsdk-try-extension-heading.light{color:#0a0b0d}.-cbwsdk-css-reset .-cbwsdk-try-extension-heading.dark{color:#fff}.-cbwsdk-css-reset .-cbwsdk-try-extension-cta{appearance:none;border:none;background:none;color:#0052ff;cursor:pointer;padding:0;text-decoration:none;display:block;font-weight:600;font-size:16px;line-height:24px}.-cbwsdk-css-reset .-cbwsdk-try-extension-cta.light{color:#0052ff}.-cbwsdk-css-reset .-cbwsdk-try-extension-cta.dark{color:#588af5}.-cbwsdk-css-reset .-cbwsdk-try-extension-cta-wrapper{display:flex;align-items:center;margin-top:12px}.-cbwsdk-css-reset .-cbwsdk-try-extension-cta-icon{display:block;margin-left:4px;height:14px}.-cbwsdk-css-reset .-cbwsdk-try-extension-list{display:flex;flex-direction:column;justify-content:center;align-items:center;margin:0;padding:0;list-style:none;height:100%}.-cbwsdk-css-reset .-cbwsdk-try-extension-list-item{display:flex;align-items:center;flex-flow:nowrap;margin-top:24px}.-cbwsdk-css-reset .-cbwsdk-try-extension-list-item:first-of-type{margin-top:0}.-cbwsdk-css-reset .-cbwsdk-try-extension-list-item-icon-wrapper{display:block}.-cbwsdk-css-reset .-cbwsdk-try-extension-list-item-icon{display:flex;height:32px;width:32px;border-radius:50%}.-cbwsdk-css-reset .-cbwsdk-try-extension-list-item-icon svg{margin:auto;display:block}.-cbwsdk-css-reset .-cbwsdk-try-extension-list-item-icon.light{background:#eef0f3}.-cbwsdk-css-reset .-cbwsdk-try-extension-list-item-icon.dark{background:#1e2025}.-cbwsdk-css-reset .-cbwsdk-try-extension-list-item-copy{display:block;font-weight:400;font-size:14px;line-height:20px;padding-left:12px}.-cbwsdk-css-reset .-cbwsdk-try-extension-list-item-copy.light{color:#5b636e}.-cbwsdk-css-reset .-cbwsdk-try-extension-list-item-copy.dark{color:#8a919e}";
var hle = st && st.__importDefault || function(t) {
    return t && t.__esModule ? t : {
        default: t
    }
};
Object.defineProperty(Q9, "__esModule", {
    value: !0
});
Q9.TryExtensionContent = void 0;
const Bg = hle(V9),
    ys = Dl,
    yN = a4,
    hqe = J9,
    pqe = X9,
    gqe = e7,
    mqe = hle(JB);

function yqe({
    theme: t
}) {
    const [e, n] = (0, yN.useState)(!1), r = (0, yN.useCallback)(() => {
        window.open("https://api.wallet.coinbase.com/rpc/v2/desktop/chrome", "_blank")
    }, []), i = (0, yN.useCallback)(() => {
        e ? window.location.reload() : (r(), n(!0))
    }, [r, e]);
    return (0, ys.h)("div", {
        class: (0, Bg.default)("-cbwsdk-try-extension", t)
    }, (0, ys.h)("style", null, mqe.default), (0, ys.h)("div", {
        class: "-cbwsdk-try-extension-column-half"
    }, (0, ys.h)("h3", {
        class: (0, Bg.default)("-cbwsdk-try-extension-heading", t)
    }, "Or try the Coinbase Wallet browser extension"), (0, ys.h)("div", {
        class: "-cbwsdk-try-extension-cta-wrapper"
    }, (0, ys.h)("button", {
        class: (0, Bg.default)("-cbwsdk-try-extension-cta", t),
        onClick: i
    }, e ? "Refresh" : "Install"), (0, ys.h)("div", null, !e && (0, ys.h)(hqe.ArrowLeftIcon, {
        class: "-cbwsdk-try-extension-cta-icon",
        fill: t === "light" ? "#0052FF" : "#588AF5"
    })))), (0, ys.h)("div", {
        class: "-cbwsdk-try-extension-column-half"
    }, (0, ys.h)("ul", {
        class: "-cbwsdk-try-extension-list"
    }, (0, ys.h)("li", {
        class: "-cbwsdk-try-extension-list-item"
    }, (0, ys.h)("div", {
        class: "-cbwsdk-try-extension-list-item-icon-wrapper"
    }, (0, ys.h)("span", {
        class: (0, Bg.default)("-cbwsdk-try-extension-list-item-icon", t)
    }, (0, ys.h)(pqe.LaptopIcon, {
        fill: t === "light" ? "#0A0B0D" : "#FFFFFF"
    }))), (0, ys.h)("div", {
        class: (0, Bg.default)("-cbwsdk-try-extension-list-item-copy", t)
    }, "Connect with dapps with just one click on your desktop browser")), (0, ys.h)("li", {
        class: "-cbwsdk-try-extension-list-item"
    }, (0, ys.h)("div", {
        class: "-cbwsdk-try-extension-list-item-icon-wrapper"
    }, (0, ys.h)("span", {
        class: (0, Bg.default)("-cbwsdk-try-extension-list-item-icon", t)
    }, (0, ys.h)(gqe.SafeIcon, {
        fill: t === "light" ? "#0A0B0D" : "#FFFFFF"
    }))), (0, ys.h)("div", {
        class: (0, Bg.default)("-cbwsdk-try-extension-list-item-copy", t)
    }, "Add an additional layer of security by using a supported Ledger hardware wallet")))))
}
Q9.TryExtensionContent = yqe;
var XB = {};
Object.defineProperty(XB, "__esModule", {
    value: !0
});
XB.default = ".-cbwsdk-css-reset .-cbwsdk-connect-dialog{z-index:2147483647;position:fixed;top:0;left:0;right:0;bottom:0;display:flex;align-items:center;justify-content:center}.-cbwsdk-css-reset .-cbwsdk-connect-dialog-backdrop{z-index:2147483647;position:fixed;top:0;left:0;right:0;bottom:0;transition:opacity .25s}.-cbwsdk-css-reset .-cbwsdk-connect-dialog-backdrop.light{background-color:rgba(0,0,0,.5)}.-cbwsdk-css-reset .-cbwsdk-connect-dialog-backdrop.dark{background-color:rgba(50,53,61,.4)}.-cbwsdk-css-reset .-cbwsdk-connect-dialog-backdrop-hidden{opacity:0}.-cbwsdk-css-reset .-cbwsdk-connect-dialog-box{display:flex;position:relative;flex-direction:column;transform:scale(1);transition:opacity .25s,transform .25s}.-cbwsdk-css-reset .-cbwsdk-connect-dialog-box-hidden{opacity:0;transform:scale(0.85)}.-cbwsdk-css-reset .-cbwsdk-connect-dialog-container{display:block}.-cbwsdk-css-reset .-cbwsdk-connect-dialog-container-hidden{display:none}";
var ple = st && st.__importDefault || function(t) {
    return t && t.__esModule ? t : {
        default: t
    }
};
Object.defineProperty(W9, "__esModule", {
    value: !0
});
W9.ConnectDialog = void 0;
const wN = ple(V9),
    Fg = Dl,
    vN = a4,
    wqe = jf,
    vqe = Q9,
    bqe = ple(XB),
    _qe = t => {
        const {
            isOpen: e,
            darkMode: n
        } = t, [r, i] = (0, vN.useState)(!e), [s, o] = (0, vN.useState)(!e);
        (0, vN.useEffect)(() => {
            const l = [window.setTimeout(() => {
                o(!e)
            }, 10)];
            return e ? i(!1) : l.push(window.setTimeout(() => {
                i(!0)
            }, 360)), () => {
                l.forEach(window.clearTimeout)
            }
        }, [t.isOpen]);
        const a = n ? "dark" : "light";
        return (0, Fg.h)("div", {
            class: (0, wN.default)("-cbwsdk-connect-dialog-container", r && "-cbwsdk-connect-dialog-container-hidden")
        }, (0, Fg.h)("style", null, bqe.default), (0, Fg.h)("div", {
            class: (0, wN.default)("-cbwsdk-connect-dialog-backdrop", a, s && "-cbwsdk-connect-dialog-backdrop-hidden")
        }), (0, Fg.h)("div", {
            class: "-cbwsdk-connect-dialog"
        }, (0, Fg.h)("div", {
            class: (0, wN.default)("-cbwsdk-connect-dialog-box", s && "-cbwsdk-connect-dialog-box-hidden")
        }, t.connectDisabled ? null : (0, Fg.h)(wqe.ConnectContent, {
            theme: a,
            version: t.version,
            sessionId: t.sessionId,
            sessionSecret: t.sessionSecret,
            linkAPIUrl: t.linkAPIUrl,
            isConnected: t.isConnected,
            isParentConnection: t.isParentConnection,
            chainId: t.chainId,
            onCancel: t.onCancel
        }), (0, Fg.h)(vqe.TryExtensionContent, {
            theme: a
        }))))
    };
W9.ConnectDialog = _qe;
Object.defineProperty(U9, "__esModule", {
    value: !0
});
U9.LinkFlow = void 0;
const bN = Dl,
    DY = z9,
    Eqe = W9;
class xqe {
    constructor(e) {
        this.extensionUI$ = new DY.BehaviorSubject({}), this.subscriptions = new DY.Subscription, this.isConnected = !1, this.chainId = 1, this.isOpen = !1, this.onCancel = null, this.root = null, this.connectDisabled = !1, this.darkMode = e.darkMode, this.version = e.version, this.sessionId = e.sessionId, this.sessionSecret = e.sessionSecret, this.linkAPIUrl = e.linkAPIUrl, this.isParentConnection = e.isParentConnection, this.connected$ = e.connected$, this.chainId$ = e.chainId$
    }
    attach(e) {
        this.root = document.createElement("div"), this.root.className = "-cbwsdk-link-flow-root", e.appendChild(this.root), this.render(), this.subscriptions.add(this.connected$.subscribe(n => {
            this.isConnected !== n && (this.isConnected = n, this.render())
        })), this.subscriptions.add(this.chainId$.subscribe(n => {
            this.chainId !== n && (this.chainId = n, this.render())
        }))
    }
    detach() {
        var e;
        this.root && (this.subscriptions.unsubscribe(), (0, bN.render)(null, this.root), (e = this.root.parentElement) === null || e === void 0 || e.removeChild(this.root))
    }
    setConnectDisabled(e) {
        this.connectDisabled = e
    }
    open(e) {
        this.isOpen = !0, this.onCancel = e.onCancel, this.render()
    }
    close() {
        this.isOpen = !1, this.onCancel = null, this.render()
    }
    render() {
        if (!this.root) return;
        const e = this.extensionUI$.subscribe(() => {
            this.root && (0, bN.render)((0, bN.h)(Eqe.ConnectDialog, {
                darkMode: this.darkMode,
                version: this.version,
                sessionId: this.sessionId,
                sessionSecret: this.sessionSecret,
                linkAPIUrl: this.linkAPIUrl,
                isOpen: this.isOpen,
                isConnected: this.isConnected,
                isParentConnection: this.isParentConnection,
                chainId: this.chainId,
                onCancel: this.onCancel,
                connectDisabled: this.connectDisabled
            }), this.root)
        });
        this.subscriptions.add(e)
    }
}
U9.LinkFlow = xqe;
var gle = {},
    eF = {};
Object.defineProperty(eF, "__esModule", {
    value: !0
});
eF.default = ".-cbwsdk-css-reset .-gear-container{margin-left:16px !important;margin-right:9px !important;display:flex;align-items:center;justify-content:center;width:24px;height:24px;transition:opacity .25s}.-cbwsdk-css-reset .-gear-container *{user-select:none}.-cbwsdk-css-reset .-gear-container svg{opacity:0;position:absolute}.-cbwsdk-css-reset .-gear-icon{height:12px;width:12px;z-index:10000}.-cbwsdk-css-reset .-cbwsdk-snackbar{align-items:flex-end;display:flex;flex-direction:column;position:fixed;right:0;top:0;z-index:2147483647}.-cbwsdk-css-reset .-cbwsdk-snackbar *{user-select:none}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance{display:flex;flex-direction:column;margin:8px 16px 0 16px;overflow:visible;text-align:left;transform:translateX(0);transition:opacity .25s,transform .25s}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-header:hover .-gear-container svg{opacity:1}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-header{display:flex;align-items:center;background:#fff;overflow:hidden;border:1px solid #e7ebee;box-sizing:border-box;border-radius:8px;cursor:pointer}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-header-cblogo{margin:8px 8px 8px 8px}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-header *{cursor:pointer}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-header-message{color:#000;font-size:13px;line-height:1.5;user-select:none}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-menu{background:#fff;transition:opacity .25s ease-in-out,transform .25s linear,visibility 0s;visibility:hidden;border:1px solid #e7ebee;box-sizing:border-box;border-radius:8px;opacity:0;flex-direction:column;padding-left:8px;padding-right:8px}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-menu-item:last-child{margin-bottom:8px !important}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-menu-item:hover{background:#f5f7f8;border-radius:6px;transition:background .25s}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-menu-item:hover span{color:#050f19;transition:color .25s}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-menu-item:hover svg path{fill:#000;transition:fill .25s}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-menu-item{visibility:inherit;height:35px;margin-top:8px;margin-bottom:0;display:flex;flex-direction:row;align-items:center;padding:8px;cursor:pointer}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-menu-item *{visibility:inherit;cursor:pointer}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-menu-item-is-red:hover{background:rgba(223,95,103,.2);transition:background .25s}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-menu-item-is-red:hover *{cursor:pointer}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-menu-item-is-red:hover svg path{fill:#df5f67;transition:fill .25s}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-menu-item-is-red:hover span{color:#df5f67;transition:color .25s}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-menu-item-info{color:#aaa;font-size:13px;margin:0 8px 0 32px;position:absolute}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-hidden{opacity:0;text-align:left;transform:translateX(25%);transition:opacity .5s linear}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-expanded .-cbwsdk-snackbar-instance-menu{opacity:1;display:flex;transform:translateY(8px);visibility:visible}";
(function(t) {
    var e = st && st.__importDefault || function(f) {
        return f && f.__esModule ? f : {
            default: f
        }
    };
    Object.defineProperty(t, "__esModule", {
        value: !0
    }), t.SnackbarInstance = t.SnackbarContainer = t.Snackbar = void 0;
    const n = e(V9),
        r = Dl,
        i = a4,
        s = e(eF),
        o = "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTIiIGhlaWdodD0iMTIiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZD0iTTEyIDYuNzV2LTEuNWwtMS43Mi0uNTdjLS4wOC0uMjctLjE5LS41Mi0uMzItLjc3bC44MS0xLjYyLTEuMDYtMS4wNi0xLjYyLjgxYy0uMjQtLjEzLS41LS4yNC0uNzctLjMyTDYuNzUgMGgtMS41bC0uNTcgMS43MmMtLjI3LjA4LS41My4xOS0uNzcuMzJsLTEuNjItLjgxLTEuMDYgMS4wNi44MSAxLjYyYy0uMTMuMjQtLjI0LjUtLjMyLjc3TDAgNS4yNXYxLjVsMS43Mi41N2MuMDguMjcuMTkuNTMuMzIuNzdsLS44MSAxLjYyIDEuMDYgMS4wNiAxLjYyLS44MWMuMjQuMTMuNS4yMy43Ny4zMkw1LjI1IDEyaDEuNWwuNTctMS43MmMuMjctLjA4LjUyLS4xOS43Ny0uMzJsMS42Mi44MSAxLjA2LTEuMDYtLjgxLTEuNjJjLjEzLS4yNC4yMy0uNS4zMi0uNzdMMTIgNi43NXpNNiA4LjVhMi41IDIuNSAwIDAxMC01IDIuNSAyLjUgMCAwMTAgNXoiIGZpbGw9IiMwNTBGMTkiLz48L3N2Zz4=";

    function a(f) {
        switch (f) {
            case "coinbase-app":
                return "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMzAiIGhlaWdodD0iMzAiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZD0iTTE0LjY3NCAxOC44NThjLTIuMDQ1IDAtMy42NDgtMS43MjItMy42NDgtMy44NDVzMS42NTktMy44NDUgMy42NDgtMy44NDVjMS44MjQgMCAzLjMxNyAxLjM3NyAzLjU5MyAzLjIxNGgzLjcwM2MtLjMzMS0zLjk2LTMuNDgyLTcuMDU5LTcuMjk2LTcuMDU5LTQuMDM0IDAtNy4zNSAzLjQ0My03LjM1IDcuNjkgMCA0LjI0NiAzLjI2IDcuNjkgNy4zNSA3LjY5IDMuODcgMCA2Ljk2NS0zLjEgNy4yOTYtNy4wNTloLTMuNzAzYy0uMjc2IDEuODM2LTEuNzY5IDMuMjE0LTMuNTkzIDMuMjE0WiIgZmlsbD0iI2ZmZiIvPjxwYXRoIGQ9Ik0wIDEwLjY3OGMwLTMuNzExIDAtNS41OTYuNzQyLTcuMDIzQTYuNTMyIDYuNTMyIDAgMCAxIDMuNjU1Ljc0MkM1LjA4MiAwIDYuOTY3IDAgMTAuNjc4IDBoNy45MzhjMy43MTEgMCA1LjU5NiAwIDcuMDIzLjc0MmE2LjUzMSA2LjUzMSAwIDAgMSAyLjkxMyAyLjkxM2MuNzQyIDEuNDI3Ljc0MiAzLjMxMi43NDIgNy4wMjN2Ny45MzhjMCAzLjcxMSAwIDUuNTk2LS43NDIgNy4wMjNhNi41MzEgNi41MzEgMCAwIDEtMi45MTMgMi45MTNjLTEuNDI3Ljc0Mi0zLjMxMi43NDItNy4wMjMuNzQyaC03LjkzOGMtMy43MTEgMC01LjU5NiAwLTcuMDIzLS43NDJhNi41MzEgNi41MzEgMCAwIDEtMi45MTMtMi45MTNDMCAyNC4yMTIgMCAyMi4zODQgMCAxOC42MTZ2LTcuOTM4WiIgZmlsbD0iIzAwNTJGRiIvPjxwYXRoIGQ9Ik0xNC42ODQgMTkuNzczYy0yLjcyNyAwLTQuODY0LTIuMjk1LTQuODY0LTUuMTI2IDAtMi44MzEgMi4yMS01LjEyNyA0Ljg2NC01LjEyNyAyLjQzMiAwIDQuNDIyIDEuODM3IDQuNzkgNC4yODVoNC45MzhjLS40NDItNS4yOC00LjY0My05LjQxMS05LjcyOC05LjQxMS01LjM4IDAtOS44MDIgNC41OS05LjgwMiAxMC4yNTMgMCA1LjY2MiA0LjM0OCAxMC4yNTMgOS44MDIgMTAuMjUzIDUuMTU5IDAgOS4yODYtNC4xMzIgOS43MjgtOS40MTFoLTQuOTM4Yy0uMzY4IDIuNDQ4LTIuMzU4IDQuMjg0LTQuNzkgNC4yODRaIiBmaWxsPSIjZmZmIi8+PC9zdmc+";
            case "coinbase-wallet-app":
            default:
                return "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMzIiIGhlaWdodD0iMzIiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZD0iTTEuNDkyIDEwLjQxOWE4LjkzIDguOTMgMCAwMTguOTMtOC45M2gxMS4xNjNhOC45MyA4LjkzIDAgMDE4LjkzIDguOTN2MTEuMTYzYTguOTMgOC45MyAwIDAxLTguOTMgOC45M0gxMC40MjJhOC45MyA4LjkzIDAgMDEtOC45My04LjkzVjEwLjQxOXoiIGZpbGw9IiMxNjUyRjAiLz48cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEwLjQxOSAwSDIxLjU4QzI3LjMzNSAwIDMyIDQuNjY1IDMyIDEwLjQxOVYyMS41OEMzMiAyNy4zMzUgMjcuMzM1IDMyIDIxLjU4MSAzMkgxMC40MkM0LjY2NSAzMiAwIDI3LjMzNSAwIDIxLjU4MVYxMC40MkMwIDQuNjY1IDQuNjY1IDAgMTAuNDE5IDB6bTAgMS40ODhhOC45MyA4LjkzIDAgMDAtOC45MyA4LjkzdjExLjE2M2E4LjkzIDguOTMgMCAwMDguOTMgOC45M0gyMS41OGE4LjkzIDguOTMgMCAwMDguOTMtOC45M1YxMC40MmE4LjkzIDguOTMgMCAwMC04LjkzLTguOTNIMTAuNDJ6IiBmaWxsPSIjZmZmIi8+PHBhdGggZmlsbC1ydWxlPSJldmVub2RkIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGQ9Ik0xNS45OTggMjYuMDQ5Yy01LjU0OSAwLTEwLjA0Ny00LjQ5OC0xMC4wNDctMTAuMDQ3IDAtNS41NDggNC40OTgtMTAuMDQ2IDEwLjA0Ny0xMC4wNDYgNS41NDggMCAxMC4wNDYgNC40OTggMTAuMDQ2IDEwLjA0NiAwIDUuNTQ5LTQuNDk4IDEwLjA0Ny0xMC4wNDYgMTAuMDQ3eiIgZmlsbD0iI2ZmZiIvPjxwYXRoIGQ9Ik0xMi43NjIgMTQuMjU0YzAtLjgyMi42NjctMS40ODkgMS40ODktMS40ODloMy40OTdjLjgyMiAwIDEuNDg4LjY2NiAxLjQ4OCAxLjQ4OXYzLjQ5N2MwIC44MjItLjY2NiAxLjQ4OC0xLjQ4OCAxLjQ4OGgtMy40OTdhMS40ODggMS40ODggMCAwMS0xLjQ4OS0xLjQ4OHYtMy40OTh6IiBmaWxsPSIjMTY1MkYwIi8+PC9zdmc+"
        }
    }
    class l {
        constructor(h) {
            this.items = new Map, this.nextItemKey = 0, this.root = null, this.darkMode = h.darkMode
        }
        attach(h) {
            this.root = document.createElement("div"), this.root.className = "-cbwsdk-snackbar-root", h.appendChild(this.root), this.render()
        }
        presentItem(h) {
            const g = this.nextItemKey++;
            return this.items.set(g, h), this.render(), () => {
                this.items.delete(g), this.render()
            }
        }
        clear() {
            this.items.clear(), this.render()
        }
        render() {
            this.root && (0, r.render)((0, r.h)("div", null, (0, r.h)(t.SnackbarContainer, {
                darkMode: this.darkMode
            }, Array.from(this.items.entries()).map(([h, g]) => (0, r.h)(t.SnackbarInstance, Object.assign({}, g, {
                key: h
            }))))), this.root)
        }
    }
    t.Snackbar = l;
    const c = f => (0, r.h)("div", {
        class: (0, n.default)("-cbwsdk-snackbar-container")
    }, (0, r.h)("style", null, s.default), (0, r.h)("div", {
        class: "-cbwsdk-snackbar"
    }, f.children));
    t.SnackbarContainer = c;
    const u = ({
        autoExpand: f,
        message: h,
        menuItems: g,
        appSrc: y
    }) => {
        const [_, C] = (0, i.useState)(!0), [b, w] = (0, i.useState)(f ? ? !1);
        (0, i.useEffect)(() => {
            const I = [window.setTimeout(() => {
                C(!1)
            }, 1), window.setTimeout(() => {
                w(!0)
            }, 1e4)];
            return () => {
                I.forEach(window.clearTimeout)
            }
        });
        const S = () => {
            w(!b)
        };
        return (0, r.h)("div", {
            class: (0, n.default)("-cbwsdk-snackbar-instance", _ && "-cbwsdk-snackbar-instance-hidden", b && "-cbwsdk-snackbar-instance-expanded")
        }, (0, r.h)("div", {
            class: "-cbwsdk-snackbar-instance-header",
            onClick: S
        }, (0, r.h)("img", {
            src: a(y),
            class: "-cbwsdk-snackbar-instance-header-cblogo"
        }), (0, r.h)("div", {
            class: "-cbwsdk-snackbar-instance-header-message"
        }, h), (0, r.h)("div", {
            class: "-gear-container"
        }, !b && (0, r.h)("svg", {
            width: "24",
            height: "24",
            viewBox: "0 0 24 24",
            fill: "none",
            xmlns: "http://www.w3.org/2000/svg"
        }, (0, r.h)("circle", {
            cx: "12",
            cy: "12",
            r: "12",
            fill: "#F5F7F8"
        })), (0, r.h)("img", {
            src: o,
            class: "-gear-icon",
            title: "Expand"
        }))), g && g.length > 0 && (0, r.h)("div", {
            class: "-cbwsdk-snackbar-instance-menu"
        }, g.map((I, P) => (0, r.h)("div", {
            class: (0, n.default)("-cbwsdk-snackbar-instance-menu-item", I.isRed && "-cbwsdk-snackbar-instance-menu-item-is-red"),
            onClick: I.onClick,
            key: P
        }, (0, r.h)("svg", {
            width: I.svgWidth,
            height: I.svgHeight,
            viewBox: "0 0 10 11",
            fill: "none",
            xmlns: "http://www.w3.org/2000/svg"
        }, (0, r.h)("path", {
            "fill-rule": I.defaultFillRule,
            "clip-rule": I.defaultClipRule,
            d: I.path,
            fill: "#AAAAAA"
        })), (0, r.h)("span", {
            class: (0, n.default)("-cbwsdk-snackbar-instance-menu-item-info", I.isRed && "-cbwsdk-snackbar-instance-menu-item-info-is-red")
        }, I.info)))))
    };
    t.SnackbarInstance = u
})(gle);
var t7 = {},
    tF = {};
Object.defineProperty(tF, "__esModule", {
    value: !0
});
tF.default = '@namespace svg "http://www.w3.org/2000/svg";.-cbwsdk-css-reset,.-cbwsdk-css-reset *{animation:none;animation-delay:0;animation-direction:normal;animation-duration:0;animation-fill-mode:none;animation-iteration-count:1;animation-name:none;animation-play-state:running;animation-timing-function:ease;backface-visibility:visible;background:0;background-attachment:scroll;background-clip:border-box;background-color:rgba(0,0,0,0);background-image:none;background-origin:padding-box;background-position:0 0;background-position-x:0;background-position-y:0;background-repeat:repeat;background-size:auto auto;border:0;border-style:none;border-width:medium;border-color:inherit;border-bottom:0;border-bottom-color:inherit;border-bottom-left-radius:0;border-bottom-right-radius:0;border-bottom-style:none;border-bottom-width:medium;border-collapse:separate;border-image:none;border-left:0;border-left-color:inherit;border-left-style:none;border-left-width:medium;border-radius:0;border-right:0;border-right-color:inherit;border-right-style:none;border-right-width:medium;border-spacing:0;border-top:0;border-top-color:inherit;border-top-left-radius:0;border-top-right-radius:0;border-top-style:none;border-top-width:medium;box-shadow:none;box-sizing:border-box;caption-side:top;clear:none;clip:auto;color:inherit;columns:auto;column-count:auto;column-fill:balance;column-gap:normal;column-rule:medium none currentColor;column-rule-color:currentColor;column-rule-style:none;column-rule-width:none;column-span:1;column-width:auto;counter-increment:none;counter-reset:none;direction:ltr;empty-cells:show;float:none;font:normal;font-family:-apple-system,BlinkMacSystemFont,"Segoe UI","Helvetica Neue",Arial,sans-serif;font-size:medium;font-style:normal;font-variant:normal;font-weight:normal;height:auto;hyphens:none;letter-spacing:normal;line-height:normal;list-style:none;list-style-image:none;list-style-position:outside;list-style-type:disc;margin:0;margin-bottom:0;margin-left:0;margin-right:0;margin-top:0;opacity:1;orphans:0;outline:0;outline-color:invert;outline-style:none;outline-width:medium;overflow:visible;overflow-x:visible;overflow-y:visible;padding:0;padding-bottom:0;padding-left:0;padding-right:0;padding-top:0;page-break-after:auto;page-break-before:auto;page-break-inside:auto;perspective:none;perspective-origin:50% 50%;pointer-events:auto;position:static;quotes:"\\201C" "\\201D" "\\2018" "\\2019";tab-size:8;table-layout:auto;text-align:inherit;text-align-last:auto;text-decoration:none;text-decoration-color:inherit;text-decoration-line:none;text-decoration-style:solid;text-indent:0;text-shadow:none;text-transform:none;transform:none;transform-style:flat;transition:none;transition-delay:0s;transition-duration:0s;transition-property:none;transition-timing-function:ease;unicode-bidi:normal;vertical-align:baseline;visibility:visible;white-space:normal;widows:0;word-spacing:normal;z-index:auto}.-cbwsdk-css-reset strong{font-weight:bold}.-cbwsdk-css-reset *{box-sizing:border-box;font-family:-apple-system,BlinkMacSystemFont,"Segoe UI","Helvetica Neue",Arial,sans-serif;line-height:1}.-cbwsdk-css-reset [class*=container]{margin:0;padding:0}.-cbwsdk-css-reset style{display:none}';
var Sqe = st && st.__importDefault || function(t) {
    return t && t.__esModule ? t : {
        default: t
    }
};
Object.defineProperty(t7, "__esModule", {
    value: !0
});
t7.injectCssReset = void 0;
const Cqe = Sqe(tF);

function Aqe() {
    const t = document.createElement("style");
    t.type = "text/css", t.appendChild(document.createTextNode(Cqe.default)), document.documentElement.appendChild(t)
}
t7.injectCssReset = Aqe;
Object.defineProperty(F9, "__esModule", {
    value: !0
});
F9.WalletSDKUI = void 0;
const Tqe = U9,
    Iqe = gle,
    Rqe = t7;
class Oqe {
    constructor(e) {
        this.standalone = null, this.attached = !1, this.appSrc = null, this.snackbar = new Iqe.Snackbar({
            darkMode: e.darkMode
        }), this.linkFlow = new Tqe.LinkFlow({
            darkMode: e.darkMode,
            version: e.version,
            sessionId: e.session.id,
            sessionSecret: e.session.secret,
            linkAPIUrl: e.linkAPIUrl,
            connected$: e.connected$,
            chainId$: e.chainId$,
            isParentConnection: !1
        })
    }
    attach() {
        if (this.attached) throw new Error("Coinbase Wallet SDK UI is already attached");
        const e = document.documentElement,
            n = document.createElement("div");
        n.className = "-cbwsdk-css-reset", e.appendChild(n), this.linkFlow.attach(n), this.snackbar.attach(n), this.attached = !0, (0, Rqe.injectCssReset)()
    }
    setConnectDisabled(e) {
        this.linkFlow.setConnectDisabled(e)
    }
    addEthereumChain(e) {}
    watchAsset(e) {}
    switchEthereumChain(e) {}
    requestEthereumAccounts(e) {
        this.linkFlow.open({
            onCancel: e.onCancel
        })
    }
    hideRequestEthereumAccounts() {
        this.linkFlow.close()
    }
    signEthereumMessage(e) {}
    signEthereumTransaction(e) {}
    submitEthereumTransaction(e) {}
    ethereumAddressFromSignedMessage(e) {}
    showConnecting(e) {
        let n;
        return e.isUnlinkedErrorState ? n = {
            autoExpand: !0,
            message: "Connection lost",
            appSrc: this.appSrc,
            menuItems: [{
                isRed: !1,
                info: "Reset connection",
                svgWidth: "10",
                svgHeight: "11",
                path: "M5.00008 0.96875C6.73133 0.96875 8.23758 1.94375 9.00008 3.375L10.0001 2.375V5.5H9.53133H7.96883H6.87508L7.80633 4.56875C7.41258 3.3875 6.31258 2.53125 5.00008 2.53125C3.76258 2.53125 2.70633 3.2875 2.25633 4.36875L0.812576 3.76875C1.50008 2.125 3.11258 0.96875 5.00008 0.96875ZM2.19375 6.43125C2.5875 7.6125 3.6875 8.46875 5 8.46875C6.2375 8.46875 7.29375 7.7125 7.74375 6.63125L9.1875 7.23125C8.5 8.875 6.8875 10.0312 5 10.0312C3.26875 10.0312 1.7625 9.05625 1 7.625L0 8.625V5.5H0.46875H2.03125H3.125L2.19375 6.43125Z",
                defaultFillRule: "evenodd",
                defaultClipRule: "evenodd",
                onClick: e.onResetConnection
            }]
        } : n = {
            message: "Confirm on phone",
            appSrc: this.appSrc,
            menuItems: [{
                isRed: !0,
                info: "Cancel transaction",
                svgWidth: "11",
                svgHeight: "11",
                path: "M10.3711 1.52346L9.21775 0.370117L5.37109 4.21022L1.52444 0.370117L0.371094 1.52346L4.2112 5.37012L0.371094 9.21677L1.52444 10.3701L5.37109 6.53001L9.21775 10.3701L10.3711 9.21677L6.53099 5.37012L10.3711 1.52346Z",
                defaultFillRule: "inherit",
                defaultClipRule: "inherit",
                onClick: e.onCancel
            }, {
                isRed: !1,
                info: "Reset connection",
                svgWidth: "10",
                svgHeight: "11",
                path: "M5.00008 0.96875C6.73133 0.96875 8.23758 1.94375 9.00008 3.375L10.0001 2.375V5.5H9.53133H7.96883H6.87508L7.80633 4.56875C7.41258 3.3875 6.31258 2.53125 5.00008 2.53125C3.76258 2.53125 2.70633 3.2875 2.25633 4.36875L0.812576 3.76875C1.50008 2.125 3.11258 0.96875 5.00008 0.96875ZM2.19375 6.43125C2.5875 7.6125 3.6875 8.46875 5 8.46875C6.2375 8.46875 7.29375 7.7125 7.74375 6.63125L9.1875 7.23125C8.5 8.875 6.8875 10.0312 5 10.0312C3.26875 10.0312 1.7625 9.05625 1 7.625L0 8.625V5.5H0.46875H2.03125H3.125L2.19375 6.43125Z",
                defaultFillRule: "evenodd",
                defaultClipRule: "evenodd",
                onClick: e.onResetConnection
            }]
        }, this.snackbar.presentItem(n)
    }
    setAppSrc(e) {
        this.appSrc = e
    }
    reloadUI() {
        document.location.reload()
    }
    inlineAccountsResponse() {
        return !1
    }
    inlineAddEthereumChain(e) {
        return !1
    }
    inlineWatchAsset() {
        return !1
    }
    inlineSwitchEthereumChain() {
        return !1
    }
    setStandalone(e) {
        this.standalone = e
    }
    isStandalone() {
        var e;
        return (e = this.standalone) !== null && e !== void 0 ? e : !1
    }
}
F9.WalletSDKUI = Oqe;
var n7 = {},
    r7 = {};
Object.defineProperty(r7, "__esModule", {
    value: !0
});
var kw;
(function(t) {
    t.typeOfFunction = "function", t.boolTrue = !0
})(kw || (kw = {}));

function mle(t, e, n) {
    if (!n || typeof n.value !== kw.typeOfFunction) throw new TypeError("Only methods can be decorated with @bind. <" + e + "> is not a method!");
    return {
        configurable: kw.boolTrue,
        get: function() {
            var r = n.value.bind(this);
            return Object.defineProperty(this, e, {
                value: r,
                configurable: kw.boolTrue,
                writable: kw.boolTrue
            }), r
        }
    }
}
r7.bind = mle;
r7.default = mle;

function yle(t) {
    return function(n) {
        return n.lift(new Nqe(t))
    }
}
var Nqe = function() {
        function t(e) {
            this.durationSelector = e
        }
        return t.prototype.call = function(e, n) {
            return n.subscribe(new Pqe(e, this.durationSelector))
        }, t
    }(),
    Pqe = function(t) {
        Ve(e, t);

        function e(n, r) {
            var i = t.call(this, n) || this;
            return i.durationSelector = r, i.hasValue = !1, i
        }
        return e.prototype._next = function(n) {
            if (this.value = n, this.hasValue = !0, !this.throttled) {
                var r = void 0;
                try {
                    var i = this.durationSelector;
                    r = i(n)
                } catch (o) {
                    return this.destination.error(o)
                }
                var s = Zi(r, new Ki(this));
                !s || s.closed ? this.clearThrottle() : this.add(this.throttled = s)
            }
        }, e.prototype.clearThrottle = function() {
            var n = this,
                r = n.value,
                i = n.hasValue,
                s = n.throttled;
            s && (this.remove(s), this.throttled = void 0, s.unsubscribe()), i && (this.value = void 0, this.hasValue = !1, this.destination.next(r))
        }, e.prototype.notifyNext = function() {
            this.clearThrottle()
        }, e.prototype.notifyComplete = function() {
            this.clearThrottle()
        }, e
    }(Yi);

function kqe(t, e) {
    return e === void 0 && (e = ga), yle(function() {
        return Qae(t, e)
    })
}

function Mqe(t) {
    return function(n) {
        return n.lift(new Dqe(t))
    }
}
var Dqe = function() {
        function t(e) {
            this.closingNotifier = e
        }
        return t.prototype.call = function(e, n) {
            return n.subscribe(new $qe(e, this.closingNotifier))
        }, t
    }(),
    $qe = function(t) {
        Ve(e, t);

        function e(n, r) {
            var i = t.call(this, n) || this;
            return i.buffer = [], i.add(Zi(r, new Ki(i))), i
        }
        return e.prototype._next = function(n) {
            this.buffer.push(n)
        }, e.prototype.notifyNext = function() {
            var n = this.buffer;
            this.buffer = [], this.destination.next(n)
        }, e
    }(Yi);

function Lqe(t, e) {
    return e === void 0 && (e = null),
        function(r) {
            return r.lift(new Bqe(t, e))
        }
}
var Bqe = function() {
        function t(e, n) {
            this.bufferSize = e, this.startBufferEvery = n, !n || e === n ? this.subscriberClass = Fqe : this.subscriberClass = Uqe
        }
        return t.prototype.call = function(e, n) {
            return n.subscribe(new this.subscriberClass(e, this.bufferSize, this.startBufferEvery))
        }, t
    }(),
    Fqe = function(t) {
        Ve(e, t);

        function e(n, r) {
            var i = t.call(this, n) || this;
            return i.bufferSize = r, i.buffer = [], i
        }
        return e.prototype._next = function(n) {
            var r = this.buffer;
            r.push(n), r.length == this.bufferSize && (this.destination.next(r), this.buffer = [])
        }, e.prototype._complete = function() {
            var n = this.buffer;
            n.length > 0 && this.destination.next(n), t.prototype._complete.call(this)
        }, e
    }(Gt),
    Uqe = function(t) {
        Ve(e, t);

        function e(n, r, i) {
            var s = t.call(this, n) || this;
            return s.bufferSize = r, s.startBufferEvery = i, s.buffers = [], s.count = 0, s
        }
        return e.prototype._next = function(n) {
            var r = this,
                i = r.bufferSize,
                s = r.startBufferEvery,
                o = r.buffers,
                a = r.count;
            this.count++, a % s === 0 && o.push([]);
            for (var l = o.length; l--;) {
                var c = o[l];
                c.push(n), c.length === i && (o.splice(l, 1), this.destination.next(c))
            }
        }, e.prototype._complete = function() {
            for (var n = this, r = n.buffers, i = n.destination; r.length > 0;) {
                var s = r.shift();
                s.length > 0 && i.next(s)
            }
            t.prototype._complete.call(this)
        }, e
    }(Gt);

function jqe(t) {
    var e = arguments.length,
        n = ga;
    Al(arguments[arguments.length - 1]) && (n = arguments[arguments.length - 1], e--);
    var r = null;
    e >= 2 && (r = arguments[1]);
    var i = Number.POSITIVE_INFINITY;
    return e >= 3 && (i = arguments[2]),
        function(o) {
            return o.lift(new Hqe(t, r, i, n))
        }
}
var Hqe = function() {
        function t(e, n, r, i) {
            this.bufferTimeSpan = e, this.bufferCreationInterval = n, this.maxBufferSize = r, this.scheduler = i
        }
        return t.prototype.call = function(e, n) {
            return n.subscribe(new Wqe(e, this.bufferTimeSpan, this.bufferCreationInterval, this.maxBufferSize, this.scheduler))
        }, t
    }(),
    zqe = function() {
        function t() {
            this.buffer = []
        }
        return t
    }(),
    Wqe = function(t) {
        Ve(e, t);

        function e(n, r, i, s, o) {
            var a = t.call(this, n) || this;
            a.bufferTimeSpan = r, a.bufferCreationInterval = i, a.maxBufferSize = s, a.scheduler = o, a.contexts = [];
            var l = a.openContext();
            if (a.timespanOnly = i == null || i < 0, a.timespanOnly) {
                var c = {
                    subscriber: a,
                    context: l,
                    bufferTimeSpan: r
                };
                a.add(l.closeAction = o.schedule($Y, r, c))
            } else {
                var u = {
                        subscriber: a,
                        context: l
                    },
                    f = {
                        bufferTimeSpan: r,
                        bufferCreationInterval: i,
                        subscriber: a,
                        scheduler: o
                    };
                a.add(l.closeAction = o.schedule(wle, r, u)), a.add(o.schedule(Vqe, i, f))
            }
            return a
        }
        return e.prototype._next = function(n) {
            for (var r = this.contexts, i = r.length, s, o = 0; o < i; o++) {
                var a = r[o],
                    l = a.buffer;
                l.push(n), l.length == this.maxBufferSize && (s = a)
            }
            s && this.onBufferFull(s)
        }, e.prototype._error = function(n) {
            this.contexts.length = 0, t.prototype._error.call(this, n)
        }, e.prototype._complete = function() {
            for (var n = this, r = n.contexts, i = n.destination; r.length > 0;) {
                var s = r.shift();
                i.next(s.buffer)
            }
            t.prototype._complete.call(this)
        }, e.prototype._unsubscribe = function() {
            this.contexts = null
        }, e.prototype.onBufferFull = function(n) {
            this.closeContext(n);
            var r = n.closeAction;
            if (r.unsubscribe(), this.remove(r), !this.closed && this.timespanOnly) {
                n = this.openContext();
                var i = this.bufferTimeSpan,
                    s = {
                        subscriber: this,
                        context: n,
                        bufferTimeSpan: i
                    };
                this.add(n.closeAction = this.scheduler.schedule($Y, i, s))
            }
        }, e.prototype.openContext = function() {
            var n = new zqe;
            return this.contexts.push(n), n
        }, e.prototype.closeContext = function(n) {
            this.destination.next(n.buffer);
            var r = this.contexts,
                i = r ? r.indexOf(n) : -1;
            i >= 0 && r.splice(r.indexOf(n), 1)
        }, e
    }(Gt);

function $Y(t) {
    var e = t.subscriber,
        n = t.context;
    n && e.closeContext(n), e.closed || (t.context = e.openContext(), t.context.closeAction = this.schedule(t, t.bufferTimeSpan))
}

function Vqe(t) {
    var e = t.bufferCreationInterval,
        n = t.bufferTimeSpan,
        r = t.subscriber,
        i = t.scheduler,
        s = r.openContext(),
        o = this;
    r.closed || (r.add(s.closeAction = i.schedule(wle, n, {
        subscriber: r,
        context: s
    })), o.schedule(t, e))
}

function wle(t) {
    var e = t.subscriber,
        n = t.context;
    e.closeContext(n)
}

function Gqe(t, e) {
    return function(r) {
        return r.lift(new qqe(t, e))
    }
}
var qqe = function() {
        function t(e, n) {
            this.openings = e, this.closingSelector = n
        }
        return t.prototype.call = function(e, n) {
            return n.subscribe(new Kqe(e, this.openings, this.closingSelector))
        }, t
    }(),
    Kqe = function(t) {
        Ve(e, t);

        function e(n, r, i) {
            var s = t.call(this, n) || this;
            return s.closingSelector = i, s.contexts = [], s.add(Ih(s, r)), s
        }
        return e.prototype._next = function(n) {
            for (var r = this.contexts, i = r.length, s = 0; s < i; s++) r[s].buffer.push(n)
        }, e.prototype._error = function(n) {
            for (var r = this.contexts; r.length > 0;) {
                var i = r.shift();
                i.subscription.unsubscribe(), i.buffer = null, i.subscription = null
            }
            this.contexts = null, t.prototype._error.call(this, n)
        }, e.prototype._complete = function() {
            for (var n = this.contexts; n.length > 0;) {
                var r = n.shift();
                this.destination.next(r.buffer), r.subscription.unsubscribe(), r.buffer = null, r.subscription = null
            }
            this.contexts = null, t.prototype._complete.call(this)
        }, e.prototype.notifyNext = function(n, r) {
            n ? this.closeBuffer(n) : this.openBuffer(r)
        }, e.prototype.notifyComplete = function(n) {
            this.closeBuffer(n.context)
        }, e.prototype.openBuffer = function(n) {
            try {
                var r = this.closingSelector,
                    i = r.call(this, n);
                i && this.trySubscribe(i)
            } catch (s) {
                this._error(s)
            }
        }, e.prototype.closeBuffer = function(n) {
            var r = this.contexts;
            if (r && n) {
                var i = n.buffer,
                    s = n.subscription;
                this.destination.next(i), r.splice(r.indexOf(n), 1), this.remove(s), s.unsubscribe()
            }
        }, e.prototype.trySubscribe = function(n) {
            var r = this.contexts,
                i = [],
                s = new ki,
                o = {
                    buffer: i,
                    subscription: s
                };
            r.push(o);
            var a = Ih(this, n, o);
            !a || a.closed ? this.closeBuffer(o) : (a.context = o, this.add(a), s.add(a))
        }, e
    }(Cy);

function Yqe(t) {
    return function(e) {
        return e.lift(new Zqe(t))
    }
}
var Zqe = function() {
        function t(e) {
            this.closingSelector = e
        }
        return t.prototype.call = function(e, n) {
            return n.subscribe(new Qqe(e, this.closingSelector))
        }, t
    }(),
    Qqe = function(t) {
        Ve(e, t);

        function e(n, r) {
            var i = t.call(this, n) || this;
            return i.closingSelector = r, i.subscribing = !1, i.openBuffer(), i
        }
        return e.prototype._next = function(n) {
            this.buffer.push(n)
        }, e.prototype._complete = function() {
            var n = this.buffer;
            n && this.destination.next(n), t.prototype._complete.call(this)
        }, e.prototype._unsubscribe = function() {
            this.buffer = void 0, this.subscribing = !1
        }, e.prototype.notifyNext = function() {
            this.openBuffer()
        }, e.prototype.notifyComplete = function() {
            this.subscribing ? this.complete() : this.openBuffer()
        }, e.prototype.openBuffer = function() {
            var n = this.closingSubscription;
            n && (this.remove(n), n.unsubscribe());
            var r = this.buffer;
            this.buffer && this.destination.next(r), this.buffer = [];
            var i;
            try {
                var s = this.closingSelector;
                i = s()
            } catch (o) {
                return this.error(o)
            }
            n = new ki, this.closingSubscription = n, this.add(n), this.subscribing = !0, n.add(Zi(i, new Ki(this))), this.subscribing = !1
        }, e
    }(Yi);

function Jqe(t) {
    return function(n) {
        var r = new Xqe(t),
            i = n.lift(r);
        return r.caught = i
    }
}
var Xqe = function() {
        function t(e) {
            this.selector = e
        }
        return t.prototype.call = function(e, n) {
            return n.subscribe(new eKe(e, this.selector, this.caught))
        }, t
    }(),
    eKe = function(t) {
        Ve(e, t);

        function e(n, r, i) {
            var s = t.call(this, n) || this;
            return s.selector = r, s.caught = i, s
        }
        return e.prototype.error = function(n) {
            if (!this.isStopped) {
                var r = void 0;
                try {
                    r = this.selector(n, this.caught)
                } catch (o) {
                    t.prototype.error.call(this, o);
                    return
                }
                this._unsubscribeAndRecycle();
                var i = new Ki(this);
                this.add(i);
                var s = Zi(r, i);
                s !== i && this.add(s)
            }
        }, e
    }(Yi);

function tKe(t) {
    return function(e) {
        return e.lift(new jB(t))
    }
}

function nKe() {
    for (var t = [], e = 0; e < arguments.length; e++) t[e] = arguments[e];
    var n = null;
    return typeof t[t.length - 1] == "function" && (n = t.pop()), t.length === 1 && pa(t[0]) && (t = t[0].slice()),
        function(r) {
            return r.lift.call(zh([r].concat(t)), new jB(n))
        }
}

function rKe() {
    for (var t = [], e = 0; e < arguments.length; e++) t[e] = arguments[e];
    return function(n) {
        return n.lift.call(f6.apply(void 0, [n].concat(t)))
    }
}

function vle(t, e) {
    return jm(t, e, 1)
}

function iKe(t, e) {
    return vle(function() {
        return t
    }, e)
}

function sKe(t) {
    return function(e) {
        return e.lift(new oKe(t, e))
    }
}
var oKe = function() {
        function t(e, n) {
            this.predicate = e, this.source = n
        }
        return t.prototype.call = function(e, n) {
            return n.subscribe(new aKe(e, this.predicate, this.source))
        }, t
    }(),
    aKe = function(t) {
        Ve(e, t);

        function e(n, r, i) {
            var s = t.call(this, n) || this;
            return s.predicate = r, s.source = i, s.count = 0, s.index = 0, s
        }
        return e.prototype._next = function(n) {
            this.predicate ? this._tryPredicate(n) : this.count++
        }, e.prototype._tryPredicate = function(n) {
            var r;
            try {
                r = this.predicate(n, this.index++, this.source)
            } catch (i) {
                this.destination.error(i);
                return
            }
            r && this.count++
        }, e.prototype._complete = function() {
            this.destination.next(this.count), this.destination.complete()
        }, e
    }(Gt);

function lKe(t) {
    return function(e) {
        return e.lift(new cKe(t))
    }
}
var cKe = function() {
        function t(e) {
            this.durationSelector = e
        }
        return t.prototype.call = function(e, n) {
            return n.subscribe(new uKe(e, this.durationSelector))
        }, t
    }(),
    uKe = function(t) {
        Ve(e, t);

        function e(n, r) {
            var i = t.call(this, n) || this;
            return i.durationSelector = r, i.hasValue = !1, i
        }
        return e.prototype._next = function(n) {
            try {
                var r = this.durationSelector.call(this, n);
                r && this._tryNext(n, r)
            } catch (i) {
                this.destination.error(i)
            }
        }, e.prototype._complete = function() {
            this.emitValue(), this.destination.complete()
        }, e.prototype._tryNext = function(n, r) {
            var i = this.durationSubscription;
            this.value = n, this.hasValue = !0, i && (i.unsubscribe(), this.remove(i)), i = Zi(r, new Ki(this)), i && !i.closed && this.add(this.durationSubscription = i)
        }, e.prototype.notifyNext = function() {
            this.emitValue()
        }, e.prototype.notifyComplete = function() {
            this.emitValue()
        }, e.prototype.emitValue = function() {
            if (this.hasValue) {
                var n = this.value,
                    r = this.durationSubscription;
                r && (this.durationSubscription = void 0, r.unsubscribe(), this.remove(r)), this.value = void 0, this.hasValue = !1, t.prototype._next.call(this, n)
            }
        }, e
    }(Yi);

function fKe(t, e) {
    return e === void 0 && (e = ga),
        function(n) {
            return n.lift(new dKe(t, e))
        }
}
var dKe = function() {
        function t(e, n) {
            this.dueTime = e, this.scheduler = n
        }
        return t.prototype.call = function(e, n) {
            return n.subscribe(new hKe(e, this.dueTime, this.scheduler))
        }, t
    }(),
    hKe = function(t) {
        Ve(e, t);

        function e(n, r, i) {
            var s = t.call(this, n) || this;
            return s.dueTime = r, s.scheduler = i, s.debouncedSubscription = null, s.lastValue = null, s.hasValue = !1, s
        }
        return e.prototype._next = function(n) {
            this.clearDebounce(), this.lastValue = n, this.hasValue = !0, this.add(this.debouncedSubscription = this.scheduler.schedule(pKe, this.dueTime, this))
        }, e.prototype._complete = function() {
            this.debouncedNext(), this.destination.complete()
        }, e.prototype.debouncedNext = function() {
            if (this.clearDebounce(), this.hasValue) {
                var n = this.lastValue;
                this.lastValue = null, this.hasValue = !1, this.destination.next(n)
            }
        }, e.prototype.clearDebounce = function() {
            var n = this.debouncedSubscription;
            n !== null && (this.remove(n), n.unsubscribe(), this.debouncedSubscription = null)
        }, e
    }(Gt);

function pKe(t) {
    t.debouncedNext()
}

function l4(t) {
    return t === void 0 && (t = null),
        function(e) {
            return e.lift(new gKe(t))
        }
}
var gKe = function() {
        function t(e) {
            this.defaultValue = e
        }
        return t.prototype.call = function(e, n) {
            return n.subscribe(new mKe(e, this.defaultValue))
        }, t
    }(),
    mKe = function(t) {
        Ve(e, t);

        function e(n, r) {
            var i = t.call(this, n) || this;
            return i.defaultValue = r, i.isEmpty = !0, i
        }
        return e.prototype._next = function(n) {
            this.isEmpty = !1, this.destination.next(n)
        }, e.prototype._complete = function() {
            this.isEmpty && this.destination.next(this.defaultValue), this.destination.complete()
        }, e
    }(Gt);

function ble(t) {
    return t instanceof Date && !isNaN(+t)
}

function yKe(t, e) {
    e === void 0 && (e = ga);
    var n = ble(t),
        r = n ? +t - e.now() : Math.abs(t);
    return function(i) {
        return i.lift(new wKe(r, e))
    }
}
var wKe = function() {
        function t(e, n) {
            this.delay = e, this.scheduler = n
        }
        return t.prototype.call = function(e, n) {
            return n.subscribe(new vKe(e, this.delay, this.scheduler))
        }, t
    }(),
    vKe = function(t) {
        Ve(e, t);

        function e(n, r, i) {
            var s = t.call(this, n) || this;
            return s.delay = r, s.scheduler = i, s.queue = [], s.active = !1, s.errored = !1, s
        }
        return e.dispatch = function(n) {
            for (var r = n.source, i = r.queue, s = n.scheduler, o = n.destination; i.length > 0 && i[0].time - s.now() <= 0;) i.shift().notification.observe(o);
            if (i.length > 0) {
                var a = Math.max(0, i[0].time - s.now());
                this.schedule(n, a)
            } else this.unsubscribe(), r.active = !1
        }, e.prototype._schedule = function(n) {
            this.active = !0;
            var r = this.destination;
            r.add(n.schedule(e.dispatch, this.delay, {
                source: this,
                destination: this.destination,
                scheduler: n
            }))
        }, e.prototype.scheduleNotification = function(n) {
            if (this.errored !== !0) {
                var r = this.scheduler,
                    i = new bKe(r.now() + this.delay, n);
                this.queue.push(i), this.active === !1 && this._schedule(r)
            }
        }, e.prototype._next = function(n) {
            this.scheduleNotification(mh.createNext(n))
        }, e.prototype._error = function(n) {
            this.errored = !0, this.queue = [], this.destination.error(n), this.unsubscribe()
        }, e.prototype._complete = function() {
            this.scheduleNotification(mh.createComplete()), this.unsubscribe()
        }, e
    }(Gt),
    bKe = function() {
        function t(e, n) {
            this.time = e, this.notification = n
        }
        return t
    }();

function _Ke(t, e) {
    return e ? function(n) {
        return new xKe(n, e).lift(new LY(t))
    } : function(n) {
        return n.lift(new LY(t))
    }
}
var LY = function() {
        function t(e) {
            this.delayDurationSelector = e
        }
        return t.prototype.call = function(e, n) {
            return n.subscribe(new EKe(e, this.delayDurationSelector))
        }, t
    }(),
    EKe = function(t) {
        Ve(e, t);

        function e(n, r) {
            var i = t.call(this, n) || this;
            return i.delayDurationSelector = r, i.completed = !1, i.delayNotifierSubscriptions = [], i.index = 0, i
        }
        return e.prototype.notifyNext = function(n, r, i, s, o) {
            this.destination.next(n), this.removeSubscription(o), this.tryComplete()
        }, e.prototype.notifyError = function(n, r) {
            this._error(n)
        }, e.prototype.notifyComplete = function(n) {
            var r = this.removeSubscription(n);
            r && this.destination.next(r), this.tryComplete()
        }, e.prototype._next = function(n) {
            var r = this.index++;
            try {
                var i = this.delayDurationSelector(n, r);
                i && this.tryDelay(i, n)
            } catch (s) {
                this.destination.error(s)
            }
        }, e.prototype._complete = function() {
            this.completed = !0, this.tryComplete(), this.unsubscribe()
        }, e.prototype.removeSubscription = function(n) {
            n.unsubscribe();
            var r = this.delayNotifierSubscriptions.indexOf(n);
            return r !== -1 && this.delayNotifierSubscriptions.splice(r, 1), n.outerValue
        }, e.prototype.tryDelay = function(n, r) {
            var i = Ih(this, n, r);
            if (i && !i.closed) {
                var s = this.destination;
                s.add(i), this.delayNotifierSubscriptions.push(i)
            }
        }, e.prototype.tryComplete = function() {
            this.completed && this.delayNotifierSubscriptions.length === 0 && this.destination.complete()
        }, e
    }(Cy),
    xKe = function(t) {
        Ve(e, t);

        function e(n, r) {
            var i = t.call(this) || this;
            return i.source = n, i.subscriptionDelay = r, i
        }
        return e.prototype._subscribe = function(n) {
            this.subscriptionDelay.subscribe(new SKe(n, this.source))
        }, e
    }(Fn),
    SKe = function(t) {
        Ve(e, t);

        function e(n, r) {
            var i = t.call(this) || this;
            return i.parent = n, i.source = r, i.sourceSubscribed = !1, i
        }
        return e.prototype._next = function(n) {
            this.subscribeToSource()
        }, e.prototype._error = function(n) {
            this.unsubscribe(), this.parent.error(n)
        }, e.prototype._complete = function() {
            this.unsubscribe(), this.subscribeToSource()
        }, e.prototype.subscribeToSource = function() {
            this.sourceSubscribed || (this.sourceSubscribed = !0, this.unsubscribe(), this.source.subscribe(this.parent))
        }, e
    }(Gt);

function CKe() {
    return function(e) {
        return e.lift(new AKe)
    }
}
var AKe = function() {
        function t() {}
        return t.prototype.call = function(e, n) {
            return n.subscribe(new TKe(e))
        }, t
    }(),
    TKe = function(t) {
        Ve(e, t);

        function e(n) {
            return t.call(this, n) || this
        }
        return e.prototype._next = function(n) {
            n.observe(this.destination)
        }, e
    }(Gt);

function IKe(t, e) {
    return function(n) {
        return n.lift(new RKe(t, e))
    }
}
var RKe = function() {
        function t(e, n) {
            this.keySelector = e, this.flushes = n
        }
        return t.prototype.call = function(e, n) {
            return n.subscribe(new OKe(e, this.keySelector, this.flushes))
        }, t
    }(),
    OKe = function(t) {
        Ve(e, t);

        function e(n, r, i) {
            var s = t.call(this, n) || this;
            return s.keySelector = r, s.values = new Set, i && s.add(Zi(i, new Ki(s))), s
        }
        return e.prototype.notifyNext = function() {
            this.values.clear()
        }, e.prototype.notifyError = function(n) {
            this._error(n)
        }, e.prototype._next = function(n) {
            this.keySelector ? this._useKeySelector(n) : this._finalizeNext(n, n)
        }, e.prototype._useKeySelector = function(n) {
            var r, i = this.destination;
            try {
                r = this.keySelector(n)
            } catch (s) {
                i.error(s);
                return
            }
            this._finalizeNext(r, n)
        }, e.prototype._finalizeNext = function(n, r) {
            var i = this.values;
            i.has(n) || (i.add(n), this.destination.next(r))
        }, e
    }(Yi);

function _le(t, e) {
    return function(n) {
        return n.lift(new NKe(t, e))
    }
}
var NKe = function() {
        function t(e, n) {
            this.compare = e, this.keySelector = n
        }
        return t.prototype.call = function(e, n) {
            return n.subscribe(new PKe(e, this.compare, this.keySelector))
        }, t
    }(),
    PKe = function(t) {
        Ve(e, t);

        function e(n, r, i) {
            var s = t.call(this, n) || this;
            return s.keySelector = i, s.hasKey = !1, typeof r == "function" && (s.compare = r), s
        }
        return e.prototype.compare = function(n, r) {
            return n === r
        }, e.prototype._next = function(n) {
            var r;
            try {
                var i = this.keySelector;
                r = i ? i(n) : n
            } catch (a) {
                return this.destination.error(a)
            }
            var s = !1;
            if (this.hasKey) try {
                var o = this.compare;
                s = o(this.key, r)
            } catch (a) {
                return this.destination.error(a)
            } else this.hasKey = !0;
            s || (this.key = r, this.destination.next(n))
        }, e
    }(Gt);

function kKe(t, e) {
    return _le(function(n, r) {
        return e ? e(n[t], r[t]) : n[t] === r[t]
    })
}

function i7(t) {
    return t === void 0 && (t = $Ke),
        function(e) {
            return e.lift(new MKe(t))
        }
}
var MKe = function() {
        function t(e) {
            this.errorFactory = e
        }
        return t.prototype.call = function(e, n) {
            return n.subscribe(new DKe(e, this.errorFactory))
        }, t
    }(),
    DKe = function(t) {
        Ve(e, t);

        function e(n, r) {
            var i = t.call(this, n) || this;
            return i.errorFactory = r, i.hasValue = !1, i
        }
        return e.prototype._next = function(n) {
            this.hasValue = !0, this.destination.next(n)
        }, e.prototype._complete = function() {
            if (this.hasValue) return this.destination.complete();
            var n = void 0;
            try {
                n = this.errorFactory()
            } catch (r) {
                n = r
            }
            this.destination.error(n)
        }, e
    }(Gt);

function $Ke() {
    return new o4
}

function nF(t) {
    return function(e) {
        return t === 0 ? G2() : e.lift(new LKe(t))
    }
}
var LKe = function() {
        function t(e) {
            if (this.total = e, this.total < 0) throw new u2
        }
        return t.prototype.call = function(e, n) {
            return n.subscribe(new BKe(e, this.total))
        }, t
    }(),
    BKe = function(t) {
        Ve(e, t);

        function e(n, r) {
            var i = t.call(this, n) || this;
            return i.total = r, i.count = 0, i
        }
        return e.prototype._next = function(n) {
            var r = this.total,
                i = ++this.count;
            i <= r && (this.destination.next(n), i === r && (this.destination.complete(), this.unsubscribe()))
        }, e
    }(Gt);

function FKe(t, e) {
    if (t < 0) throw new u2;
    var n = arguments.length >= 2;
    return function(r) {
        return r.pipe(Yp(function(i, s) {
            return s === t
        }), nF(1), n ? l4(e) : i7(function() {
            return new u2
        }))
    }
}

function UKe() {
    for (var t = [], e = 0; e < arguments.length; e++) t[e] = arguments[e];
    return function(n) {
        return f6(n, H9.apply(void 0, t))
    }
}

function jKe(t, e) {
    return function(n) {
        return n.lift(new HKe(t, e, n))
    }
}
var HKe = function() {
        function t(e, n, r) {
            this.predicate = e, this.thisArg = n, this.source = r
        }
        return t.prototype.call = function(e, n) {
            return n.subscribe(new zKe(e, this.predicate, this.thisArg, this.source))
        }, t
    }(),
    zKe = function(t) {
        Ve(e, t);

        function e(n, r, i, s) {
            var o = t.call(this, n) || this;
            return o.predicate = r, o.thisArg = i, o.source = s, o.index = 0, o.thisArg = i || o, o
        }
        return e.prototype.notifyComplete = function(n) {
            this.destination.next(n), this.destination.complete()
        }, e.prototype._next = function(n) {
            var r = !1;
            try {
                r = this.predicate.call(this.thisArg, n, this.index++, this.source)
            } catch (i) {
                this.destination.error(i);
                return
            }
            r || this.notifyComplete(!1)
        }, e.prototype._complete = function() {
            this.notifyComplete(!0)
        }, e
    }(Gt);

function WKe() {
    return function(t) {
        return t.lift(new VKe)
    }
}
var VKe = function() {
        function t() {}
        return t.prototype.call = function(e, n) {
            return n.subscribe(new GKe(e))
        }, t
    }(),
    GKe = function(t) {
        Ve(e, t);

        function e(n) {
            var r = t.call(this, n) || this;
            return r.hasCompleted = !1, r.hasSubscription = !1, r
        }
        return e.prototype._next = function(n) {
            this.hasSubscription || (this.hasSubscription = !0, this.add(Zi(n, new Ki(this))))
        }, e.prototype._complete = function() {
            this.hasCompleted = !0, this.hasSubscription || this.destination.complete()
        }, e.prototype.notifyComplete = function() {
            this.hasSubscription = !1, this.hasCompleted && this.destination.complete()
        }, e
    }(Yi);

function Ele(t, e) {
    return e ? function(n) {
        return n.pipe(Ele(function(r, i) {
            return zh(t(r, i)).pipe(Bc(function(s, o) {
                return e(r, s, i, o)
            }))
        }))
    } : function(n) {
        return n.lift(new qKe(t))
    }
}
var qKe = function() {
        function t(e) {
            this.project = e
        }
        return t.prototype.call = function(e, n) {
            return n.subscribe(new KKe(e, this.project))
        }, t
    }(),
    KKe = function(t) {
        Ve(e, t);

        function e(n, r) {
            var i = t.call(this, n) || this;
            return i.project = r, i.hasSubscription = !1, i.hasCompleted = !1, i.index = 0, i
        }
        return e.prototype._next = function(n) {
            this.hasSubscription || this.tryNext(n)
        }, e.prototype.tryNext = function(n) {
            var r, i = this.index++;
            try {
                r = this.project(n, i)
            } catch (s) {
                this.destination.error(s);
                return
            }
            this.hasSubscription = !0, this._innerSub(r)
        }, e.prototype._innerSub = function(n) {
            var r = new Ki(this),
                i = this.destination;
            i.add(r);
            var s = Zi(n, r);
            s !== r && i.add(s)
        }, e.prototype._complete = function() {
            this.hasCompleted = !0, this.hasSubscription || this.destination.complete(), this.unsubscribe()
        }, e.prototype.notifyNext = function(n) {
            this.destination.next(n)
        }, e.prototype.notifyError = function(n) {
            this.destination.error(n)
        }, e.prototype.notifyComplete = function() {
            this.hasSubscription = !1, this.hasCompleted && this.destination.complete()
        }, e
    }(Yi);

function YKe(t, e, n) {
    return e === void 0 && (e = Number.POSITIVE_INFINITY), e = (e || 0) < 1 ? Number.POSITIVE_INFINITY : e,
        function(r) {
            return r.lift(new ZKe(t, e, n))
        }
}
var ZKe = function() {
        function t(e, n, r) {
            this.project = e, this.concurrent = n, this.scheduler = r
        }
        return t.prototype.call = function(e, n) {
            return n.subscribe(new QKe(e, this.project, this.concurrent, this.scheduler))
        }, t
    }(),
    QKe = function(t) {
        Ve(e, t);

        function e(n, r, i, s) {
            var o = t.call(this, n) || this;
            return o.project = r, o.concurrent = i, o.scheduler = s, o.index = 0, o.active = 0, o.hasCompleted = !1, i < Number.POSITIVE_INFINITY && (o.buffer = []), o
        }
        return e.dispatch = function(n) {
            var r = n.subscriber,
                i = n.result,
                s = n.value,
                o = n.index;
            r.subscribeToProjection(i, s, o)
        }, e.prototype._next = function(n) {
            var r = this.destination;
            if (r.closed) {
                this._complete();
                return
            }
            var i = this.index++;
            if (this.active < this.concurrent) {
                r.next(n);
                try {
                    var s = this.project,
                        o = s(n, i);
                    if (!this.scheduler) this.subscribeToProjection(o, n, i);
                    else {
                        var a = {
                                subscriber: this,
                                result: o,
                                value: n,
                                index: i
                            },
                            l = this.destination;
                        l.add(this.scheduler.schedule(e.dispatch, 0, a))
                    }
                } catch (c) {
                    r.error(c)
                }
            } else this.buffer.push(n)
        }, e.prototype.subscribeToProjection = function(n, r, i) {
            this.active++;
            var s = this.destination;
            s.add(Zi(n, new Ki(this)))
        }, e.prototype._complete = function() {
            this.hasCompleted = !0, this.hasCompleted && this.active === 0 && this.destination.complete(), this.unsubscribe()
        }, e.prototype.notifyNext = function(n) {
            this._next(n)
        }, e.prototype.notifyComplete = function() {
            var n = this.buffer;
            this.active--, n && n.length > 0 && this._next(n.shift()), this.hasCompleted && this.active === 0 && this.destination.complete()
        }, e
    }(Yi);

function JKe(t) {
    return function(e) {
        return e.lift(new XKe(t))
    }
}
var XKe = function() {
        function t(e) {
            this.callback = e
        }
        return t.prototype.call = function(e, n) {
            return n.subscribe(new eYe(e, this.callback))
        }, t
    }(),
    eYe = function(t) {
        Ve(e, t);

        function e(n, r) {
            var i = t.call(this, n) || this;
            return i.add(new ki(r)), i
        }
        return e
    }(Gt);

function tYe(t, e) {
    if (typeof t != "function") throw new TypeError("predicate is not a function");
    return function(n) {
        return n.lift(new xle(t, n, !1, e))
    }
}
var xle = function() {
        function t(e, n, r, i) {
            this.predicate = e, this.source = n, this.yieldIndex = r, this.thisArg = i
        }
        return t.prototype.call = function(e, n) {
            return n.subscribe(new nYe(e, this.predicate, this.source, this.yieldIndex, this.thisArg))
        }, t
    }(),
    nYe = function(t) {
        Ve(e, t);

        function e(n, r, i, s, o) {
            var a = t.call(this, n) || this;
            return a.predicate = r, a.source = i, a.yieldIndex = s, a.thisArg = o, a.index = 0, a
        }
        return e.prototype.notifyComplete = function(n) {
            var r = this.destination;
            r.next(n), r.complete(), this.unsubscribe()
        }, e.prototype._next = function(n) {
            var r = this,
                i = r.predicate,
                s = r.thisArg,
                o = this.index++;
            try {
                var a = i.call(s || this, n, o, this.source);
                a && this.notifyComplete(this.yieldIndex ? o : n)
            } catch (l) {
                this.destination.error(l)
            }
        }, e.prototype._complete = function() {
            this.notifyComplete(this.yieldIndex ? -1 : void 0)
        }, e
    }(Gt);

function rYe(t, e) {
    return function(n) {
        return n.lift(new xle(t, n, !0, e))
    }
}

function iYe(t, e) {
    var n = arguments.length >= 2;
    return function(r) {
        return r.pipe(t ? Yp(function(i, s) {
            return t(i, s, r)
        }) : qp, nF(1), n ? l4(e) : i7(function() {
            return new o4
        }))
    }
}

function sYe() {
    return function(e) {
        return e.lift(new oYe)
    }
}
var oYe = function() {
        function t() {}
        return t.prototype.call = function(e, n) {
            return n.subscribe(new aYe(e))
        }, t
    }(),
    aYe = function(t) {
        Ve(e, t);

        function e() {
            return t !== null && t.apply(this, arguments) || this
        }
        return e.prototype._next = function(n) {}, e
    }(Gt);

function lYe() {
    return function(t) {
        return t.lift(new cYe)
    }
}
var cYe = function() {
        function t() {}
        return t.prototype.call = function(e, n) {
            return n.subscribe(new uYe(e))
        }, t
    }(),
    uYe = function(t) {
        Ve(e, t);

        function e(n) {
            return t.call(this, n) || this
        }
        return e.prototype.notifyComplete = function(n) {
            var r = this.destination;
            r.next(n), r.complete()
        }, e.prototype._next = function(n) {
            this.notifyComplete(!1)
        }, e.prototype._complete = function() {
            this.notifyComplete(!0)
        }, e
    }(Gt);

function rA(t) {
    return function(n) {
        return t === 0 ? G2() : n.lift(new fYe(t))
    }
}
var fYe = function() {
        function t(e) {
            if (this.total = e, this.total < 0) throw new u2
        }
        return t.prototype.call = function(e, n) {
            return n.subscribe(new dYe(e, this.total))
        }, t
    }(),
    dYe = function(t) {
        Ve(e, t);

        function e(n, r) {
            var i = t.call(this, n) || this;
            return i.total = r, i.ring = new Array, i.count = 0, i
        }
        return e.prototype._next = function(n) {
            var r = this.ring,
                i = this.total,
                s = this.count++;
            if (r.length < i) r.push(n);
            else {
                var o = s % i;
                r[o] = n
            }
        }, e.prototype._complete = function() {
            var n = this.destination,
                r = this.count;
            if (r > 0)
                for (var i = this.count >= this.total ? this.total : this.count, s = this.ring, o = 0; o < i; o++) {
                    var a = r++ % i;
                    n.next(s[a])
                }
            n.complete()
        }, e
    }(Gt);

function hYe(t, e) {
    var n = arguments.length >= 2;
    return function(r) {
        return r.pipe(t ? Yp(function(i, s) {
            return t(i, s, r)
        }) : qp, rA(1), n ? l4(e) : i7(function() {
            return new o4
        }))
    }
}

function pYe(t) {
    return function(e) {
        return e.lift(new gYe(t))
    }
}
var gYe = function() {
        function t(e) {
            this.value = e
        }
        return t.prototype.call = function(e, n) {
            return n.subscribe(new mYe(e, this.value))
        }, t
    }(),
    mYe = function(t) {
        Ve(e, t);

        function e(n, r) {
            var i = t.call(this, n) || this;
            return i.value = r, i
        }
        return e.prototype._next = function(n) {
            this.destination.next(this.value)
        }, e
    }(Gt);

function yYe() {
    return function(e) {
        return e.lift(new wYe)
    }
}
var wYe = function() {
        function t() {}
        return t.prototype.call = function(e, n) {
            return n.subscribe(new vYe(e))
        }, t
    }(),
    vYe = function(t) {
        Ve(e, t);

        function e(n) {
            return t.call(this, n) || this
        }
        return e.prototype._next = function(n) {
            this.destination.next(mh.createNext(n))
        }, e.prototype._error = function(n) {
            var r = this.destination;
            r.next(mh.createError(n)), r.complete()
        }, e.prototype._complete = function() {
            var n = this.destination;
            n.next(mh.createComplete()), n.complete()
        }, e
    }(Gt);

function iA(t, e) {
    var n = !1;
    return arguments.length >= 2 && (n = !0),
        function(i) {
            return i.lift(new bYe(t, e, n))
        }
}
var bYe = function() {
        function t(e, n, r) {
            r === void 0 && (r = !1), this.accumulator = e, this.seed = n, this.hasSeed = r
        }
        return t.prototype.call = function(e, n) {
            return n.subscribe(new _Ye(e, this.accumulator, this.seed, this.hasSeed))
        }, t
    }(),
    _Ye = function(t) {
        Ve(e, t);

        function e(n, r, i, s) {
            var o = t.call(this, n) || this;
            return o.accumulator = r, o._seed = i, o.hasSeed = s, o.index = 0, o
        }
        return Object.defineProperty(e.prototype, "seed", {
            get: function() {
                return this._seed
            },
            set: function(n) {
                this.hasSeed = !0, this._seed = n
            },
            enumerable: !0,
            configurable: !0
        }), e.prototype._next = function(n) {
            if (!this.hasSeed) this.seed = n, this.destination.next(n);
            else return this._tryNext(n)
        }, e.prototype._tryNext = function(n) {
            var r = this.index++,
                i;
            try {
                i = this.accumulator(this.seed, n, r)
            } catch (s) {
                this.destination.error(s)
            }
            this.seed = i, this.destination.next(i)
        }, e
    }(Gt);

function s7(t, e) {
    return arguments.length >= 2 ? function(r) {
        return AM(iA(t, e), rA(1), l4(e))(r)
    } : function(r) {
        return AM(iA(function(i, s, o) {
            return t(i, s, o + 1)
        }), rA(1))(r)
    }
}

function EYe(t) {
    var e = typeof t == "function" ? function(n, r) {
        return t(n, r) > 0 ? n : r
    } : function(n, r) {
        return n > r ? n : r
    };
    return s7(e)
}

function xYe() {
    for (var t = [], e = 0; e < arguments.length; e++) t[e] = arguments[e];
    return function(n) {
        return n.lift.call(qae.apply(void 0, [n].concat(t)))
    }
}

function SYe(t, e, n) {
    return n === void 0 && (n = Number.POSITIVE_INFINITY), typeof e == "function" ? jm(function() {
        return t
    }, e, n) : (typeof e == "number" && (n = e), jm(function() {
        return t
    }, n))
}

function CYe(t, e, n) {
    return n === void 0 && (n = Number.POSITIVE_INFINITY),
        function(r) {
            return r.lift(new AYe(t, e, n))
        }
}
var AYe = function() {
        function t(e, n, r) {
            this.accumulator = e, this.seed = n, this.concurrent = r
        }
        return t.prototype.call = function(e, n) {
            return n.subscribe(new TYe(e, this.accumulator, this.seed, this.concurrent))
        }, t
    }(),
    TYe = function(t) {
        Ve(e, t);

        function e(n, r, i, s) {
            var o = t.call(this, n) || this;
            return o.accumulator = r, o.acc = i, o.concurrent = s, o.hasValue = !1, o.hasCompleted = !1, o.buffer = [], o.active = 0, o.index = 0, o
        }
        return e.prototype._next = function(n) {
            if (this.active < this.concurrent) {
                var r = this.index++,
                    i = this.destination,
                    s = void 0;
                try {
                    var o = this.accumulator;
                    s = o(this.acc, n, r)
                } catch (a) {
                    return i.error(a)
                }
                this.active++, this._innerSub(s)
            } else this.buffer.push(n)
        }, e.prototype._innerSub = function(n) {
            var r = new Ki(this),
                i = this.destination;
            i.add(r);
            var s = Zi(n, r);
            s !== r && i.add(s)
        }, e.prototype._complete = function() {
            this.hasCompleted = !0, this.active === 0 && this.buffer.length === 0 && (this.hasValue === !1 && this.destination.next(this.acc), this.destination.complete()), this.unsubscribe()
        }, e.prototype.notifyNext = function(n) {
            var r = this.destination;
            this.acc = n, this.hasValue = !0, r.next(n)
        }, e.prototype.notifyComplete = function() {
            var n = this.buffer;
            this.active--, n.length > 0 ? this._next(n.shift()) : this.active === 0 && this.hasCompleted && (this.hasValue === !1 && this.destination.next(this.acc), this.destination.complete())
        }, e
    }(Yi);

function IYe(t) {
    var e = typeof t == "function" ? function(n, r) {
        return t(n, r) < 0 ? n : r
    } : function(n, r) {
        return n < r ? n : r
    };
    return s7(e)
}

function Hm(t, e) {
    return function(r) {
        var i;
        if (typeof t == "function" ? i = t : i = function() {
                return t
            }, typeof e == "function") return r.lift(new RYe(i, e));
        var s = Object.create(r, oVe);
        return s.source = r, s.subjectFactory = i, s
    }
}
var RYe = function() {
    function t(e, n) {
        this.subjectFactory = e, this.selector = n
    }
    return t.prototype.call = function(e, n) {
        var r = this.selector,
            i = this.subjectFactory(),
            s = r(i).subscribe(e);
        return s.add(n.subscribe(i)), s
    }, t
}();

function OYe() {
    for (var t = [], e = 0; e < arguments.length; e++) t[e] = arguments[e];
    return t.length === 1 && pa(t[0]) && (t = t[0]),
        function(n) {
            return n.lift(new NYe(t))
        }
}
var NYe = function() {
        function t(e) {
            this.nextSources = e
        }
        return t.prototype.call = function(e, n) {
            return n.subscribe(new PYe(e, this.nextSources))
        }, t
    }(),
    PYe = function(t) {
        Ve(e, t);

        function e(n, r) {
            var i = t.call(this, n) || this;
            return i.destination = n, i.nextSources = r, i
        }
        return e.prototype.notifyError = function() {
            this.subscribeToNextSource()
        }, e.prototype.notifyComplete = function() {
            this.subscribeToNextSource()
        }, e.prototype._error = function(n) {
            this.subscribeToNextSource(), this.unsubscribe()
        }, e.prototype._complete = function() {
            this.subscribeToNextSource(), this.unsubscribe()
        }, e.prototype.subscribeToNextSource = function() {
            var n = this.nextSources.shift();
            if (n) {
                var r = new Ki(this),
                    i = this.destination;
                i.add(r);
                var s = Zi(n, r);
                s !== r && i.add(s)
            } else this.destination.complete()
        }, e
    }(Yi);

function kYe() {
    return function(t) {
        return t.lift(new MYe)
    }
}
var MYe = function() {
        function t() {}
        return t.prototype.call = function(e, n) {
            return n.subscribe(new DYe(e))
        }, t
    }(),
    DYe = function(t) {
        Ve(e, t);

        function e(n) {
            var r = t.call(this, n) || this;
            return r.hasPrev = !1, r
        }
        return e.prototype._next = function(n) {
            var r;
            this.hasPrev ? r = [this.prev, n] : this.hasPrev = !0, this.prev = n, r && this.destination.next(r)
        }, e
    }(Gt);

function $Ye(t, e) {
    return function(n) {
        return [Yp(t, e)(n), Yp(Yae(t, e))(n)]
    }
}

function LYe() {
    for (var t = [], e = 0; e < arguments.length; e++) t[e] = arguments[e];
    var n = t.length;
    if (n === 0) throw new Error("list of properties cannot be empty.");
    return function(r) {
        return Bc(BYe(t, n))(r)
    }
}

function BYe(t, e) {
    var n = function(r) {
        for (var i = r, s = 0; s < e; s++) {
            var o = i != null ? i[t[s]] : void 0;
            if (o !== void 0) i = o;
            else return
        }
        return i
    };
    return n
}

function FYe(t) {
    return t ? Hm(function() {
        return new Qs
    }, t) : Hm(new Qs)
}

function UYe(t) {
    return function(e) {
        return Hm(new Iae(t))(e)
    }
}

function jYe() {
    return function(t) {
        return Hm(new q2)(t)
    }
}

function HYe(t, e, n, r) {
    n && typeof n != "function" && (r = n);
    var i = typeof n == "function" ? n : void 0,
        s = new UB(t, e, r);
    return function(o) {
        return Hm(function() {
            return s
        }, i)(o)
    }
}

function zYe() {
    for (var t = [], e = 0; e < arguments.length; e++) t[e] = arguments[e];
    return function(r) {
        return t.length === 1 && pa(t[0]) && (t = t[0]), r.lift.call(Zae.apply(void 0, [r].concat(t)))
    }
}

function WYe(t) {
    return t === void 0 && (t = -1),
        function(e) {
            return t === 0 ? G2() : t < 0 ? e.lift(new BY(-1, e)) : e.lift(new BY(t - 1, e))
        }
}
var BY = function() {
        function t(e, n) {
            this.count = e, this.source = n
        }
        return t.prototype.call = function(e, n) {
            return n.subscribe(new VYe(e, this.count, this.source))
        }, t
    }(),
    VYe = function(t) {
        Ve(e, t);

        function e(n, r, i) {
            var s = t.call(this, n) || this;
            return s.count = r, s.source = i, s
        }
        return e.prototype.complete = function() {
            if (!this.isStopped) {
                var n = this,
                    r = n.source,
                    i = n.count;
                if (i === 0) return t.prototype.complete.call(this);
                i > -1 && (this.count = i - 1), r.subscribe(this._unsubscribeAndRecycle())
            }
        }, e
    }(Gt);

function GYe(t) {
    return function(e) {
        return e.lift(new qYe(t))
    }
}
var qYe = function() {
        function t(e) {
            this.notifier = e
        }
        return t.prototype.call = function(e, n) {
            return n.subscribe(new KYe(e, this.notifier, n))
        }, t
    }(),
    KYe = function(t) {
        Ve(e, t);

        function e(n, r, i) {
            var s = t.call(this, n) || this;
            return s.notifier = r, s.source = i, s.sourceIsBeingSubscribedTo = !0, s
        }
        return e.prototype.notifyNext = function() {
            this.sourceIsBeingSubscribedTo = !0, this.source.subscribe(this)
        }, e.prototype.notifyComplete = function() {
            if (this.sourceIsBeingSubscribedTo === !1) return t.prototype.complete.call(this)
        }, e.prototype.complete = function() {
            if (this.sourceIsBeingSubscribedTo = !1, !this.isStopped) {
                if (this.retries || this.subscribeToRetries(), !this.retriesSubscription || this.retriesSubscription.closed) return t.prototype.complete.call(this);
                this._unsubscribeAndRecycle(), this.notifications.next(void 0)
            }
        }, e.prototype._unsubscribe = function() {
            var n = this,
                r = n.notifications,
                i = n.retriesSubscription;
            r && (r.unsubscribe(), this.notifications = void 0), i && (i.unsubscribe(), this.retriesSubscription = void 0), this.retries = void 0
        }, e.prototype._unsubscribeAndRecycle = function() {
            var n = this._unsubscribe;
            return this._unsubscribe = null, t.prototype._unsubscribeAndRecycle.call(this), this._unsubscribe = n, this
        }, e.prototype.subscribeToRetries = function() {
            this.notifications = new Qs;
            var n;
            try {
                var r = this.notifier;
                n = r(this.notifications)
            } catch {
                return t.prototype.complete.call(this)
            }
            this.retries = n, this.retriesSubscription = Zi(n, new Ki(this))
        }, e
    }(Yi);

function YYe(t) {
    return t === void 0 && (t = -1),
        function(e) {
            return e.lift(new ZYe(t, e))
        }
}
var ZYe = function() {
        function t(e, n) {
            this.count = e, this.source = n
        }
        return t.prototype.call = function(e, n) {
            return n.subscribe(new QYe(e, this.count, this.source))
        }, t
    }(),
    QYe = function(t) {
        Ve(e, t);

        function e(n, r, i) {
            var s = t.call(this, n) || this;
            return s.count = r, s.source = i, s
        }
        return e.prototype.error = function(n) {
            if (!this.isStopped) {
                var r = this,
                    i = r.source,
                    s = r.count;
                if (s === 0) return t.prototype.error.call(this, n);
                s > -1 && (this.count = s - 1), i.subscribe(this._unsubscribeAndRecycle())
            }
        }, e
    }(Gt);

function JYe(t) {
    return function(e) {
        return e.lift(new XYe(t, e))
    }
}
var XYe = function() {
        function t(e, n) {
            this.notifier = e, this.source = n
        }
        return t.prototype.call = function(e, n) {
            return n.subscribe(new eZe(e, this.notifier, this.source))
        }, t
    }(),
    eZe = function(t) {
        Ve(e, t);

        function e(n, r, i) {
            var s = t.call(this, n) || this;
            return s.notifier = r, s.source = i, s
        }
        return e.prototype.error = function(n) {
            if (!this.isStopped) {
                var r = this.errors,
                    i = this.retries,
                    s = this.retriesSubscription;
                if (i) this.errors = void 0, this.retriesSubscription = void 0;
                else {
                    r = new Qs;
                    try {
                        var o = this.notifier;
                        i = o(r)
                    } catch (a) {
                        return t.prototype.error.call(this, a)
                    }
                    s = Zi(i, new Ki(this))
                }
                this._unsubscribeAndRecycle(), this.errors = r, this.retries = i, this.retriesSubscription = s, r.next(n)
            }
        }, e.prototype._unsubscribe = function() {
            var n = this,
                r = n.errors,
                i = n.retriesSubscription;
            r && (r.unsubscribe(), this.errors = void 0), i && (i.unsubscribe(), this.retriesSubscription = void 0), this.retries = void 0
        }, e.prototype.notifyNext = function() {
            var n = this._unsubscribe;
            this._unsubscribe = null, this._unsubscribeAndRecycle(), this._unsubscribe = n, this.source.subscribe(this)
        }, e
    }(Yi);

function tZe(t) {
    return function(e) {
        return e.lift(new nZe(t))
    }
}
var nZe = function() {
        function t(e) {
            this.notifier = e
        }
        return t.prototype.call = function(e, n) {
            var r = new rZe(e),
                i = n.subscribe(r);
            return i.add(Zi(this.notifier, new Ki(r))), i
        }, t
    }(),
    rZe = function(t) {
        Ve(e, t);

        function e() {
            var n = t !== null && t.apply(this, arguments) || this;
            return n.hasValue = !1, n
        }
        return e.prototype._next = function(n) {
            this.value = n, this.hasValue = !0
        }, e.prototype.notifyNext = function() {
            this.emitValue()
        }, e.prototype.notifyComplete = function() {
            this.emitValue()
        }, e.prototype.emitValue = function() {
            this.hasValue && (this.hasValue = !1, this.destination.next(this.value))
        }, e
    }(Yi);

function iZe(t, e) {
    return e === void 0 && (e = ga),
        function(n) {
            return n.lift(new sZe(t, e))
        }
}
var sZe = function() {
        function t(e, n) {
            this.period = e, this.scheduler = n
        }
        return t.prototype.call = function(e, n) {
            return n.subscribe(new oZe(e, this.period, this.scheduler))
        }, t
    }(),
    oZe = function(t) {
        Ve(e, t);

        function e(n, r, i) {
            var s = t.call(this, n) || this;
            return s.period = r, s.scheduler = i, s.hasValue = !1, s.add(i.schedule(aZe, r, {
                subscriber: s,
                period: r
            })), s
        }
        return e.prototype._next = function(n) {
            this.lastValue = n, this.hasValue = !0
        }, e.prototype.notifyNext = function() {
            this.hasValue && (this.hasValue = !1, this.destination.next(this.lastValue))
        }, e
    }(Gt);

function aZe(t) {
    var e = t.subscriber,
        n = t.period;
    e.notifyNext(), this.schedule(t, n)
}

function lZe(t, e) {
    return function(n) {
        return n.lift(new cZe(t, e))
    }
}
var cZe = function() {
        function t(e, n) {
            this.compareTo = e, this.comparator = n
        }
        return t.prototype.call = function(e, n) {
            return n.subscribe(new uZe(e, this.compareTo, this.comparator))
        }, t
    }(),
    uZe = function(t) {
        Ve(e, t);

        function e(n, r, i) {
            var s = t.call(this, n) || this;
            return s.compareTo = r, s.comparator = i, s._a = [], s._b = [], s._oneComplete = !1, s.destination.add(r.subscribe(new fZe(n, s))), s
        }
        return e.prototype._next = function(n) {
            this._oneComplete && this._b.length === 0 ? this.emit(!1) : (this._a.push(n), this.checkValues())
        }, e.prototype._complete = function() {
            this._oneComplete ? this.emit(this._a.length === 0 && this._b.length === 0) : this._oneComplete = !0, this.unsubscribe()
        }, e.prototype.checkValues = function() {
            for (var n = this, r = n._a, i = n._b, s = n.comparator; r.length > 0 && i.length > 0;) {
                var o = r.shift(),
                    a = i.shift(),
                    l = !1;
                try {
                    l = s ? s(o, a) : o === a
                } catch (c) {
                    this.destination.error(c)
                }
                l || this.emit(!1)
            }
        }, e.prototype.emit = function(n) {
            var r = this.destination;
            r.next(n), r.complete()
        }, e.prototype.nextB = function(n) {
            this._oneComplete && this._a.length === 0 ? this.emit(!1) : (this._b.push(n), this.checkValues())
        }, e.prototype.completeB = function() {
            this._oneComplete ? this.emit(this._a.length === 0 && this._b.length === 0) : this._oneComplete = !0
        }, e
    }(Gt),
    fZe = function(t) {
        Ve(e, t);

        function e(n, r) {
            var i = t.call(this, n) || this;
            return i.parent = r, i
        }
        return e.prototype._next = function(n) {
            this.parent.nextB(n)
        }, e.prototype._error = function(n) {
            this.parent.error(n), this.unsubscribe()
        }, e.prototype._complete = function() {
            this.parent.completeB(), this.unsubscribe()
        }, e
    }(Gt);

function dZe() {
    return new Qs
}

function hZe() {
    return function(t) {
        return LB()(Hm(dZe)(t))
    }
}

function pZe(t, e, n) {
    var r;
    return t && typeof t == "object" ? r = t : r = {
            bufferSize: t,
            windowTime: e,
            refCount: !1,
            scheduler: n
        },
        function(i) {
            return i.lift(gZe(r))
        }
}

function gZe(t) {
    var e = t.bufferSize,
        n = e === void 0 ? Number.POSITIVE_INFINITY : e,
        r = t.windowTime,
        i = r === void 0 ? Number.POSITIVE_INFINITY : r,
        s = t.refCount,
        o = t.scheduler,
        a, l = 0,
        c, u = !1,
        f = !1;
    return function(g) {
        l++;
        var y;
        !a || u ? (u = !1, a = new UB(n, i, o), y = a.subscribe(this), c = g.subscribe({
            next: function(_) {
                a.next(_)
            },
            error: function(_) {
                u = !0, a.error(_)
            },
            complete: function() {
                f = !0, c = void 0, a.complete()
            }
        }), f && (c = void 0)) : y = a.subscribe(this), this.add(function() {
            l--, y.unsubscribe(), y = void 0, c && !f && s && l === 0 && (c.unsubscribe(), c = void 0, a = void 0)
        })
    }
}

function mZe(t) {
    return function(e) {
        return e.lift(new yZe(t, e))
    }
}
var yZe = function() {
        function t(e, n) {
            this.predicate = e, this.source = n
        }
        return t.prototype.call = function(e, n) {
            return n.subscribe(new wZe(e, this.predicate, this.source))
        }, t
    }(),
    wZe = function(t) {
        Ve(e, t);

        function e(n, r, i) {
            var s = t.call(this, n) || this;
            return s.predicate = r, s.source = i, s.seenValue = !1, s.index = 0, s
        }
        return e.prototype.applySingleValue = function(n) {
            this.seenValue ? this.destination.error("Sequence contains more than one element") : (this.seenValue = !0, this.singleValue = n)
        }, e.prototype._next = function(n) {
            var r = this.index++;
            this.predicate ? this.tryNext(n, r) : this.applySingleValue(n)
        }, e.prototype.tryNext = function(n, r) {
            try {
                this.predicate(n, r, this.source) && this.applySingleValue(n)
            } catch (i) {
                this.destination.error(i)
            }
        }, e.prototype._complete = function() {
            var n = this.destination;
            this.index > 0 ? (n.next(this.seenValue ? this.singleValue : void 0), n.complete()) : n.error(new o4)
        }, e
    }(Gt);

function vZe(t) {
    return function(e) {
        return e.lift(new bZe(t))
    }
}
var bZe = function() {
        function t(e) {
            this.total = e
        }
        return t.prototype.call = function(e, n) {
            return n.subscribe(new _Ze(e, this.total))
        }, t
    }(),
    _Ze = function(t) {
        Ve(e, t);

        function e(n, r) {
            var i = t.call(this, n) || this;
            return i.total = r, i.count = 0, i
        }
        return e.prototype._next = function(n) {
            ++this.count > this.total && this.destination.next(n)
        }, e
    }(Gt);

function EZe(t) {
    return function(e) {
        return e.lift(new xZe(t))
    }
}
var xZe = function() {
        function t(e) {
            if (this._skipCount = e, this._skipCount < 0) throw new u2
        }
        return t.prototype.call = function(e, n) {
            return this._skipCount === 0 ? n.subscribe(new Gt(e)) : n.subscribe(new SZe(e, this._skipCount))
        }, t
    }(),
    SZe = function(t) {
        Ve(e, t);

        function e(n, r) {
            var i = t.call(this, n) || this;
            return i._skipCount = r, i._count = 0, i._ring = new Array(r), i
        }
        return e.prototype._next = function(n) {
            var r = this._skipCount,
                i = this._count++;
            if (i < r) this._ring[i] = n;
            else {
                var s = i % r,
                    o = this._ring,
                    a = o[s];
                o[s] = n, this.destination.next(a)
            }
        }, e
    }(Gt);

function CZe(t) {
    return function(e) {
        return e.lift(new AZe(t))
    }
}
var AZe = function() {
        function t(e) {
            this.notifier = e
        }
        return t.prototype.call = function(e, n) {
            return n.subscribe(new TZe(e, this.notifier))
        }, t
    }(),
    TZe = function(t) {
        Ve(e, t);

        function e(n, r) {
            var i = t.call(this, n) || this;
            i.hasValue = !1;
            var s = new Ki(i);
            i.add(s), i.innerSubscription = s;
            var o = Zi(r, s);
            return o !== s && (i.add(o), i.innerSubscription = o), i
        }
        return e.prototype._next = function(n) {
            this.hasValue && t.prototype._next.call(this, n)
        }, e.prototype.notifyNext = function() {
            this.hasValue = !0, this.innerSubscription && this.innerSubscription.unsubscribe()
        }, e.prototype.notifyComplete = function() {}, e
    }(Yi);

function IZe(t) {
    return function(e) {
        return e.lift(new RZe(t))
    }
}
var RZe = function() {
        function t(e) {
            this.predicate = e
        }
        return t.prototype.call = function(e, n) {
            return n.subscribe(new OZe(e, this.predicate))
        }, t
    }(),
    OZe = function(t) {
        Ve(e, t);

        function e(n, r) {
            var i = t.call(this, n) || this;
            return i.predicate = r, i.skipping = !0, i.index = 0, i
        }
        return e.prototype._next = function(n) {
            var r = this.destination;
            this.skipping && this.tryCallPredicate(n), this.skipping || r.next(n)
        }, e.prototype.tryCallPredicate = function(n) {
            try {
                var r = this.predicate(n, this.index++);
                this.skipping = !!r
            } catch (i) {
                this.destination.error(i)
            }
        }, e
    }(Gt);

function NZe() {
    for (var t = [], e = 0; e < arguments.length; e++) t[e] = arguments[e];
    var n = t[t.length - 1];
    return Al(n) ? (t.pop(), function(r) {
        return f6(t, r, n)
    }) : function(r) {
        return f6(t, r)
    }
}
var PZe = function(t) {
    Ve(e, t);

    function e(n, r, i) {
        r === void 0 && (r = 0), i === void 0 && (i = m8);
        var s = t.call(this) || this;
        return s.source = n, s.delayTime = r, s.scheduler = i, (!f2(r) || r < 0) && (s.delayTime = 0), (!i || typeof i.schedule != "function") && (s.scheduler = m8), s
    }
    return e.create = function(n, r, i) {
        return r === void 0 && (r = 0), i === void 0 && (i = m8), new e(n, r, i)
    }, e.dispatch = function(n) {
        var r = n.source,
            i = n.subscriber;
        return this.add(r.subscribe(i))
    }, e.prototype._subscribe = function(n) {
        var r = this.delayTime,
            i = this.source,
            s = this.scheduler;
        return s.schedule(e.dispatch, r, {
            source: i,
            subscriber: n
        })
    }, e
}(Fn);

function kZe(t, e) {
    return e === void 0 && (e = 0),
        function(r) {
            return r.lift(new MZe(t, e))
        }
}
var MZe = function() {
    function t(e, n) {
        this.scheduler = e, this.delay = n
    }
    return t.prototype.call = function(e, n) {
        return new PZe(n, this.delay, this.scheduler).subscribe(e)
    }, t
}();

function d6(t, e) {
    return typeof e == "function" ? function(n) {
        return n.pipe(d6(function(r, i) {
            return zh(t(r, i)).pipe(Bc(function(s, o) {
                return e(r, s, i, o)
            }))
        }))
    } : function(n) {
        return n.lift(new DZe(t))
    }
}
var DZe = function() {
        function t(e) {
            this.project = e
        }
        return t.prototype.call = function(e, n) {
            return n.subscribe(new $Ze(e, this.project))
        }, t
    }(),
    $Ze = function(t) {
        Ve(e, t);

        function e(n, r) {
            var i = t.call(this, n) || this;
            return i.project = r, i.index = 0, i
        }
        return e.prototype._next = function(n) {
            var r, i = this.index++;
            try {
                r = this.project(n, i)
            } catch (s) {
                this.destination.error(s);
                return
            }
            this._innerSub(r)
        }, e.prototype._innerSub = function(n) {
            var r = this.innerSubscription;
            r && r.unsubscribe();
            var i = new Ki(this),
                s = this.destination;
            s.add(i), this.innerSubscription = Zi(n, i), this.innerSubscription !== i && s.add(this.innerSubscription)
        }, e.prototype._complete = function() {
            var n = this.innerSubscription;
            (!n || n.closed) && t.prototype._complete.call(this), this.unsubscribe()
        }, e.prototype._unsubscribe = function() {
            this.innerSubscription = void 0
        }, e.prototype.notifyComplete = function() {
            this.innerSubscription = void 0, this.isStopped && t.prototype._complete.call(this)
        }, e.prototype.notifyNext = function(n) {
            this.destination.next(n)
        }, e
    }(Yi);

function LZe() {
    return d6(qp)
}

function BZe(t, e) {
    return e ? d6(function() {
        return t
    }, e) : d6(function() {
        return t
    })
}

function FZe(t) {
    return function(e) {
        return e.lift(new UZe(t))
    }
}
var UZe = function() {
        function t(e) {
            this.notifier = e
        }
        return t.prototype.call = function(e, n) {
            var r = new jZe(e),
                i = Zi(this.notifier, new Ki(r));
            return i && !r.seenValue ? (r.add(i), n.subscribe(r)) : r
        }, t
    }(),
    jZe = function(t) {
        Ve(e, t);

        function e(n) {
            var r = t.call(this, n) || this;
            return r.seenValue = !1, r
        }
        return e.prototype.notifyNext = function() {
            this.seenValue = !0, this.complete()
        }, e.prototype.notifyComplete = function() {}, e
    }(Yi);

function HZe(t, e) {
    return e === void 0 && (e = !1),
        function(n) {
            return n.lift(new zZe(t, e))
        }
}
var zZe = function() {
        function t(e, n) {
            this.predicate = e, this.inclusive = n
        }
        return t.prototype.call = function(e, n) {
            return n.subscribe(new WZe(e, this.predicate, this.inclusive))
        }, t
    }(),
    WZe = function(t) {
        Ve(e, t);

        function e(n, r, i) {
            var s = t.call(this, n) || this;
            return s.predicate = r, s.inclusive = i, s.index = 0, s
        }
        return e.prototype._next = function(n) {
            var r = this.destination,
                i;
            try {
                i = this.predicate(n, this.index++)
            } catch (s) {
                r.error(s);
                return
            }
            this.nextOrComplete(n, i)
        }, e.prototype.nextOrComplete = function(n, r) {
            var i = this.destination;
            r ? i.next(n) : (this.inclusive && i.next(n), i.complete())
        }, e
    }(Gt);

function VZe(t, e, n) {
    return function(i) {
        return i.lift(new GZe(t, e, n))
    }
}
var GZe = function() {
        function t(e, n, r) {
            this.nextOrObserver = e, this.error = n, this.complete = r
        }
        return t.prototype.call = function(e, n) {
            return n.subscribe(new qZe(e, this.nextOrObserver, this.error, this.complete))
        }, t
    }(),
    qZe = function(t) {
        Ve(e, t);

        function e(n, r, i, s) {
            var o = t.call(this, n) || this;
            return o._tapNext = pf, o._tapError = pf, o._tapComplete = pf, o._tapError = i || pf, o._tapComplete = s || pf, l2(r) ? (o._context = o, o._tapNext = r) : r && (o._context = r, o._tapNext = r.next || pf, o._tapError = r.error || pf, o._tapComplete = r.complete || pf), o
        }
        return e.prototype._next = function(n) {
            try {
                this._tapNext.call(this._context, n)
            } catch (r) {
                this.destination.error(r);
                return
            }
            this.destination.next(n)
        }, e.prototype._error = function(n) {
            try {
                this._tapError.call(this._context, n)
            } catch (r) {
                this.destination.error(r);
                return
            }
            this.destination.error(n)
        }, e.prototype._complete = function() {
            try {
                this._tapComplete.call(this._context)
            } catch (n) {
                this.destination.error(n);
                return
            }
            return this.destination.complete()
        }, e
    }(Gt),
    Sle = {
        leading: !0,
        trailing: !1
    };

function KZe(t, e) {
    return e === void 0 && (e = Sle),
        function(n) {
            return n.lift(new YZe(t, !!e.leading, !!e.trailing))
        }
}
var YZe = function() {
        function t(e, n, r) {
            this.durationSelector = e, this.leading = n, this.trailing = r
        }
        return t.prototype.call = function(e, n) {
            return n.subscribe(new ZZe(e, this.durationSelector, this.leading, this.trailing))
        }, t
    }(),
    ZZe = function(t) {
        Ve(e, t);

        function e(n, r, i, s) {
            var o = t.call(this, n) || this;
            return o.destination = n, o.durationSelector = r, o._leading = i, o._trailing = s, o._hasValue = !1, o
        }
        return e.prototype._next = function(n) {
            this._hasValue = !0, this._sendValue = n, this._throttled || (this._leading ? this.send() : this.throttle(n))
        }, e.prototype.send = function() {
            var n = this,
                r = n._hasValue,
                i = n._sendValue;
            r && (this.destination.next(i), this.throttle(i)), this._hasValue = !1, this._sendValue = void 0
        }, e.prototype.throttle = function(n) {
            var r = this.tryDurationSelector(n);
            r && this.add(this._throttled = Zi(r, new Ki(this)))
        }, e.prototype.tryDurationSelector = function(n) {
            try {
                return this.durationSelector(n)
            } catch (r) {
                return this.destination.error(r), null
            }
        }, e.prototype.throttlingDone = function() {
            var n = this,
                r = n._throttled,
                i = n._trailing;
            r && r.unsubscribe(), this._throttled = void 0, i && this.send()
        }, e.prototype.notifyNext = function() {
            this.throttlingDone()
        }, e.prototype.notifyComplete = function() {
            this.throttlingDone()
        }, e
    }(Yi);

function QZe(t, e, n) {
    return e === void 0 && (e = ga), n === void 0 && (n = Sle),
        function(r) {
            return r.lift(new JZe(t, e, n.leading, n.trailing))
        }
}
var JZe = function() {
        function t(e, n, r, i) {
            this.duration = e, this.scheduler = n, this.leading = r, this.trailing = i
        }
        return t.prototype.call = function(e, n) {
            return n.subscribe(new XZe(e, this.duration, this.scheduler, this.leading, this.trailing))
        }, t
    }(),
    XZe = function(t) {
        Ve(e, t);

        function e(n, r, i, s, o) {
            var a = t.call(this, n) || this;
            return a.duration = r, a.scheduler = i, a.leading = s, a.trailing = o, a._hasTrailingValue = !1, a._trailingValue = null, a
        }
        return e.prototype._next = function(n) {
            this.throttled ? this.trailing && (this._trailingValue = n, this._hasTrailingValue = !0) : (this.add(this.throttled = this.scheduler.schedule(eQe, this.duration, {
                subscriber: this
            })), this.leading ? this.destination.next(n) : this.trailing && (this._trailingValue = n, this._hasTrailingValue = !0))
        }, e.prototype._complete = function() {
            this._hasTrailingValue ? (this.destination.next(this._trailingValue), this.destination.complete()) : this.destination.complete()
        }, e.prototype.clearThrottle = function() {
            var n = this.throttled;
            n && (this.trailing && this._hasTrailingValue && (this.destination.next(this._trailingValue), this._trailingValue = null, this._hasTrailingValue = !1), n.unsubscribe(), this.remove(n), this.throttled = null)
        }, e
    }(Gt);

function eQe(t) {
    var e = t.subscriber;
    e.clearThrottle()
}

function tQe(t) {
    return t === void 0 && (t = ga),
        function(e) {
            return zB(function() {
                return e.pipe(iA(function(n, r) {
                    var i = n.current;
                    return {
                        value: r,
                        current: t.now(),
                        last: i
                    }
                }, {
                    current: t.now(),
                    value: void 0,
                    last: void 0
                }), Bc(function(n) {
                    var r = n.current,
                        i = n.last,
                        s = n.value;
                    return new nQe(s, r - i)
                }))
            })
        }
}
var nQe = function() {
    function t(e, n) {
        this.value = e, this.interval = n
    }
    return t
}();

function Cle(t, e, n) {
    return n === void 0 && (n = ga),
        function(r) {
            var i = ble(t),
                s = i ? +t - n.now() : Math.abs(t);
            return r.lift(new rQe(s, i, e, n))
        }
}
var rQe = function() {
        function t(e, n, r, i) {
            this.waitFor = e, this.absoluteTimeout = n, this.withObservable = r, this.scheduler = i
        }
        return t.prototype.call = function(e, n) {
            return n.subscribe(new iQe(e, this.absoluteTimeout, this.waitFor, this.withObservable, this.scheduler))
        }, t
    }(),
    iQe = function(t) {
        Ve(e, t);

        function e(n, r, i, s, o) {
            var a = t.call(this, n) || this;
            return a.absoluteTimeout = r, a.waitFor = i, a.withObservable = s, a.scheduler = o, a.scheduleTimeout(), a
        }
        return e.dispatchTimeout = function(n) {
            var r = n.withObservable;
            n._unsubscribeAndRecycle(), n.add(Zi(r, new Ki(n)))
        }, e.prototype.scheduleTimeout = function() {
            var n = this.action;
            n ? this.action = n.schedule(this, this.waitFor) : this.add(this.action = this.scheduler.schedule(e.dispatchTimeout, this.waitFor, this))
        }, e.prototype._next = function(n) {
            this.absoluteTimeout || this.scheduleTimeout(), t.prototype._next.call(this, n)
        }, e.prototype._unsubscribe = function() {
            this.action = void 0, this.scheduler = null, this.withObservable = null
        }, e
    }(Yi);

function sQe(t, e) {
    return e === void 0 && (e = ga), Cle(t, FB(new Lae), e)
}

function oQe(t) {
    return t === void 0 && (t = ga), Bc(function(e) {
        return new aQe(e, t.now())
    })
}
var aQe = function() {
    function t(e, n) {
        this.value = e, this.timestamp = n
    }
    return t
}();

function lQe(t, e, n) {
    return n === 0 ? [e] : (t.push(e), t)
}

function cQe() {
    return s7(lQe, [])
}

function uQe(t) {
    return function(n) {
        return n.lift(new fQe(t))
    }
}
var fQe = function() {
        function t(e) {
            this.windowBoundaries = e
        }
        return t.prototype.call = function(e, n) {
            var r = new dQe(e),
                i = n.subscribe(r);
            return i.closed || r.add(Zi(this.windowBoundaries, new Ki(r))), i
        }, t
    }(),
    dQe = function(t) {
        Ve(e, t);

        function e(n) {
            var r = t.call(this, n) || this;
            return r.window = new Qs, n.next(r.window), r
        }
        return e.prototype.notifyNext = function() {
            this.openWindow()
        }, e.prototype.notifyError = function(n) {
            this._error(n)
        }, e.prototype.notifyComplete = function() {
            this._complete()
        }, e.prototype._next = function(n) {
            this.window.next(n)
        }, e.prototype._error = function(n) {
            this.window.error(n), this.destination.error(n)
        }, e.prototype._complete = function() {
            this.window.complete(), this.destination.complete()
        }, e.prototype._unsubscribe = function() {
            this.window = null
        }, e.prototype.openWindow = function() {
            var n = this.window;
            n && n.complete();
            var r = this.destination,
                i = this.window = new Qs;
            r.next(i)
        }, e
    }(Yi);

function hQe(t, e) {
    return e === void 0 && (e = 0),
        function(r) {
            return r.lift(new pQe(t, e))
        }
}
var pQe = function() {
        function t(e, n) {
            this.windowSize = e, this.startWindowEvery = n
        }
        return t.prototype.call = function(e, n) {
            return n.subscribe(new gQe(e, this.windowSize, this.startWindowEvery))
        }, t
    }(),
    gQe = function(t) {
        Ve(e, t);

        function e(n, r, i) {
            var s = t.call(this, n) || this;
            return s.destination = n, s.windowSize = r, s.startWindowEvery = i, s.windows = [new Qs], s.count = 0, n.next(s.windows[0]), s
        }
        return e.prototype._next = function(n) {
            for (var r = this.startWindowEvery > 0 ? this.startWindowEvery : this.windowSize, i = this.destination, s = this.windowSize, o = this.windows, a = o.length, l = 0; l < a && !this.closed; l++) o[l].next(n);
            var c = this.count - s + 1;
            if (c >= 0 && c % r === 0 && !this.closed && o.shift().complete(), ++this.count % r === 0 && !this.closed) {
                var u = new Qs;
                o.push(u), i.next(u)
            }
        }, e.prototype._error = function(n) {
            var r = this.windows;
            if (r)
                for (; r.length > 0 && !this.closed;) r.shift().error(n);
            this.destination.error(n)
        }, e.prototype._complete = function() {
            var n = this.windows;
            if (n)
                for (; n.length > 0 && !this.closed;) n.shift().complete();
            this.destination.complete()
        }, e.prototype._unsubscribe = function() {
            this.count = 0, this.windows = null
        }, e
    }(Gt);

function mQe(t) {
    var e = ga,
        n = null,
        r = Number.POSITIVE_INFINITY;
    return Al(arguments[3]) && (e = arguments[3]), Al(arguments[2]) ? e = arguments[2] : f2(arguments[2]) && (r = Number(arguments[2])), Al(arguments[1]) ? e = arguments[1] : f2(arguments[1]) && (n = Number(arguments[1])),
        function(s) {
            return s.lift(new yQe(t, n, r, e))
        }
}
var yQe = function() {
        function t(e, n, r, i) {
            this.windowTimeSpan = e, this.windowCreationInterval = n, this.maxWindowSize = r, this.scheduler = i
        }
        return t.prototype.call = function(e, n) {
            return n.subscribe(new vQe(e, this.windowTimeSpan, this.windowCreationInterval, this.maxWindowSize, this.scheduler))
        }, t
    }(),
    wQe = function(t) {
        Ve(e, t);

        function e() {
            var n = t !== null && t.apply(this, arguments) || this;
            return n._numberOfNextedValues = 0, n
        }
        return e.prototype.next = function(n) {
            this._numberOfNextedValues++, t.prototype.next.call(this, n)
        }, Object.defineProperty(e.prototype, "numberOfNextedValues", {
            get: function() {
                return this._numberOfNextedValues
            },
            enumerable: !0,
            configurable: !0
        }), e
    }(Qs),
    vQe = function(t) {
        Ve(e, t);

        function e(n, r, i, s, o) {
            var a = t.call(this, n) || this;
            a.destination = n, a.windowTimeSpan = r, a.windowCreationInterval = i, a.maxWindowSize = s, a.scheduler = o, a.windows = [];
            var l = a.openWindow();
            if (i !== null && i >= 0) {
                var c = {
                        subscriber: a,
                        window: l,
                        context: null
                    },
                    u = {
                        windowTimeSpan: r,
                        windowCreationInterval: i,
                        subscriber: a,
                        scheduler: o
                    };
                a.add(o.schedule(Ale, r, c)), a.add(o.schedule(_Qe, i, u))
            } else {
                var f = {
                    subscriber: a,
                    window: l,
                    windowTimeSpan: r
                };
                a.add(o.schedule(bQe, r, f))
            }
            return a
        }
        return e.prototype._next = function(n) {
            for (var r = this.windows, i = r.length, s = 0; s < i; s++) {
                var o = r[s];
                o.closed || (o.next(n), o.numberOfNextedValues >= this.maxWindowSize && this.closeWindow(o))
            }
        }, e.prototype._error = function(n) {
            for (var r = this.windows; r.length > 0;) r.shift().error(n);
            this.destination.error(n)
        }, e.prototype._complete = function() {
            for (var n = this.windows; n.length > 0;) {
                var r = n.shift();
                r.closed || r.complete()
            }
            this.destination.complete()
        }, e.prototype.openWindow = function() {
            var n = new wQe;
            this.windows.push(n);
            var r = this.destination;
            return r.next(n), n
        }, e.prototype.closeWindow = function(n) {
            n.complete();
            var r = this.windows;
            r.splice(r.indexOf(n), 1)
        }, e
    }(Gt);

function bQe(t) {
    var e = t.subscriber,
        n = t.windowTimeSpan,
        r = t.window;
    r && e.closeWindow(r), t.window = e.openWindow(), this.schedule(t, n)
}

function _Qe(t) {
    var e = t.windowTimeSpan,
        n = t.subscriber,
        r = t.scheduler,
        i = t.windowCreationInterval,
        s = n.openWindow(),
        o = this,
        a = {
            action: o,
            subscription: null
        },
        l = {
            subscriber: n,
            window: s,
            context: a
        };
    a.subscription = r.schedule(Ale, e, l), o.add(a.subscription), o.schedule(t, i)
}

function Ale(t) {
    var e = t.subscriber,
        n = t.window,
        r = t.context;
    r && r.action && r.subscription && r.action.remove(r.subscription), e.closeWindow(n)
}

function EQe(t, e) {
    return function(n) {
        return n.lift(new xQe(t, e))
    }
}
var xQe = function() {
        function t(e, n) {
            this.openings = e, this.closingSelector = n
        }
        return t.prototype.call = function(e, n) {
            return n.subscribe(new SQe(e, this.openings, this.closingSelector))
        }, t
    }(),
    SQe = function(t) {
        Ve(e, t);

        function e(n, r, i) {
            var s = t.call(this, n) || this;
            return s.openings = r, s.closingSelector = i, s.contexts = [], s.add(s.openSubscription = Ih(s, r, r)), s
        }
        return e.prototype._next = function(n) {
            var r = this.contexts;
            if (r)
                for (var i = r.length, s = 0; s < i; s++) r[s].window.next(n)
        }, e.prototype._error = function(n) {
            var r = this.contexts;
            if (this.contexts = null, r)
                for (var i = r.length, s = -1; ++s < i;) {
                    var o = r[s];
                    o.window.error(n), o.subscription.unsubscribe()
                }
            t.prototype._error.call(this, n)
        }, e.prototype._complete = function() {
            var n = this.contexts;
            if (this.contexts = null, n)
                for (var r = n.length, i = -1; ++i < r;) {
                    var s = n[i];
                    s.window.complete(), s.subscription.unsubscribe()
                }
            t.prototype._complete.call(this)
        }, e.prototype._unsubscribe = function() {
            var n = this.contexts;
            if (this.contexts = null, n)
                for (var r = n.length, i = -1; ++i < r;) {
                    var s = n[i];
                    s.window.unsubscribe(), s.subscription.unsubscribe()
                }
        }, e.prototype.notifyNext = function(n, r, i, s, o) {
            if (n === this.openings) {
                var a = void 0;
                try {
                    var l = this.closingSelector;
                    a = l(r)
                } catch (g) {
                    return this.error(g)
                }
                var c = new Qs,
                    u = new ki,
                    f = {
                        window: c,
                        subscription: u
                    };
                this.contexts.push(f);
                var h = Ih(this, a, f);
                h.closed ? this.closeWindow(this.contexts.length - 1) : (h.context = f, u.add(h)), this.destination.next(c)
            } else this.closeWindow(this.contexts.indexOf(n))
        }, e.prototype.notifyError = function(n) {
            this.error(n)
        }, e.prototype.notifyComplete = function(n) {
            n !== this.openSubscription && this.closeWindow(this.contexts.indexOf(n.context))
        }, e.prototype.closeWindow = function(n) {
            if (n !== -1) {
                var r = this.contexts,
                    i = r[n],
                    s = i.window,
                    o = i.subscription;
                r.splice(n, 1), s.complete(), o.unsubscribe()
            }
        }, e
    }(Cy);

function CQe(t) {
    return function(n) {
        return n.lift(new AQe(t))
    }
}
var AQe = function() {
        function t(e) {
            this.closingSelector = e
        }
        return t.prototype.call = function(e, n) {
            return n.subscribe(new TQe(e, this.closingSelector))
        }, t
    }(),
    TQe = function(t) {
        Ve(e, t);

        function e(n, r) {
            var i = t.call(this, n) || this;
            return i.destination = n, i.closingSelector = r, i.openWindow(), i
        }
        return e.prototype.notifyNext = function(n, r, i, s, o) {
            this.openWindow(o)
        }, e.prototype.notifyError = function(n) {
            this._error(n)
        }, e.prototype.notifyComplete = function(n) {
            this.openWindow(n)
        }, e.prototype._next = function(n) {
            this.window.next(n)
        }, e.prototype._error = function(n) {
            this.window.error(n), this.destination.error(n), this.unsubscribeClosingNotification()
        }, e.prototype._complete = function() {
            this.window.complete(), this.destination.complete(), this.unsubscribeClosingNotification()
        }, e.prototype.unsubscribeClosingNotification = function() {
            this.closingNotification && this.closingNotification.unsubscribe()
        }, e.prototype.openWindow = function(n) {
            n === void 0 && (n = null), n && (this.remove(n), n.unsubscribe());
            var r = this.window;
            r && r.complete();
            var i = this.window = new Qs;
            this.destination.next(i);
            var s;
            try {
                var o = this.closingSelector;
                s = o()
            } catch (a) {
                this.destination.error(a), this.window.error(a);
                return
            }
            this.add(this.closingNotification = Ih(this, s))
        }, e
    }(Cy);

function IQe() {
    for (var t = [], e = 0; e < arguments.length; e++) t[e] = arguments[e];
    return function(n) {
        var r;
        typeof t[t.length - 1] == "function" && (r = t.pop());
        var i = t;
        return n.lift(new RQe(i, r))
    }
}
var RQe = function() {
        function t(e, n) {
            this.observables = e, this.project = n
        }
        return t.prototype.call = function(e, n) {
            return n.subscribe(new OQe(e, this.observables, this.project))
        }, t
    }(),
    OQe = function(t) {
        Ve(e, t);

        function e(n, r, i) {
            var s = t.call(this, n) || this;
            s.observables = r, s.project = i, s.toRespond = [];
            var o = r.length;
            s.values = new Array(o);
            for (var a = 0; a < o; a++) s.toRespond.push(a);
            for (var a = 0; a < o; a++) {
                var l = r[a];
                s.add(Ih(s, l, void 0, a))
            }
            return s
        }
        return e.prototype.notifyNext = function(n, r, i) {
            this.values[i] = r;
            var s = this.toRespond;
            if (s.length > 0) {
                var o = s.indexOf(i);
                o !== -1 && s.splice(o, 1)
            }
        }, e.prototype.notifyComplete = function() {}, e.prototype._next = function(n) {
            if (this.toRespond.length === 0) {
                var r = [n].concat(this.values);
                this.project ? this._tryProject(r) : this.destination.next(r)
            }
        }, e.prototype._tryProject = function(n) {
            var r;
            try {
                r = this.project.apply(this, n)
            } catch (i) {
                this.destination.error(i);
                return
            }
            this.destination.next(r)
        }, e
    }(Cy);

function NQe() {
    for (var t = [], e = 0; e < arguments.length; e++) t[e] = arguments[e];
    return function(r) {
        return r.lift.call(Jae.apply(void 0, [r].concat(t)))
    }
}

function PQe(t) {
    return function(e) {
        return e.lift(new Xae(t))
    }
}
const kQe = Object.freeze(Object.defineProperty({
        __proto__: null,
        audit: yle,
        auditTime: kqe,
        buffer: Mqe,
        bufferCount: Lqe,
        bufferTime: jqe,
        bufferToggle: Gqe,
        bufferWhen: Yqe,
        catchError: Jqe,
        combineAll: tKe,
        combineLatest: nKe,
        concat: rKe,
        concatAll: zae,
        concatMap: vle,
        concatMapTo: iKe,
        count: sKe,
        debounce: lKe,
        debounceTime: fKe,
        defaultIfEmpty: l4,
        delay: yKe,
        delayWhen: _Ke,
        dematerialize: CKe,
        distinct: IKe,
        distinctUntilChanged: _le,
        distinctUntilKeyChanged: kKe,
        elementAt: FKe,
        endWith: UKe,
        every: jKe,
        exhaust: WKe,
        exhaustMap: Ele,
        expand: YKe,
        filter: Yp,
        finalize: JKe,
        find: tYe,
        findIndex: rYe,
        first: iYe,
        flatMap: eGe,
        groupBy: lVe,
        ignoreElements: sYe,
        isEmpty: lYe,
        last: hYe,
        map: Bc,
        mapTo: pYe,
        materialize: yYe,
        max: EYe,
        merge: xYe,
        mergeAll: HB,
        mergeMap: jm,
        mergeMapTo: SYe,
        mergeScan: CYe,
        min: IYe,
        multicast: Hm,
        observeOn: wVe,
        onErrorResumeNext: OYe,
        pairwise: kYe,
        partition: $Ye,
        pluck: LYe,
        publish: FYe,
        publishBehavior: UYe,
        publishLast: jYe,
        publishReplay: HYe,
        race: zYe,
        reduce: s7,
        refCount: LB,
        repeat: WYe,
        repeatWhen: GYe,
        retry: YYe,
        retryWhen: JYe,
        sample: tZe,
        sampleTime: iZe,
        scan: iA,
        sequenceEqual: lZe,
        share: hZe,
        shareReplay: pZe,
        single: mZe,
        skip: vZe,
        skipLast: EZe,
        skipUntil: CZe,
        skipWhile: IZe,
        startWith: NZe,
        subscribeOn: kZe,
        switchAll: LZe,
        switchMap: d6,
        switchMapTo: BZe,
        take: nF,
        takeLast: rA,
        takeUntil: FZe,
        takeWhile: HZe,
        tap: VZe,
        throttle: KZe,
        throttleTime: QZe,
        throwIfEmpty: i7,
        timeInterval: tQe,
        timeout: sQe,
        timeoutWith: Cle,
        timestamp: oQe,
        toArray: cQe,
        window: uQe,
        windowCount: hQe,
        windowTime: mQe,
        windowToggle: EQe,
        windowWhen: CQe,
        withLatestFrom: IQe,
        zip: NQe,
        zipAll: PQe
    }, Symbol.toStringTag, {
        value: "Module"
    })),
    rF = Fu(kQe);
var o7 = {},
    bc = {};
Object.defineProperty(bc, "__esModule", {
    value: !0
});
bc.ClientMessagePublishEvent = bc.ClientMessageSetSessionConfig = bc.ClientMessageGetSessionConfig = bc.ClientMessageIsLinked = bc.ClientMessageHostSession = void 0;

function MQe(t) {
    return Object.assign({
        type: "HostSession"
    }, t)
}
bc.ClientMessageHostSession = MQe;

function DQe(t) {
    return Object.assign({
        type: "IsLinked"
    }, t)
}
bc.ClientMessageIsLinked = DQe;

function $Qe(t) {
    return Object.assign({
        type: "GetSessionConfig"
    }, t)
}
bc.ClientMessageGetSessionConfig = $Qe;

function LQe(t) {
    return Object.assign({
        type: "SetSessionConfig"
    }, t)
}
bc.ClientMessageSetSessionConfig = LQe;

function BQe(t) {
    return Object.assign({
        type: "PublishEvent"
    }, t)
}
bc.ClientMessagePublishEvent = BQe;
var Tle = {};
(function(t) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    }), t.RxWebSocket = t.ConnectionState = void 0;
    const e = z9,
        n = rF;
    var r;
    (function(s) {
        s[s.DISCONNECTED = 0] = "DISCONNECTED", s[s.CONNECTING = 1] = "CONNECTING", s[s.CONNECTED = 2] = "CONNECTED"
    })(r = t.ConnectionState || (t.ConnectionState = {}));
    class i {
        constructor(o, a = WebSocket) {
            this.WebSocketClass = a, this.webSocket = null, this.connectionStateSubject = new e.BehaviorSubject(r.DISCONNECTED), this.incomingDataSubject = new e.Subject, this.url = o.replace(/^http/, "ws")
        }
        connect() {
            return this.webSocket ? (0, e.throwError)(new Error("webSocket object is not null")) : new e.Observable(o => {
                let a;
                try {
                    this.webSocket = a = new this.WebSocketClass(this.url)
                } catch (l) {
                    o.error(l);
                    return
                }
                this.connectionStateSubject.next(r.CONNECTING), a.onclose = l => {
                    this.clearWebSocket(), o.error(new Error(`websocket error ${l.code}: ${l.reason}`)), this.connectionStateSubject.next(r.DISCONNECTED)
                }, a.onopen = l => {
                    o.next(), o.complete(), this.connectionStateSubject.next(r.CONNECTED)
                }, a.onmessage = l => {
                    this.incomingDataSubject.next(l.data)
                }
            }).pipe((0, n.take)(1))
        }
        disconnect() {
            const {
                webSocket: o
            } = this;
            if (o) {
                this.clearWebSocket(), this.connectionStateSubject.next(r.DISCONNECTED);
                try {
                    o.close()
                } catch {}
            }
        }
        get connectionState$() {
            return this.connectionStateSubject.asObservable()
        }
        get incomingData$() {
            return this.incomingDataSubject.asObservable()
        }
        get incomingJSONData$() {
            return this.incomingData$.pipe((0, n.flatMap)(o => {
                let a;
                try {
                    a = JSON.parse(o)
                } catch {
                    return (0, e.empty)()
                }
                return (0, e.of)(a)
            }))
        }
        sendData(o) {
            const {
                webSocket: a
            } = this;
            if (!a) throw new Error("websocket is not connected");
            a.send(o)
        }
        clearWebSocket() {
            const {
                webSocket: o
            } = this;
            o && (this.webSocket = null, o.onclose = null, o.onerror = null, o.onmessage = null, o.onopen = null)
        }
    }
    t.RxWebSocket = i
})(Tle);
var a7 = {};
Object.defineProperty(a7, "__esModule", {
    value: !0
});
a7.isServerMessageFail = void 0;

function FQe(t) {
    return t && t.type === "Fail" && typeof t.id == "number" && typeof t.sessionId == "string" && typeof t.error == "string"
}
a7.isServerMessageFail = FQe;
Object.defineProperty(o7, "__esModule", {
    value: !0
});
o7.WalletSDKConnection = void 0;
const qc = z9,
    rr = rF,
    Y5 = L2,
    cw = HE,
    Z5 = bc,
    Q5 = D2,
    hS = Tle,
    _N = a7,
    FY = 1e4,
    UQe = 6e4;
class jQe {
    constructor(e, n, r, i, s = WebSocket) {
        this.sessionId = e, this.sessionKey = n, this.diagnostic = i, this.subscriptions = new qc.Subscription, this.destroyed = !1, this.lastHeartbeatResponse = 0, this.nextReqId = (0, cw.IntNumber)(1), this.connectedSubject = new qc.BehaviorSubject(!1), this.linkedSubject = new qc.BehaviorSubject(!1), this.sessionConfigSubject = new qc.ReplaySubject(1);
        const o = new hS.RxWebSocket(r + "/rpc", s);
        this.ws = o, this.subscriptions.add(o.connectionState$.pipe((0, rr.tap)(a => {
            var l;
            return (l = this.diagnostic) === null || l === void 0 ? void 0 : l.log(Q5.EVENTS.CONNECTED_STATE_CHANGE, {
                state: a,
                sessionIdHash: Y5.Session.hash(e)
            })
        }), (0, rr.skip)(1), (0, rr.filter)(a => a === hS.ConnectionState.DISCONNECTED && !this.destroyed), (0, rr.delay)(5e3), (0, rr.filter)(a => !this.destroyed), (0, rr.flatMap)(a => o.connect()), (0, rr.retry)()).subscribe()), this.subscriptions.add(o.connectionState$.pipe((0, rr.skip)(2), (0, rr.switchMap)(a => (0, qc.iif)(() => a === hS.ConnectionState.CONNECTED, this.authenticate().pipe((0, rr.tap)(l => this.sendIsLinked()), (0, rr.tap)(l => this.sendGetSessionConfig()), (0, rr.map)(l => !0)), (0, qc.of)(!1))), (0, rr.distinctUntilChanged)(), (0, rr.catchError)(a => (0, qc.of)(!1))).subscribe(a => this.connectedSubject.next(a))), this.subscriptions.add(o.connectionState$.pipe((0, rr.skip)(1), (0, rr.switchMap)(a => (0, qc.iif)(() => a === hS.ConnectionState.CONNECTED, (0, qc.timer)(0, FY)))).subscribe(a => a === 0 ? this.updateLastHeartbeat() : this.heartbeat())), this.subscriptions.add(o.incomingData$.pipe((0, rr.filter)(a => a === "h")).subscribe(a => this.updateLastHeartbeat())), this.subscriptions.add(o.incomingJSONData$.pipe((0, rr.filter)(a => ["IsLinkedOK", "Linked"].includes(a.type))).subscribe(a => {
            var l;
            const c = a;
            (l = this.diagnostic) === null || l === void 0 || l.log(Q5.EVENTS.LINKED, {
                sessionIdHash: Y5.Session.hash(e),
                linked: c.linked,
                type: a.type,
                onlineGuests: c.onlineGuests
            }), this.linkedSubject.next(c.linked || c.onlineGuests > 0)
        })), this.subscriptions.add(o.incomingJSONData$.pipe((0, rr.filter)(a => ["GetSessionConfigOK", "SessionConfigUpdated"].includes(a.type))).subscribe(a => {
            var l;
            const c = a;
            (l = this.diagnostic) === null || l === void 0 || l.log(Q5.EVENTS.SESSION_CONFIG_RECEIVED, {
                sessionIdHash: Y5.Session.hash(e),
                metadata_keys: c && c.metadata ? Object.keys(c.metadata) : void 0
            }), this.sessionConfigSubject.next({
                webhookId: c.webhookId,
                webhookUrl: c.webhookUrl,
                metadata: c.metadata
            })
        }))
    }
    connect() {
        var e;
        if (this.destroyed) throw new Error("instance is destroyed");
        (e = this.diagnostic) === null || e === void 0 || e.log(Q5.EVENTS.STARTED_CONNECTING, {
            sessionIdHash: Y5.Session.hash(this.sessionId)
        }), this.ws.connect().subscribe()
    }
    destroy() {
        var e;
        this.subscriptions.unsubscribe(), this.ws.disconnect(), (e = this.diagnostic) === null || e === void 0 || e.log(Q5.EVENTS.DISCONNECTED, {
            sessionIdHash: Y5.Session.hash(this.sessionId)
        }), this.destroyed = !0
    }
    get isDestroyed() {
        return this.destroyed
    }
    get connected$() {
        return this.connectedSubject.asObservable()
    }
    get onceConnected$() {
        return this.connected$.pipe((0, rr.filter)(e => e), (0, rr.take)(1), (0, rr.map)(() => {}))
    }
    get linked$() {
        return this.linkedSubject.asObservable()
    }
    get onceLinked$() {
        return this.linked$.pipe((0, rr.filter)(e => e), (0, rr.take)(1), (0, rr.map)(() => {}))
    }
    get sessionConfig$() {
        return this.sessionConfigSubject.asObservable()
    }
    get incomingEvent$() {
        return this.ws.incomingJSONData$.pipe((0, rr.filter)(e => {
            if (e.type !== "Event") return !1;
            const n = e;
            return typeof n.sessionId == "string" && typeof n.eventId == "string" && typeof n.event == "string" && typeof n.data == "string"
        }), (0, rr.map)(e => e))
    }
    setSessionMetadata(e, n) {
        const r = (0, Z5.ClientMessageSetSessionConfig)({
            id: (0, cw.IntNumber)(this.nextReqId++),
            sessionId: this.sessionId,
            metadata: {
                [e]: n
            }
        });
        return this.onceConnected$.pipe((0, rr.flatMap)(i => this.makeRequest(r)), (0, rr.map)(i => {
            if ((0, _N.isServerMessageFail)(i)) throw new Error(i.error || "failed to set session metadata")
        }))
    }
    publishEvent(e, n, r = !1) {
        const i = (0, Z5.ClientMessagePublishEvent)({
            id: (0, cw.IntNumber)(this.nextReqId++),
            sessionId: this.sessionId,
            event: e,
            data: n,
            callWebhook: r
        });
        return this.onceLinked$.pipe((0, rr.flatMap)(s => this.makeRequest(i)), (0, rr.map)(s => {
            if ((0, _N.isServerMessageFail)(s)) throw new Error(s.error || "failed to publish event");
            return s.eventId
        }))
    }
    sendData(e) {
        this.ws.sendData(JSON.stringify(e))
    }
    updateLastHeartbeat() {
        this.lastHeartbeatResponse = Date.now()
    }
    heartbeat() {
        if (Date.now() - this.lastHeartbeatResponse > FY * 2) {
            this.ws.disconnect();
            return
        }
        try {
            this.ws.sendData("h")
        } catch {}
    }
    makeRequest(e, n = UQe) {
        const r = e.id;
        try {
            this.sendData(e)
        } catch (i) {
            return (0, qc.throwError)(i)
        }
        return this.ws.incomingJSONData$.pipe((0, rr.timeoutWith)(n, (0, qc.throwError)(new Error(`request ${r} timed out`))), (0, rr.filter)(i => i.id === r), (0, rr.take)(1))
    }
    authenticate() {
        const e = (0, Z5.ClientMessageHostSession)({
            id: (0, cw.IntNumber)(this.nextReqId++),
            sessionId: this.sessionId,
            sessionKey: this.sessionKey
        });
        return this.makeRequest(e).pipe((0, rr.map)(n => {
            if ((0, _N.isServerMessageFail)(n)) throw new Error(n.error || "failed to authentcate")
        }))
    }
    sendIsLinked() {
        const e = (0, Z5.ClientMessageIsLinked)({
            id: (0, cw.IntNumber)(this.nextReqId++),
            sessionId: this.sessionId
        });
        this.sendData(e)
    }
    sendGetSessionConfig() {
        const e = (0, Z5.ClientMessageGetSessionConfig)({
            id: (0, cw.IntNumber)(this.nextReqId++),
            sessionId: this.sessionId
        });
        this.sendData(e)
    }
}
o7.WalletSDKConnection = jQe;
var h2 = {};
Object.defineProperty(h2, "__esModule", {
    value: !0
});
h2.decrypt = h2.encrypt = void 0;
const sA = Ut;
async function HQe(t, e) {
    if (e.length !== 64) throw Error("secret must be 256 bits");
    const n = crypto.getRandomValues(new Uint8Array(12)),
        r = await crypto.subtle.importKey("raw", (0, sA.hexStringToUint8Array)(e), {
            name: "aes-gcm"
        }, !1, ["encrypt", "decrypt"]),
        i = new TextEncoder,
        s = await window.crypto.subtle.encrypt({
            name: "AES-GCM",
            iv: n
        }, r, i.encode(t)),
        o = 16,
        a = s.slice(s.byteLength - o),
        l = s.slice(0, s.byteLength - o),
        c = new Uint8Array(a),
        u = new Uint8Array(l),
        f = new Uint8Array([...n, ...c, ...u]);
    return (0, sA.uint8ArrayToHex)(f)
}
h2.encrypt = HQe;

function zQe(t, e) {
    if (e.length !== 64) throw Error("secret must be 256 bits");
    return new Promise((n, r) => {
        (async function() {
            const i = await crypto.subtle.importKey("raw", (0, sA.hexStringToUint8Array)(e), {
                    name: "aes-gcm"
                }, !1, ["encrypt", "decrypt"]),
                s = (0, sA.hexStringToUint8Array)(t),
                o = s.slice(0, 12),
                a = s.slice(12, 28),
                l = s.slice(28),
                c = new Uint8Array([...l, ...a]),
                u = {
                    name: "AES-GCM",
                    iv: new Uint8Array(o)
                };
            try {
                const f = await window.crypto.subtle.decrypt(u, i, c),
                    h = new TextDecoder;
                n(h.decode(f))
            } catch (f) {
                r(f)
            }
        })()
    })
}
h2.decrypt = zQe;
var l7 = {},
    c7 = {};
(function(t) {
    Object.defineProperty(t, "__esModule", {
            value: !0
        }), t.RelayMessageType = void 0,
        function(e) {
            e.SESSION_ID_REQUEST = "SESSION_ID_REQUEST", e.SESSION_ID_RESPONSE = "SESSION_ID_RESPONSE", e.LINKED = "LINKED", e.UNLINKED = "UNLINKED", e.WEB3_REQUEST = "WEB3_REQUEST", e.WEB3_REQUEST_CANCELED = "WEB3_REQUEST_CANCELED", e.WEB3_RESPONSE = "WEB3_RESPONSE"
        }(t.RelayMessageType || (t.RelayMessageType = {}))
})(c7);
Object.defineProperty(l7, "__esModule", {
    value: !0
});
l7.Web3RequestCanceledMessage = void 0;
const WQe = c7;

function VQe(t) {
    return {
        type: WQe.RelayMessageType.WEB3_REQUEST_CANCELED,
        id: t
    }
}
l7.Web3RequestCanceledMessage = VQe;
var u7 = {};
Object.defineProperty(u7, "__esModule", {
    value: !0
});
u7.Web3RequestMessage = void 0;
const GQe = c7;

function qQe(t) {
    return Object.assign({
        type: GQe.RelayMessageType.WEB3_REQUEST
    }, t)
}
u7.Web3RequestMessage = qQe;
var p2 = {};
Object.defineProperty(p2, "__esModule", {
    value: !0
});
p2.isWeb3ResponseMessage = p2.Web3ResponseMessage = void 0;
const Ile = c7;

function KQe(t) {
    return Object.assign({
        type: Ile.RelayMessageType.WEB3_RESPONSE
    }, t)
}
p2.Web3ResponseMessage = KQe;

function YQe(t) {
    return t && t.type === Ile.RelayMessageType.WEB3_RESPONSE
}
p2.isWeb3ResponseMessage = YQe;
var ZQe = st && st.__createBinding || (Object.create ? function(t, e, n, r) {
        r === void 0 && (r = n), Object.defineProperty(t, r, {
            enumerable: !0,
            get: function() {
                return e[n]
            }
        })
    } : function(t, e, n, r) {
        r === void 0 && (r = n), t[r] = e[n]
    }),
    QQe = st && st.__setModuleDefault || (Object.create ? function(t, e) {
        Object.defineProperty(t, "default", {
            enumerable: !0,
            value: e
        })
    } : function(t, e) {
        t.default = e
    }),
    Rle = st && st.__decorate || function(t, e, n, r) {
        var i = arguments.length,
            s = i < 3 ? e : r === null ? r = Object.getOwnPropertyDescriptor(e, n) : r,
            o;
        if (typeof Reflect == "object" && typeof Reflect.decorate == "function") s = Reflect.decorate(t, e, n, r);
        else
            for (var a = t.length - 1; a >= 0; a--)(o = t[a]) && (s = (i < 3 ? o(s) : i > 3 ? o(e, n, s) : o(e, n)) || s);
        return i > 3 && s && Object.defineProperty(e, n, s), s
    },
    JQe = st && st.__importStar || function(t) {
        if (t && t.__esModule) return t;
        var e = {};
        if (t != null)
            for (var n in t) n !== "default" && Object.prototype.hasOwnProperty.call(t, n) && ZQe(e, t, n);
        return QQe(e, t), e
    },
    XQe = st && st.__importDefault || function(t) {
        return t && t.__esModule ? t : {
            default: t
        }
    };
Object.defineProperty(n7, "__esModule", {
    value: !0
});
n7.WalletSDKRelay = void 0;
const Ole = XQe(r7),
    Ug = z9,
    As = rF,
    bo = D2,
    eJe = o7,
    uw = DE,
    tJe = HE,
    di = Ut,
    d0 = JQe(h2),
    h0 = L2,
    pS = _u,
    to = h9,
    nJe = l7,
    rJe = u7,
    Xl = Kr,
    Ta = p2;
class mu extends pS.WalletSDKRelayAbstract {
    constructor(e) {
        var n;
        super(), this.accountsCallback = null, this.chainCallback = null, this.dappDefaultChainSubject = new Ug.BehaviorSubject(1), this.dappDefaultChain = 1, this.appName = "", this.appLogoUrl = null, this.subscriptions = new Ug.Subscription, this.linkAPIUrl = e.linkAPIUrl, this.storage = e.storage, this.options = e;
        const {
            session: r,
            ui: i,
            connection: s
        } = this.subscribe();
        if (this._session = r, this.connection = s, this.relayEventManager = e.relayEventManager, e.diagnosticLogger && e.eventListener) throw new Error("Can't have both eventListener and diagnosticLogger options, use only diagnosticLogger");
        e.eventListener ? this.diagnostic = {
            log: e.eventListener.onEvent
        } : this.diagnostic = e.diagnosticLogger, this._reloadOnDisconnect = (n = e.reloadOnDisconnect) !== null && n !== void 0 ? n : !0, this.ui = i
    }
    subscribe() {
        this.subscriptions.add(this.dappDefaultChainSubject.subscribe(i => {
            this.dappDefaultChain !== i && (this.dappDefaultChain = i)
        }));
        const e = h0.Session.load(this.storage) || new h0.Session(this.storage).save(),
            n = new eJe.WalletSDKConnection(e.id, e.key, this.linkAPIUrl, this.diagnostic);
        this.subscriptions.add(n.sessionConfig$.subscribe({
            next: i => {
                this.onSessionConfigChanged(i)
            },
            error: () => {
                var i;
                (i = this.diagnostic) === null || i === void 0 || i.log(bo.EVENTS.GENERAL_ERROR, {
                    message: "error while invoking session config callback"
                })
            }
        })), this.subscriptions.add(n.incomingEvent$.pipe((0, As.filter)(i => i.event === "Web3Response")).subscribe({
            next: this.handleIncomingEvent
        })), this.subscriptions.add(n.linked$.pipe((0, As.skip)(1), (0, As.tap)(i => {
            var s;
            this.isLinked = i;
            const o = this.storage.getItem(pS.LOCAL_STORAGE_ADDRESSES_KEY);
            if (i && (this.session.linked = i), this.isUnlinkedErrorState = !1, o) {
                const a = o.split(" "),
                    l = this.storage.getItem("IsStandaloneSigning") === "true";
                if (a[0] !== "" && !i && this.session.linked && !l) {
                    this.isUnlinkedErrorState = !0;
                    const c = this.getSessionIdHash();
                    (s = this.diagnostic) === null || s === void 0 || s.log(bo.EVENTS.UNLINKED_ERROR_STATE, {
                        sessionIdHash: c
                    })
                }
            }
        })).subscribe()), this.subscriptions.add(n.sessionConfig$.pipe((0, As.filter)(i => !!i.metadata && i.metadata.__destroyed === "1")).subscribe(() => {
            var i;
            const s = n.isDestroyed;
            return (i = this.diagnostic) === null || i === void 0 || i.log(bo.EVENTS.METADATA_DESTROYED, {
                alreadyDestroyed: s,
                sessionIdHash: this.getSessionIdHash()
            }), this.resetAndReload()
        })), this.subscriptions.add(n.sessionConfig$.pipe((0, As.filter)(i => i.metadata && i.metadata.WalletUsername !== void 0)).pipe((0, As.mergeMap)(i => d0.decrypt(i.metadata.WalletUsername, e.secret))).subscribe({
            next: i => {
                this.storage.setItem(pS.WALLET_USER_NAME_KEY, i)
            },
            error: () => {
                var i;
                (i = this.diagnostic) === null || i === void 0 || i.log(bo.EVENTS.GENERAL_ERROR, {
                    message: "Had error decrypting",
                    value: "username"
                })
            }
        })), this.subscriptions.add(n.sessionConfig$.pipe((0, As.filter)(i => i.metadata && i.metadata.AppVersion !== void 0)).pipe((0, As.mergeMap)(i => d0.decrypt(i.metadata.AppVersion, e.secret))).subscribe({
            next: i => {
                this.storage.setItem(pS.APP_VERSION_KEY, i)
            },
            error: () => {
                var i;
                (i = this.diagnostic) === null || i === void 0 || i.log(bo.EVENTS.GENERAL_ERROR, {
                    message: "Had error decrypting",
                    value: "appversion"
                })
            }
        })), this.subscriptions.add(n.sessionConfig$.pipe((0, As.filter)(i => i.metadata && i.metadata.ChainId !== void 0 && i.metadata.JsonRpcUrl !== void 0)).pipe((0, As.mergeMap)(i => (0, Ug.zip)(d0.decrypt(i.metadata.ChainId, e.secret), d0.decrypt(i.metadata.JsonRpcUrl, e.secret)))).pipe((0, As.distinctUntilChanged)()).subscribe({
            next: ([i, s]) => {
                this.chainCallback && this.chainCallback(i, s)
            },
            error: () => {
                var i;
                (i = this.diagnostic) === null || i === void 0 || i.log(bo.EVENTS.GENERAL_ERROR, {
                    message: "Had error decrypting",
                    value: "chainId|jsonRpcUrl"
                })
            }
        })), this.subscriptions.add(n.sessionConfig$.pipe((0, As.filter)(i => i.metadata && i.metadata.EthereumAddress !== void 0)).pipe((0, As.mergeMap)(i => d0.decrypt(i.metadata.EthereumAddress, e.secret))).subscribe({
            next: i => {
                this.accountsCallback && this.accountsCallback([i]), mu.accountRequestCallbackIds.size > 0 && (Array.from(mu.accountRequestCallbackIds.values()).forEach(s => {
                    const o = (0, Ta.Web3ResponseMessage)({
                        id: s,
                        response: (0, Xl.RequestEthereumAccountsResponse)([i])
                    });
                    this.invokeCallback(Object.assign(Object.assign({}, o), {
                        id: s
                    }))
                }), mu.accountRequestCallbackIds.clear())
            },
            error: () => {
                var i;
                (i = this.diagnostic) === null || i === void 0 || i.log(bo.EVENTS.GENERAL_ERROR, {
                    message: "Had error decrypting",
                    value: "selectedAddress"
                })
            }
        })), this.subscriptions.add(n.sessionConfig$.pipe((0, As.filter)(i => i.metadata && i.metadata.AppSrc !== void 0)).pipe((0, As.mergeMap)(i => d0.decrypt(i.metadata.AppSrc, e.secret))).subscribe({
            next: i => {
                this.ui.setAppSrc(i)
            },
            error: () => {
                var i;
                (i = this.diagnostic) === null || i === void 0 || i.log(bo.EVENTS.GENERAL_ERROR, {
                    message: "Had error decrypting",
                    value: "appSrc"
                })
            }
        }));
        const r = this.options.uiConstructor({
            linkAPIUrl: this.options.linkAPIUrl,
            version: this.options.version,
            darkMode: this.options.darkMode,
            session: e,
            connected$: n.connected$,
            chainId$: this.dappDefaultChainSubject
        });
        return n.connect(), {
            session: e,
            ui: r,
            connection: n
        }
    }
    attachUI() {
        this.ui.attach()
    }
    resetAndReload() {
        this.connection.setSessionMetadata("__destroyed", "1").pipe((0, As.timeout)(1e3), (0, As.catchError)(e => (0, Ug.of)(null))).subscribe(e => {
            var n, r, i;
            const s = this.ui.isStandalone();
            try {
                this.subscriptions.unsubscribe()
            } catch {
                (n = this.diagnostic) === null || n === void 0 || n.log(bo.EVENTS.GENERAL_ERROR, {
                    message: "Had error unsubscribing"
                })
            }(r = this.diagnostic) === null || r === void 0 || r.log(bo.EVENTS.SESSION_STATE_CHANGE, {
                method: "relay::resetAndReload",
                sessionMetadataChange: "__destroyed, 1",
                sessionIdHash: this.getSessionIdHash()
            }), this.connection.destroy();
            const o = h0.Session.load(this.storage);
            if ((o == null ? void 0 : o.id) === this._session.id ? this.storage.clear() : o && ((i = this.diagnostic) === null || i === void 0 || i.log(bo.EVENTS.SKIPPED_CLEARING_SESSION, {
                    sessionIdHash: this.getSessionIdHash(),
                    storedSessionIdHash: h0.Session.hash(o.id)
                })), this._reloadOnDisconnect) {
                this.ui.reloadUI();
                return
            }
            this.accountsCallback && this.accountsCallback([], !0), this.subscriptions = new Ug.Subscription;
            const {
                session: a,
                ui: l,
                connection: c
            } = this.subscribe();
            this._session = a, this.connection = c, this.ui = l, s && this.ui.setStandalone && this.ui.setStandalone(!0), this.attachUI()
        }, e => {
            var n;
            (n = this.diagnostic) === null || n === void 0 || n.log(bo.EVENTS.FAILURE, {
                method: "relay::resetAndReload",
                message: `failed to reset and reload with ${e}`,
                sessionIdHash: this.getSessionIdHash()
            })
        })
    }
    setAppInfo(e, n) {
        this.appName = e, this.appLogoUrl = n
    }
    getStorageItem(e) {
        return this.storage.getItem(e)
    }
    get session() {
        return this._session
    }
    setStorageItem(e, n) {
        this.storage.setItem(e, n)
    }
    signEthereumMessage(e, n, r, i) {
        return this.sendRequest({
            method: to.Web3Method.signEthereumMessage,
            params: {
                message: (0, di.hexStringFromBuffer)(e, !0),
                address: n,
                addPrefix: r,
                typedDataJson: i || null
            }
        })
    }
    ethereumAddressFromSignedMessage(e, n, r) {
        return this.sendRequest({
            method: to.Web3Method.ethereumAddressFromSignedMessage,
            params: {
                message: (0, di.hexStringFromBuffer)(e, !0),
                signature: (0, di.hexStringFromBuffer)(n, !0),
                addPrefix: r
            }
        })
    }
    signEthereumTransaction(e) {
        return this.sendRequest({
            method: to.Web3Method.signEthereumTransaction,
            params: {
                fromAddress: e.fromAddress,
                toAddress: e.toAddress,
                weiValue: (0, di.bigIntStringFromBN)(e.weiValue),
                data: (0, di.hexStringFromBuffer)(e.data, !0),
                nonce: e.nonce,
                gasPriceInWei: e.gasPriceInWei ? (0, di.bigIntStringFromBN)(e.gasPriceInWei) : null,
                maxFeePerGas: e.gasPriceInWei ? (0, di.bigIntStringFromBN)(e.gasPriceInWei) : null,
                maxPriorityFeePerGas: e.gasPriceInWei ? (0, di.bigIntStringFromBN)(e.gasPriceInWei) : null,
                gasLimit: e.gasLimit ? (0, di.bigIntStringFromBN)(e.gasLimit) : null,
                chainId: e.chainId,
                shouldSubmit: !1
            }
        })
    }
    signAndSubmitEthereumTransaction(e) {
        return this.sendRequest({
            method: to.Web3Method.signEthereumTransaction,
            params: {
                fromAddress: e.fromAddress,
                toAddress: e.toAddress,
                weiValue: (0, di.bigIntStringFromBN)(e.weiValue),
                data: (0, di.hexStringFromBuffer)(e.data, !0),
                nonce: e.nonce,
                gasPriceInWei: e.gasPriceInWei ? (0, di.bigIntStringFromBN)(e.gasPriceInWei) : null,
                maxFeePerGas: e.maxFeePerGas ? (0, di.bigIntStringFromBN)(e.maxFeePerGas) : null,
                maxPriorityFeePerGas: e.maxPriorityFeePerGas ? (0, di.bigIntStringFromBN)(e.maxPriorityFeePerGas) : null,
                gasLimit: e.gasLimit ? (0, di.bigIntStringFromBN)(e.gasLimit) : null,
                chainId: e.chainId,
                shouldSubmit: !0
            }
        })
    }
    submitEthereumTransaction(e, n) {
        return this.sendRequest({
            method: to.Web3Method.submitEthereumTransaction,
            params: {
                signedTransaction: (0, di.hexStringFromBuffer)(e, !0),
                chainId: n
            }
        })
    }
    scanQRCode(e) {
        return this.sendRequest({
            method: to.Web3Method.scanQRCode,
            params: {
                regExp: e
            }
        })
    }
    getQRCodeUrl() {
        return (0, di.createQrUrl)(this._session.id, this._session.secret, this.linkAPIUrl, !1, this.options.version, this.dappDefaultChain)
    }
    genericRequest(e, n) {
        return this.sendRequest({
            method: to.Web3Method.generic,
            params: {
                action: n,
                data: e
            }
        })
    }
    sendGenericMessage(e) {
        return this.sendRequest(e)
    }
    sendRequest(e) {
        let n = null;
        const r = (0, di.randomBytesHex)(8),
            i = o => {
                this.publishWeb3RequestCanceledEvent(r), this.handleErrorResponse(r, e.method, o), n == null || n()
            };
        return {
            promise: new Promise((o, a) => {
                this.ui.isStandalone() || (n = this.ui.showConnecting({
                    isUnlinkedErrorState: this.isUnlinkedErrorState,
                    onCancel: i,
                    onResetConnection: this.resetAndReload
                })), this.relayEventManager.callbacks.set(r, l => {
                    if (n == null || n(), l.errorMessage) return a(new Error(l.errorMessage));
                    o(l)
                }), this.ui.isStandalone() ? this.sendRequestStandalone(r, e) : this.publishWeb3RequestEvent(r, e)
            }),
            cancel: i
        }
    }
    setConnectDisabled(e) {
        this.ui.setConnectDisabled(e)
    }
    setAccountsCallback(e) {
        this.accountsCallback = e
    }
    setChainCallback(e) {
        this.chainCallback = e
    }
    setDappDefaultChainCallback(e) {
        this.dappDefaultChainSubject.next(e)
    }
    publishWeb3RequestEvent(e, n) {
        var r;
        const i = (0, rJe.Web3RequestMessage)({
                id: e,
                request: n
            }),
            s = h0.Session.load(this.storage);
        (r = this.diagnostic) === null || r === void 0 || r.log(bo.EVENTS.WEB3_REQUEST, {
            eventId: i.id,
            method: `relay::${i.request.method}`,
            sessionIdHash: this.getSessionIdHash(),
            storedSessionIdHash: s ? h0.Session.hash(s.id) : "",
            isSessionMismatched: ((s == null ? void 0 : s.id) !== this._session.id).toString()
        }), this.subscriptions.add(this.publishEvent("Web3Request", i, !0).subscribe({
            next: o => {
                var a;
                (a = this.diagnostic) === null || a === void 0 || a.log(bo.EVENTS.WEB3_REQUEST_PUBLISHED, {
                    eventId: i.id,
                    method: `relay::${i.request.method}`,
                    sessionIdHash: this.getSessionIdHash(),
                    storedSessionIdHash: s ? h0.Session.hash(s.id) : "",
                    isSessionMismatched: ((s == null ? void 0 : s.id) !== this._session.id).toString()
                })
            },
            error: o => {
                this.handleWeb3ResponseMessage((0, Ta.Web3ResponseMessage)({
                    id: i.id,
                    response: {
                        method: i.request.method,
                        errorMessage: o.message
                    }
                }))
            }
        }))
    }
    publishWeb3RequestCanceledEvent(e) {
        const n = (0, nJe.Web3RequestCanceledMessage)(e);
        this.subscriptions.add(this.publishEvent("Web3RequestCanceled", n, !1).subscribe())
    }
    publishEvent(e, n, r) {
        const i = this.session.secret;
        return new Ug.Observable(s => {
            d0.encrypt(JSON.stringify(Object.assign(Object.assign({}, n), {
                origin: location.origin
            })), i).then(o => {
                s.next(o), s.complete()
            })
        }).pipe((0, As.mergeMap)(s => this.connection.publishEvent(e, s, r)))
    }
    handleIncomingEvent(e) {
        try {
            this.subscriptions.add((0, Ug.from)(d0.decrypt(e.data, this.session.secret)).pipe((0, As.map)(n => JSON.parse(n))).subscribe({
                next: n => {
                    const r = (0, Ta.isWeb3ResponseMessage)(n) ? n : null;
                    r && this.handleWeb3ResponseMessage(r)
                },
                error: () => {
                    var n;
                    (n = this.diagnostic) === null || n === void 0 || n.log(bo.EVENTS.GENERAL_ERROR, {
                        message: "Had error decrypting",
                        value: "incomingEvent"
                    })
                }
            }))
        } catch {
            return
        }
    }
    handleWeb3ResponseMessage(e) {
        var n;
        const {
            response: r
        } = e;
        if ((n = this.diagnostic) === null || n === void 0 || n.log(bo.EVENTS.WEB3_RESPONSE, {
                eventId: e.id,
                method: `relay::${r.method}`,
                sessionIdHash: this.getSessionIdHash()
            }), (0, Xl.isRequestEthereumAccountsResponse)(r)) {
            mu.accountRequestCallbackIds.forEach(i => this.invokeCallback(Object.assign(Object.assign({}, e), {
                id: i
            }))), mu.accountRequestCallbackIds.clear();
            return
        }
        this.invokeCallback(e)
    }
    handleErrorResponse(e, n, r, i) {
        var s;
        const o = (s = r == null ? void 0 : r.message) !== null && s !== void 0 ? s : (0, uw.standardErrorMessage)(i);
        this.handleWeb3ResponseMessage((0, Ta.Web3ResponseMessage)({
            id: e,
            response: {
                method: n,
                errorMessage: o,
                errorCode: i
            }
        }))
    }
    invokeCallback(e) {
        const n = this.relayEventManager.callbacks.get(e.id);
        n && (n(e.response), this.relayEventManager.callbacks.delete(e.id))
    }
    requestEthereumAccounts() {
        const e = {
                method: to.Web3Method.requestEthereumAccounts,
                params: {
                    appName: this.appName,
                    appLogoUrl: this.appLogoUrl || null
                }
            },
            n = (0, di.randomBytesHex)(8),
            r = s => {
                this.publishWeb3RequestCanceledEvent(n), this.handleErrorResponse(n, e.method, s)
            };
        return {
            promise: new Promise((s, o) => {
                var a;
                this.relayEventManager.callbacks.set(n, c => {
                    if (this.ui.hideRequestEthereumAccounts(), c.errorMessage) return o(new Error(c.errorMessage));
                    s(c)
                });
                const l = ((a = window == null ? void 0 : window.navigator) === null || a === void 0 ? void 0 : a.userAgent) || null;
                if (l && /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(l)) {
                    let c;
                    try {
                        (0, di.isInIFrame)() && window.top ? c = window.top.location : c = window.location
                    } catch {
                        c = window.location
                    }
                    c.href = `https://www.coinbase.com/connect-dapp?uri=${encodeURIComponent(c.href)}`;
                    return
                }
                if (this.ui.inlineAccountsResponse()) {
                    const c = u => {
                        this.handleWeb3ResponseMessage((0, Ta.Web3ResponseMessage)({
                            id: n,
                            response: (0, Xl.RequestEthereumAccountsResponse)(u)
                        }))
                    };
                    this.ui.requestEthereumAccounts({
                        onCancel: r,
                        onAccounts: c
                    })
                } else {
                    const c = uw.standardErrors.provider.userRejectedRequest("User denied account authorization");
                    this.ui.requestEthereumAccounts({
                        onCancel: () => r(c)
                    })
                }
                mu.accountRequestCallbackIds.add(n), !this.ui.inlineAccountsResponse() && !this.ui.isStandalone() && this.publishWeb3RequestEvent(n, e)
            }),
            cancel: r
        }
    }
    selectProvider(e) {
        const n = {
                method: to.Web3Method.selectProvider,
                params: {
                    providerOptions: e
                }
            },
            r = (0, di.randomBytesHex)(8),
            i = o => {
                this.publishWeb3RequestCanceledEvent(r), this.handleErrorResponse(r, n.method, o)
            },
            s = new Promise((o, a) => {
                this.relayEventManager.callbacks.set(r, u => {
                    if (u.errorMessage) return a(new Error(u.errorMessage));
                    o(u)
                });
                const l = u => {
                        this.handleWeb3ResponseMessage((0, Ta.Web3ResponseMessage)({
                            id: r,
                            response: (0, Xl.SelectProviderResponse)(tJe.ProviderType.Unselected)
                        }))
                    },
                    c = u => {
                        this.handleWeb3ResponseMessage((0, Ta.Web3ResponseMessage)({
                            id: r,
                            response: (0, Xl.SelectProviderResponse)(u)
                        }))
                    };
                this.ui.selectProvider && this.ui.selectProvider({
                    onApprove: c,
                    onCancel: l,
                    providerOptions: e
                })
            });
        return {
            cancel: i,
            promise: s
        }
    }
    watchAsset(e, n, r, i, s, o) {
        const a = {
            method: to.Web3Method.watchAsset,
            params: {
                type: e,
                options: {
                    address: n,
                    symbol: r,
                    decimals: i,
                    image: s
                },
                chainId: o
            }
        };
        let l = null;
        const c = (0, di.randomBytesHex)(8),
            u = h => {
                this.publishWeb3RequestCanceledEvent(c), this.handleErrorResponse(c, a.method, h), l == null || l()
            };
        this.ui.inlineWatchAsset() || (l = this.ui.showConnecting({
            isUnlinkedErrorState: this.isUnlinkedErrorState,
            onCancel: u,
            onResetConnection: this.resetAndReload
        }));
        const f = new Promise((h, g) => {
            this.relayEventManager.callbacks.set(c, C => {
                if (l == null || l(), C.errorMessage) return g(new Error(C.errorMessage));
                h(C)
            });
            const y = C => {
                    this.handleWeb3ResponseMessage((0, Ta.Web3ResponseMessage)({
                        id: c,
                        response: (0, Xl.WatchAssetReponse)(!1)
                    }))
                },
                _ = () => {
                    this.handleWeb3ResponseMessage((0, Ta.Web3ResponseMessage)({
                        id: c,
                        response: (0, Xl.WatchAssetReponse)(!0)
                    }))
                };
            this.ui.inlineWatchAsset() && this.ui.watchAsset({
                onApprove: _,
                onCancel: y,
                type: e,
                address: n,
                symbol: r,
                decimals: i,
                image: s,
                chainId: o
            }), !this.ui.inlineWatchAsset() && !this.ui.isStandalone() && this.publishWeb3RequestEvent(c, a)
        });
        return {
            cancel: u,
            promise: f
        }
    }
    addEthereumChain(e, n, r, i, s, o) {
        const a = {
            method: to.Web3Method.addEthereumChain,
            params: {
                chainId: e,
                rpcUrls: n,
                blockExplorerUrls: i,
                chainName: s,
                iconUrls: r,
                nativeCurrency: o
            }
        };
        let l = null;
        const c = (0, di.randomBytesHex)(8),
            u = h => {
                this.publishWeb3RequestCanceledEvent(c), this.handleErrorResponse(c, a.method, h), l == null || l()
            };
        return this.ui.inlineAddEthereumChain(e) || (l = this.ui.showConnecting({
            isUnlinkedErrorState: this.isUnlinkedErrorState,
            onCancel: u,
            onResetConnection: this.resetAndReload
        })), {
            promise: new Promise((h, g) => {
                this.relayEventManager.callbacks.set(c, C => {
                    if (l == null || l(), C.errorMessage) return g(new Error(C.errorMessage));
                    h(C)
                });
                const y = C => {
                        this.handleWeb3ResponseMessage((0, Ta.Web3ResponseMessage)({
                            id: c,
                            response: (0, Xl.AddEthereumChainResponse)({
                                isApproved: !1,
                                rpcUrl: ""
                            })
                        }))
                    },
                    _ = C => {
                        this.handleWeb3ResponseMessage((0, Ta.Web3ResponseMessage)({
                            id: c,
                            response: (0, Xl.AddEthereumChainResponse)({
                                isApproved: !0,
                                rpcUrl: C
                            })
                        }))
                    };
                this.ui.inlineAddEthereumChain(e) && this.ui.addEthereumChain({
                    onCancel: y,
                    onApprove: _,
                    chainId: a.params.chainId,
                    rpcUrls: a.params.rpcUrls,
                    blockExplorerUrls: a.params.blockExplorerUrls,
                    chainName: a.params.chainName,
                    iconUrls: a.params.iconUrls,
                    nativeCurrency: a.params.nativeCurrency
                }), !this.ui.inlineAddEthereumChain(e) && !this.ui.isStandalone() && this.publishWeb3RequestEvent(c, a)
            }),
            cancel: u
        }
    }
    switchEthereumChain(e, n) {
        const r = {
                method: to.Web3Method.switchEthereumChain,
                params: Object.assign({
                    chainId: e
                }, {
                    address: n
                })
            },
            i = (0, di.randomBytesHex)(8),
            s = a => {
                this.publishWeb3RequestCanceledEvent(i), this.handleErrorResponse(i, r.method, a)
            };
        return {
            promise: new Promise((a, l) => {
                this.relayEventManager.callbacks.set(i, f => {
                    if ((0, Xl.isErrorResponse)(f) && f.errorCode) return l(uw.standardErrors.provider.custom({
                        code: f.errorCode,
                        message: "Unrecognized chain ID. Try adding the chain using addEthereumChain first."
                    }));
                    if (f.errorMessage) return l(new Error(f.errorMessage));
                    a(f)
                });
                const c = f => {
                        var h;
                        if (f) {
                            const g = (h = (0, uw.getErrorCode)(f)) !== null && h !== void 0 ? h : uw.standardErrorCodes.provider.unsupportedChain;
                            this.handleErrorResponse(i, to.Web3Method.switchEthereumChain, f instanceof Error ? f : uw.standardErrors.provider.unsupportedChain(e), g)
                        } else this.handleWeb3ResponseMessage((0, Ta.Web3ResponseMessage)({
                            id: i,
                            response: (0, Xl.SwitchEthereumChainResponse)({
                                isApproved: !1,
                                rpcUrl: ""
                            })
                        }))
                    },
                    u = f => {
                        this.handleWeb3ResponseMessage((0, Ta.Web3ResponseMessage)({
                            id: i,
                            response: (0, Xl.SwitchEthereumChainResponse)({
                                isApproved: !0,
                                rpcUrl: f
                            })
                        }))
                    };
                this.ui.switchEthereumChain({
                    onCancel: c,
                    onApprove: u,
                    chainId: r.params.chainId,
                    address: r.params.address
                }), !this.ui.inlineSwitchEthereumChain() && !this.ui.isStandalone() && this.publishWeb3RequestEvent(i, r)
            }),
            cancel: s
        }
    }
    inlineAddEthereumChain(e) {
        return this.ui.inlineAddEthereumChain(e)
    }
    getSessionIdHash() {
        return h0.Session.hash(this._session.id)
    }
    sendRequestStandalone(e, n) {
        const r = s => {
                this.handleErrorResponse(e, n.method, s)
            },
            i = s => {
                this.handleWeb3ResponseMessage((0, Ta.Web3ResponseMessage)({
                    id: e,
                    response: s
                }))
            };
        switch (n.method) {
            case to.Web3Method.signEthereumMessage:
                this.ui.signEthereumMessage({
                    request: n,
                    onSuccess: i,
                    onCancel: r
                });
                break;
            case to.Web3Method.signEthereumTransaction:
                this.ui.signEthereumTransaction({
                    request: n,
                    onSuccess: i,
                    onCancel: r
                });
                break;
            case to.Web3Method.submitEthereumTransaction:
                this.ui.submitEthereumTransaction({
                    request: n,
                    onSuccess: i,
                    onCancel: r
                });
                break;
            case to.Web3Method.ethereumAddressFromSignedMessage:
                this.ui.ethereumAddressFromSignedMessage({
                    request: n,
                    onSuccess: i
                });
                break;
            default:
                r();
                break
        }
    }
    onSessionConfigChanged(e) {}
}
mu.accountRequestCallbackIds = new Set;
Rle([Ole.default], mu.prototype, "resetAndReload", null);
Rle([Ole.default], mu.prototype, "handleIncomingEvent", null);
n7.WalletSDKRelay = mu;
var f7 = {};
Object.defineProperty(f7, "__esModule", {
    value: !0
});
f7.WalletSDKRelayEventManager = void 0;
const iJe = Ut;
class sJe {
    constructor() {
        this._nextRequestId = 0, this.callbacks = new Map
    }
    makeRequestId() {
        this._nextRequestId = (this._nextRequestId + 1) % 2147483647;
        const e = this._nextRequestId,
            n = (0, iJe.prepend0x)(e.toString(16));
        return this.callbacks.get(n) && this.callbacks.delete(n), e
    }
}
f7.WalletSDKRelayEventManager = sJe;
Object.defineProperty(s6, "__esModule", {
    value: !0
});
s6.CoinbaseWalletSDK = void 0;
const oJe = c9,
    aJe = u9,
    lJe = f9,
    cJe = Jb,
    uJe = F9,
    fJe = n7,
    dJe = f7,
    hJe = Ut,
    Nle = $2;
class d7 {
    constructor(e) {
        var n, r, i;
        this._appName = "", this._appLogoUrl = null, this._relay = null, this._relayEventManager = null;
        const s = e.linkAPIUrl || aJe.LINK_API_URL;
        let o;
        if (e.uiConstructor ? o = e.uiConstructor : o = c => new uJe.WalletSDKUI(c), typeof e.overrideIsMetaMask > "u" ? this._overrideIsMetaMask = !1 : this._overrideIsMetaMask = e.overrideIsMetaMask, this._overrideIsCoinbaseWallet = (n = e.overrideIsCoinbaseWallet) !== null && n !== void 0 ? n : !0, this._overrideIsCoinbaseBrowser = (r = e.overrideIsCoinbaseBrowser) !== null && r !== void 0 ? r : !1, e.diagnosticLogger && e.eventListener) throw new Error("Can't have both eventListener and diagnosticLogger options, use only diagnosticLogger");
        e.eventListener ? this._diagnosticLogger = {
            log: e.eventListener.onEvent
        } : this._diagnosticLogger = e.diagnosticLogger, this._reloadOnDisconnect = (i = e.reloadOnDisconnect) !== null && i !== void 0 ? i : !0;
        const a = new URL(s),
            l = `${a.protocol}//${a.host}`;
        this._storage = new lJe.ScopedLocalStorage(`-walletlink:${l}`), this._storage.setItem("version", d7.VERSION), !(this.walletExtension || this.coinbaseBrowser) && (this._relayEventManager = new dJe.WalletSDKRelayEventManager, this._relay = new fJe.WalletSDKRelay({
            linkAPIUrl: s,
            version: Nle.LIB_VERSION,
            darkMode: !!e.darkMode,
            uiConstructor: o,
            storage: this._storage,
            relayEventManager: this._relayEventManager,
            diagnosticLogger: this._diagnosticLogger,
            reloadOnDisconnect: this._reloadOnDisconnect
        }), this.setAppInfo(e.appName, e.appLogoUrl), !e.headlessMode && this._relay.attachUI())
    }
    makeWeb3Provider(e = "", n = 1) {
        const r = this.walletExtension;
        if (r) return this.isCipherProvider(r) || r.setProviderInfo(e, n), this._reloadOnDisconnect === !1 && typeof r.disableReloadOnDisconnect == "function" && r.disableReloadOnDisconnect(), r;
        const i = this.coinbaseBrowser;
        if (i) return i;
        const s = this._relay;
        if (!s || !this._relayEventManager || !this._storage) throw new Error("Relay not initialized, should never happen");
        return e || s.setConnectDisabled(!0), new cJe.CoinbaseWalletProvider({
            relayProvider: () => Promise.resolve(s),
            relayEventManager: this._relayEventManager,
            storage: this._storage,
            jsonRpcUrl: e,
            chainId: n,
            qrUrl: this.getQrUrl(),
            diagnosticLogger: this._diagnosticLogger,
            overrideIsMetaMask: this._overrideIsMetaMask,
            overrideIsCoinbaseWallet: this._overrideIsCoinbaseWallet,
            overrideIsCoinbaseBrowser: this._overrideIsCoinbaseBrowser
        })
    }
    setAppInfo(e, n) {
        var r;
        this._appName = e || "DApp", this._appLogoUrl = n || (0, hJe.getFavicon)();
        const i = this.walletExtension;
        i ? this.isCipherProvider(i) || i.setAppInfo(this._appName, this._appLogoUrl) : (r = this._relay) === null || r === void 0 || r.setAppInfo(this._appName, this._appLogoUrl)
    }
    disconnect() {
        var e;
        const n = this.walletExtension;
        n ? n.close() : (e = this._relay) === null || e === void 0 || e.resetAndReload()
    }
    getQrUrl() {
        var e, n;
        return (n = (e = this._relay) === null || e === void 0 ? void 0 : e.getQRCodeUrl()) !== null && n !== void 0 ? n : null
    }
    getCoinbaseWalletLogo(e, n = 240) {
        return (0, oJe.walletLogo)(e, n)
    }
    get walletExtension() {
        var e;
        return (e = window.coinbaseWalletExtension) !== null && e !== void 0 ? e : window.walletLinkExtension
    }
    get coinbaseBrowser() {
        var e, n;
        try {
            const r = (e = window.ethereum) !== null && e !== void 0 ? e : (n = window.top) === null || n === void 0 ? void 0 : n.ethereum;
            return r && "isCoinbaseBrowser" in r && r.isCoinbaseBrowser ? r : void 0
        } catch {
            return
        }
    }
    isCipherProvider(e) {
        return typeof e.isCipher == "boolean" && e.isCipher
    }
}
s6.CoinbaseWalletSDK = d7;
d7.VERSION = Nle.LIB_VERSION;
(function(t) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    }), t.CoinbaseWalletProvider = t.CoinbaseWalletSDK = void 0;
    const e = s6,
        n = Jb;
    var r = s6;
    Object.defineProperty(t, "CoinbaseWalletSDK", {
        enumerable: !0,
        get: function() {
            return r.CoinbaseWalletSDK
        }
    });
    var i = Jb;
    Object.defineProperty(t, "CoinbaseWalletProvider", {
        enumerable: !0,
        get: function() {
            return i.CoinbaseWalletProvider
        }
    }), t.default = e.CoinbaseWalletSDK, typeof window < "u" && (window.CoinbaseWalletSDK = e.CoinbaseWalletSDK, window.CoinbaseWalletProvider = n.CoinbaseWalletProvider, window.WalletLink = e.CoinbaseWalletSDK, window.WalletLinkProvider = n.CoinbaseWalletProvider)
})(zie);

function pJe(t) {
    const {
        enableEIP6963: e = !0,
        enableInjected: n = !0,
        enableCoinbase: r = !0,
        enableEmail: i = !1,
        metadata: s,
        rpcUrl: o,
        defaultChainId: a
    } = t;
    let l, c;
    const u = {
        metadata: s
    };

    function f() {
        if (l) return l;
        if (!(typeof window > "u") && window.ethereum) return l = window.ethereum, l
    }

    function h() {
        return c || (typeof window > "u" ? void 0 : (c = new zie.CoinbaseWalletSDK({
            appName: s.name,
            appLogoUrl: s.icons[0],
            darkMode: !1
        }).makeWeb3Provider(o, a), c))
    }
    return n && (u.injected = f()), r && o && a && (u.coinbase = h()), e && (u.EIP6963 = !0), i && (u.email = !0), u
}
let gS;

function gJe(t) {
    return gS || (gS = new bke({ ...t,
        _sdkVersion: `react-ethers-${yt.VERSION}`
    })), _ke(gS), gS
}

function fg() {
    const {
        provider: t,
        providerType: e
    } = JX(ht.state);
    return {
        walletProvider: t,
        walletProviderType: e
    }
}

function xs() {
    const {
        address: t,
        isConnected: e,
        chainId: n
    } = JX(ht.state);
    return {
        address: t,
        isConnected: e,
        chainId: n
    }
}
var MM = {},
    Ple = {
        exports: {}
    },
    $l = {},
    kle = {
        exports: {}
    },
    Mle = {};
/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
(function(t) {
    function e(O, L) {
        var G = O.length;
        O.push(L);
        e: for (; 0 < G;) {
            var j = G - 1 >>> 1,
                R = O[j];
            if (0 < i(R, L)) O[j] = L, O[G] = R, G = j;
            else break e
        }
    }

    function n(O) {
        return O.length === 0 ? null : O[0]
    }

    function r(O) {
        if (O.length === 0) return null;
        var L = O[0],
            G = O.pop();
        if (G !== L) {
            O[0] = G;
            e: for (var j = 0, R = O.length, Y = R >>> 1; j < Y;) {
                var ve = 2 * (j + 1) - 1,
                    V = O[ve],
                    X = ve + 1,
                    q = O[X];
                if (0 > i(V, G)) X < R && 0 > i(q, V) ? (O[j] = q, O[X] = G, j = X) : (O[j] = V, O[ve] = G, j = ve);
                else if (X < R && 0 > i(q, G)) O[j] = q, O[X] = G, j = X;
                else break e
            }
        }
        return L
    }

    function i(O, L) {
        var G = O.sortIndex - L.sortIndex;
        return G !== 0 ? G : O.id - L.id
    }
    if (typeof performance == "object" && typeof performance.now == "function") {
        var s = performance;
        t.unstable_now = function() {
            return s.now()
        }
    } else {
        var o = Date,
            a = o.now();
        t.unstable_now = function() {
            return o.now() - a
        }
    }
    var l = [],
        c = [],
        u = 1,
        f = null,
        h = 3,
        g = !1,
        y = !1,
        _ = !1,
        C = typeof setTimeout == "function" ? setTimeout : null,
        b = typeof clearTimeout == "function" ? clearTimeout : null,
        w = typeof setImmediate < "u" ? setImmediate : null;
    typeof navigator < "u" && navigator.scheduling !== void 0 && navigator.scheduling.isInputPending !== void 0 && navigator.scheduling.isInputPending.bind(navigator.scheduling);

    function S(O) {
        for (var L = n(c); L !== null;) {
            if (L.callback === null) r(c);
            else if (L.startTime <= O) r(c), L.sortIndex = L.expirationTime, e(l, L);
            else break;
            L = n(c)
        }
    }

    function I(O) {
        if (_ = !1, S(O), !y)
            if (n(l) !== null) y = !0, T(P);
            else {
                var L = n(c);
                L !== null && N(I, L.startTime - O)
            }
    }

    function P(O, L) {
        y = !1, _ && (_ = !1, b(E), E = -1), g = !0;
        var G = h;
        try {
            for (S(L), f = n(l); f !== null && (!(f.expirationTime > L) || O && !K());) {
                var j = f.callback;
                if (typeof j == "function") {
                    f.callback = null, h = f.priorityLevel;
                    var R = j(f.expirationTime <= L);
                    L = t.unstable_now(), typeof R == "function" ? f.callback = R : f === n(l) && r(l), S(L)
                } else r(l);
                f = n(l)
            }
            if (f !== null) var Y = !0;
            else {
                var ve = n(c);
                ve !== null && N(I, ve.startTime - L), Y = !1
            }
            return Y
        } finally {
            f = null, h = G, g = !1
        }
    }
    var M = !1,
        A = null,
        E = -1,
        $ = 5,
        H = -1;

    function K() {
        return !(t.unstable_now() - H < $)
    }

    function te() {
        if (A !== null) {
            var O = t.unstable_now();
            H = O;
            var L = !0;
            try {
                L = A(!0, O)
            } finally {
                L ? U() : (M = !1, A = null)
            }
        } else M = !1
    }
    var U;
    if (typeof w == "function") U = function() {
        w(te)
    };
    else if (typeof MessageChannel < "u") {
        var m = new MessageChannel,
            v = m.port2;
        m.port1.onmessage = te, U = function() {
            v.postMessage(null)
        }
    } else U = function() {
        C(te, 0)
    };

    function T(O) {
        A = O, M || (M = !0, U())
    }

    function N(O, L) {
        E = C(function() {
            O(t.unstable_now())
        }, L)
    }
    t.unstable_IdlePriority = 5, t.unstable_ImmediatePriority = 1, t.unstable_LowPriority = 4, t.unstable_NormalPriority = 3, t.unstable_Profiling = null, t.unstable_UserBlockingPriority = 2, t.unstable_cancelCallback = function(O) {
        O.callback = null
    }, t.unstable_continueExecution = function() {
        y || g || (y = !0, T(P))
    }, t.unstable_forceFrameRate = function(O) {
        0 > O || 125 < O ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : $ = 0 < O ? Math.floor(1e3 / O) : 5
    }, t.unstable_getCurrentPriorityLevel = function() {
        return h
    }, t.unstable_getFirstCallbackNode = function() {
        return n(l)
    }, t.unstable_next = function(O) {
        switch (h) {
            case 1:
            case 2:
            case 3:
                var L = 3;
                break;
            default:
                L = h
        }
        var G = h;
        h = L;
        try {
            return O()
        } finally {
            h = G
        }
    }, t.unstable_pauseExecution = function() {}, t.unstable_requestPaint = function() {}, t.unstable_runWithPriority = function(O, L) {
        switch (O) {
            case 1:
            case 2:
            case 3:
            case 4:
            case 5:
                break;
            default:
                O = 3
        }
        var G = h;
        h = O;
        try {
            return L()
        } finally {
            h = G
        }
    }, t.unstable_scheduleCallback = function(O, L, G) {
        var j = t.unstable_now();
        switch (typeof G == "object" && G !== null ? (G = G.delay, G = typeof G == "number" && 0 < G ? j + G : j) : G = j, O) {
            case 1:
                var R = -1;
                break;
            case 2:
                R = 250;
                break;
            case 5:
                R = 1073741823;
                break;
            case 4:
                R = 1e4;
                break;
            default:
                R = 5e3
        }
        return R = G + R, O = {
            id: u++,
            callback: L,
            priorityLevel: O,
            startTime: G,
            expirationTime: R,
            sortIndex: -1
        }, G > j ? (O.sortIndex = G, e(c, O), n(l) === null && O === n(c) && (_ ? (b(E), E = -1) : _ = !0, N(I, G - j))) : (O.sortIndex = R, e(l, O), y || g || (y = !0, T(P))), O
    }, t.unstable_shouldYield = K, t.unstable_wrapCallback = function(O) {
        var L = h;
        return function() {
            var G = h;
            h = L;
            try {
                return O.apply(this, arguments)
            } finally {
                h = G
            }
        }
    }
})(Mle);
kle.exports = Mle;
var mJe = kle.exports;
/**
 * @license React
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var yJe = ae,
    Ol = mJe;

function Ye(t) {
    for (var e = "https://reactjs.org/docs/error-decoder.html?invariant=" + t, n = 1; n < arguments.length; n++) e += "&args[]=" + encodeURIComponent(arguments[n]);
    return "Minified React error #" + t + "; visit " + e + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings."
}
var Dle = new Set,
    h6 = {};

function Ty(t, e) {
    g2(t, e), g2(t + "Capture", e)
}

function g2(t, e) {
    for (h6[t] = e, t = 0; t < e.length; t++) Dle.add(e[t])
}
var Oh = !(typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u"),
    DM = Object.prototype.hasOwnProperty,
    wJe = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/,
    UY = {},
    jY = {};

function vJe(t) {
    return DM.call(jY, t) ? !0 : DM.call(UY, t) ? !1 : wJe.test(t) ? jY[t] = !0 : (UY[t] = !0, !1)
}

function bJe(t, e, n, r) {
    if (n !== null && n.type === 0) return !1;
    switch (typeof e) {
        case "function":
        case "symbol":
            return !0;
        case "boolean":
            return r ? !1 : n !== null ? !n.acceptsBooleans : (t = t.toLowerCase().slice(0, 5), t !== "data-" && t !== "aria-");
        default:
            return !1
    }
}

function _Je(t, e, n, r) {
    if (e === null || typeof e > "u" || bJe(t, e, n, r)) return !0;
    if (r) return !1;
    if (n !== null) switch (n.type) {
        case 3:
            return !e;
        case 4:
            return e === !1;
        case 5:
            return isNaN(e);
        case 6:
            return isNaN(e) || 1 > e
    }
    return !1
}

function wa(t, e, n, r, i, s, o) {
    this.acceptsBooleans = e === 2 || e === 3 || e === 4, this.attributeName = r, this.attributeNamespace = i, this.mustUseProperty = n, this.propertyName = t, this.type = e, this.sanitizeURL = s, this.removeEmptyString = o
}
var lo = {};
"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(t) {
    lo[t] = new wa(t, 0, !1, t, null, !1, !1)
});
[
    ["acceptCharset", "accept-charset"],
    ["className", "class"],
    ["htmlFor", "for"],
    ["httpEquiv", "http-equiv"]
].forEach(function(t) {
    var e = t[0];
    lo[e] = new wa(e, 1, !1, t[1], null, !1, !1)
});
["contentEditable", "draggable", "spellCheck", "value"].forEach(function(t) {
    lo[t] = new wa(t, 2, !1, t.toLowerCase(), null, !1, !1)
});
["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(t) {
    lo[t] = new wa(t, 2, !1, t, null, !1, !1)
});
"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(t) {
    lo[t] = new wa(t, 3, !1, t.toLowerCase(), null, !1, !1)
});
["checked", "multiple", "muted", "selected"].forEach(function(t) {
    lo[t] = new wa(t, 3, !0, t, null, !1, !1)
});
["capture", "download"].forEach(function(t) {
    lo[t] = new wa(t, 4, !1, t, null, !1, !1)
});
["cols", "rows", "size", "span"].forEach(function(t) {
    lo[t] = new wa(t, 6, !1, t, null, !1, !1)
});
["rowSpan", "start"].forEach(function(t) {
    lo[t] = new wa(t, 5, !1, t.toLowerCase(), null, !1, !1)
});
var iF = /[\-:]([a-z])/g;

function sF(t) {
    return t[1].toUpperCase()
}
"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(t) {
    var e = t.replace(iF, sF);
    lo[e] = new wa(e, 1, !1, t, null, !1, !1)
});
"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(t) {
    var e = t.replace(iF, sF);
    lo[e] = new wa(e, 1, !1, t, "http://www.w3.org/1999/xlink", !1, !1)
});
["xml:base", "xml:lang", "xml:space"].forEach(function(t) {
    var e = t.replace(iF, sF);
    lo[e] = new wa(e, 1, !1, t, "http://www.w3.org/XML/1998/namespace", !1, !1)
});
["tabIndex", "crossOrigin"].forEach(function(t) {
    lo[t] = new wa(t, 1, !1, t.toLowerCase(), null, !1, !1)
});
lo.xlinkHref = new wa("xlinkHref", 1, !1, "xlink:href", "http://www.w3.org/1999/xlink", !0, !1);
["src", "href", "action", "formAction"].forEach(function(t) {
    lo[t] = new wa(t, 1, !1, t.toLowerCase(), null, !0, !0)
});

function oF(t, e, n, r) {
    var i = lo.hasOwnProperty(e) ? lo[e] : null;
    (i !== null ? i.type !== 0 : r || !(2 < e.length) || e[0] !== "o" && e[0] !== "O" || e[1] !== "n" && e[1] !== "N") && (_Je(e, n, i, r) && (n = null), r || i === null ? vJe(e) && (n === null ? t.removeAttribute(e) : t.setAttribute(e, "" + n)) : i.mustUseProperty ? t[i.propertyName] = n === null ? i.type === 3 ? !1 : "" : n : (e = i.attributeName, r = i.attributeNamespace, n === null ? t.removeAttribute(e) : (i = i.type, n = i === 3 || i === 4 && n === !0 ? "" : "" + n, r ? t.setAttributeNS(r, e, n) : t.setAttribute(e, n))))
}
var Wh = yJe.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED,
    mS = Symbol.for("react.element"),
    Mw = Symbol.for("react.portal"),
    Dw = Symbol.for("react.fragment"),
    aF = Symbol.for("react.strict_mode"),
    $M = Symbol.for("react.profiler"),
    $le = Symbol.for("react.provider"),
    Lle = Symbol.for("react.context"),
    lF = Symbol.for("react.forward_ref"),
    LM = Symbol.for("react.suspense"),
    BM = Symbol.for("react.suspense_list"),
    cF = Symbol.for("react.memo"),
    A0 = Symbol.for("react.lazy"),
    Ble = Symbol.for("react.offscreen"),
    HY = Symbol.iterator;

function J5(t) {
    return t === null || typeof t != "object" ? null : (t = HY && t[HY] || t["@@iterator"], typeof t == "function" ? t : null)
}
var Mi = Object.assign,
    EN;

function R3(t) {
    if (EN === void 0) try {
        throw Error()
    } catch (n) {
        var e = n.stack.trim().match(/\n( *(at )?)/);
        EN = e && e[1] || ""
    }
    return `
` + EN + t
}
var xN = !1;

function SN(t, e) {
    if (!t || xN) return "";
    xN = !0;
    var n = Error.prepareStackTrace;
    Error.prepareStackTrace = void 0;
    try {
        if (e)
            if (e = function() {
                    throw Error()
                }, Object.defineProperty(e.prototype, "props", {
                    set: function() {
                        throw Error()
                    }
                }), typeof Reflect == "object" && Reflect.construct) {
                try {
                    Reflect.construct(e, [])
                } catch (c) {
                    var r = c
                }
                Reflect.construct(t, [], e)
            } else {
                try {
                    e.call()
                } catch (c) {
                    r = c
                }
                t.call(e.prototype)
            }
        else {
            try {
                throw Error()
            } catch (c) {
                r = c
            }
            t()
        }
    } catch (c) {
        if (c && r && typeof c.stack == "string") {
            for (var i = c.stack.split(`
`), s = r.stack.split(`
`), o = i.length - 1, a = s.length - 1; 1 <= o && 0 <= a && i[o] !== s[a];) a--;
            for (; 1 <= o && 0 <= a; o--, a--)
                if (i[o] !== s[a]) {
                    if (o !== 1 || a !== 1)
                        do
                            if (o--, a--, 0 > a || i[o] !== s[a]) {
                                var l = `
` + i[o].replace(" at new ", " at ");
                                return t.displayName && l.includes("<anonymous>") && (l = l.replace("<anonymous>", t.displayName)), l
                            }
                    while (1 <= o && 0 <= a);
                    break
                }
        }
    } finally {
        xN = !1, Error.prepareStackTrace = n
    }
    return (t = t ? t.displayName || t.name : "") ? R3(t) : ""
}

function EJe(t) {
    switch (t.tag) {
        case 5:
            return R3(t.type);
        case 16:
            return R3("Lazy");
        case 13:
            return R3("Suspense");
        case 19:
            return R3("SuspenseList");
        case 0:
        case 2:
        case 15:
            return t = SN(t.type, !1), t;
        case 11:
            return t = SN(t.type.render, !1), t;
        case 1:
            return t = SN(t.type, !0), t;
        default:
            return ""
    }
}

function FM(t) {
    if (t == null) return null;
    if (typeof t == "function") return t.displayName || t.name || null;
    if (typeof t == "string") return t;
    switch (t) {
        case Dw:
            return "Fragment";
        case Mw:
            return "Portal";
        case $M:
            return "Profiler";
        case aF:
            return "StrictMode";
        case LM:
            return "Suspense";
        case BM:
            return "SuspenseList"
    }
    if (typeof t == "object") switch (t.$$typeof) {
        case Lle:
            return (t.displayName || "Context") + ".Consumer";
        case $le:
            return (t._context.displayName || "Context") + ".Provider";
        case lF:
            var e = t.render;
            return t = t.displayName, t || (t = e.displayName || e.name || "", t = t !== "" ? "ForwardRef(" + t + ")" : "ForwardRef"), t;
        case cF:
            return e = t.displayName || null, e !== null ? e : FM(t.type) || "Memo";
        case A0:
            e = t._payload, t = t._init;
            try {
                return FM(t(e))
            } catch {}
    }
    return null
}

function xJe(t) {
    var e = t.type;
    switch (t.tag) {
        case 24:
            return "Cache";
        case 9:
            return (e.displayName || "Context") + ".Consumer";
        case 10:
            return (e._context.displayName || "Context") + ".Provider";
        case 18:
            return "DehydratedFragment";
        case 11:
            return t = e.render, t = t.displayName || t.name || "", e.displayName || (t !== "" ? "ForwardRef(" + t + ")" : "ForwardRef");
        case 7:
            return "Fragment";
        case 5:
            return e;
        case 4:
            return "Portal";
        case 3:
            return "Root";
        case 6:
            return "Text";
        case 16:
            return FM(e);
        case 8:
            return e === aF ? "StrictMode" : "Mode";
        case 22:
            return "Offscreen";
        case 12:
            return "Profiler";
        case 21:
            return "Scope";
        case 13:
            return "Suspense";
        case 19:
            return "SuspenseList";
        case 25:
            return "TracingMarker";
        case 1:
        case 0:
        case 17:
        case 2:
        case 14:
        case 15:
            if (typeof e == "function") return e.displayName || e.name || null;
            if (typeof e == "string") return e
    }
    return null
}

function Zp(t) {
    switch (typeof t) {
        case "boolean":
        case "number":
        case "string":
        case "undefined":
            return t;
        case "object":
            return t;
        default:
            return ""
    }
}

function Fle(t) {
    var e = t.type;
    return (t = t.nodeName) && t.toLowerCase() === "input" && (e === "checkbox" || e === "radio")
}

function SJe(t) {
    var e = Fle(t) ? "checked" : "value",
        n = Object.getOwnPropertyDescriptor(t.constructor.prototype, e),
        r = "" + t[e];
    if (!t.hasOwnProperty(e) && typeof n < "u" && typeof n.get == "function" && typeof n.set == "function") {
        var i = n.get,
            s = n.set;
        return Object.defineProperty(t, e, {
            configurable: !0,
            get: function() {
                return i.call(this)
            },
            set: function(o) {
                r = "" + o, s.call(this, o)
            }
        }), Object.defineProperty(t, e, {
            enumerable: n.enumerable
        }), {
            getValue: function() {
                return r
            },
            setValue: function(o) {
                r = "" + o
            },
            stopTracking: function() {
                t._valueTracker = null, delete t[e]
            }
        }
    }
}

function yS(t) {
    t._valueTracker || (t._valueTracker = SJe(t))
}

function Ule(t) {
    if (!t) return !1;
    var e = t._valueTracker;
    if (!e) return !0;
    var n = e.getValue(),
        r = "";
    return t && (r = Fle(t) ? t.checked ? "true" : "false" : t.value), t = r, t !== n ? (e.setValue(t), !0) : !1
}

function oA(t) {
    if (t = t || (typeof document < "u" ? document : void 0), typeof t > "u") return null;
    try {
        return t.activeElement || t.body
    } catch {
        return t.body
    }
}

function UM(t, e) {
    var n = e.checked;
    return Mi({}, e, {
        defaultChecked: void 0,
        defaultValue: void 0,
        value: void 0,
        checked: n ? ? t._wrapperState.initialChecked
    })
}

function zY(t, e) {
    var n = e.defaultValue == null ? "" : e.defaultValue,
        r = e.checked != null ? e.checked : e.defaultChecked;
    n = Zp(e.value != null ? e.value : n), t._wrapperState = {
        initialChecked: r,
        initialValue: n,
        controlled: e.type === "checkbox" || e.type === "radio" ? e.checked != null : e.value != null
    }
}

function jle(t, e) {
    e = e.checked, e != null && oF(t, "checked", e, !1)
}

function jM(t, e) {
    jle(t, e);
    var n = Zp(e.value),
        r = e.type;
    if (n != null) r === "number" ? (n === 0 && t.value === "" || t.value != n) && (t.value = "" + n) : t.value !== "" + n && (t.value = "" + n);
    else if (r === "submit" || r === "reset") {
        t.removeAttribute("value");
        return
    }
    e.hasOwnProperty("value") ? HM(t, e.type, n) : e.hasOwnProperty("defaultValue") && HM(t, e.type, Zp(e.defaultValue)), e.checked == null && e.defaultChecked != null && (t.defaultChecked = !!e.defaultChecked)
}

function WY(t, e, n) {
    if (e.hasOwnProperty("value") || e.hasOwnProperty("defaultValue")) {
        var r = e.type;
        if (!(r !== "submit" && r !== "reset" || e.value !== void 0 && e.value !== null)) return;
        e = "" + t._wrapperState.initialValue, n || e === t.value || (t.value = e), t.defaultValue = e
    }
    n = t.name, n !== "" && (t.name = ""), t.defaultChecked = !!t._wrapperState.initialChecked, n !== "" && (t.name = n)
}

function HM(t, e, n) {
    (e !== "number" || oA(t.ownerDocument) !== t) && (n == null ? t.defaultValue = "" + t._wrapperState.initialValue : t.defaultValue !== "" + n && (t.defaultValue = "" + n))
}
var O3 = Array.isArray;

function hv(t, e, n, r) {
    if (t = t.options, e) {
        e = {};
        for (var i = 0; i < n.length; i++) e["$" + n[i]] = !0;
        for (n = 0; n < t.length; n++) i = e.hasOwnProperty("$" + t[n].value), t[n].selected !== i && (t[n].selected = i), i && r && (t[n].defaultSelected = !0)
    } else {
        for (n = "" + Zp(n), e = null, i = 0; i < t.length; i++) {
            if (t[i].value === n) {
                t[i].selected = !0, r && (t[i].defaultSelected = !0);
                return
            }
            e !== null || t[i].disabled || (e = t[i])
        }
        e !== null && (e.selected = !0)
    }
}

function zM(t, e) {
    if (e.dangerouslySetInnerHTML != null) throw Error(Ye(91));
    return Mi({}, e, {
        value: void 0,
        defaultValue: void 0,
        children: "" + t._wrapperState.initialValue
    })
}

function VY(t, e) {
    var n = e.value;
    if (n == null) {
        if (n = e.children, e = e.defaultValue, n != null) {
            if (e != null) throw Error(Ye(92));
            if (O3(n)) {
                if (1 < n.length) throw Error(Ye(93));
                n = n[0]
            }
            e = n
        }
        e == null && (e = ""), n = e
    }
    t._wrapperState = {
        initialValue: Zp(n)
    }
}

function Hle(t, e) {
    var n = Zp(e.value),
        r = Zp(e.defaultValue);
    n != null && (n = "" + n, n !== t.value && (t.value = n), e.defaultValue == null && t.defaultValue !== n && (t.defaultValue = n)), r != null && (t.defaultValue = "" + r)
}

function GY(t) {
    var e = t.textContent;
    e === t._wrapperState.initialValue && e !== "" && e !== null && (t.value = e)
}

function zle(t) {
    switch (t) {
        case "svg":
            return "http://www.w3.org/2000/svg";
        case "math":
            return "http://www.w3.org/1998/Math/MathML";
        default:
            return "http://www.w3.org/1999/xhtml"
    }
}

function WM(t, e) {
    return t == null || t === "http://www.w3.org/1999/xhtml" ? zle(e) : t === "http://www.w3.org/2000/svg" && e === "foreignObject" ? "http://www.w3.org/1999/xhtml" : t
}
var wS, Wle = function(t) {
    return typeof MSApp < "u" && MSApp.execUnsafeLocalFunction ? function(e, n, r, i) {
        MSApp.execUnsafeLocalFunction(function() {
            return t(e, n, r, i)
        })
    } : t
}(function(t, e) {
    if (t.namespaceURI !== "http://www.w3.org/2000/svg" || "innerHTML" in t) t.innerHTML = e;
    else {
        for (wS = wS || document.createElement("div"), wS.innerHTML = "<svg>" + e.valueOf().toString() + "</svg>", e = wS.firstChild; t.firstChild;) t.removeChild(t.firstChild);
        for (; e.firstChild;) t.appendChild(e.firstChild)
    }
});

function p6(t, e) {
    if (e) {
        var n = t.firstChild;
        if (n && n === t.lastChild && n.nodeType === 3) {
            n.nodeValue = e;
            return
        }
    }
    t.textContent = e
}
var J3 = {
        animationIterationCount: !0,
        aspectRatio: !0,
        borderImageOutset: !0,
        borderImageSlice: !0,
        borderImageWidth: !0,
        boxFlex: !0,
        boxFlexGroup: !0,
        boxOrdinalGroup: !0,
        columnCount: !0,
        columns: !0,
        flex: !0,
        flexGrow: !0,
        flexPositive: !0,
        flexShrink: !0,
        flexNegative: !0,
        flexOrder: !0,
        gridArea: !0,
        gridRow: !0,
        gridRowEnd: !0,
        gridRowSpan: !0,
        gridRowStart: !0,
        gridColumn: !0,
        gridColumnEnd: !0,
        gridColumnSpan: !0,
        gridColumnStart: !0,
        fontWeight: !0,
        lineClamp: !0,
        lineHeight: !0,
        opacity: !0,
        order: !0,
        orphans: !0,
        tabSize: !0,
        widows: !0,
        zIndex: !0,
        zoom: !0,
        fillOpacity: !0,
        floodOpacity: !0,
        stopOpacity: !0,
        strokeDasharray: !0,
        strokeDashoffset: !0,
        strokeMiterlimit: !0,
        strokeOpacity: !0,
        strokeWidth: !0
    },
    CJe = ["Webkit", "ms", "Moz", "O"];
Object.keys(J3).forEach(function(t) {
    CJe.forEach(function(e) {
        e = e + t.charAt(0).toUpperCase() + t.substring(1), J3[e] = J3[t]
    })
});

function Vle(t, e, n) {
    return e == null || typeof e == "boolean" || e === "" ? "" : n || typeof e != "number" || e === 0 || J3.hasOwnProperty(t) && J3[t] ? ("" + e).trim() : e + "px"
}

function Gle(t, e) {
    t = t.style;
    for (var n in e)
        if (e.hasOwnProperty(n)) {
            var r = n.indexOf("--") === 0,
                i = Vle(n, e[n], r);
            n === "float" && (n = "cssFloat"), r ? t.setProperty(n, i) : t[n] = i
        }
}
var AJe = Mi({
    menuitem: !0
}, {
    area: !0,
    base: !0,
    br: !0,
    col: !0,
    embed: !0,
    hr: !0,
    img: !0,
    input: !0,
    keygen: !0,
    link: !0,
    meta: !0,
    param: !0,
    source: !0,
    track: !0,
    wbr: !0
});

function VM(t, e) {
    if (e) {
        if (AJe[t] && (e.children != null || e.dangerouslySetInnerHTML != null)) throw Error(Ye(137, t));
        if (e.dangerouslySetInnerHTML != null) {
            if (e.children != null) throw Error(Ye(60));
            if (typeof e.dangerouslySetInnerHTML != "object" || !("__html" in e.dangerouslySetInnerHTML)) throw Error(Ye(61))
        }
        if (e.style != null && typeof e.style != "object") throw Error(Ye(62))
    }
}

function GM(t, e) {
    if (t.indexOf("-") === -1) return typeof e.is == "string";
    switch (t) {
        case "annotation-xml":
        case "color-profile":
        case "font-face":
        case "font-face-src":
        case "font-face-uri":
        case "font-face-format":
        case "font-face-name":
        case "missing-glyph":
            return !1;
        default:
            return !0
    }
}
var qM = null;

function uF(t) {
    return t = t.target || t.srcElement || window, t.correspondingUseElement && (t = t.correspondingUseElement), t.nodeType === 3 ? t.parentNode : t
}
var KM = null,
    pv = null,
    gv = null;

function qY(t) {
    if (t = f4(t)) {
        if (typeof KM != "function") throw Error(Ye(280));
        var e = t.stateNode;
        e && (e = y7(e), KM(t.stateNode, t.type, e))
    }
}

function qle(t) {
    pv ? gv ? gv.push(t) : gv = [t] : pv = t
}

function Kle() {
    if (pv) {
        var t = pv,
            e = gv;
        if (gv = pv = null, qY(t), e)
            for (t = 0; t < e.length; t++) qY(e[t])
    }
}

function Yle(t, e) {
    return t(e)
}

function Zle() {}
var CN = !1;

function Qle(t, e, n) {
    if (CN) return t(e, n);
    CN = !0;
    try {
        return Yle(t, e, n)
    } finally {
        CN = !1, (pv !== null || gv !== null) && (Zle(), Kle())
    }
}

function g6(t, e) {
    var n = t.stateNode;
    if (n === null) return null;
    var r = y7(n);
    if (r === null) return null;
    n = r[e];
    e: switch (e) {
        case "onClick":
        case "onClickCapture":
        case "onDoubleClick":
        case "onDoubleClickCapture":
        case "onMouseDown":
        case "onMouseDownCapture":
        case "onMouseMove":
        case "onMouseMoveCapture":
        case "onMouseUp":
        case "onMouseUpCapture":
        case "onMouseEnter":
            (r = !r.disabled) || (t = t.type, r = !(t === "button" || t === "input" || t === "select" || t === "textarea")), t = !r;
            break e;
        default:
            t = !1
    }
    if (t) return null;
    if (n && typeof n != "function") throw Error(Ye(231, e, typeof n));
    return n
}
var YM = !1;
if (Oh) try {
    var X5 = {};
    Object.defineProperty(X5, "passive", {
        get: function() {
            YM = !0
        }
    }), window.addEventListener("test", X5, X5), window.removeEventListener("test", X5, X5)
} catch {
    YM = !1
}

function TJe(t, e, n, r, i, s, o, a, l) {
    var c = Array.prototype.slice.call(arguments, 3);
    try {
        e.apply(n, c)
    } catch (u) {
        this.onError(u)
    }
}
var X3 = !1,
    aA = null,
    lA = !1,
    ZM = null,
    IJe = {
        onError: function(t) {
            X3 = !0, aA = t
        }
    };

function RJe(t, e, n, r, i, s, o, a, l) {
    X3 = !1, aA = null, TJe.apply(IJe, arguments)
}

function OJe(t, e, n, r, i, s, o, a, l) {
    if (RJe.apply(this, arguments), X3) {
        if (X3) {
            var c = aA;
            X3 = !1, aA = null
        } else throw Error(Ye(198));
        lA || (lA = !0, ZM = c)
    }
}

function Iy(t) {
    var e = t,
        n = t;
    if (t.alternate)
        for (; e.return;) e = e.return;
    else {
        t = e;
        do e = t, e.flags & 4098 && (n = e.return), t = e.return; while (t)
    }
    return e.tag === 3 ? n : null
}

function Jle(t) {
    if (t.tag === 13) {
        var e = t.memoizedState;
        if (e === null && (t = t.alternate, t !== null && (e = t.memoizedState)), e !== null) return e.dehydrated
    }
    return null
}

function KY(t) {
    if (Iy(t) !== t) throw Error(Ye(188))
}

function NJe(t) {
    var e = t.alternate;
    if (!e) {
        if (e = Iy(t), e === null) throw Error(Ye(188));
        return e !== t ? null : t
    }
    for (var n = t, r = e;;) {
        var i = n.return;
        if (i === null) break;
        var s = i.alternate;
        if (s === null) {
            if (r = i.return, r !== null) {
                n = r;
                continue
            }
            break
        }
        if (i.child === s.child) {
            for (s = i.child; s;) {
                if (s === n) return KY(i), t;
                if (s === r) return KY(i), e;
                s = s.sibling
            }
            throw Error(Ye(188))
        }
        if (n.return !== r.return) n = i, r = s;
        else {
            for (var o = !1, a = i.child; a;) {
                if (a === n) {
                    o = !0, n = i, r = s;
                    break
                }
                if (a === r) {
                    o = !0, r = i, n = s;
                    break
                }
                a = a.sibling
            }
            if (!o) {
                for (a = s.child; a;) {
                    if (a === n) {
                        o = !0, n = s, r = i;
                        break
                    }
                    if (a === r) {
                        o = !0, r = s, n = i;
                        break
                    }
                    a = a.sibling
                }
                if (!o) throw Error(Ye(189))
            }
        }
        if (n.alternate !== r) throw Error(Ye(190))
    }
    if (n.tag !== 3) throw Error(Ye(188));
    return n.stateNode.current === n ? t : e
}

function Xle(t) {
    return t = NJe(t), t !== null ? ece(t) : null
}

function ece(t) {
    if (t.tag === 5 || t.tag === 6) return t;
    for (t = t.child; t !== null;) {
        var e = ece(t);
        if (e !== null) return e;
        t = t.sibling
    }
    return null
}
var tce = Ol.unstable_scheduleCallback,
    YY = Ol.unstable_cancelCallback,
    PJe = Ol.unstable_shouldYield,
    kJe = Ol.unstable_requestPaint,
    us = Ol.unstable_now,
    MJe = Ol.unstable_getCurrentPriorityLevel,
    fF = Ol.unstable_ImmediatePriority,
    nce = Ol.unstable_UserBlockingPriority,
    cA = Ol.unstable_NormalPriority,
    DJe = Ol.unstable_LowPriority,
    rce = Ol.unstable_IdlePriority,
    h7 = null,
    Yf = null;

function $Je(t) {
    if (Yf && typeof Yf.onCommitFiberRoot == "function") try {
        Yf.onCommitFiberRoot(h7, t, void 0, (t.current.flags & 128) === 128)
    } catch {}
}
var Cu = Math.clz32 ? Math.clz32 : FJe,
    LJe = Math.log,
    BJe = Math.LN2;

function FJe(t) {
    return t >>>= 0, t === 0 ? 32 : 31 - (LJe(t) / BJe | 0) | 0
}
var vS = 64,
    bS = 4194304;

function N3(t) {
    switch (t & -t) {
        case 1:
            return 1;
        case 2:
            return 2;
        case 4:
            return 4;
        case 8:
            return 8;
        case 16:
            return 16;
        case 32:
            return 32;
        case 64:
        case 128:
        case 256:
        case 512:
        case 1024:
        case 2048:
        case 4096:
        case 8192:
        case 16384:
        case 32768:
        case 65536:
        case 131072:
        case 262144:
        case 524288:
        case 1048576:
        case 2097152:
            return t & 4194240;
        case 4194304:
        case 8388608:
        case 16777216:
        case 33554432:
        case 67108864:
            return t & 130023424;
        case 134217728:
            return 134217728;
        case 268435456:
            return 268435456;
        case 536870912:
            return 536870912;
        case 1073741824:
            return 1073741824;
        default:
            return t
    }
}

function uA(t, e) {
    var n = t.pendingLanes;
    if (n === 0) return 0;
    var r = 0,
        i = t.suspendedLanes,
        s = t.pingedLanes,
        o = n & 268435455;
    if (o !== 0) {
        var a = o & ~i;
        a !== 0 ? r = N3(a) : (s &= o, s !== 0 && (r = N3(s)))
    } else o = n & ~i, o !== 0 ? r = N3(o) : s !== 0 && (r = N3(s));
    if (r === 0) return 0;
    if (e !== 0 && e !== r && !(e & i) && (i = r & -r, s = e & -e, i >= s || i === 16 && (s & 4194240) !== 0)) return e;
    if (r & 4 && (r |= n & 16), e = t.entangledLanes, e !== 0)
        for (t = t.entanglements, e &= r; 0 < e;) n = 31 - Cu(e), i = 1 << n, r |= t[n], e &= ~i;
    return r
}

function UJe(t, e) {
    switch (t) {
        case 1:
        case 2:
        case 4:
            return e + 250;
        case 8:
        case 16:
        case 32:
        case 64:
        case 128:
        case 256:
        case 512:
        case 1024:
        case 2048:
        case 4096:
        case 8192:
        case 16384:
        case 32768:
        case 65536:
        case 131072:
        case 262144:
        case 524288:
        case 1048576:
        case 2097152:
            return e + 5e3;
        case 4194304:
        case 8388608:
        case 16777216:
        case 33554432:
        case 67108864:
            return -1;
        case 134217728:
        case 268435456:
        case 536870912:
        case 1073741824:
            return -1;
        default:
            return -1
    }
}

function jJe(t, e) {
    for (var n = t.suspendedLanes, r = t.pingedLanes, i = t.expirationTimes, s = t.pendingLanes; 0 < s;) {
        var o = 31 - Cu(s),
            a = 1 << o,
            l = i[o];
        l === -1 ? (!(a & n) || a & r) && (i[o] = UJe(a, e)) : l <= e && (t.expiredLanes |= a), s &= ~a
    }
}

function QM(t) {
    return t = t.pendingLanes & -1073741825, t !== 0 ? t : t & 1073741824 ? 1073741824 : 0
}

function ice() {
    var t = vS;
    return vS <<= 1, !(vS & 4194240) && (vS = 64), t
}

function AN(t) {
    for (var e = [], n = 0; 31 > n; n++) e.push(t);
    return e
}

function c4(t, e, n) {
    t.pendingLanes |= e, e !== 536870912 && (t.suspendedLanes = 0, t.pingedLanes = 0), t = t.eventTimes, e = 31 - Cu(e), t[e] = n
}

function HJe(t, e) {
    var n = t.pendingLanes & ~e;
    t.pendingLanes = e, t.suspendedLanes = 0, t.pingedLanes = 0, t.expiredLanes &= e, t.mutableReadLanes &= e, t.entangledLanes &= e, e = t.entanglements;
    var r = t.eventTimes;
    for (t = t.expirationTimes; 0 < n;) {
        var i = 31 - Cu(n),
            s = 1 << i;
        e[i] = 0, r[i] = -1, t[i] = -1, n &= ~s
    }
}

function dF(t, e) {
    var n = t.entangledLanes |= e;
    for (t = t.entanglements; n;) {
        var r = 31 - Cu(n),
            i = 1 << r;
        i & e | t[r] & e && (t[r] |= e), n &= ~i
    }
}
var Or = 0;

function sce(t) {
    return t &= -t, 1 < t ? 4 < t ? t & 268435455 ? 16 : 536870912 : 4 : 1
}
var oce, hF, ace, lce, cce, JM = !1,
    _S = [],
    xp = null,
    Sp = null,
    Cp = null,
    m6 = new Map,
    y6 = new Map,
    D0 = [],
    zJe = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" ");

function ZY(t, e) {
    switch (t) {
        case "focusin":
        case "focusout":
            xp = null;
            break;
        case "dragenter":
        case "dragleave":
            Sp = null;
            break;
        case "mouseover":
        case "mouseout":
            Cp = null;
            break;
        case "pointerover":
        case "pointerout":
            m6.delete(e.pointerId);
            break;
        case "gotpointercapture":
        case "lostpointercapture":
            y6.delete(e.pointerId)
    }
}

function e3(t, e, n, r, i, s) {
    return t === null || t.nativeEvent !== s ? (t = {
        blockedOn: e,
        domEventName: n,
        eventSystemFlags: r,
        nativeEvent: s,
        targetContainers: [i]
    }, e !== null && (e = f4(e), e !== null && hF(e)), t) : (t.eventSystemFlags |= r, e = t.targetContainers, i !== null && e.indexOf(i) === -1 && e.push(i), t)
}

function WJe(t, e, n, r, i) {
    switch (e) {
        case "focusin":
            return xp = e3(xp, t, e, n, r, i), !0;
        case "dragenter":
            return Sp = e3(Sp, t, e, n, r, i), !0;
        case "mouseover":
            return Cp = e3(Cp, t, e, n, r, i), !0;
        case "pointerover":
            var s = i.pointerId;
            return m6.set(s, e3(m6.get(s) || null, t, e, n, r, i)), !0;
        case "gotpointercapture":
            return s = i.pointerId, y6.set(s, e3(y6.get(s) || null, t, e, n, r, i)), !0
    }
    return !1
}

function uce(t) {
    var e = m1(t.target);
    if (e !== null) {
        var n = Iy(e);
        if (n !== null) {
            if (e = n.tag, e === 13) {
                if (e = Jle(n), e !== null) {
                    t.blockedOn = e, cce(t.priority, function() {
                        ace(n)
                    });
                    return
                }
            } else if (e === 3 && n.stateNode.current.memoizedState.isDehydrated) {
                t.blockedOn = n.tag === 3 ? n.stateNode.containerInfo : null;
                return
            }
        }
    }
    t.blockedOn = null
}

function w8(t) {
    if (t.blockedOn !== null) return !1;
    for (var e = t.targetContainers; 0 < e.length;) {
        var n = XM(t.domEventName, t.eventSystemFlags, e[0], t.nativeEvent);
        if (n === null) {
            n = t.nativeEvent;
            var r = new n.constructor(n.type, n);
            qM = r, n.target.dispatchEvent(r), qM = null
        } else return e = f4(n), e !== null && hF(e), t.blockedOn = n, !1;
        e.shift()
    }
    return !0
}

function QY(t, e, n) {
    w8(t) && n.delete(e)
}

function VJe() {
    JM = !1, xp !== null && w8(xp) && (xp = null), Sp !== null && w8(Sp) && (Sp = null), Cp !== null && w8(Cp) && (Cp = null), m6.forEach(QY), y6.forEach(QY)
}

function t3(t, e) {
    t.blockedOn === e && (t.blockedOn = null, JM || (JM = !0, Ol.unstable_scheduleCallback(Ol.unstable_NormalPriority, VJe)))
}

function w6(t) {
    function e(i) {
        return t3(i, t)
    }
    if (0 < _S.length) {
        t3(_S[0], t);
        for (var n = 1; n < _S.length; n++) {
            var r = _S[n];
            r.blockedOn === t && (r.blockedOn = null)
        }
    }
    for (xp !== null && t3(xp, t), Sp !== null && t3(Sp, t), Cp !== null && t3(Cp, t), m6.forEach(e), y6.forEach(e), n = 0; n < D0.length; n++) r = D0[n], r.blockedOn === t && (r.blockedOn = null);
    for (; 0 < D0.length && (n = D0[0], n.blockedOn === null);) uce(n), n.blockedOn === null && D0.shift()
}
var mv = Wh.ReactCurrentBatchConfig,
    fA = !0;

function GJe(t, e, n, r) {
    var i = Or,
        s = mv.transition;
    mv.transition = null;
    try {
        Or = 1, pF(t, e, n, r)
    } finally {
        Or = i, mv.transition = s
    }
}

function qJe(t, e, n, r) {
    var i = Or,
        s = mv.transition;
    mv.transition = null;
    try {
        Or = 4, pF(t, e, n, r)
    } finally {
        Or = i, mv.transition = s
    }
}

function pF(t, e, n, r) {
    if (fA) {
        var i = XM(t, e, n, r);
        if (i === null) $N(t, e, r, dA, n), ZY(t, r);
        else if (WJe(i, t, e, n, r)) r.stopPropagation();
        else if (ZY(t, r), e & 4 && -1 < zJe.indexOf(t)) {
            for (; i !== null;) {
                var s = f4(i);
                if (s !== null && oce(s), s = XM(t, e, n, r), s === null && $N(t, e, r, dA, n), s === i) break;
                i = s
            }
            i !== null && r.stopPropagation()
        } else $N(t, e, r, null, n)
    }
}
var dA = null;

function XM(t, e, n, r) {
    if (dA = null, t = uF(r), t = m1(t), t !== null)
        if (e = Iy(t), e === null) t = null;
        else if (n = e.tag, n === 13) {
        if (t = Jle(e), t !== null) return t;
        t = null
    } else if (n === 3) {
        if (e.stateNode.current.memoizedState.isDehydrated) return e.tag === 3 ? e.stateNode.containerInfo : null;
        t = null
    } else e !== t && (t = null);
    return dA = t, null
}

function fce(t) {
    switch (t) {
        case "cancel":
        case "click":
        case "close":
        case "contextmenu":
        case "copy":
        case "cut":
        case "auxclick":
        case "dblclick":
        case "dragend":
        case "dragstart":
        case "drop":
        case "focusin":
        case "focusout":
        case "input":
        case "invalid":
        case "keydown":
        case "keypress":
        case "keyup":
        case "mousedown":
        case "mouseup":
        case "paste":
        case "pause":
        case "play":
        case "pointercancel":
        case "pointerdown":
        case "pointerup":
        case "ratechange":
        case "reset":
        case "resize":
        case "seeked":
        case "submit":
        case "touchcancel":
        case "touchend":
        case "touchstart":
        case "volumechange":
        case "change":
        case "selectionchange":
        case "textInput":
        case "compositionstart":
        case "compositionend":
        case "compositionupdate":
        case "beforeblur":
        case "afterblur":
        case "beforeinput":
        case "blur":
        case "fullscreenchange":
        case "focus":
        case "hashchange":
        case "popstate":
        case "select":
        case "selectstart":
            return 1;
        case "drag":
        case "dragenter":
        case "dragexit":
        case "dragleave":
        case "dragover":
        case "mousemove":
        case "mouseout":
        case "mouseover":
        case "pointermove":
        case "pointerout":
        case "pointerover":
        case "scroll":
        case "toggle":
        case "touchmove":
        case "wheel":
        case "mouseenter":
        case "mouseleave":
        case "pointerenter":
        case "pointerleave":
            return 4;
        case "message":
            switch (MJe()) {
                case fF:
                    return 1;
                case nce:
                    return 4;
                case cA:
                case DJe:
                    return 16;
                case rce:
                    return 536870912;
                default:
                    return 16
            }
        default:
            return 16
    }
}
var hp = null,
    gF = null,
    v8 = null;

function dce() {
    if (v8) return v8;
    var t, e = gF,
        n = e.length,
        r, i = "value" in hp ? hp.value : hp.textContent,
        s = i.length;
    for (t = 0; t < n && e[t] === i[t]; t++);
    var o = n - t;
    for (r = 1; r <= o && e[n - r] === i[s - r]; r++);
    return v8 = i.slice(t, 1 < r ? 1 - r : void 0)
}

function b8(t) {
    var e = t.keyCode;
    return "charCode" in t ? (t = t.charCode, t === 0 && e === 13 && (t = 13)) : t = e, t === 10 && (t = 13), 32 <= t || t === 13 ? t : 0
}

function ES() {
    return !0
}

function JY() {
    return !1
}

function Ll(t) {
    function e(n, r, i, s, o) {
        this._reactName = n, this._targetInst = i, this.type = r, this.nativeEvent = s, this.target = o, this.currentTarget = null;
        for (var a in t) t.hasOwnProperty(a) && (n = t[a], this[a] = n ? n(s) : s[a]);
        return this.isDefaultPrevented = (s.defaultPrevented != null ? s.defaultPrevented : s.returnValue === !1) ? ES : JY, this.isPropagationStopped = JY, this
    }
    return Mi(e.prototype, {
        preventDefault: function() {
            this.defaultPrevented = !0;
            var n = this.nativeEvent;
            n && (n.preventDefault ? n.preventDefault() : typeof n.returnValue != "unknown" && (n.returnValue = !1), this.isDefaultPrevented = ES)
        },
        stopPropagation: function() {
            var n = this.nativeEvent;
            n && (n.stopPropagation ? n.stopPropagation() : typeof n.cancelBubble != "unknown" && (n.cancelBubble = !0), this.isPropagationStopped = ES)
        },
        persist: function() {},
        isPersistent: ES
    }), e
}
var Y2 = {
        eventPhase: 0,
        bubbles: 0,
        cancelable: 0,
        timeStamp: function(t) {
            return t.timeStamp || Date.now()
        },
        defaultPrevented: 0,
        isTrusted: 0
    },
    mF = Ll(Y2),
    u4 = Mi({}, Y2, {
        view: 0,
        detail: 0
    }),
    KJe = Ll(u4),
    TN, IN, n3, p7 = Mi({}, u4, {
        screenX: 0,
        screenY: 0,
        clientX: 0,
        clientY: 0,
        pageX: 0,
        pageY: 0,
        ctrlKey: 0,
        shiftKey: 0,
        altKey: 0,
        metaKey: 0,
        getModifierState: yF,
        button: 0,
        buttons: 0,
        relatedTarget: function(t) {
            return t.relatedTarget === void 0 ? t.fromElement === t.srcElement ? t.toElement : t.fromElement : t.relatedTarget
        },
        movementX: function(t) {
            return "movementX" in t ? t.movementX : (t !== n3 && (n3 && t.type === "mousemove" ? (TN = t.screenX - n3.screenX, IN = t.screenY - n3.screenY) : IN = TN = 0, n3 = t), TN)
        },
        movementY: function(t) {
            return "movementY" in t ? t.movementY : IN
        }
    }),
    XY = Ll(p7),
    YJe = Mi({}, p7, {
        dataTransfer: 0
    }),
    ZJe = Ll(YJe),
    QJe = Mi({}, u4, {
        relatedTarget: 0
    }),
    RN = Ll(QJe),
    JJe = Mi({}, Y2, {
        animationName: 0,
        elapsedTime: 0,
        pseudoElement: 0
    }),
    XJe = Ll(JJe),
    eXe = Mi({}, Y2, {
        clipboardData: function(t) {
            return "clipboardData" in t ? t.clipboardData : window.clipboardData
        }
    }),
    tXe = Ll(eXe),
    nXe = Mi({}, Y2, {
        data: 0
    }),
    eZ = Ll(nXe),
    rXe = {
        Esc: "Escape",
        Spacebar: " ",
        Left: "ArrowLeft",
        Up: "ArrowUp",
        Right: "ArrowRight",
        Down: "ArrowDown",
        Del: "Delete",
        Win: "OS",
        Menu: "ContextMenu",
        Apps: "ContextMenu",
        Scroll: "ScrollLock",
        MozPrintableKey: "Unidentified"
    },
    iXe = {
        8: "Backspace",
        9: "Tab",
        12: "Clear",
        13: "Enter",
        16: "Shift",
        17: "Control",
        18: "Alt",
        19: "Pause",
        20: "CapsLock",
        27: "Escape",
        32: " ",
        33: "PageUp",
        34: "PageDown",
        35: "End",
        36: "Home",
        37: "ArrowLeft",
        38: "ArrowUp",
        39: "ArrowRight",
        40: "ArrowDown",
        45: "Insert",
        46: "Delete",
        112: "F1",
        113: "F2",
        114: "F3",
        115: "F4",
        116: "F5",
        117: "F6",
        118: "F7",
        119: "F8",
        120: "F9",
        121: "F10",
        122: "F11",
        123: "F12",
        144: "NumLock",
        145: "ScrollLock",
        224: "Meta"
    },
    sXe = {
        Alt: "altKey",
        Control: "ctrlKey",
        Meta: "metaKey",
        Shift: "shiftKey"
    };

function oXe(t) {
    var e = this.nativeEvent;
    return e.getModifierState ? e.getModifierState(t) : (t = sXe[t]) ? !!e[t] : !1
}

function yF() {
    return oXe
}
var aXe = Mi({}, u4, {
        key: function(t) {
            if (t.key) {
                var e = rXe[t.key] || t.key;
                if (e !== "Unidentified") return e
            }
            return t.type === "keypress" ? (t = b8(t), t === 13 ? "Enter" : String.fromCharCode(t)) : t.type === "keydown" || t.type === "keyup" ? iXe[t.keyCode] || "Unidentified" : ""
        },
        code: 0,
        location: 0,
        ctrlKey: 0,
        shiftKey: 0,
        altKey: 0,
        metaKey: 0,
        repeat: 0,
        locale: 0,
        getModifierState: yF,
        charCode: function(t) {
            return t.type === "keypress" ? b8(t) : 0
        },
        keyCode: function(t) {
            return t.type === "keydown" || t.type === "keyup" ? t.keyCode : 0
        },
        which: function(t) {
            return t.type === "keypress" ? b8(t) : t.type === "keydown" || t.type === "keyup" ? t.keyCode : 0
        }
    }),
    lXe = Ll(aXe),
    cXe = Mi({}, p7, {
        pointerId: 0,
        width: 0,
        height: 0,
        pressure: 0,
        tangentialPressure: 0,
        tiltX: 0,
        tiltY: 0,
        twist: 0,
        pointerType: 0,
        isPrimary: 0
    }),
    tZ = Ll(cXe),
    uXe = Mi({}, u4, {
        touches: 0,
        targetTouches: 0,
        changedTouches: 0,
        altKey: 0,
        metaKey: 0,
        ctrlKey: 0,
        shiftKey: 0,
        getModifierState: yF
    }),
    fXe = Ll(uXe),
    dXe = Mi({}, Y2, {
        propertyName: 0,
        elapsedTime: 0,
        pseudoElement: 0
    }),
    hXe = Ll(dXe),
    pXe = Mi({}, p7, {
        deltaX: function(t) {
            return "deltaX" in t ? t.deltaX : "wheelDeltaX" in t ? -t.wheelDeltaX : 0
        },
        deltaY: function(t) {
            return "deltaY" in t ? t.deltaY : "wheelDeltaY" in t ? -t.wheelDeltaY : "wheelDelta" in t ? -t.wheelDelta : 0
        },
        deltaZ: 0,
        deltaMode: 0
    }),
    gXe = Ll(pXe),
    mXe = [9, 13, 27, 32],
    wF = Oh && "CompositionEvent" in window,
    e_ = null;
Oh && "documentMode" in document && (e_ = document.documentMode);
var yXe = Oh && "TextEvent" in window && !e_,
    hce = Oh && (!wF || e_ && 8 < e_ && 11 >= e_),
    nZ = " ",
    rZ = !1;

function pce(t, e) {
    switch (t) {
        case "keyup":
            return mXe.indexOf(e.keyCode) !== -1;
        case "keydown":
            return e.keyCode !== 229;
        case "keypress":
        case "mousedown":
        case "focusout":
            return !0;
        default:
            return !1
    }
}

function gce(t) {
    return t = t.detail, typeof t == "object" && "data" in t ? t.data : null
}
var $w = !1;

function wXe(t, e) {
    switch (t) {
        case "compositionend":
            return gce(e);
        case "keypress":
            return e.which !== 32 ? null : (rZ = !0, nZ);
        case "textInput":
            return t = e.data, t === nZ && rZ ? null : t;
        default:
            return null
    }
}

function vXe(t, e) {
    if ($w) return t === "compositionend" || !wF && pce(t, e) ? (t = dce(), v8 = gF = hp = null, $w = !1, t) : null;
    switch (t) {
        case "paste":
            return null;
        case "keypress":
            if (!(e.ctrlKey || e.altKey || e.metaKey) || e.ctrlKey && e.altKey) {
                if (e.char && 1 < e.char.length) return e.char;
                if (e.which) return String.fromCharCode(e.which)
            }
            return null;
        case "compositionend":
            return hce && e.locale !== "ko" ? null : e.data;
        default:
            return null
    }
}
var bXe = {
    color: !0,
    date: !0,
    datetime: !0,
    "datetime-local": !0,
    email: !0,
    month: !0,
    number: !0,
    password: !0,
    range: !0,
    search: !0,
    tel: !0,
    text: !0,
    time: !0,
    url: !0,
    week: !0
};

function iZ(t) {
    var e = t && t.nodeName && t.nodeName.toLowerCase();
    return e === "input" ? !!bXe[t.type] : e === "textarea"
}

function mce(t, e, n, r) {
    qle(r), e = hA(e, "onChange"), 0 < e.length && (n = new mF("onChange", "change", null, n, r), t.push({
        event: n,
        listeners: e
    }))
}
var t_ = null,
    v6 = null;

function _Xe(t) {
    Tce(t, 0)
}

function g7(t) {
    var e = Fw(t);
    if (Ule(e)) return t
}

function EXe(t, e) {
    if (t === "change") return e
}
var yce = !1;
if (Oh) {
    var ON;
    if (Oh) {
        var NN = "oninput" in document;
        if (!NN) {
            var sZ = document.createElement("div");
            sZ.setAttribute("oninput", "return;"), NN = typeof sZ.oninput == "function"
        }
        ON = NN
    } else ON = !1;
    yce = ON && (!document.documentMode || 9 < document.documentMode)
}

function oZ() {
    t_ && (t_.detachEvent("onpropertychange", wce), v6 = t_ = null)
}

function wce(t) {
    if (t.propertyName === "value" && g7(v6)) {
        var e = [];
        mce(e, v6, t, uF(t)), Qle(_Xe, e)
    }
}

function xXe(t, e, n) {
    t === "focusin" ? (oZ(), t_ = e, v6 = n, t_.attachEvent("onpropertychange", wce)) : t === "focusout" && oZ()
}

function SXe(t) {
    if (t === "selectionchange" || t === "keyup" || t === "keydown") return g7(v6)
}

function CXe(t, e) {
    if (t === "click") return g7(e)
}

function AXe(t, e) {
    if (t === "input" || t === "change") return g7(e)
}

function TXe(t, e) {
    return t === e && (t !== 0 || 1 / t === 1 / e) || t !== t && e !== e
}
var $u = typeof Object.is == "function" ? Object.is : TXe;

function b6(t, e) {
    if ($u(t, e)) return !0;
    if (typeof t != "object" || t === null || typeof e != "object" || e === null) return !1;
    var n = Object.keys(t),
        r = Object.keys(e);
    if (n.length !== r.length) return !1;
    for (r = 0; r < n.length; r++) {
        var i = n[r];
        if (!DM.call(e, i) || !$u(t[i], e[i])) return !1
    }
    return !0
}

function aZ(t) {
    for (; t && t.firstChild;) t = t.firstChild;
    return t
}

function lZ(t, e) {
    var n = aZ(t);
    t = 0;
    for (var r; n;) {
        if (n.nodeType === 3) {
            if (r = t + n.textContent.length, t <= e && r >= e) return {
                node: n,
                offset: e - t
            };
            t = r
        }
        e: {
            for (; n;) {
                if (n.nextSibling) {
                    n = n.nextSibling;
                    break e
                }
                n = n.parentNode
            }
            n = void 0
        }
        n = aZ(n)
    }
}

function vce(t, e) {
    return t && e ? t === e ? !0 : t && t.nodeType === 3 ? !1 : e && e.nodeType === 3 ? vce(t, e.parentNode) : "contains" in t ? t.contains(e) : t.compareDocumentPosition ? !!(t.compareDocumentPosition(e) & 16) : !1 : !1
}

function bce() {
    for (var t = window, e = oA(); e instanceof t.HTMLIFrameElement;) {
        try {
            var n = typeof e.contentWindow.location.href == "string"
        } catch {
            n = !1
        }
        if (n) t = e.contentWindow;
        else break;
        e = oA(t.document)
    }
    return e
}

function vF(t) {
    var e = t && t.nodeName && t.nodeName.toLowerCase();
    return e && (e === "input" && (t.type === "text" || t.type === "search" || t.type === "tel" || t.type === "url" || t.type === "password") || e === "textarea" || t.contentEditable === "true")
}

function IXe(t) {
    var e = bce(),
        n = t.focusedElem,
        r = t.selectionRange;
    if (e !== n && n && n.ownerDocument && vce(n.ownerDocument.documentElement, n)) {
        if (r !== null && vF(n)) {
            if (e = r.start, t = r.end, t === void 0 && (t = e), "selectionStart" in n) n.selectionStart = e, n.selectionEnd = Math.min(t, n.value.length);
            else if (t = (e = n.ownerDocument || document) && e.defaultView || window, t.getSelection) {
                t = t.getSelection();
                var i = n.textContent.length,
                    s = Math.min(r.start, i);
                r = r.end === void 0 ? s : Math.min(r.end, i), !t.extend && s > r && (i = r, r = s, s = i), i = lZ(n, s);
                var o = lZ(n, r);
                i && o && (t.rangeCount !== 1 || t.anchorNode !== i.node || t.anchorOffset !== i.offset || t.focusNode !== o.node || t.focusOffset !== o.offset) && (e = e.createRange(), e.setStart(i.node, i.offset), t.removeAllRanges(), s > r ? (t.addRange(e), t.extend(o.node, o.offset)) : (e.setEnd(o.node, o.offset), t.addRange(e)))
            }
        }
        for (e = [], t = n; t = t.parentNode;) t.nodeType === 1 && e.push({
            element: t,
            left: t.scrollLeft,
            top: t.scrollTop
        });
        for (typeof n.focus == "function" && n.focus(), n = 0; n < e.length; n++) t = e[n], t.element.scrollLeft = t.left, t.element.scrollTop = t.top
    }
}
var RXe = Oh && "documentMode" in document && 11 >= document.documentMode,
    Lw = null,
    eD = null,
    n_ = null,
    tD = !1;

function cZ(t, e, n) {
    var r = n.window === n ? n.document : n.nodeType === 9 ? n : n.ownerDocument;
    tD || Lw == null || Lw !== oA(r) || (r = Lw, "selectionStart" in r && vF(r) ? r = {
        start: r.selectionStart,
        end: r.selectionEnd
    } : (r = (r.ownerDocument && r.ownerDocument.defaultView || window).getSelection(), r = {
        anchorNode: r.anchorNode,
        anchorOffset: r.anchorOffset,
        focusNode: r.focusNode,
        focusOffset: r.focusOffset
    }), n_ && b6(n_, r) || (n_ = r, r = hA(eD, "onSelect"), 0 < r.length && (e = new mF("onSelect", "select", null, e, n), t.push({
        event: e,
        listeners: r
    }), e.target = Lw)))
}

function xS(t, e) {
    var n = {};
    return n[t.toLowerCase()] = e.toLowerCase(), n["Webkit" + t] = "webkit" + e, n["Moz" + t] = "moz" + e, n
}
var Bw = {
        animationend: xS("Animation", "AnimationEnd"),
        animationiteration: xS("Animation", "AnimationIteration"),
        animationstart: xS("Animation", "AnimationStart"),
        transitionend: xS("Transition", "TransitionEnd")
    },
    PN = {},
    _ce = {};
Oh && (_ce = document.createElement("div").style, "AnimationEvent" in window || (delete Bw.animationend.animation, delete Bw.animationiteration.animation, delete Bw.animationstart.animation), "TransitionEvent" in window || delete Bw.transitionend.transition);

function m7(t) {
    if (PN[t]) return PN[t];
    if (!Bw[t]) return t;
    var e = Bw[t],
        n;
    for (n in e)
        if (e.hasOwnProperty(n) && n in _ce) return PN[t] = e[n];
    return t
}
var Ece = m7("animationend"),
    xce = m7("animationiteration"),
    Sce = m7("animationstart"),
    Cce = m7("transitionend"),
    Ace = new Map,
    uZ = "abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");

function dg(t, e) {
    Ace.set(t, e), Ty(e, [t])
}
for (var kN = 0; kN < uZ.length; kN++) {
    var MN = uZ[kN],
        OXe = MN.toLowerCase(),
        NXe = MN[0].toUpperCase() + MN.slice(1);
    dg(OXe, "on" + NXe)
}
dg(Ece, "onAnimationEnd");
dg(xce, "onAnimationIteration");
dg(Sce, "onAnimationStart");
dg("dblclick", "onDoubleClick");
dg("focusin", "onFocus");
dg("focusout", "onBlur");
dg(Cce, "onTransitionEnd");
g2("onMouseEnter", ["mouseout", "mouseover"]);
g2("onMouseLeave", ["mouseout", "mouseover"]);
g2("onPointerEnter", ["pointerout", "pointerover"]);
g2("onPointerLeave", ["pointerout", "pointerover"]);
Ty("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" "));
Ty("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" "));
Ty("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]);
Ty("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" "));
Ty("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" "));
Ty("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" "));
var P3 = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "),
    PXe = new Set("cancel close invalid load scroll toggle".split(" ").concat(P3));

function fZ(t, e, n) {
    var r = t.type || "unknown-event";
    t.currentTarget = n, OJe(r, e, void 0, t), t.currentTarget = null
}

function Tce(t, e) {
    e = (e & 4) !== 0;
    for (var n = 0; n < t.length; n++) {
        var r = t[n],
            i = r.event;
        r = r.listeners;
        e: {
            var s = void 0;
            if (e)
                for (var o = r.length - 1; 0 <= o; o--) {
                    var a = r[o],
                        l = a.instance,
                        c = a.currentTarget;
                    if (a = a.listener, l !== s && i.isPropagationStopped()) break e;
                    fZ(i, a, c), s = l
                } else
                    for (o = 0; o < r.length; o++) {
                        if (a = r[o], l = a.instance, c = a.currentTarget, a = a.listener, l !== s && i.isPropagationStopped()) break e;
                        fZ(i, a, c), s = l
                    }
        }
    }
    if (lA) throw t = ZM, lA = !1, ZM = null, t
}

function ni(t, e) {
    var n = e[oD];
    n === void 0 && (n = e[oD] = new Set);
    var r = t + "__bubble";
    n.has(r) || (Ice(e, t, 2, !1), n.add(r))
}

function DN(t, e, n) {
    var r = 0;
    e && (r |= 4), Ice(n, t, r, e)
}
var SS = "_reactListening" + Math.random().toString(36).slice(2);

function _6(t) {
    if (!t[SS]) {
        t[SS] = !0, Dle.forEach(function(n) {
            n !== "selectionchange" && (PXe.has(n) || DN(n, !1, t), DN(n, !0, t))
        });
        var e = t.nodeType === 9 ? t : t.ownerDocument;
        e === null || e[SS] || (e[SS] = !0, DN("selectionchange", !1, e))
    }
}

function Ice(t, e, n, r) {
    switch (fce(e)) {
        case 1:
            var i = GJe;
            break;
        case 4:
            i = qJe;
            break;
        default:
            i = pF
    }
    n = i.bind(null, e, n, t), i = void 0, !YM || e !== "touchstart" && e !== "touchmove" && e !== "wheel" || (i = !0), r ? i !== void 0 ? t.addEventListener(e, n, {
        capture: !0,
        passive: i
    }) : t.addEventListener(e, n, !0) : i !== void 0 ? t.addEventListener(e, n, {
        passive: i
    }) : t.addEventListener(e, n, !1)
}

function $N(t, e, n, r, i) {
    var s = r;
    if (!(e & 1) && !(e & 2) && r !== null) e: for (;;) {
        if (r === null) return;
        var o = r.tag;
        if (o === 3 || o === 4) {
            var a = r.stateNode.containerInfo;
            if (a === i || a.nodeType === 8 && a.parentNode === i) break;
            if (o === 4)
                for (o = r.return; o !== null;) {
                    var l = o.tag;
                    if ((l === 3 || l === 4) && (l = o.stateNode.containerInfo, l === i || l.nodeType === 8 && l.parentNode === i)) return;
                    o = o.return
                }
            for (; a !== null;) {
                if (o = m1(a), o === null) return;
                if (l = o.tag, l === 5 || l === 6) {
                    r = s = o;
                    continue e
                }
                a = a.parentNode
            }
        }
        r = r.return
    }
    Qle(function() {
        var c = s,
            u = uF(n),
            f = [];
        e: {
            var h = Ace.get(t);
            if (h !== void 0) {
                var g = mF,
                    y = t;
                switch (t) {
                    case "keypress":
                        if (b8(n) === 0) break e;
                    case "keydown":
                    case "keyup":
                        g = lXe;
                        break;
                    case "focusin":
                        y = "focus", g = RN;
                        break;
                    case "focusout":
                        y = "blur", g = RN;
                        break;
                    case "beforeblur":
                    case "afterblur":
                        g = RN;
                        break;
                    case "click":
                        if (n.button === 2) break e;
                    case "auxclick":
                    case "dblclick":
                    case "mousedown":
                    case "mousemove":
                    case "mouseup":
                    case "mouseout":
                    case "mouseover":
                    case "contextmenu":
                        g = XY;
                        break;
                    case "drag":
                    case "dragend":
                    case "dragenter":
                    case "dragexit":
                    case "dragleave":
                    case "dragover":
                    case "dragstart":
                    case "drop":
                        g = ZJe;
                        break;
                    case "touchcancel":
                    case "touchend":
                    case "touchmove":
                    case "touchstart":
                        g = fXe;
                        break;
                    case Ece:
                    case xce:
                    case Sce:
                        g = XJe;
                        break;
                    case Cce:
                        g = hXe;
                        break;
                    case "scroll":
                        g = KJe;
                        break;
                    case "wheel":
                        g = gXe;
                        break;
                    case "copy":
                    case "cut":
                    case "paste":
                        g = tXe;
                        break;
                    case "gotpointercapture":
                    case "lostpointercapture":
                    case "pointercancel":
                    case "pointerdown":
                    case "pointermove":
                    case "pointerout":
                    case "pointerover":
                    case "pointerup":
                        g = tZ
                }
                var _ = (e & 4) !== 0,
                    C = !_ && t === "scroll",
                    b = _ ? h !== null ? h + "Capture" : null : h;
                _ = [];
                for (var w = c, S; w !== null;) {
                    S = w;
                    var I = S.stateNode;
                    if (S.tag === 5 && I !== null && (S = I, b !== null && (I = g6(w, b), I != null && _.push(E6(w, I, S)))), C) break;
                    w = w.return
                }
                0 < _.length && (h = new g(h, y, null, n, u), f.push({
                    event: h,
                    listeners: _
                }))
            }
        }
        if (!(e & 7)) {
            e: {
                if (h = t === "mouseover" || t === "pointerover", g = t === "mouseout" || t === "pointerout", h && n !== qM && (y = n.relatedTarget || n.fromElement) && (m1(y) || y[Nh])) break e;
                if ((g || h) && (h = u.window === u ? u : (h = u.ownerDocument) ? h.defaultView || h.parentWindow : window, g ? (y = n.relatedTarget || n.toElement, g = c, y = y ? m1(y) : null, y !== null && (C = Iy(y), y !== C || y.tag !== 5 && y.tag !== 6) && (y = null)) : (g = null, y = c), g !== y)) {
                    if (_ = XY, I = "onMouseLeave", b = "onMouseEnter", w = "mouse", (t === "pointerout" || t === "pointerover") && (_ = tZ, I = "onPointerLeave", b = "onPointerEnter", w = "pointer"), C = g == null ? h : Fw(g), S = y == null ? h : Fw(y), h = new _(I, w + "leave", g, n, u), h.target = C, h.relatedTarget = S, I = null, m1(u) === c && (_ = new _(b, w + "enter", y, n, u), _.target = S, _.relatedTarget = C, I = _), C = I, g && y) t: {
                        for (_ = g, b = y, w = 0, S = _; S; S = fw(S)) w++;
                        for (S = 0, I = b; I; I = fw(I)) S++;
                        for (; 0 < w - S;) _ = fw(_),
                        w--;
                        for (; 0 < S - w;) b = fw(b),
                        S--;
                        for (; w--;) {
                            if (_ === b || b !== null && _ === b.alternate) break t;
                            _ = fw(_), b = fw(b)
                        }
                        _ = null
                    }
                    else _ = null;
                    g !== null && dZ(f, h, g, _, !1), y !== null && C !== null && dZ(f, C, y, _, !0)
                }
            }
            e: {
                if (h = c ? Fw(c) : window, g = h.nodeName && h.nodeName.toLowerCase(), g === "select" || g === "input" && h.type === "file") var P = EXe;
                else if (iZ(h))
                    if (yce) P = AXe;
                    else {
                        P = SXe;
                        var M = xXe
                    }
                else(g = h.nodeName) && g.toLowerCase() === "input" && (h.type === "checkbox" || h.type === "radio") && (P = CXe);
                if (P && (P = P(t, c))) {
                    mce(f, P, n, u);
                    break e
                }
                M && M(t, h, c),
                t === "focusout" && (M = h._wrapperState) && M.controlled && h.type === "number" && HM(h, "number", h.value)
            }
            switch (M = c ? Fw(c) : window, t) {
                case "focusin":
                    (iZ(M) || M.contentEditable === "true") && (Lw = M, eD = c, n_ = null);
                    break;
                case "focusout":
                    n_ = eD = Lw = null;
                    break;
                case "mousedown":
                    tD = !0;
                    break;
                case "contextmenu":
                case "mouseup":
                case "dragend":
                    tD = !1, cZ(f, n, u);
                    break;
                case "selectionchange":
                    if (RXe) break;
                case "keydown":
                case "keyup":
                    cZ(f, n, u)
            }
            var A;
            if (wF) e: {
                switch (t) {
                    case "compositionstart":
                        var E = "onCompositionStart";
                        break e;
                    case "compositionend":
                        E = "onCompositionEnd";
                        break e;
                    case "compositionupdate":
                        E = "onCompositionUpdate";
                        break e
                }
                E = void 0
            }
            else $w ? pce(t, n) && (E = "onCompositionEnd") : t === "keydown" && n.keyCode === 229 && (E = "onCompositionStart");E && (hce && n.locale !== "ko" && ($w || E !== "onCompositionStart" ? E === "onCompositionEnd" && $w && (A = dce()) : (hp = u, gF = "value" in hp ? hp.value : hp.textContent, $w = !0)), M = hA(c, E), 0 < M.length && (E = new eZ(E, t, null, n, u), f.push({
                event: E,
                listeners: M
            }), A ? E.data = A : (A = gce(n), A !== null && (E.data = A)))),
            (A = yXe ? wXe(t, n) : vXe(t, n)) && (c = hA(c, "onBeforeInput"), 0 < c.length && (u = new eZ("onBeforeInput", "beforeinput", null, n, u), f.push({
                event: u,
                listeners: c
            }), u.data = A))
        }
        Tce(f, e)
    })
}

function E6(t, e, n) {
    return {
        instance: t,
        listener: e,
        currentTarget: n
    }
}

function hA(t, e) {
    for (var n = e + "Capture", r = []; t !== null;) {
        var i = t,
            s = i.stateNode;
        i.tag === 5 && s !== null && (i = s, s = g6(t, n), s != null && r.unshift(E6(t, s, i)), s = g6(t, e), s != null && r.push(E6(t, s, i))), t = t.return
    }
    return r
}

function fw(t) {
    if (t === null) return null;
    do t = t.return; while (t && t.tag !== 5);
    return t || null
}

function dZ(t, e, n, r, i) {
    for (var s = e._reactName, o = []; n !== null && n !== r;) {
        var a = n,
            l = a.alternate,
            c = a.stateNode;
        if (l !== null && l === r) break;
        a.tag === 5 && c !== null && (a = c, i ? (l = g6(n, s), l != null && o.unshift(E6(n, l, a))) : i || (l = g6(n, s), l != null && o.push(E6(n, l, a)))), n = n.return
    }
    o.length !== 0 && t.push({
        event: e,
        listeners: o
    })
}
var kXe = /\r\n?/g,
    MXe = /\u0000|\uFFFD/g;

function hZ(t) {
    return (typeof t == "string" ? t : "" + t).replace(kXe, `
`).replace(MXe, "")
}

function CS(t, e, n) {
    if (e = hZ(e), hZ(t) !== e && n) throw Error(Ye(425))
}

function pA() {}
var nD = null,
    rD = null;

function iD(t, e) {
    return t === "textarea" || t === "noscript" || typeof e.children == "string" || typeof e.children == "number" || typeof e.dangerouslySetInnerHTML == "object" && e.dangerouslySetInnerHTML !== null && e.dangerouslySetInnerHTML.__html != null
}
var sD = typeof setTimeout == "function" ? setTimeout : void 0,
    DXe = typeof clearTimeout == "function" ? clearTimeout : void 0,
    pZ = typeof Promise == "function" ? Promise : void 0,
    $Xe = typeof queueMicrotask == "function" ? queueMicrotask : typeof pZ < "u" ? function(t) {
        return pZ.resolve(null).then(t).catch(LXe)
    } : sD;

function LXe(t) {
    setTimeout(function() {
        throw t
    })
}

function LN(t, e) {
    var n = e,
        r = 0;
    do {
        var i = n.nextSibling;
        if (t.removeChild(n), i && i.nodeType === 8)
            if (n = i.data, n === "/$") {
                if (r === 0) {
                    t.removeChild(i), w6(e);
                    return
                }
                r--
            } else n !== "$" && n !== "$?" && n !== "$!" || r++;
        n = i
    } while (n);
    w6(e)
}

function Ap(t) {
    for (; t != null; t = t.nextSibling) {
        var e = t.nodeType;
        if (e === 1 || e === 3) break;
        if (e === 8) {
            if (e = t.data, e === "$" || e === "$!" || e === "$?") break;
            if (e === "/$") return null
        }
    }
    return t
}

function gZ(t) {
    t = t.previousSibling;
    for (var e = 0; t;) {
        if (t.nodeType === 8) {
            var n = t.data;
            if (n === "$" || n === "$!" || n === "$?") {
                if (e === 0) return t;
                e--
            } else n === "/$" && e++
        }
        t = t.previousSibling
    }
    return null
}
var Z2 = Math.random().toString(36).slice(2),
    $f = "__reactFiber$" + Z2,
    x6 = "__reactProps$" + Z2,
    Nh = "__reactContainer$" + Z2,
    oD = "__reactEvents$" + Z2,
    BXe = "__reactListeners$" + Z2,
    FXe = "__reactHandles$" + Z2;

function m1(t) {
    var e = t[$f];
    if (e) return e;
    for (var n = t.parentNode; n;) {
        if (e = n[Nh] || n[$f]) {
            if (n = e.alternate, e.child !== null || n !== null && n.child !== null)
                for (t = gZ(t); t !== null;) {
                    if (n = t[$f]) return n;
                    t = gZ(t)
                }
            return e
        }
        t = n, n = t.parentNode
    }
    return null
}

function f4(t) {
    return t = t[$f] || t[Nh], !t || t.tag !== 5 && t.tag !== 6 && t.tag !== 13 && t.tag !== 3 ? null : t
}

function Fw(t) {
    if (t.tag === 5 || t.tag === 6) return t.stateNode;
    throw Error(Ye(33))
}

function y7(t) {
    return t[x6] || null
}
var aD = [],
    Uw = -1;

function hg(t) {
    return {
        current: t
    }
}

function oi(t) {
    0 > Uw || (t.current = aD[Uw], aD[Uw] = null, Uw--)
}

function Yr(t, e) {
    Uw++, aD[Uw] = t.current, t.current = e
}
var Qp = {},
    Lo = hg(Qp),
    Ha = hg(!1),
    zm = Qp;

function m2(t, e) {
    var n = t.type.contextTypes;
    if (!n) return Qp;
    var r = t.stateNode;
    if (r && r.__reactInternalMemoizedUnmaskedChildContext === e) return r.__reactInternalMemoizedMaskedChildContext;
    var i = {},
        s;
    for (s in n) i[s] = e[s];
    return r && (t = t.stateNode, t.__reactInternalMemoizedUnmaskedChildContext = e, t.__reactInternalMemoizedMaskedChildContext = i), i
}

function za(t) {
    return t = t.childContextTypes, t != null
}

function gA() {
    oi(Ha), oi(Lo)
}

function mZ(t, e, n) {
    if (Lo.current !== Qp) throw Error(Ye(168));
    Yr(Lo, e), Yr(Ha, n)
}

function Rce(t, e, n) {
    var r = t.stateNode;
    if (e = e.childContextTypes, typeof r.getChildContext != "function") return n;
    r = r.getChildContext();
    for (var i in r)
        if (!(i in e)) throw Error(Ye(108, xJe(t) || "Unknown", i));
    return Mi({}, n, r)
}

function mA(t) {
    return t = (t = t.stateNode) && t.__reactInternalMemoizedMergedChildContext || Qp, zm = Lo.current, Yr(Lo, t), Yr(Ha, Ha.current), !0
}

function yZ(t, e, n) {
    var r = t.stateNode;
    if (!r) throw Error(Ye(169));
    n ? (t = Rce(t, e, zm), r.__reactInternalMemoizedMergedChildContext = t, oi(Ha), oi(Lo), Yr(Lo, t)) : oi(Ha), Yr(Ha, n)
}
var qd = null,
    w7 = !1,
    BN = !1;

function Oce(t) {
    qd === null ? qd = [t] : qd.push(t)
}

function UXe(t) {
    w7 = !0, Oce(t)
}

function pg() {
    if (!BN && qd !== null) {
        BN = !0;
        var t = 0,
            e = Or;
        try {
            var n = qd;
            for (Or = 1; t < n.length; t++) {
                var r = n[t];
                do r = r(!0); while (r !== null)
            }
            qd = null, w7 = !1
        } catch (i) {
            throw qd !== null && (qd = qd.slice(t + 1)), tce(fF, pg), i
        } finally {
            Or = e, BN = !1
        }
    }
    return null
}
var jw = [],
    Hw = 0,
    yA = null,
    wA = 0,
    yc = [],
    wc = 0,
    Wm = null,
    uh = 1,
    fh = "";

function Gg(t, e) {
    jw[Hw++] = wA, jw[Hw++] = yA, yA = t, wA = e
}

function Nce(t, e, n) {
    yc[wc++] = uh, yc[wc++] = fh, yc[wc++] = Wm, Wm = t;
    var r = uh;
    t = fh;
    var i = 32 - Cu(r) - 1;
    r &= ~(1 << i), n += 1;
    var s = 32 - Cu(e) + i;
    if (30 < s) {
        var o = i - i % 5;
        s = (r & (1 << o) - 1).toString(32), r >>= o, i -= o, uh = 1 << 32 - Cu(e) + i | n << i | r, fh = s + t
    } else uh = 1 << s | n << i | r, fh = t
}

function bF(t) {
    t.return !== null && (Gg(t, 1), Nce(t, 1, 0))
}

function _F(t) {
    for (; t === yA;) yA = jw[--Hw], jw[Hw] = null, wA = jw[--Hw], jw[Hw] = null;
    for (; t === Wm;) Wm = yc[--wc], yc[wc] = null, fh = yc[--wc], yc[wc] = null, uh = yc[--wc], yc[wc] = null
}
var Tl = null,
    Sl = null,
    mi = !1,
    yu = null;

function Pce(t, e) {
    var n = Ec(5, null, null, 0);
    n.elementType = "DELETED", n.stateNode = e, n.return = t, e = t.deletions, e === null ? (t.deletions = [n], t.flags |= 16) : e.push(n)
}

function wZ(t, e) {
    switch (t.tag) {
        case 5:
            var n = t.type;
            return e = e.nodeType !== 1 || n.toLowerCase() !== e.nodeName.toLowerCase() ? null : e, e !== null ? (t.stateNode = e, Tl = t, Sl = Ap(e.firstChild), !0) : !1;
        case 6:
            return e = t.pendingProps === "" || e.nodeType !== 3 ? null : e, e !== null ? (t.stateNode = e, Tl = t, Sl = null, !0) : !1;
        case 13:
            return e = e.nodeType !== 8 ? null : e, e !== null ? (n = Wm !== null ? {
                id: uh,
                overflow: fh
            } : null, t.memoizedState = {
                dehydrated: e,
                treeContext: n,
                retryLane: 1073741824
            }, n = Ec(18, null, null, 0), n.stateNode = e, n.return = t, t.child = n, Tl = t, Sl = null, !0) : !1;
        default:
            return !1
    }
}

function lD(t) {
    return (t.mode & 1) !== 0 && (t.flags & 128) === 0
}

function cD(t) {
    if (mi) {
        var e = Sl;
        if (e) {
            var n = e;
            if (!wZ(t, e)) {
                if (lD(t)) throw Error(Ye(418));
                e = Ap(n.nextSibling);
                var r = Tl;
                e && wZ(t, e) ? Pce(r, n) : (t.flags = t.flags & -4097 | 2, mi = !1, Tl = t)
            }
        } else {
            if (lD(t)) throw Error(Ye(418));
            t.flags = t.flags & -4097 | 2, mi = !1, Tl = t
        }
    }
}

function vZ(t) {
    for (t = t.return; t !== null && t.tag !== 5 && t.tag !== 3 && t.tag !== 13;) t = t.return;
    Tl = t
}

function AS(t) {
    if (t !== Tl) return !1;
    if (!mi) return vZ(t), mi = !0, !1;
    var e;
    if ((e = t.tag !== 3) && !(e = t.tag !== 5) && (e = t.type, e = e !== "head" && e !== "body" && !iD(t.type, t.memoizedProps)), e && (e = Sl)) {
        if (lD(t)) throw kce(), Error(Ye(418));
        for (; e;) Pce(t, e), e = Ap(e.nextSibling)
    }
    if (vZ(t), t.tag === 13) {
        if (t = t.memoizedState, t = t !== null ? t.dehydrated : null, !t) throw Error(Ye(317));
        e: {
            for (t = t.nextSibling, e = 0; t;) {
                if (t.nodeType === 8) {
                    var n = t.data;
                    if (n === "/$") {
                        if (e === 0) {
                            Sl = Ap(t.nextSibling);
                            break e
                        }
                        e--
                    } else n !== "$" && n !== "$!" && n !== "$?" || e++
                }
                t = t.nextSibling
            }
            Sl = null
        }
    } else Sl = Tl ? Ap(t.stateNode.nextSibling) : null;
    return !0
}

function kce() {
    for (var t = Sl; t;) t = Ap(t.nextSibling)
}

function y2() {
    Sl = Tl = null, mi = !1
}

function EF(t) {
    yu === null ? yu = [t] : yu.push(t)
}
var jXe = Wh.ReactCurrentBatchConfig;

function r3(t, e, n) {
    if (t = n.ref, t !== null && typeof t != "function" && typeof t != "object") {
        if (n._owner) {
            if (n = n._owner, n) {
                if (n.tag !== 1) throw Error(Ye(309));
                var r = n.stateNode
            }
            if (!r) throw Error(Ye(147, t));
            var i = r,
                s = "" + t;
            return e !== null && e.ref !== null && typeof e.ref == "function" && e.ref._stringRef === s ? e.ref : (e = function(o) {
                var a = i.refs;
                o === null ? delete a[s] : a[s] = o
            }, e._stringRef = s, e)
        }
        if (typeof t != "string") throw Error(Ye(284));
        if (!n._owner) throw Error(Ye(290, t))
    }
    return t
}

function TS(t, e) {
    throw t = Object.prototype.toString.call(e), Error(Ye(31, t === "[object Object]" ? "object with keys {" + Object.keys(e).join(", ") + "}" : t))
}

function bZ(t) {
    var e = t._init;
    return e(t._payload)
}

function Mce(t) {
    function e(b, w) {
        if (t) {
            var S = b.deletions;
            S === null ? (b.deletions = [w], b.flags |= 16) : S.push(w)
        }
    }

    function n(b, w) {
        if (!t) return null;
        for (; w !== null;) e(b, w), w = w.sibling;
        return null
    }

    function r(b, w) {
        for (b = new Map; w !== null;) w.key !== null ? b.set(w.key, w) : b.set(w.index, w), w = w.sibling;
        return b
    }

    function i(b, w) {
        return b = Op(b, w), b.index = 0, b.sibling = null, b
    }

    function s(b, w, S) {
        return b.index = S, t ? (S = b.alternate, S !== null ? (S = S.index, S < w ? (b.flags |= 2, w) : S) : (b.flags |= 2, w)) : (b.flags |= 1048576, w)
    }

    function o(b) {
        return t && b.alternate === null && (b.flags |= 2), b
    }

    function a(b, w, S, I) {
        return w === null || w.tag !== 6 ? (w = VN(S, b.mode, I), w.return = b, w) : (w = i(w, S), w.return = b, w)
    }

    function l(b, w, S, I) {
        var P = S.type;
        return P === Dw ? u(b, w, S.props.children, I, S.key) : w !== null && (w.elementType === P || typeof P == "object" && P !== null && P.$$typeof === A0 && bZ(P) === w.type) ? (I = i(w, S.props), I.ref = r3(b, w, S), I.return = b, I) : (I = T8(S.type, S.key, S.props, null, b.mode, I), I.ref = r3(b, w, S), I.return = b, I)
    }

    function c(b, w, S, I) {
        return w === null || w.tag !== 4 || w.stateNode.containerInfo !== S.containerInfo || w.stateNode.implementation !== S.implementation ? (w = GN(S, b.mode, I), w.return = b, w) : (w = i(w, S.children || []), w.return = b, w)
    }

    function u(b, w, S, I, P) {
        return w === null || w.tag !== 7 ? (w = om(S, b.mode, I, P), w.return = b, w) : (w = i(w, S), w.return = b, w)
    }

    function f(b, w, S) {
        if (typeof w == "string" && w !== "" || typeof w == "number") return w = VN("" + w, b.mode, S), w.return = b, w;
        if (typeof w == "object" && w !== null) {
            switch (w.$$typeof) {
                case mS:
                    return S = T8(w.type, w.key, w.props, null, b.mode, S), S.ref = r3(b, null, w), S.return = b, S;
                case Mw:
                    return w = GN(w, b.mode, S), w.return = b, w;
                case A0:
                    var I = w._init;
                    return f(b, I(w._payload), S)
            }
            if (O3(w) || J5(w)) return w = om(w, b.mode, S, null), w.return = b, w;
            TS(b, w)
        }
        return null
    }

    function h(b, w, S, I) {
        var P = w !== null ? w.key : null;
        if (typeof S == "string" && S !== "" || typeof S == "number") return P !== null ? null : a(b, w, "" + S, I);
        if (typeof S == "object" && S !== null) {
            switch (S.$$typeof) {
                case mS:
                    return S.key === P ? l(b, w, S, I) : null;
                case Mw:
                    return S.key === P ? c(b, w, S, I) : null;
                case A0:
                    return P = S._init, h(b, w, P(S._payload), I)
            }
            if (O3(S) || J5(S)) return P !== null ? null : u(b, w, S, I, null);
            TS(b, S)
        }
        return null
    }

    function g(b, w, S, I, P) {
        if (typeof I == "string" && I !== "" || typeof I == "number") return b = b.get(S) || null, a(w, b, "" + I, P);
        if (typeof I == "object" && I !== null) {
            switch (I.$$typeof) {
                case mS:
                    return b = b.get(I.key === null ? S : I.key) || null, l(w, b, I, P);
                case Mw:
                    return b = b.get(I.key === null ? S : I.key) || null, c(w, b, I, P);
                case A0:
                    var M = I._init;
                    return g(b, w, S, M(I._payload), P)
            }
            if (O3(I) || J5(I)) return b = b.get(S) || null, u(w, b, I, P, null);
            TS(w, I)
        }
        return null
    }

    function y(b, w, S, I) {
        for (var P = null, M = null, A = w, E = w = 0, $ = null; A !== null && E < S.length; E++) {
            A.index > E ? ($ = A, A = null) : $ = A.sibling;
            var H = h(b, A, S[E], I);
            if (H === null) {
                A === null && (A = $);
                break
            }
            t && A && H.alternate === null && e(b, A), w = s(H, w, E), M === null ? P = H : M.sibling = H, M = H, A = $
        }
        if (E === S.length) return n(b, A), mi && Gg(b, E), P;
        if (A === null) {
            for (; E < S.length; E++) A = f(b, S[E], I), A !== null && (w = s(A, w, E), M === null ? P = A : M.sibling = A, M = A);
            return mi && Gg(b, E), P
        }
        for (A = r(b, A); E < S.length; E++) $ = g(A, b, E, S[E], I), $ !== null && (t && $.alternate !== null && A.delete($.key === null ? E : $.key), w = s($, w, E), M === null ? P = $ : M.sibling = $, M = $);
        return t && A.forEach(function(K) {
            return e(b, K)
        }), mi && Gg(b, E), P
    }

    function _(b, w, S, I) {
        var P = J5(S);
        if (typeof P != "function") throw Error(Ye(150));
        if (S = P.call(S), S == null) throw Error(Ye(151));
        for (var M = P = null, A = w, E = w = 0, $ = null, H = S.next(); A !== null && !H.done; E++, H = S.next()) {
            A.index > E ? ($ = A, A = null) : $ = A.sibling;
            var K = h(b, A, H.value, I);
            if (K === null) {
                A === null && (A = $);
                break
            }
            t && A && K.alternate === null && e(b, A), w = s(K, w, E), M === null ? P = K : M.sibling = K, M = K, A = $
        }
        if (H.done) return n(b, A), mi && Gg(b, E), P;
        if (A === null) {
            for (; !H.done; E++, H = S.next()) H = f(b, H.value, I), H !== null && (w = s(H, w, E), M === null ? P = H : M.sibling = H, M = H);
            return mi && Gg(b, E), P
        }
        for (A = r(b, A); !H.done; E++, H = S.next()) H = g(A, b, E, H.value, I), H !== null && (t && H.alternate !== null && A.delete(H.key === null ? E : H.key), w = s(H, w, E), M === null ? P = H : M.sibling = H, M = H);
        return t && A.forEach(function(te) {
            return e(b, te)
        }), mi && Gg(b, E), P
    }

    function C(b, w, S, I) {
        if (typeof S == "object" && S !== null && S.type === Dw && S.key === null && (S = S.props.children), typeof S == "object" && S !== null) {
            switch (S.$$typeof) {
                case mS:
                    e: {
                        for (var P = S.key, M = w; M !== null;) {
                            if (M.key === P) {
                                if (P = S.type, P === Dw) {
                                    if (M.tag === 7) {
                                        n(b, M.sibling), w = i(M, S.props.children), w.return = b, b = w;
                                        break e
                                    }
                                } else if (M.elementType === P || typeof P == "object" && P !== null && P.$$typeof === A0 && bZ(P) === M.type) {
                                    n(b, M.sibling), w = i(M, S.props), w.ref = r3(b, M, S), w.return = b, b = w;
                                    break e
                                }
                                n(b, M);
                                break
                            } else e(b, M);
                            M = M.sibling
                        }
                        S.type === Dw ? (w = om(S.props.children, b.mode, I, S.key), w.return = b, b = w) : (I = T8(S.type, S.key, S.props, null, b.mode, I), I.ref = r3(b, w, S), I.return = b, b = I)
                    }
                    return o(b);
                case Mw:
                    e: {
                        for (M = S.key; w !== null;) {
                            if (w.key === M)
                                if (w.tag === 4 && w.stateNode.containerInfo === S.containerInfo && w.stateNode.implementation === S.implementation) {
                                    n(b, w.sibling), w = i(w, S.children || []), w.return = b, b = w;
                                    break e
                                } else {
                                    n(b, w);
                                    break
                                }
                            else e(b, w);
                            w = w.sibling
                        }
                        w = GN(S, b.mode, I),
                        w.return = b,
                        b = w
                    }
                    return o(b);
                case A0:
                    return M = S._init, C(b, w, M(S._payload), I)
            }
            if (O3(S)) return y(b, w, S, I);
            if (J5(S)) return _(b, w, S, I);
            TS(b, S)
        }
        return typeof S == "string" && S !== "" || typeof S == "number" ? (S = "" + S, w !== null && w.tag === 6 ? (n(b, w.sibling), w = i(w, S), w.return = b, b = w) : (n(b, w), w = VN(S, b.mode, I), w.return = b, b = w), o(b)) : n(b, w)
    }
    return C
}
var w2 = Mce(!0),
    Dce = Mce(!1),
    vA = hg(null),
    bA = null,
    zw = null,
    xF = null;

function SF() {
    xF = zw = bA = null
}

function CF(t) {
    var e = vA.current;
    oi(vA), t._currentValue = e
}

function uD(t, e, n) {
    for (; t !== null;) {
        var r = t.alternate;
        if ((t.childLanes & e) !== e ? (t.childLanes |= e, r !== null && (r.childLanes |= e)) : r !== null && (r.childLanes & e) !== e && (r.childLanes |= e), t === n) break;
        t = t.return
    }
}

function yv(t, e) {
    bA = t, xF = zw = null, t = t.dependencies, t !== null && t.firstContext !== null && (t.lanes & e && (ja = !0), t.firstContext = null)
}

function Nc(t) {
    var e = t._currentValue;
    if (xF !== t)
        if (t = {
                context: t,
                memoizedValue: e,
                next: null
            }, zw === null) {
            if (bA === null) throw Error(Ye(308));
            zw = t, bA.dependencies = {
                lanes: 0,
                firstContext: t
            }
        } else zw = zw.next = t;
    return e
}
var y1 = null;

function AF(t) {
    y1 === null ? y1 = [t] : y1.push(t)
}

function $ce(t, e, n, r) {
    var i = e.interleaved;
    return i === null ? (n.next = n, AF(e)) : (n.next = i.next, i.next = n), e.interleaved = n, Ph(t, r)
}

function Ph(t, e) {
    t.lanes |= e;
    var n = t.alternate;
    for (n !== null && (n.lanes |= e), n = t, t = t.return; t !== null;) t.childLanes |= e, n = t.alternate, n !== null && (n.childLanes |= e), n = t, t = t.return;
    return n.tag === 3 ? n.stateNode : null
}
var T0 = !1;

function TF(t) {
    t.updateQueue = {
        baseState: t.memoizedState,
        firstBaseUpdate: null,
        lastBaseUpdate: null,
        shared: {
            pending: null,
            interleaved: null,
            lanes: 0
        },
        effects: null
    }
}

function Lce(t, e) {
    t = t.updateQueue, e.updateQueue === t && (e.updateQueue = {
        baseState: t.baseState,
        firstBaseUpdate: t.firstBaseUpdate,
        lastBaseUpdate: t.lastBaseUpdate,
        shared: t.shared,
        effects: t.effects
    })
}

function yh(t, e) {
    return {
        eventTime: t,
        lane: e,
        tag: 0,
        payload: null,
        callback: null,
        next: null
    }
}

function Tp(t, e, n) {
    var r = t.updateQueue;
    if (r === null) return null;
    if (r = r.shared, fr & 2) {
        var i = r.pending;
        return i === null ? e.next = e : (e.next = i.next, i.next = e), r.pending = e, Ph(t, n)
    }
    return i = r.interleaved, i === null ? (e.next = e, AF(r)) : (e.next = i.next, i.next = e), r.interleaved = e, Ph(t, n)
}

function _8(t, e, n) {
    if (e = e.updateQueue, e !== null && (e = e.shared, (n & 4194240) !== 0)) {
        var r = e.lanes;
        r &= t.pendingLanes, n |= r, e.lanes = n, dF(t, n)
    }
}

function _Z(t, e) {
    var n = t.updateQueue,
        r = t.alternate;
    if (r !== null && (r = r.updateQueue, n === r)) {
        var i = null,
            s = null;
        if (n = n.firstBaseUpdate, n !== null) {
            do {
                var o = {
                    eventTime: n.eventTime,
                    lane: n.lane,
                    tag: n.tag,
                    payload: n.payload,
                    callback: n.callback,
                    next: null
                };
                s === null ? i = s = o : s = s.next = o, n = n.next
            } while (n !== null);
            s === null ? i = s = e : s = s.next = e
        } else i = s = e;
        n = {
            baseState: r.baseState,
            firstBaseUpdate: i,
            lastBaseUpdate: s,
            shared: r.shared,
            effects: r.effects
        }, t.updateQueue = n;
        return
    }
    t = n.lastBaseUpdate, t === null ? n.firstBaseUpdate = e : t.next = e, n.lastBaseUpdate = e
}

function _A(t, e, n, r) {
    var i = t.updateQueue;
    T0 = !1;
    var s = i.firstBaseUpdate,
        o = i.lastBaseUpdate,
        a = i.shared.pending;
    if (a !== null) {
        i.shared.pending = null;
        var l = a,
            c = l.next;
        l.next = null, o === null ? s = c : o.next = c, o = l;
        var u = t.alternate;
        u !== null && (u = u.updateQueue, a = u.lastBaseUpdate, a !== o && (a === null ? u.firstBaseUpdate = c : a.next = c, u.lastBaseUpdate = l))
    }
    if (s !== null) {
        var f = i.baseState;
        o = 0, u = c = l = null, a = s;
        do {
            var h = a.lane,
                g = a.eventTime;
            if ((r & h) === h) {
                u !== null && (u = u.next = {
                    eventTime: g,
                    lane: 0,
                    tag: a.tag,
                    payload: a.payload,
                    callback: a.callback,
                    next: null
                });
                e: {
                    var y = t,
                        _ = a;
                    switch (h = e, g = n, _.tag) {
                        case 1:
                            if (y = _.payload, typeof y == "function") {
                                f = y.call(g, f, h);
                                break e
                            }
                            f = y;
                            break e;
                        case 3:
                            y.flags = y.flags & -65537 | 128;
                        case 0:
                            if (y = _.payload, h = typeof y == "function" ? y.call(g, f, h) : y, h == null) break e;
                            f = Mi({}, f, h);
                            break e;
                        case 2:
                            T0 = !0
                    }
                }
                a.callback !== null && a.lane !== 0 && (t.flags |= 64, h = i.effects, h === null ? i.effects = [a] : h.push(a))
            } else g = {
                eventTime: g,
                lane: h,
                tag: a.tag,
                payload: a.payload,
                callback: a.callback,
                next: null
            }, u === null ? (c = u = g, l = f) : u = u.next = g, o |= h;
            if (a = a.next, a === null) {
                if (a = i.shared.pending, a === null) break;
                h = a, a = h.next, h.next = null, i.lastBaseUpdate = h, i.shared.pending = null
            }
        } while (!0);
        if (u === null && (l = f), i.baseState = l, i.firstBaseUpdate = c, i.lastBaseUpdate = u, e = i.shared.interleaved, e !== null) {
            i = e;
            do o |= i.lane, i = i.next; while (i !== e)
        } else s === null && (i.shared.lanes = 0);
        Gm |= o, t.lanes = o, t.memoizedState = f
    }
}

function EZ(t, e, n) {
    if (t = e.effects, e.effects = null, t !== null)
        for (e = 0; e < t.length; e++) {
            var r = t[e],
                i = r.callback;
            if (i !== null) {
                if (r.callback = null, r = n, typeof i != "function") throw Error(Ye(191, i));
                i.call(r)
            }
        }
}
var d4 = {},
    Zf = hg(d4),
    S6 = hg(d4),
    C6 = hg(d4);

function w1(t) {
    if (t === d4) throw Error(Ye(174));
    return t
}

function IF(t, e) {
    switch (Yr(C6, e), Yr(S6, t), Yr(Zf, d4), t = e.nodeType, t) {
        case 9:
        case 11:
            e = (e = e.documentElement) ? e.namespaceURI : WM(null, "");
            break;
        default:
            t = t === 8 ? e.parentNode : e, e = t.namespaceURI || null, t = t.tagName, e = WM(e, t)
    }
    oi(Zf), Yr(Zf, e)
}

function v2() {
    oi(Zf), oi(S6), oi(C6)
}

function Bce(t) {
    w1(C6.current);
    var e = w1(Zf.current),
        n = WM(e, t.type);
    e !== n && (Yr(S6, t), Yr(Zf, n))
}

function RF(t) {
    S6.current === t && (oi(Zf), oi(S6))
}
var Ii = hg(0);

function EA(t) {
    for (var e = t; e !== null;) {
        if (e.tag === 13) {
            var n = e.memoizedState;
            if (n !== null && (n = n.dehydrated, n === null || n.data === "$?" || n.data === "$!")) return e
        } else if (e.tag === 19 && e.memoizedProps.revealOrder !== void 0) {
            if (e.flags & 128) return e
        } else if (e.child !== null) {
            e.child.return = e, e = e.child;
            continue
        }
        if (e === t) break;
        for (; e.sibling === null;) {
            if (e.return === null || e.return === t) return null;
            e = e.return
        }
        e.sibling.return = e.return, e = e.sibling
    }
    return null
}
var FN = [];

function OF() {
    for (var t = 0; t < FN.length; t++) FN[t]._workInProgressVersionPrimary = null;
    FN.length = 0
}
var E8 = Wh.ReactCurrentDispatcher,
    UN = Wh.ReactCurrentBatchConfig,
    Vm = 0,
    Ni = null,
    Rs = null,
    Vs = null,
    xA = !1,
    r_ = !1,
    A6 = 0,
    HXe = 0;

function _o() {
    throw Error(Ye(321))
}

function NF(t, e) {
    if (e === null) return !1;
    for (var n = 0; n < e.length && n < t.length; n++)
        if (!$u(t[n], e[n])) return !1;
    return !0
}

function PF(t, e, n, r, i, s) {
    if (Vm = s, Ni = e, e.memoizedState = null, e.updateQueue = null, e.lanes = 0, E8.current = t === null || t.memoizedState === null ? GXe : qXe, t = n(r, i), r_) {
        s = 0;
        do {
            if (r_ = !1, A6 = 0, 25 <= s) throw Error(Ye(301));
            s += 1, Vs = Rs = null, e.updateQueue = null, E8.current = KXe, t = n(r, i)
        } while (r_)
    }
    if (E8.current = SA, e = Rs !== null && Rs.next !== null, Vm = 0, Vs = Rs = Ni = null, xA = !1, e) throw Error(Ye(300));
    return t
}

function kF() {
    var t = A6 !== 0;
    return A6 = 0, t
}

function gf() {
    var t = {
        memoizedState: null,
        baseState: null,
        baseQueue: null,
        queue: null,
        next: null
    };
    return Vs === null ? Ni.memoizedState = Vs = t : Vs = Vs.next = t, Vs
}

function Pc() {
    if (Rs === null) {
        var t = Ni.alternate;
        t = t !== null ? t.memoizedState : null
    } else t = Rs.next;
    var e = Vs === null ? Ni.memoizedState : Vs.next;
    if (e !== null) Vs = e, Rs = t;
    else {
        if (t === null) throw Error(Ye(310));
        Rs = t, t = {
            memoizedState: Rs.memoizedState,
            baseState: Rs.baseState,
            baseQueue: Rs.baseQueue,
            queue: Rs.queue,
            next: null
        }, Vs === null ? Ni.memoizedState = Vs = t : Vs = Vs.next = t
    }
    return Vs
}

function T6(t, e) {
    return typeof e == "function" ? e(t) : e
}

function jN(t) {
    var e = Pc(),
        n = e.queue;
    if (n === null) throw Error(Ye(311));
    n.lastRenderedReducer = t;
    var r = Rs,
        i = r.baseQueue,
        s = n.pending;
    if (s !== null) {
        if (i !== null) {
            var o = i.next;
            i.next = s.next, s.next = o
        }
        r.baseQueue = i = s, n.pending = null
    }
    if (i !== null) {
        s = i.next, r = r.baseState;
        var a = o = null,
            l = null,
            c = s;
        do {
            var u = c.lane;
            if ((Vm & u) === u) l !== null && (l = l.next = {
                lane: 0,
                action: c.action,
                hasEagerState: c.hasEagerState,
                eagerState: c.eagerState,
                next: null
            }), r = c.hasEagerState ? c.eagerState : t(r, c.action);
            else {
                var f = {
                    lane: u,
                    action: c.action,
                    hasEagerState: c.hasEagerState,
                    eagerState: c.eagerState,
                    next: null
                };
                l === null ? (a = l = f, o = r) : l = l.next = f, Ni.lanes |= u, Gm |= u
            }
            c = c.next
        } while (c !== null && c !== s);
        l === null ? o = r : l.next = a, $u(r, e.memoizedState) || (ja = !0), e.memoizedState = r, e.baseState = o, e.baseQueue = l, n.lastRenderedState = r
    }
    if (t = n.interleaved, t !== null) {
        i = t;
        do s = i.lane, Ni.lanes |= s, Gm |= s, i = i.next; while (i !== t)
    } else i === null && (n.lanes = 0);
    return [e.memoizedState, n.dispatch]
}

function HN(t) {
    var e = Pc(),
        n = e.queue;
    if (n === null) throw Error(Ye(311));
    n.lastRenderedReducer = t;
    var r = n.dispatch,
        i = n.pending,
        s = e.memoizedState;
    if (i !== null) {
        n.pending = null;
        var o = i = i.next;
        do s = t(s, o.action), o = o.next; while (o !== i);
        $u(s, e.memoizedState) || (ja = !0), e.memoizedState = s, e.baseQueue === null && (e.baseState = s), n.lastRenderedState = s
    }
    return [s, r]
}

function Fce() {}

function Uce(t, e) {
    var n = Ni,
        r = Pc(),
        i = e(),
        s = !$u(r.memoizedState, i);
    if (s && (r.memoizedState = i, ja = !0), r = r.queue, MF(zce.bind(null, n, r, t), [t]), r.getSnapshot !== e || s || Vs !== null && Vs.memoizedState.tag & 1) {
        if (n.flags |= 2048, I6(9, Hce.bind(null, n, r, i, e), void 0, null), Zs === null) throw Error(Ye(349));
        Vm & 30 || jce(n, e, i)
    }
    return i
}

function jce(t, e, n) {
    t.flags |= 16384, t = {
        getSnapshot: e,
        value: n
    }, e = Ni.updateQueue, e === null ? (e = {
        lastEffect: null,
        stores: null
    }, Ni.updateQueue = e, e.stores = [t]) : (n = e.stores, n === null ? e.stores = [t] : n.push(t))
}

function Hce(t, e, n, r) {
    e.value = n, e.getSnapshot = r, Wce(e) && Vce(t)
}

function zce(t, e, n) {
    return n(function() {
        Wce(e) && Vce(t)
    })
}

function Wce(t) {
    var e = t.getSnapshot;
    t = t.value;
    try {
        var n = e();
        return !$u(t, n)
    } catch {
        return !0
    }
}

function Vce(t) {
    var e = Ph(t, 1);
    e !== null && Au(e, t, 1, -1)
}

function xZ(t) {
    var e = gf();
    return typeof t == "function" && (t = t()), e.memoizedState = e.baseState = t, t = {
        pending: null,
        interleaved: null,
        lanes: 0,
        dispatch: null,
        lastRenderedReducer: T6,
        lastRenderedState: t
    }, e.queue = t, t = t.dispatch = VXe.bind(null, Ni, t), [e.memoizedState, t]
}

function I6(t, e, n, r) {
    return t = {
        tag: t,
        create: e,
        destroy: n,
        deps: r,
        next: null
    }, e = Ni.updateQueue, e === null ? (e = {
        lastEffect: null,
        stores: null
    }, Ni.updateQueue = e, e.lastEffect = t.next = t) : (n = e.lastEffect, n === null ? e.lastEffect = t.next = t : (r = n.next, n.next = t, t.next = r, e.lastEffect = t)), t
}

function Gce() {
    return Pc().memoizedState
}

function x8(t, e, n, r) {
    var i = gf();
    Ni.flags |= t, i.memoizedState = I6(1 | e, n, void 0, r === void 0 ? null : r)
}

function v7(t, e, n, r) {
    var i = Pc();
    r = r === void 0 ? null : r;
    var s = void 0;
    if (Rs !== null) {
        var o = Rs.memoizedState;
        if (s = o.destroy, r !== null && NF(r, o.deps)) {
            i.memoizedState = I6(e, n, s, r);
            return
        }
    }
    Ni.flags |= t, i.memoizedState = I6(1 | e, n, s, r)
}

function SZ(t, e) {
    return x8(8390656, 8, t, e)
}

function MF(t, e) {
    return v7(2048, 8, t, e)
}

function qce(t, e) {
    return v7(4, 2, t, e)
}

function Kce(t, e) {
    return v7(4, 4, t, e)
}

function Yce(t, e) {
    if (typeof e == "function") return t = t(), e(t),
        function() {
            e(null)
        };
    if (e != null) return t = t(), e.current = t,
        function() {
            e.current = null
        }
}

function Zce(t, e, n) {
    return n = n != null ? n.concat([t]) : null, v7(4, 4, Yce.bind(null, e, t), n)
}

function DF() {}

function Qce(t, e) {
    var n = Pc();
    e = e === void 0 ? null : e;
    var r = n.memoizedState;
    return r !== null && e !== null && NF(e, r[1]) ? r[0] : (n.memoizedState = [t, e], t)
}

function Jce(t, e) {
    var n = Pc();
    e = e === void 0 ? null : e;
    var r = n.memoizedState;
    return r !== null && e !== null && NF(e, r[1]) ? r[0] : (t = t(), n.memoizedState = [t, e], t)
}

function Xce(t, e, n) {
    return Vm & 21 ? ($u(n, e) || (n = ice(), Ni.lanes |= n, Gm |= n, t.baseState = !0), e) : (t.baseState && (t.baseState = !1, ja = !0), t.memoizedState = n)
}

function zXe(t, e) {
    var n = Or;
    Or = n !== 0 && 4 > n ? n : 4, t(!0);
    var r = UN.transition;
    UN.transition = {};
    try {
        t(!1), e()
    } finally {
        Or = n, UN.transition = r
    }
}

function eue() {
    return Pc().memoizedState
}

function WXe(t, e, n) {
    var r = Rp(t);
    if (n = {
            lane: r,
            action: n,
            hasEagerState: !1,
            eagerState: null,
            next: null
        }, tue(t)) nue(e, n);
    else if (n = $ce(t, e, n, r), n !== null) {
        var i = ua();
        Au(n, t, r, i), rue(n, e, r)
    }
}

function VXe(t, e, n) {
    var r = Rp(t),
        i = {
            lane: r,
            action: n,
            hasEagerState: !1,
            eagerState: null,
            next: null
        };
    if (tue(t)) nue(e, i);
    else {
        var s = t.alternate;
        if (t.lanes === 0 && (s === null || s.lanes === 0) && (s = e.lastRenderedReducer, s !== null)) try {
            var o = e.lastRenderedState,
                a = s(o, n);
            if (i.hasEagerState = !0, i.eagerState = a, $u(a, o)) {
                var l = e.interleaved;
                l === null ? (i.next = i, AF(e)) : (i.next = l.next, l.next = i), e.interleaved = i;
                return
            }
        } catch {} finally {}
        n = $ce(t, e, i, r), n !== null && (i = ua(), Au(n, t, r, i), rue(n, e, r))
    }
}

function tue(t) {
    var e = t.alternate;
    return t === Ni || e !== null && e === Ni
}

function nue(t, e) {
    r_ = xA = !0;
    var n = t.pending;
    n === null ? e.next = e : (e.next = n.next, n.next = e), t.pending = e
}

function rue(t, e, n) {
    if (n & 4194240) {
        var r = e.lanes;
        r &= t.pendingLanes, n |= r, e.lanes = n, dF(t, n)
    }
}
var SA = {
        readContext: Nc,
        useCallback: _o,
        useContext: _o,
        useEffect: _o,
        useImperativeHandle: _o,
        useInsertionEffect: _o,
        useLayoutEffect: _o,
        useMemo: _o,
        useReducer: _o,
        useRef: _o,
        useState: _o,
        useDebugValue: _o,
        useDeferredValue: _o,
        useTransition: _o,
        useMutableSource: _o,
        useSyncExternalStore: _o,
        useId: _o,
        unstable_isNewReconciler: !1
    },
    GXe = {
        readContext: Nc,
        useCallback: function(t, e) {
            return gf().memoizedState = [t, e === void 0 ? null : e], t
        },
        useContext: Nc,
        useEffect: SZ,
        useImperativeHandle: function(t, e, n) {
            return n = n != null ? n.concat([t]) : null, x8(4194308, 4, Yce.bind(null, e, t), n)
        },
        useLayoutEffect: function(t, e) {
            return x8(4194308, 4, t, e)
        },
        useInsertionEffect: function(t, e) {
            return x8(4, 2, t, e)
        },
        useMemo: function(t, e) {
            var n = gf();
            return e = e === void 0 ? null : e, t = t(), n.memoizedState = [t, e], t
        },
        useReducer: function(t, e, n) {
            var r = gf();
            return e = n !== void 0 ? n(e) : e, r.memoizedState = r.baseState = e, t = {
                pending: null,
                interleaved: null,
                lanes: 0,
                dispatch: null,
                lastRenderedReducer: t,
                lastRenderedState: e
            }, r.queue = t, t = t.dispatch = WXe.bind(null, Ni, t), [r.memoizedState, t]
        },
        useRef: function(t) {
            var e = gf();
            return t = {
                current: t
            }, e.memoizedState = t
        },
        useState: xZ,
        useDebugValue: DF,
        useDeferredValue: function(t) {
            return gf().memoizedState = t
        },
        useTransition: function() {
            var t = xZ(!1),
                e = t[0];
            return t = zXe.bind(null, t[1]), gf().memoizedState = t, [e, t]
        },
        useMutableSource: function() {},
        useSyncExternalStore: function(t, e, n) {
            var r = Ni,
                i = gf();
            if (mi) {
                if (n === void 0) throw Error(Ye(407));
                n = n()
            } else {
                if (n = e(), Zs === null) throw Error(Ye(349));
                Vm & 30 || jce(r, e, n)
            }
            i.memoizedState = n;
            var s = {
                value: n,
                getSnapshot: e
            };
            return i.queue = s, SZ(zce.bind(null, r, s, t), [t]), r.flags |= 2048, I6(9, Hce.bind(null, r, s, n, e), void 0, null), n
        },
        useId: function() {
            var t = gf(),
                e = Zs.identifierPrefix;
            if (mi) {
                var n = fh,
                    r = uh;
                n = (r & ~(1 << 32 - Cu(r) - 1)).toString(32) + n, e = ":" + e + "R" + n, n = A6++, 0 < n && (e += "H" + n.toString(32)), e += ":"
            } else n = HXe++, e = ":" + e + "r" + n.toString(32) + ":";
            return t.memoizedState = e
        },
        unstable_isNewReconciler: !1
    },
    qXe = {
        readContext: Nc,
        useCallback: Qce,
        useContext: Nc,
        useEffect: MF,
        useImperativeHandle: Zce,
        useInsertionEffect: qce,
        useLayoutEffect: Kce,
        useMemo: Jce,
        useReducer: jN,
        useRef: Gce,
        useState: function() {
            return jN(T6)
        },
        useDebugValue: DF,
        useDeferredValue: function(t) {
            var e = Pc();
            return Xce(e, Rs.memoizedState, t)
        },
        useTransition: function() {
            var t = jN(T6)[0],
                e = Pc().memoizedState;
            return [t, e]
        },
        useMutableSource: Fce,
        useSyncExternalStore: Uce,
        useId: eue,
        unstable_isNewReconciler: !1
    },
    KXe = {
        readContext: Nc,
        useCallback: Qce,
        useContext: Nc,
        useEffect: MF,
        useImperativeHandle: Zce,
        useInsertionEffect: qce,
        useLayoutEffect: Kce,
        useMemo: Jce,
        useReducer: HN,
        useRef: Gce,
        useState: function() {
            return HN(T6)
        },
        useDebugValue: DF,
        useDeferredValue: function(t) {
            var e = Pc();
            return Rs === null ? e.memoizedState = t : Xce(e, Rs.memoizedState, t)
        },
        useTransition: function() {
            var t = HN(T6)[0],
                e = Pc().memoizedState;
            return [t, e]
        },
        useMutableSource: Fce,
        useSyncExternalStore: Uce,
        useId: eue,
        unstable_isNewReconciler: !1
    };

function iu(t, e) {
    if (t && t.defaultProps) {
        e = Mi({}, e), t = t.defaultProps;
        for (var n in t) e[n] === void 0 && (e[n] = t[n]);
        return e
    }
    return e
}

function fD(t, e, n, r) {
    e = t.memoizedState, n = n(r, e), n = n == null ? e : Mi({}, e, n), t.memoizedState = n, t.lanes === 0 && (t.updateQueue.baseState = n)
}
var b7 = {
    isMounted: function(t) {
        return (t = t._reactInternals) ? Iy(t) === t : !1
    },
    enqueueSetState: function(t, e, n) {
        t = t._reactInternals;
        var r = ua(),
            i = Rp(t),
            s = yh(r, i);
        s.payload = e, n != null && (s.callback = n), e = Tp(t, s, i), e !== null && (Au(e, t, i, r), _8(e, t, i))
    },
    enqueueReplaceState: function(t, e, n) {
        t = t._reactInternals;
        var r = ua(),
            i = Rp(t),
            s = yh(r, i);
        s.tag = 1, s.payload = e, n != null && (s.callback = n), e = Tp(t, s, i), e !== null && (Au(e, t, i, r), _8(e, t, i))
    },
    enqueueForceUpdate: function(t, e) {
        t = t._reactInternals;
        var n = ua(),
            r = Rp(t),
            i = yh(n, r);
        i.tag = 2, e != null && (i.callback = e), e = Tp(t, i, r), e !== null && (Au(e, t, r, n), _8(e, t, r))
    }
};

function CZ(t, e, n, r, i, s, o) {
    return t = t.stateNode, typeof t.shouldComponentUpdate == "function" ? t.shouldComponentUpdate(r, s, o) : e.prototype && e.prototype.isPureReactComponent ? !b6(n, r) || !b6(i, s) : !0
}

function iue(t, e, n) {
    var r = !1,
        i = Qp,
        s = e.contextType;
    return typeof s == "object" && s !== null ? s = Nc(s) : (i = za(e) ? zm : Lo.current, r = e.contextTypes, s = (r = r != null) ? m2(t, i) : Qp), e = new e(n, s), t.memoizedState = e.state !== null && e.state !== void 0 ? e.state : null, e.updater = b7, t.stateNode = e, e._reactInternals = t, r && (t = t.stateNode, t.__reactInternalMemoizedUnmaskedChildContext = i, t.__reactInternalMemoizedMaskedChildContext = s), e
}

function AZ(t, e, n, r) {
    t = e.state, typeof e.componentWillReceiveProps == "function" && e.componentWillReceiveProps(n, r), typeof e.UNSAFE_componentWillReceiveProps == "function" && e.UNSAFE_componentWillReceiveProps(n, r), e.state !== t && b7.enqueueReplaceState(e, e.state, null)
}

function dD(t, e, n, r) {
    var i = t.stateNode;
    i.props = n, i.state = t.memoizedState, i.refs = {}, TF(t);
    var s = e.contextType;
    typeof s == "object" && s !== null ? i.context = Nc(s) : (s = za(e) ? zm : Lo.current, i.context = m2(t, s)), i.state = t.memoizedState, s = e.getDerivedStateFromProps, typeof s == "function" && (fD(t, e, s, n), i.state = t.memoizedState), typeof e.getDerivedStateFromProps == "function" || typeof i.getSnapshotBeforeUpdate == "function" || typeof i.UNSAFE_componentWillMount != "function" && typeof i.componentWillMount != "function" || (e = i.state, typeof i.componentWillMount == "function" && i.componentWillMount(), typeof i.UNSAFE_componentWillMount == "function" && i.UNSAFE_componentWillMount(), e !== i.state && b7.enqueueReplaceState(i, i.state, null), _A(t, n, i, r), i.state = t.memoizedState), typeof i.componentDidMount == "function" && (t.flags |= 4194308)
}

function b2(t, e) {
    try {
        var n = "",
            r = e;
        do n += EJe(r), r = r.return; while (r);
        var i = n
    } catch (s) {
        i = `
Error generating stack: ` + s.message + `
` + s.stack
    }
    return {
        value: t,
        source: e,
        stack: i,
        digest: null
    }
}

function zN(t, e, n) {
    return {
        value: t,
        source: null,
        stack: n ? ? null,
        digest: e ? ? null
    }
}

function hD(t, e) {
    try {
        console.error(e.value)
    } catch (n) {
        setTimeout(function() {
            throw n
        })
    }
}
var YXe = typeof WeakMap == "function" ? WeakMap : Map;

function sue(t, e, n) {
    n = yh(-1, n), n.tag = 3, n.payload = {
        element: null
    };
    var r = e.value;
    return n.callback = function() {
        AA || (AA = !0, xD = r), hD(t, e)
    }, n
}

function oue(t, e, n) {
    n = yh(-1, n), n.tag = 3;
    var r = t.type.getDerivedStateFromError;
    if (typeof r == "function") {
        var i = e.value;
        n.payload = function() {
            return r(i)
        }, n.callback = function() {
            hD(t, e)
        }
    }
    var s = t.stateNode;
    return s !== null && typeof s.componentDidCatch == "function" && (n.callback = function() {
        hD(t, e), typeof r != "function" && (Ip === null ? Ip = new Set([this]) : Ip.add(this));
        var o = e.stack;
        this.componentDidCatch(e.value, {
            componentStack: o !== null ? o : ""
        })
    }), n
}

function TZ(t, e, n) {
    var r = t.pingCache;
    if (r === null) {
        r = t.pingCache = new YXe;
        var i = new Set;
        r.set(e, i)
    } else i = r.get(e), i === void 0 && (i = new Set, r.set(e, i));
    i.has(n) || (i.add(n), t = uet.bind(null, t, e, n), e.then(t, t))
}

function IZ(t) {
    do {
        var e;
        if ((e = t.tag === 13) && (e = t.memoizedState, e = e !== null ? e.dehydrated !== null : !0), e) return t;
        t = t.return
    } while (t !== null);
    return null
}

function RZ(t, e, n, r, i) {
    return t.mode & 1 ? (t.flags |= 65536, t.lanes = i, t) : (t === e ? t.flags |= 65536 : (t.flags |= 128, n.flags |= 131072, n.flags &= -52805, n.tag === 1 && (n.alternate === null ? n.tag = 17 : (e = yh(-1, 1), e.tag = 2, Tp(n, e, 1))), n.lanes |= 1), t)
}
var ZXe = Wh.ReactCurrentOwner,
    ja = !1;

function ea(t, e, n, r) {
    e.child = t === null ? Dce(e, null, n, r) : w2(e, t.child, n, r)
}

function OZ(t, e, n, r, i) {
    n = n.render;
    var s = e.ref;
    return yv(e, i), r = PF(t, e, n, r, s, i), n = kF(), t !== null && !ja ? (e.updateQueue = t.updateQueue, e.flags &= -2053, t.lanes &= ~i, kh(t, e, i)) : (mi && n && bF(e), e.flags |= 1, ea(t, e, r, i), e.child)
}

function NZ(t, e, n, r, i) {
    if (t === null) {
        var s = n.type;
        return typeof s == "function" && !zF(s) && s.defaultProps === void 0 && n.compare === null && n.defaultProps === void 0 ? (e.tag = 15, e.type = s, aue(t, e, s, r, i)) : (t = T8(n.type, null, r, e, e.mode, i), t.ref = e.ref, t.return = e, e.child = t)
    }
    if (s = t.child, !(t.lanes & i)) {
        var o = s.memoizedProps;
        if (n = n.compare, n = n !== null ? n : b6, n(o, r) && t.ref === e.ref) return kh(t, e, i)
    }
    return e.flags |= 1, t = Op(s, r), t.ref = e.ref, t.return = e, e.child = t
}

function aue(t, e, n, r, i) {
    if (t !== null) {
        var s = t.memoizedProps;
        if (b6(s, r) && t.ref === e.ref)
            if (ja = !1, e.pendingProps = r = s, (t.lanes & i) !== 0) t.flags & 131072 && (ja = !0);
            else return e.lanes = t.lanes, kh(t, e, i)
    }
    return pD(t, e, n, r, i)
}

function lue(t, e, n) {
    var r = e.pendingProps,
        i = r.children,
        s = t !== null ? t.memoizedState : null;
    if (r.mode === "hidden")
        if (!(e.mode & 1)) e.memoizedState = {
            baseLanes: 0,
            cachePool: null,
            transitions: null
        }, Yr(Vw, vl), vl |= n;
        else {
            if (!(n & 1073741824)) return t = s !== null ? s.baseLanes | n : n, e.lanes = e.childLanes = 1073741824, e.memoizedState = {
                baseLanes: t,
                cachePool: null,
                transitions: null
            }, e.updateQueue = null, Yr(Vw, vl), vl |= t, null;
            e.memoizedState = {
                baseLanes: 0,
                cachePool: null,
                transitions: null
            }, r = s !== null ? s.baseLanes : n, Yr(Vw, vl), vl |= r
        }
    else s !== null ? (r = s.baseLanes | n, e.memoizedState = null) : r = n, Yr(Vw, vl), vl |= r;
    return ea(t, e, i, n), e.child
}

function cue(t, e) {
    var n = e.ref;
    (t === null && n !== null || t !== null && t.ref !== n) && (e.flags |= 512, e.flags |= 2097152)
}

function pD(t, e, n, r, i) {
    var s = za(n) ? zm : Lo.current;
    return s = m2(e, s), yv(e, i), n = PF(t, e, n, r, s, i), r = kF(), t !== null && !ja ? (e.updateQueue = t.updateQueue, e.flags &= -2053, t.lanes &= ~i, kh(t, e, i)) : (mi && r && bF(e), e.flags |= 1, ea(t, e, n, i), e.child)
}

function PZ(t, e, n, r, i) {
    if (za(n)) {
        var s = !0;
        mA(e)
    } else s = !1;
    if (yv(e, i), e.stateNode === null) S8(t, e), iue(e, n, r), dD(e, n, r, i), r = !0;
    else if (t === null) {
        var o = e.stateNode,
            a = e.memoizedProps;
        o.props = a;
        var l = o.context,
            c = n.contextType;
        typeof c == "object" && c !== null ? c = Nc(c) : (c = za(n) ? zm : Lo.current, c = m2(e, c));
        var u = n.getDerivedStateFromProps,
            f = typeof u == "function" || typeof o.getSnapshotBeforeUpdate == "function";
        f || typeof o.UNSAFE_componentWillReceiveProps != "function" && typeof o.componentWillReceiveProps != "function" || (a !== r || l !== c) && AZ(e, o, r, c), T0 = !1;
        var h = e.memoizedState;
        o.state = h, _A(e, r, o, i), l = e.memoizedState, a !== r || h !== l || Ha.current || T0 ? (typeof u == "function" && (fD(e, n, u, r), l = e.memoizedState), (a = T0 || CZ(e, n, a, r, h, l, c)) ? (f || typeof o.UNSAFE_componentWillMount != "function" && typeof o.componentWillMount != "function" || (typeof o.componentWillMount == "function" && o.componentWillMount(), typeof o.UNSAFE_componentWillMount == "function" && o.UNSAFE_componentWillMount()), typeof o.componentDidMount == "function" && (e.flags |= 4194308)) : (typeof o.componentDidMount == "function" && (e.flags |= 4194308), e.memoizedProps = r, e.memoizedState = l), o.props = r, o.state = l, o.context = c, r = a) : (typeof o.componentDidMount == "function" && (e.flags |= 4194308), r = !1)
    } else {
        o = e.stateNode, Lce(t, e), a = e.memoizedProps, c = e.type === e.elementType ? a : iu(e.type, a), o.props = c, f = e.pendingProps, h = o.context, l = n.contextType, typeof l == "object" && l !== null ? l = Nc(l) : (l = za(n) ? zm : Lo.current, l = m2(e, l));
        var g = n.getDerivedStateFromProps;
        (u = typeof g == "function" || typeof o.getSnapshotBeforeUpdate == "function") || typeof o.UNSAFE_componentWillReceiveProps != "function" && typeof o.componentWillReceiveProps != "function" || (a !== f || h !== l) && AZ(e, o, r, l), T0 = !1, h = e.memoizedState, o.state = h, _A(e, r, o, i);
        var y = e.memoizedState;
        a !== f || h !== y || Ha.current || T0 ? (typeof g == "function" && (fD(e, n, g, r), y = e.memoizedState), (c = T0 || CZ(e, n, c, r, h, y, l) || !1) ? (u || typeof o.UNSAFE_componentWillUpdate != "function" && typeof o.componentWillUpdate != "function" || (typeof o.componentWillUpdate == "function" && o.componentWillUpdate(r, y, l), typeof o.UNSAFE_componentWillUpdate == "function" && o.UNSAFE_componentWillUpdate(r, y, l)), typeof o.componentDidUpdate == "function" && (e.flags |= 4), typeof o.getSnapshotBeforeUpdate == "function" && (e.flags |= 1024)) : (typeof o.componentDidUpdate != "function" || a === t.memoizedProps && h === t.memoizedState || (e.flags |= 4), typeof o.getSnapshotBeforeUpdate != "function" || a === t.memoizedProps && h === t.memoizedState || (e.flags |= 1024), e.memoizedProps = r, e.memoizedState = y), o.props = r, o.state = y, o.context = l, r = c) : (typeof o.componentDidUpdate != "function" || a === t.memoizedProps && h === t.memoizedState || (e.flags |= 4), typeof o.getSnapshotBeforeUpdate != "function" || a === t.memoizedProps && h === t.memoizedState || (e.flags |= 1024), r = !1)
    }
    return gD(t, e, n, r, s, i)
}

function gD(t, e, n, r, i, s) {
    cue(t, e);
    var o = (e.flags & 128) !== 0;
    if (!r && !o) return i && yZ(e, n, !1), kh(t, e, s);
    r = e.stateNode, ZXe.current = e;
    var a = o && typeof n.getDerivedStateFromError != "function" ? null : r.render();
    return e.flags |= 1, t !== null && o ? (e.child = w2(e, t.child, null, s), e.child = w2(e, null, a, s)) : ea(t, e, a, s), e.memoizedState = r.state, i && yZ(e, n, !0), e.child
}

function uue(t) {
    var e = t.stateNode;
    e.pendingContext ? mZ(t, e.pendingContext, e.pendingContext !== e.context) : e.context && mZ(t, e.context, !1), IF(t, e.containerInfo)
}

function kZ(t, e, n, r, i) {
    return y2(), EF(i), e.flags |= 256, ea(t, e, n, r), e.child
}
var mD = {
    dehydrated: null,
    treeContext: null,
    retryLane: 0
};

function yD(t) {
    return {
        baseLanes: t,
        cachePool: null,
        transitions: null
    }
}

function fue(t, e, n) {
    var r = e.pendingProps,
        i = Ii.current,
        s = !1,
        o = (e.flags & 128) !== 0,
        a;
    if ((a = o) || (a = t !== null && t.memoizedState === null ? !1 : (i & 2) !== 0), a ? (s = !0, e.flags &= -129) : (t === null || t.memoizedState !== null) && (i |= 1), Yr(Ii, i & 1), t === null) return cD(e), t = e.memoizedState, t !== null && (t = t.dehydrated, t !== null) ? (e.mode & 1 ? t.data === "$!" ? e.lanes = 8 : e.lanes = 1073741824 : e.lanes = 1, null) : (o = r.children, t = r.fallback, s ? (r = e.mode, s = e.child, o = {
        mode: "hidden",
        children: o
    }, !(r & 1) && s !== null ? (s.childLanes = 0, s.pendingProps = o) : s = x7(o, r, 0, null), t = om(t, r, n, null), s.return = e, t.return = e, s.sibling = t, e.child = s, e.child.memoizedState = yD(n), e.memoizedState = mD, t) : $F(e, o));
    if (i = t.memoizedState, i !== null && (a = i.dehydrated, a !== null)) return QXe(t, e, o, r, a, i, n);
    if (s) {
        s = r.fallback, o = e.mode, i = t.child, a = i.sibling;
        var l = {
            mode: "hidden",
            children: r.children
        };
        return !(o & 1) && e.child !== i ? (r = e.child, r.childLanes = 0, r.pendingProps = l, e.deletions = null) : (r = Op(i, l), r.subtreeFlags = i.subtreeFlags & 14680064), a !== null ? s = Op(a, s) : (s = om(s, o, n, null), s.flags |= 2), s.return = e, r.return = e, r.sibling = s, e.child = r, r = s, s = e.child, o = t.child.memoizedState, o = o === null ? yD(n) : {
            baseLanes: o.baseLanes | n,
            cachePool: null,
            transitions: o.transitions
        }, s.memoizedState = o, s.childLanes = t.childLanes & ~n, e.memoizedState = mD, r
    }
    return s = t.child, t = s.sibling, r = Op(s, {
        mode: "visible",
        children: r.children
    }), !(e.mode & 1) && (r.lanes = n), r.return = e, r.sibling = null, t !== null && (n = e.deletions, n === null ? (e.deletions = [t], e.flags |= 16) : n.push(t)), e.child = r, e.memoizedState = null, r
}

function $F(t, e) {
    return e = x7({
        mode: "visible",
        children: e
    }, t.mode, 0, null), e.return = t, t.child = e
}

function IS(t, e, n, r) {
    return r !== null && EF(r), w2(e, t.child, null, n), t = $F(e, e.pendingProps.children), t.flags |= 2, e.memoizedState = null, t
}

function QXe(t, e, n, r, i, s, o) {
    if (n) return e.flags & 256 ? (e.flags &= -257, r = zN(Error(Ye(422))), IS(t, e, o, r)) : e.memoizedState !== null ? (e.child = t.child, e.flags |= 128, null) : (s = r.fallback, i = e.mode, r = x7({
        mode: "visible",
        children: r.children
    }, i, 0, null), s = om(s, i, o, null), s.flags |= 2, r.return = e, s.return = e, r.sibling = s, e.child = r, e.mode & 1 && w2(e, t.child, null, o), e.child.memoizedState = yD(o), e.memoizedState = mD, s);
    if (!(e.mode & 1)) return IS(t, e, o, null);
    if (i.data === "$!") {
        if (r = i.nextSibling && i.nextSibling.dataset, r) var a = r.dgst;
        return r = a, s = Error(Ye(419)), r = zN(s, r, void 0), IS(t, e, o, r)
    }
    if (a = (o & t.childLanes) !== 0, ja || a) {
        if (r = Zs, r !== null) {
            switch (o & -o) {
                case 4:
                    i = 2;
                    break;
                case 16:
                    i = 8;
                    break;
                case 64:
                case 128:
                case 256:
                case 512:
                case 1024:
                case 2048:
                case 4096:
                case 8192:
                case 16384:
                case 32768:
                case 65536:
                case 131072:
                case 262144:
                case 524288:
                case 1048576:
                case 2097152:
                case 4194304:
                case 8388608:
                case 16777216:
                case 33554432:
                case 67108864:
                    i = 32;
                    break;
                case 536870912:
                    i = 268435456;
                    break;
                default:
                    i = 0
            }
            i = i & (r.suspendedLanes | o) ? 0 : i, i !== 0 && i !== s.retryLane && (s.retryLane = i, Ph(t, i), Au(r, t, i, -1))
        }
        return HF(), r = zN(Error(Ye(421))), IS(t, e, o, r)
    }
    return i.data === "$?" ? (e.flags |= 128, e.child = t.child, e = fet.bind(null, t), i._reactRetry = e, null) : (t = s.treeContext, Sl = Ap(i.nextSibling), Tl = e, mi = !0, yu = null, t !== null && (yc[wc++] = uh, yc[wc++] = fh, yc[wc++] = Wm, uh = t.id, fh = t.overflow, Wm = e), e = $F(e, r.children), e.flags |= 4096, e)
}

function MZ(t, e, n) {
    t.lanes |= e;
    var r = t.alternate;
    r !== null && (r.lanes |= e), uD(t.return, e, n)
}

function WN(t, e, n, r, i) {
    var s = t.memoizedState;
    s === null ? t.memoizedState = {
        isBackwards: e,
        rendering: null,
        renderingStartTime: 0,
        last: r,
        tail: n,
        tailMode: i
    } : (s.isBackwards = e, s.rendering = null, s.renderingStartTime = 0, s.last = r, s.tail = n, s.tailMode = i)
}

function due(t, e, n) {
    var r = e.pendingProps,
        i = r.revealOrder,
        s = r.tail;
    if (ea(t, e, r.children, n), r = Ii.current, r & 2) r = r & 1 | 2, e.flags |= 128;
    else {
        if (t !== null && t.flags & 128) e: for (t = e.child; t !== null;) {
            if (t.tag === 13) t.memoizedState !== null && MZ(t, n, e);
            else if (t.tag === 19) MZ(t, n, e);
            else if (t.child !== null) {
                t.child.return = t, t = t.child;
                continue
            }
            if (t === e) break e;
            for (; t.sibling === null;) {
                if (t.return === null || t.return === e) break e;
                t = t.return
            }
            t.sibling.return = t.return, t = t.sibling
        }
        r &= 1
    }
    if (Yr(Ii, r), !(e.mode & 1)) e.memoizedState = null;
    else switch (i) {
        case "forwards":
            for (n = e.child, i = null; n !== null;) t = n.alternate, t !== null && EA(t) === null && (i = n), n = n.sibling;
            n = i, n === null ? (i = e.child, e.child = null) : (i = n.sibling, n.sibling = null), WN(e, !1, i, n, s);
            break;
        case "backwards":
            for (n = null, i = e.child, e.child = null; i !== null;) {
                if (t = i.alternate, t !== null && EA(t) === null) {
                    e.child = i;
                    break
                }
                t = i.sibling, i.sibling = n, n = i, i = t
            }
            WN(e, !0, n, null, s);
            break;
        case "together":
            WN(e, !1, null, null, void 0);
            break;
        default:
            e.memoizedState = null
    }
    return e.child
}

function S8(t, e) {
    !(e.mode & 1) && t !== null && (t.alternate = null, e.alternate = null, e.flags |= 2)
}

function kh(t, e, n) {
    if (t !== null && (e.dependencies = t.dependencies), Gm |= e.lanes, !(n & e.childLanes)) return null;
    if (t !== null && e.child !== t.child) throw Error(Ye(153));
    if (e.child !== null) {
        for (t = e.child, n = Op(t, t.pendingProps), e.child = n, n.return = e; t.sibling !== null;) t = t.sibling, n = n.sibling = Op(t, t.pendingProps), n.return = e;
        n.sibling = null
    }
    return e.child
}

function JXe(t, e, n) {
    switch (e.tag) {
        case 3:
            uue(e), y2();
            break;
        case 5:
            Bce(e);
            break;
        case 1:
            za(e.type) && mA(e);
            break;
        case 4:
            IF(e, e.stateNode.containerInfo);
            break;
        case 10:
            var r = e.type._context,
                i = e.memoizedProps.value;
            Yr(vA, r._currentValue), r._currentValue = i;
            break;
        case 13:
            if (r = e.memoizedState, r !== null) return r.dehydrated !== null ? (Yr(Ii, Ii.current & 1), e.flags |= 128, null) : n & e.child.childLanes ? fue(t, e, n) : (Yr(Ii, Ii.current & 1), t = kh(t, e, n), t !== null ? t.sibling : null);
            Yr(Ii, Ii.current & 1);
            break;
        case 19:
            if (r = (n & e.childLanes) !== 0, t.flags & 128) {
                if (r) return due(t, e, n);
                e.flags |= 128
            }
            if (i = e.memoizedState, i !== null && (i.rendering = null, i.tail = null, i.lastEffect = null), Yr(Ii, Ii.current), r) break;
            return null;
        case 22:
        case 23:
            return e.lanes = 0, lue(t, e, n)
    }
    return kh(t, e, n)
}
var hue, wD, pue, gue;
hue = function(t, e) {
    for (var n = e.child; n !== null;) {
        if (n.tag === 5 || n.tag === 6) t.appendChild(n.stateNode);
        else if (n.tag !== 4 && n.child !== null) {
            n.child.return = n, n = n.child;
            continue
        }
        if (n === e) break;
        for (; n.sibling === null;) {
            if (n.return === null || n.return === e) return;
            n = n.return
        }
        n.sibling.return = n.return, n = n.sibling
    }
};
wD = function() {};
pue = function(t, e, n, r) {
    var i = t.memoizedProps;
    if (i !== r) {
        t = e.stateNode, w1(Zf.current);
        var s = null;
        switch (n) {
            case "input":
                i = UM(t, i), r = UM(t, r), s = [];
                break;
            case "select":
                i = Mi({}, i, {
                    value: void 0
                }), r = Mi({}, r, {
                    value: void 0
                }), s = [];
                break;
            case "textarea":
                i = zM(t, i), r = zM(t, r), s = [];
                break;
            default:
                typeof i.onClick != "function" && typeof r.onClick == "function" && (t.onclick = pA)
        }
        VM(n, r);
        var o;
        n = null;
        for (c in i)
            if (!r.hasOwnProperty(c) && i.hasOwnProperty(c) && i[c] != null)
                if (c === "style") {
                    var a = i[c];
                    for (o in a) a.hasOwnProperty(o) && (n || (n = {}), n[o] = "")
                } else c !== "dangerouslySetInnerHTML" && c !== "children" && c !== "suppressContentEditableWarning" && c !== "suppressHydrationWarning" && c !== "autoFocus" && (h6.hasOwnProperty(c) ? s || (s = []) : (s = s || []).push(c, null));
        for (c in r) {
            var l = r[c];
            if (a = i != null ? i[c] : void 0, r.hasOwnProperty(c) && l !== a && (l != null || a != null))
                if (c === "style")
                    if (a) {
                        for (o in a) !a.hasOwnProperty(o) || l && l.hasOwnProperty(o) || (n || (n = {}), n[o] = "");
                        for (o in l) l.hasOwnProperty(o) && a[o] !== l[o] && (n || (n = {}), n[o] = l[o])
                    } else n || (s || (s = []), s.push(c, n)), n = l;
            else c === "dangerouslySetInnerHTML" ? (l = l ? l.__html : void 0, a = a ? a.__html : void 0, l != null && a !== l && (s = s || []).push(c, l)) : c === "children" ? typeof l != "string" && typeof l != "number" || (s = s || []).push(c, "" + l) : c !== "suppressContentEditableWarning" && c !== "suppressHydrationWarning" && (h6.hasOwnProperty(c) ? (l != null && c === "onScroll" && ni("scroll", t), s || a === l || (s = [])) : (s = s || []).push(c, l))
        }
        n && (s = s || []).push("style", n);
        var c = s;
        (e.updateQueue = c) && (e.flags |= 4)
    }
};
gue = function(t, e, n, r) {
    n !== r && (e.flags |= 4)
};

function i3(t, e) {
    if (!mi) switch (t.tailMode) {
        case "hidden":
            e = t.tail;
            for (var n = null; e !== null;) e.alternate !== null && (n = e), e = e.sibling;
            n === null ? t.tail = null : n.sibling = null;
            break;
        case "collapsed":
            n = t.tail;
            for (var r = null; n !== null;) n.alternate !== null && (r = n), n = n.sibling;
            r === null ? e || t.tail === null ? t.tail = null : t.tail.sibling = null : r.sibling = null
    }
}

function Eo(t) {
    var e = t.alternate !== null && t.alternate.child === t.child,
        n = 0,
        r = 0;
    if (e)
        for (var i = t.child; i !== null;) n |= i.lanes | i.childLanes, r |= i.subtreeFlags & 14680064, r |= i.flags & 14680064, i.return = t, i = i.sibling;
    else
        for (i = t.child; i !== null;) n |= i.lanes | i.childLanes, r |= i.subtreeFlags, r |= i.flags, i.return = t, i = i.sibling;
    return t.subtreeFlags |= r, t.childLanes = n, e
}

function XXe(t, e, n) {
    var r = e.pendingProps;
    switch (_F(e), e.tag) {
        case 2:
        case 16:
        case 15:
        case 0:
        case 11:
        case 7:
        case 8:
        case 12:
        case 9:
        case 14:
            return Eo(e), null;
        case 1:
            return za(e.type) && gA(), Eo(e), null;
        case 3:
            return r = e.stateNode, v2(), oi(Ha), oi(Lo), OF(), r.pendingContext && (r.context = r.pendingContext, r.pendingContext = null), (t === null || t.child === null) && (AS(e) ? e.flags |= 4 : t === null || t.memoizedState.isDehydrated && !(e.flags & 256) || (e.flags |= 1024, yu !== null && (AD(yu), yu = null))), wD(t, e), Eo(e), null;
        case 5:
            RF(e);
            var i = w1(C6.current);
            if (n = e.type, t !== null && e.stateNode != null) pue(t, e, n, r, i), t.ref !== e.ref && (e.flags |= 512, e.flags |= 2097152);
            else {
                if (!r) {
                    if (e.stateNode === null) throw Error(Ye(166));
                    return Eo(e), null
                }
                if (t = w1(Zf.current), AS(e)) {
                    r = e.stateNode, n = e.type;
                    var s = e.memoizedProps;
                    switch (r[$f] = e, r[x6] = s, t = (e.mode & 1) !== 0, n) {
                        case "dialog":
                            ni("cancel", r), ni("close", r);
                            break;
                        case "iframe":
                        case "object":
                        case "embed":
                            ni("load", r);
                            break;
                        case "video":
                        case "audio":
                            for (i = 0; i < P3.length; i++) ni(P3[i], r);
                            break;
                        case "source":
                            ni("error", r);
                            break;
                        case "img":
                        case "image":
                        case "link":
                            ni("error", r), ni("load", r);
                            break;
                        case "details":
                            ni("toggle", r);
                            break;
                        case "input":
                            zY(r, s), ni("invalid", r);
                            break;
                        case "select":
                            r._wrapperState = {
                                wasMultiple: !!s.multiple
                            }, ni("invalid", r);
                            break;
                        case "textarea":
                            VY(r, s), ni("invalid", r)
                    }
                    VM(n, s), i = null;
                    for (var o in s)
                        if (s.hasOwnProperty(o)) {
                            var a = s[o];
                            o === "children" ? typeof a == "string" ? r.textContent !== a && (s.suppressHydrationWarning !== !0 && CS(r.textContent, a, t), i = ["children", a]) : typeof a == "number" && r.textContent !== "" + a && (s.suppressHydrationWarning !== !0 && CS(r.textContent, a, t), i = ["children", "" + a]) : h6.hasOwnProperty(o) && a != null && o === "onScroll" && ni("scroll", r)
                        }
                    switch (n) {
                        case "input":
                            yS(r), WY(r, s, !0);
                            break;
                        case "textarea":
                            yS(r), GY(r);
                            break;
                        case "select":
                        case "option":
                            break;
                        default:
                            typeof s.onClick == "function" && (r.onclick = pA)
                    }
                    r = i, e.updateQueue = r, r !== null && (e.flags |= 4)
                } else {
                    o = i.nodeType === 9 ? i : i.ownerDocument, t === "http://www.w3.org/1999/xhtml" && (t = zle(n)), t === "http://www.w3.org/1999/xhtml" ? n === "script" ? (t = o.createElement("div"), t.innerHTML = "<script><\/script>", t = t.removeChild(t.firstChild)) : typeof r.is == "string" ? t = o.createElement(n, {
                        is: r.is
                    }) : (t = o.createElement(n), n === "select" && (o = t, r.multiple ? o.multiple = !0 : r.size && (o.size = r.size))) : t = o.createElementNS(t, n), t[$f] = e, t[x6] = r, hue(t, e, !1, !1), e.stateNode = t;
                    e: {
                        switch (o = GM(n, r), n) {
                            case "dialog":
                                ni("cancel", t), ni("close", t), i = r;
                                break;
                            case "iframe":
                            case "object":
                            case "embed":
                                ni("load", t), i = r;
                                break;
                            case "video":
                            case "audio":
                                for (i = 0; i < P3.length; i++) ni(P3[i], t);
                                i = r;
                                break;
                            case "source":
                                ni("error", t), i = r;
                                break;
                            case "img":
                            case "image":
                            case "link":
                                ni("error", t), ni("load", t), i = r;
                                break;
                            case "details":
                                ni("toggle", t), i = r;
                                break;
                            case "input":
                                zY(t, r), i = UM(t, r), ni("invalid", t);
                                break;
                            case "option":
                                i = r;
                                break;
                            case "select":
                                t._wrapperState = {
                                    wasMultiple: !!r.multiple
                                }, i = Mi({}, r, {
                                    value: void 0
                                }), ni("invalid", t);
                                break;
                            case "textarea":
                                VY(t, r), i = zM(t, r), ni("invalid", t);
                                break;
                            default:
                                i = r
                        }
                        VM(n, i),
                        a = i;
                        for (s in a)
                            if (a.hasOwnProperty(s)) {
                                var l = a[s];
                                s === "style" ? Gle(t, l) : s === "dangerouslySetInnerHTML" ? (l = l ? l.__html : void 0, l != null && Wle(t, l)) : s === "children" ? typeof l == "string" ? (n !== "textarea" || l !== "") && p6(t, l) : typeof l == "number" && p6(t, "" + l) : s !== "suppressContentEditableWarning" && s !== "suppressHydrationWarning" && s !== "autoFocus" && (h6.hasOwnProperty(s) ? l != null && s === "onScroll" && ni("scroll", t) : l != null && oF(t, s, l, o))
                            }
                        switch (n) {
                            case "input":
                                yS(t), WY(t, r, !1);
                                break;
                            case "textarea":
                                yS(t), GY(t);
                                break;
                            case "option":
                                r.value != null && t.setAttribute("value", "" + Zp(r.value));
                                break;
                            case "select":
                                t.multiple = !!r.multiple, s = r.value, s != null ? hv(t, !!r.multiple, s, !1) : r.defaultValue != null && hv(t, !!r.multiple, r.defaultValue, !0);
                                break;
                            default:
                                typeof i.onClick == "function" && (t.onclick = pA)
                        }
                        switch (n) {
                            case "button":
                            case "input":
                            case "select":
                            case "textarea":
                                r = !!r.autoFocus;
                                break e;
                            case "img":
                                r = !0;
                                break e;
                            default:
                                r = !1
                        }
                    }
                    r && (e.flags |= 4)
                }
                e.ref !== null && (e.flags |= 512, e.flags |= 2097152)
            }
            return Eo(e), null;
        case 6:
            if (t && e.stateNode != null) gue(t, e, t.memoizedProps, r);
            else {
                if (typeof r != "string" && e.stateNode === null) throw Error(Ye(166));
                if (n = w1(C6.current), w1(Zf.current), AS(e)) {
                    if (r = e.stateNode, n = e.memoizedProps, r[$f] = e, (s = r.nodeValue !== n) && (t = Tl, t !== null)) switch (t.tag) {
                        case 3:
                            CS(r.nodeValue, n, (t.mode & 1) !== 0);
                            break;
                        case 5:
                            t.memoizedProps.suppressHydrationWarning !== !0 && CS(r.nodeValue, n, (t.mode & 1) !== 0)
                    }
                    s && (e.flags |= 4)
                } else r = (n.nodeType === 9 ? n : n.ownerDocument).createTextNode(r), r[$f] = e, e.stateNode = r
            }
            return Eo(e), null;
        case 13:
            if (oi(Ii), r = e.memoizedState, t === null || t.memoizedState !== null && t.memoizedState.dehydrated !== null) {
                if (mi && Sl !== null && e.mode & 1 && !(e.flags & 128)) kce(), y2(), e.flags |= 98560, s = !1;
                else if (s = AS(e), r !== null && r.dehydrated !== null) {
                    if (t === null) {
                        if (!s) throw Error(Ye(318));
                        if (s = e.memoizedState, s = s !== null ? s.dehydrated : null, !s) throw Error(Ye(317));
                        s[$f] = e
                    } else y2(), !(e.flags & 128) && (e.memoizedState = null), e.flags |= 4;
                    Eo(e), s = !1
                } else yu !== null && (AD(yu), yu = null), s = !0;
                if (!s) return e.flags & 65536 ? e : null
            }
            return e.flags & 128 ? (e.lanes = n, e) : (r = r !== null, r !== (t !== null && t.memoizedState !== null) && r && (e.child.flags |= 8192, e.mode & 1 && (t === null || Ii.current & 1 ? Ns === 0 && (Ns = 3) : HF())), e.updateQueue !== null && (e.flags |= 4), Eo(e), null);
        case 4:
            return v2(), wD(t, e), t === null && _6(e.stateNode.containerInfo), Eo(e), null;
        case 10:
            return CF(e.type._context), Eo(e), null;
        case 17:
            return za(e.type) && gA(), Eo(e), null;
        case 19:
            if (oi(Ii), s = e.memoizedState, s === null) return Eo(e), null;
            if (r = (e.flags & 128) !== 0, o = s.rendering, o === null)
                if (r) i3(s, !1);
                else {
                    if (Ns !== 0 || t !== null && t.flags & 128)
                        for (t = e.child; t !== null;) {
                            if (o = EA(t), o !== null) {
                                for (e.flags |= 128, i3(s, !1), r = o.updateQueue, r !== null && (e.updateQueue = r, e.flags |= 4), e.subtreeFlags = 0, r = n, n = e.child; n !== null;) s = n, t = r, s.flags &= 14680066, o = s.alternate, o === null ? (s.childLanes = 0, s.lanes = t, s.child = null, s.subtreeFlags = 0, s.memoizedProps = null, s.memoizedState = null, s.updateQueue = null, s.dependencies = null, s.stateNode = null) : (s.childLanes = o.childLanes, s.lanes = o.lanes, s.child = o.child, s.subtreeFlags = 0, s.deletions = null, s.memoizedProps = o.memoizedProps, s.memoizedState = o.memoizedState, s.updateQueue = o.updateQueue, s.type = o.type, t = o.dependencies, s.dependencies = t === null ? null : {
                                    lanes: t.lanes,
                                    firstContext: t.firstContext
                                }), n = n.sibling;
                                return Yr(Ii, Ii.current & 1 | 2), e.child
                            }
                            t = t.sibling
                        }
                    s.tail !== null && us() > _2 && (e.flags |= 128, r = !0, i3(s, !1), e.lanes = 4194304)
                }
            else {
                if (!r)
                    if (t = EA(o), t !== null) {
                        if (e.flags |= 128, r = !0, n = t.updateQueue, n !== null && (e.updateQueue = n, e.flags |= 4), i3(s, !0), s.tail === null && s.tailMode === "hidden" && !o.alternate && !mi) return Eo(e), null
                    } else 2 * us() - s.renderingStartTime > _2 && n !== 1073741824 && (e.flags |= 128, r = !0, i3(s, !1), e.lanes = 4194304);
                s.isBackwards ? (o.sibling = e.child, e.child = o) : (n = s.last, n !== null ? n.sibling = o : e.child = o, s.last = o)
            }
            return s.tail !== null ? (e = s.tail, s.rendering = e, s.tail = e.sibling, s.renderingStartTime = us(), e.sibling = null, n = Ii.current, Yr(Ii, r ? n & 1 | 2 : n & 1), e) : (Eo(e), null);
        case 22:
        case 23:
            return jF(), r = e.memoizedState !== null, t !== null && t.memoizedState !== null !== r && (e.flags |= 8192), r && e.mode & 1 ? vl & 1073741824 && (Eo(e), e.subtreeFlags & 6 && (e.flags |= 8192)) : Eo(e), null;
        case 24:
            return null;
        case 25:
            return null
    }
    throw Error(Ye(156, e.tag))
}

function eet(t, e) {
    switch (_F(e), e.tag) {
        case 1:
            return za(e.type) && gA(), t = e.flags, t & 65536 ? (e.flags = t & -65537 | 128, e) : null;
        case 3:
            return v2(), oi(Ha), oi(Lo), OF(), t = e.flags, t & 65536 && !(t & 128) ? (e.flags = t & -65537 | 128, e) : null;
        case 5:
            return RF(e), null;
        case 13:
            if (oi(Ii), t = e.memoizedState, t !== null && t.dehydrated !== null) {
                if (e.alternate === null) throw Error(Ye(340));
                y2()
            }
            return t = e.flags, t & 65536 ? (e.flags = t & -65537 | 128, e) : null;
        case 19:
            return oi(Ii), null;
        case 4:
            return v2(), null;
        case 10:
            return CF(e.type._context), null;
        case 22:
        case 23:
            return jF(), null;
        case 24:
            return null;
        default:
            return null
    }
}
var RS = !1,
    Oo = !1,
    tet = typeof WeakSet == "function" ? WeakSet : Set,
    It = null;

function Ww(t, e) {
    var n = t.ref;
    if (n !== null)
        if (typeof n == "function") try {
            n(null)
        } catch (r) {
            zi(t, e, r)
        } else n.current = null
}

function vD(t, e, n) {
    try {
        n()
    } catch (r) {
        zi(t, e, r)
    }
}
var DZ = !1;

function net(t, e) {
    if (nD = fA, t = bce(), vF(t)) {
        if ("selectionStart" in t) var n = {
            start: t.selectionStart,
            end: t.selectionEnd
        };
        else e: {
            n = (n = t.ownerDocument) && n.defaultView || window;
            var r = n.getSelection && n.getSelection();
            if (r && r.rangeCount !== 0) {
                n = r.anchorNode;
                var i = r.anchorOffset,
                    s = r.focusNode;
                r = r.focusOffset;
                try {
                    n.nodeType, s.nodeType
                } catch {
                    n = null;
                    break e
                }
                var o = 0,
                    a = -1,
                    l = -1,
                    c = 0,
                    u = 0,
                    f = t,
                    h = null;
                t: for (;;) {
                    for (var g; f !== n || i !== 0 && f.nodeType !== 3 || (a = o + i), f !== s || r !== 0 && f.nodeType !== 3 || (l = o + r), f.nodeType === 3 && (o += f.nodeValue.length), (g = f.firstChild) !== null;) h = f, f = g;
                    for (;;) {
                        if (f === t) break t;
                        if (h === n && ++c === i && (a = o), h === s && ++u === r && (l = o), (g = f.nextSibling) !== null) break;
                        f = h, h = f.parentNode
                    }
                    f = g
                }
                n = a === -1 || l === -1 ? null : {
                    start: a,
                    end: l
                }
            } else n = null
        }
        n = n || {
            start: 0,
            end: 0
        }
    } else n = null;
    for (rD = {
            focusedElem: t,
            selectionRange: n
        }, fA = !1, It = e; It !== null;)
        if (e = It, t = e.child, (e.subtreeFlags & 1028) !== 0 && t !== null) t.return = e, It = t;
        else
            for (; It !== null;) {
                e = It;
                try {
                    var y = e.alternate;
                    if (e.flags & 1024) switch (e.tag) {
                        case 0:
                        case 11:
                        case 15:
                            break;
                        case 1:
                            if (y !== null) {
                                var _ = y.memoizedProps,
                                    C = y.memoizedState,
                                    b = e.stateNode,
                                    w = b.getSnapshotBeforeUpdate(e.elementType === e.type ? _ : iu(e.type, _), C);
                                b.__reactInternalSnapshotBeforeUpdate = w
                            }
                            break;
                        case 3:
                            var S = e.stateNode.containerInfo;
                            S.nodeType === 1 ? S.textContent = "" : S.nodeType === 9 && S.documentElement && S.removeChild(S.documentElement);
                            break;
                        case 5:
                        case 6:
                        case 4:
                        case 17:
                            break;
                        default:
                            throw Error(Ye(163))
                    }
                } catch (I) {
                    zi(e, e.return, I)
                }
                if (t = e.sibling, t !== null) {
                    t.return = e.return, It = t;
                    break
                }
                It = e.return
            }
    return y = DZ, DZ = !1, y
}

function i_(t, e, n) {
    var r = e.updateQueue;
    if (r = r !== null ? r.lastEffect : null, r !== null) {
        var i = r = r.next;
        do {
            if ((i.tag & t) === t) {
                var s = i.destroy;
                i.destroy = void 0, s !== void 0 && vD(e, n, s)
            }
            i = i.next
        } while (i !== r)
    }
}

function _7(t, e) {
    if (e = e.updateQueue, e = e !== null ? e.lastEffect : null, e !== null) {
        var n = e = e.next;
        do {
            if ((n.tag & t) === t) {
                var r = n.create;
                n.destroy = r()
            }
            n = n.next
        } while (n !== e)
    }
}

function bD(t) {
    var e = t.ref;
    if (e !== null) {
        var n = t.stateNode;
        switch (t.tag) {
            case 5:
                t = n;
                break;
            default:
                t = n
        }
        typeof e == "function" ? e(t) : e.current = t
    }
}

function mue(t) {
    var e = t.alternate;
    e !== null && (t.alternate = null, mue(e)), t.child = null, t.deletions = null, t.sibling = null, t.tag === 5 && (e = t.stateNode, e !== null && (delete e[$f], delete e[x6], delete e[oD], delete e[BXe], delete e[FXe])), t.stateNode = null, t.return = null, t.dependencies = null, t.memoizedProps = null, t.memoizedState = null, t.pendingProps = null, t.stateNode = null, t.updateQueue = null
}

function yue(t) {
    return t.tag === 5 || t.tag === 3 || t.tag === 4
}

function $Z(t) {
    e: for (;;) {
        for (; t.sibling === null;) {
            if (t.return === null || yue(t.return)) return null;
            t = t.return
        }
        for (t.sibling.return = t.return, t = t.sibling; t.tag !== 5 && t.tag !== 6 && t.tag !== 18;) {
            if (t.flags & 2 || t.child === null || t.tag === 4) continue e;
            t.child.return = t, t = t.child
        }
        if (!(t.flags & 2)) return t.stateNode
    }
}

function _D(t, e, n) {
    var r = t.tag;
    if (r === 5 || r === 6) t = t.stateNode, e ? n.nodeType === 8 ? n.parentNode.insertBefore(t, e) : n.insertBefore(t, e) : (n.nodeType === 8 ? (e = n.parentNode, e.insertBefore(t, n)) : (e = n, e.appendChild(t)), n = n._reactRootContainer, n != null || e.onclick !== null || (e.onclick = pA));
    else if (r !== 4 && (t = t.child, t !== null))
        for (_D(t, e, n), t = t.sibling; t !== null;) _D(t, e, n), t = t.sibling
}

function ED(t, e, n) {
    var r = t.tag;
    if (r === 5 || r === 6) t = t.stateNode, e ? n.insertBefore(t, e) : n.appendChild(t);
    else if (r !== 4 && (t = t.child, t !== null))
        for (ED(t, e, n), t = t.sibling; t !== null;) ED(t, e, n), t = t.sibling
}
var ro = null,
    pu = !1;

function p0(t, e, n) {
    for (n = n.child; n !== null;) wue(t, e, n), n = n.sibling
}

function wue(t, e, n) {
    if (Yf && typeof Yf.onCommitFiberUnmount == "function") try {
        Yf.onCommitFiberUnmount(h7, n)
    } catch {}
    switch (n.tag) {
        case 5:
            Oo || Ww(n, e);
        case 6:
            var r = ro,
                i = pu;
            ro = null, p0(t, e, n), ro = r, pu = i, ro !== null && (pu ? (t = ro, n = n.stateNode, t.nodeType === 8 ? t.parentNode.removeChild(n) : t.removeChild(n)) : ro.removeChild(n.stateNode));
            break;
        case 18:
            ro !== null && (pu ? (t = ro, n = n.stateNode, t.nodeType === 8 ? LN(t.parentNode, n) : t.nodeType === 1 && LN(t, n), w6(t)) : LN(ro, n.stateNode));
            break;
        case 4:
            r = ro, i = pu, ro = n.stateNode.containerInfo, pu = !0, p0(t, e, n), ro = r, pu = i;
            break;
        case 0:
        case 11:
        case 14:
        case 15:
            if (!Oo && (r = n.updateQueue, r !== null && (r = r.lastEffect, r !== null))) {
                i = r = r.next;
                do {
                    var s = i,
                        o = s.destroy;
                    s = s.tag, o !== void 0 && (s & 2 || s & 4) && vD(n, e, o), i = i.next
                } while (i !== r)
            }
            p0(t, e, n);
            break;
        case 1:
            if (!Oo && (Ww(n, e), r = n.stateNode, typeof r.componentWillUnmount == "function")) try {
                r.props = n.memoizedProps, r.state = n.memoizedState, r.componentWillUnmount()
            } catch (a) {
                zi(n, e, a)
            }
            p0(t, e, n);
            break;
        case 21:
            p0(t, e, n);
            break;
        case 22:
            n.mode & 1 ? (Oo = (r = Oo) || n.memoizedState !== null, p0(t, e, n), Oo = r) : p0(t, e, n);
            break;
        default:
            p0(t, e, n)
    }
}

function LZ(t) {
    var e = t.updateQueue;
    if (e !== null) {
        t.updateQueue = null;
        var n = t.stateNode;
        n === null && (n = t.stateNode = new tet), e.forEach(function(r) {
            var i = det.bind(null, t, r);
            n.has(r) || (n.add(r), r.then(i, i))
        })
    }
}

function Kc(t, e) {
    var n = e.deletions;
    if (n !== null)
        for (var r = 0; r < n.length; r++) {
            var i = n[r];
            try {
                var s = t,
                    o = e,
                    a = o;
                e: for (; a !== null;) {
                    switch (a.tag) {
                        case 5:
                            ro = a.stateNode, pu = !1;
                            break e;
                        case 3:
                            ro = a.stateNode.containerInfo, pu = !0;
                            break e;
                        case 4:
                            ro = a.stateNode.containerInfo, pu = !0;
                            break e
                    }
                    a = a.return
                }
                if (ro === null) throw Error(Ye(160));
                wue(s, o, i), ro = null, pu = !1;
                var l = i.alternate;
                l !== null && (l.return = null), i.return = null
            } catch (c) {
                zi(i, e, c)
            }
        }
    if (e.subtreeFlags & 12854)
        for (e = e.child; e !== null;) vue(e, t), e = e.sibling
}

function vue(t, e) {
    var n = t.alternate,
        r = t.flags;
    switch (t.tag) {
        case 0:
        case 11:
        case 14:
        case 15:
            if (Kc(e, t), cf(t), r & 4) {
                try {
                    i_(3, t, t.return), _7(3, t)
                } catch (_) {
                    zi(t, t.return, _)
                }
                try {
                    i_(5, t, t.return)
                } catch (_) {
                    zi(t, t.return, _)
                }
            }
            break;
        case 1:
            Kc(e, t), cf(t), r & 512 && n !== null && Ww(n, n.return);
            break;
        case 5:
            if (Kc(e, t), cf(t), r & 512 && n !== null && Ww(n, n.return), t.flags & 32) {
                var i = t.stateNode;
                try {
                    p6(i, "")
                } catch (_) {
                    zi(t, t.return, _)
                }
            }
            if (r & 4 && (i = t.stateNode, i != null)) {
                var s = t.memoizedProps,
                    o = n !== null ? n.memoizedProps : s,
                    a = t.type,
                    l = t.updateQueue;
                if (t.updateQueue = null, l !== null) try {
                    a === "input" && s.type === "radio" && s.name != null && jle(i, s), GM(a, o);
                    var c = GM(a, s);
                    for (o = 0; o < l.length; o += 2) {
                        var u = l[o],
                            f = l[o + 1];
                        u === "style" ? Gle(i, f) : u === "dangerouslySetInnerHTML" ? Wle(i, f) : u === "children" ? p6(i, f) : oF(i, u, f, c)
                    }
                    switch (a) {
                        case "input":
                            jM(i, s);
                            break;
                        case "textarea":
                            Hle(i, s);
                            break;
                        case "select":
                            var h = i._wrapperState.wasMultiple;
                            i._wrapperState.wasMultiple = !!s.multiple;
                            var g = s.value;
                            g != null ? hv(i, !!s.multiple, g, !1) : h !== !!s.multiple && (s.defaultValue != null ? hv(i, !!s.multiple, s.defaultValue, !0) : hv(i, !!s.multiple, s.multiple ? [] : "", !1))
                    }
                    i[x6] = s
                } catch (_) {
                    zi(t, t.return, _)
                }
            }
            break;
        case 6:
            if (Kc(e, t), cf(t), r & 4) {
                if (t.stateNode === null) throw Error(Ye(162));
                i = t.stateNode, s = t.memoizedProps;
                try {
                    i.nodeValue = s
                } catch (_) {
                    zi(t, t.return, _)
                }
            }
            break;
        case 3:
            if (Kc(e, t), cf(t), r & 4 && n !== null && n.memoizedState.isDehydrated) try {
                w6(e.containerInfo)
            } catch (_) {
                zi(t, t.return, _)
            }
            break;
        case 4:
            Kc(e, t), cf(t);
            break;
        case 13:
            Kc(e, t), cf(t), i = t.child, i.flags & 8192 && (s = i.memoizedState !== null, i.stateNode.isHidden = s, !s || i.alternate !== null && i.alternate.memoizedState !== null || (FF = us())), r & 4 && LZ(t);
            break;
        case 22:
            if (u = n !== null && n.memoizedState !== null, t.mode & 1 ? (Oo = (c = Oo) || u, Kc(e, t), Oo = c) : Kc(e, t), cf(t), r & 8192) {
                if (c = t.memoizedState !== null, (t.stateNode.isHidden = c) && !u && t.mode & 1)
                    for (It = t, u = t.child; u !== null;) {
                        for (f = It = u; It !== null;) {
                            switch (h = It, g = h.child, h.tag) {
                                case 0:
                                case 11:
                                case 14:
                                case 15:
                                    i_(4, h, h.return);
                                    break;
                                case 1:
                                    Ww(h, h.return);
                                    var y = h.stateNode;
                                    if (typeof y.componentWillUnmount == "function") {
                                        r = h, n = h.return;
                                        try {
                                            e = r, y.props = e.memoizedProps, y.state = e.memoizedState, y.componentWillUnmount()
                                        } catch (_) {
                                            zi(r, n, _)
                                        }
                                    }
                                    break;
                                case 5:
                                    Ww(h, h.return);
                                    break;
                                case 22:
                                    if (h.memoizedState !== null) {
                                        FZ(f);
                                        continue
                                    }
                            }
                            g !== null ? (g.return = h, It = g) : FZ(f)
                        }
                        u = u.sibling
                    }
                e: for (u = null, f = t;;) {
                    if (f.tag === 5) {
                        if (u === null) {
                            u = f;
                            try {
                                i = f.stateNode, c ? (s = i.style, typeof s.setProperty == "function" ? s.setProperty("display", "none", "important") : s.display = "none") : (a = f.stateNode, l = f.memoizedProps.style, o = l != null && l.hasOwnProperty("display") ? l.display : null, a.style.display = Vle("display", o))
                            } catch (_) {
                                zi(t, t.return, _)
                            }
                        }
                    } else if (f.tag === 6) {
                        if (u === null) try {
                            f.stateNode.nodeValue = c ? "" : f.memoizedProps
                        } catch (_) {
                            zi(t, t.return, _)
                        }
                    } else if ((f.tag !== 22 && f.tag !== 23 || f.memoizedState === null || f === t) && f.child !== null) {
                        f.child.return = f, f = f.child;
                        continue
                    }
                    if (f === t) break e;
                    for (; f.sibling === null;) {
                        if (f.return === null || f.return === t) break e;
                        u === f && (u = null), f = f.return
                    }
                    u === f && (u = null), f.sibling.return = f.return, f = f.sibling
                }
            }
            break;
        case 19:
            Kc(e, t), cf(t), r & 4 && LZ(t);
            break;
        case 21:
            break;
        default:
            Kc(e, t), cf(t)
    }
}

function cf(t) {
    var e = t.flags;
    if (e & 2) {
        try {
            e: {
                for (var n = t.return; n !== null;) {
                    if (yue(n)) {
                        var r = n;
                        break e
                    }
                    n = n.return
                }
                throw Error(Ye(160))
            }
            switch (r.tag) {
                case 5:
                    var i = r.stateNode;
                    r.flags & 32 && (p6(i, ""), r.flags &= -33);
                    var s = $Z(t);
                    ED(t, s, i);
                    break;
                case 3:
                case 4:
                    var o = r.stateNode.containerInfo,
                        a = $Z(t);
                    _D(t, a, o);
                    break;
                default:
                    throw Error(Ye(161))
            }
        }
        catch (l) {
            zi(t, t.return, l)
        }
        t.flags &= -3
    }
    e & 4096 && (t.flags &= -4097)
}

function ret(t, e, n) {
    It = t, bue(t)
}

function bue(t, e, n) {
    for (var r = (t.mode & 1) !== 0; It !== null;) {
        var i = It,
            s = i.child;
        if (i.tag === 22 && r) {
            var o = i.memoizedState !== null || RS;
            if (!o) {
                var a = i.alternate,
                    l = a !== null && a.memoizedState !== null || Oo;
                a = RS;
                var c = Oo;
                if (RS = o, (Oo = l) && !c)
                    for (It = i; It !== null;) o = It, l = o.child, o.tag === 22 && o.memoizedState !== null ? UZ(i) : l !== null ? (l.return = o, It = l) : UZ(i);
                for (; s !== null;) It = s, bue(s), s = s.sibling;
                It = i, RS = a, Oo = c
            }
            BZ(t)
        } else i.subtreeFlags & 8772 && s !== null ? (s.return = i, It = s) : BZ(t)
    }
}

function BZ(t) {
    for (; It !== null;) {
        var e = It;
        if (e.flags & 8772) {
            var n = e.alternate;
            try {
                if (e.flags & 8772) switch (e.tag) {
                    case 0:
                    case 11:
                    case 15:
                        Oo || _7(5, e);
                        break;
                    case 1:
                        var r = e.stateNode;
                        if (e.flags & 4 && !Oo)
                            if (n === null) r.componentDidMount();
                            else {
                                var i = e.elementType === e.type ? n.memoizedProps : iu(e.type, n.memoizedProps);
                                r.componentDidUpdate(i, n.memoizedState, r.__reactInternalSnapshotBeforeUpdate)
                            }
                        var s = e.updateQueue;
                        s !== null && EZ(e, s, r);
                        break;
                    case 3:
                        var o = e.updateQueue;
                        if (o !== null) {
                            if (n = null, e.child !== null) switch (e.child.tag) {
                                case 5:
                                    n = e.child.stateNode;
                                    break;
                                case 1:
                                    n = e.child.stateNode
                            }
                            EZ(e, o, n)
                        }
                        break;
                    case 5:
                        var a = e.stateNode;
                        if (n === null && e.flags & 4) {
                            n = a;
                            var l = e.memoizedProps;
                            switch (e.type) {
                                case "button":
                                case "input":
                                case "select":
                                case "textarea":
                                    l.autoFocus && n.focus();
                                    break;
                                case "img":
                                    l.src && (n.src = l.src)
                            }
                        }
                        break;
                    case 6:
                        break;
                    case 4:
                        break;
                    case 12:
                        break;
                    case 13:
                        if (e.memoizedState === null) {
                            var c = e.alternate;
                            if (c !== null) {
                                var u = c.memoizedState;
                                if (u !== null) {
                                    var f = u.dehydrated;
                                    f !== null && w6(f)
                                }
                            }
                        }
                        break;
                    case 19:
                    case 17:
                    case 21:
                    case 22:
                    case 23:
                    case 25:
                        break;
                    default:
                        throw Error(Ye(163))
                }
                Oo || e.flags & 512 && bD(e)
            } catch (h) {
                zi(e, e.return, h)
            }
        }
        if (e === t) {
            It = null;
            break
        }
        if (n = e.sibling, n !== null) {
            n.return = e.return, It = n;
            break
        }
        It = e.return
    }
}

function FZ(t) {
    for (; It !== null;) {
        var e = It;
        if (e === t) {
            It = null;
            break
        }
        var n = e.sibling;
        if (n !== null) {
            n.return = e.return, It = n;
            break
        }
        It = e.return
    }
}

function UZ(t) {
    for (; It !== null;) {
        var e = It;
        try {
            switch (e.tag) {
                case 0:
                case 11:
                case 15:
                    var n = e.return;
                    try {
                        _7(4, e)
                    } catch (l) {
                        zi(e, n, l)
                    }
                    break;
                case 1:
                    var r = e.stateNode;
                    if (typeof r.componentDidMount == "function") {
                        var i = e.return;
                        try {
                            r.componentDidMount()
                        } catch (l) {
                            zi(e, i, l)
                        }
                    }
                    var s = e.return;
                    try {
                        bD(e)
                    } catch (l) {
                        zi(e, s, l)
                    }
                    break;
                case 5:
                    var o = e.return;
                    try {
                        bD(e)
                    } catch (l) {
                        zi(e, o, l)
                    }
            }
        } catch (l) {
            zi(e, e.return, l)
        }
        if (e === t) {
            It = null;
            break
        }
        var a = e.sibling;
        if (a !== null) {
            a.return = e.return, It = a;
            break
        }
        It = e.return
    }
}
var iet = Math.ceil,
    CA = Wh.ReactCurrentDispatcher,
    LF = Wh.ReactCurrentOwner,
    Ac = Wh.ReactCurrentBatchConfig,
    fr = 0,
    Zs = null,
    _s = null,
    ao = 0,
    vl = 0,
    Vw = hg(0),
    Ns = 0,
    R6 = null,
    Gm = 0,
    E7 = 0,
    BF = 0,
    s_ = null,
    Ba = null,
    FF = 0,
    _2 = 1 / 0,
    jd = null,
    AA = !1,
    xD = null,
    Ip = null,
    OS = !1,
    pp = null,
    TA = 0,
    o_ = 0,
    SD = null,
    C8 = -1,
    A8 = 0;

function ua() {
    return fr & 6 ? us() : C8 !== -1 ? C8 : C8 = us()
}

function Rp(t) {
    return t.mode & 1 ? fr & 2 && ao !== 0 ? ao & -ao : jXe.transition !== null ? (A8 === 0 && (A8 = ice()), A8) : (t = Or, t !== 0 || (t = window.event, t = t === void 0 ? 16 : fce(t.type)), t) : 1
}

function Au(t, e, n, r) {
    if (50 < o_) throw o_ = 0, SD = null, Error(Ye(185));
    c4(t, n, r), (!(fr & 2) || t !== Zs) && (t === Zs && (!(fr & 2) && (E7 |= n), Ns === 4 && $0(t, ao)), Wa(t, r), n === 1 && fr === 0 && !(e.mode & 1) && (_2 = us() + 500, w7 && pg()))
}

function Wa(t, e) {
    var n = t.callbackNode;
    jJe(t, e);
    var r = uA(t, t === Zs ? ao : 0);
    if (r === 0) n !== null && YY(n), t.callbackNode = null, t.callbackPriority = 0;
    else if (e = r & -r, t.callbackPriority !== e) {
        if (n != null && YY(n), e === 1) t.tag === 0 ? UXe(jZ.bind(null, t)) : Oce(jZ.bind(null, t)), $Xe(function() {
            !(fr & 6) && pg()
        }), n = null;
        else {
            switch (sce(r)) {
                case 1:
                    n = fF;
                    break;
                case 4:
                    n = nce;
                    break;
                case 16:
                    n = cA;
                    break;
                case 536870912:
                    n = rce;
                    break;
                default:
                    n = cA
            }
            n = Iue(n, _ue.bind(null, t))
        }
        t.callbackPriority = e, t.callbackNode = n
    }
}

function _ue(t, e) {
    if (C8 = -1, A8 = 0, fr & 6) throw Error(Ye(327));
    var n = t.callbackNode;
    if (wv() && t.callbackNode !== n) return null;
    var r = uA(t, t === Zs ? ao : 0);
    if (r === 0) return null;
    if (r & 30 || r & t.expiredLanes || e) e = IA(t, r);
    else {
        e = r;
        var i = fr;
        fr |= 2;
        var s = xue();
        (Zs !== t || ao !== e) && (jd = null, _2 = us() + 500, sm(t, e));
        do try {
            aet();
            break
        } catch (a) {
            Eue(t, a)
        }
        while (!0);
        SF(), CA.current = s, fr = i, _s !== null ? e = 0 : (Zs = null, ao = 0, e = Ns)
    }
    if (e !== 0) {
        if (e === 2 && (i = QM(t), i !== 0 && (r = i, e = CD(t, i))), e === 1) throw n = R6, sm(t, 0), $0(t, r), Wa(t, us()), n;
        if (e === 6) $0(t, r);
        else {
            if (i = t.current.alternate, !(r & 30) && !set(i) && (e = IA(t, r), e === 2 && (s = QM(t), s !== 0 && (r = s, e = CD(t, s))), e === 1)) throw n = R6, sm(t, 0), $0(t, r), Wa(t, us()), n;
            switch (t.finishedWork = i, t.finishedLanes = r, e) {
                case 0:
                case 1:
                    throw Error(Ye(345));
                case 2:
                    qg(t, Ba, jd);
                    break;
                case 3:
                    if ($0(t, r), (r & 130023424) === r && (e = FF + 500 - us(), 10 < e)) {
                        if (uA(t, 0) !== 0) break;
                        if (i = t.suspendedLanes, (i & r) !== r) {
                            ua(), t.pingedLanes |= t.suspendedLanes & i;
                            break
                        }
                        t.timeoutHandle = sD(qg.bind(null, t, Ba, jd), e);
                        break
                    }
                    qg(t, Ba, jd);
                    break;
                case 4:
                    if ($0(t, r), (r & 4194240) === r) break;
                    for (e = t.eventTimes, i = -1; 0 < r;) {
                        var o = 31 - Cu(r);
                        s = 1 << o, o = e[o], o > i && (i = o), r &= ~s
                    }
                    if (r = i, r = us() - r, r = (120 > r ? 120 : 480 > r ? 480 : 1080 > r ? 1080 : 1920 > r ? 1920 : 3e3 > r ? 3e3 : 4320 > r ? 4320 : 1960 * iet(r / 1960)) - r, 10 < r) {
                        t.timeoutHandle = sD(qg.bind(null, t, Ba, jd), r);
                        break
                    }
                    qg(t, Ba, jd);
                    break;
                case 5:
                    qg(t, Ba, jd);
                    break;
                default:
                    throw Error(Ye(329))
            }
        }
    }
    return Wa(t, us()), t.callbackNode === n ? _ue.bind(null, t) : null
}

function CD(t, e) {
    var n = s_;
    return t.current.memoizedState.isDehydrated && (sm(t, e).flags |= 256), t = IA(t, e), t !== 2 && (e = Ba, Ba = n, e !== null && AD(e)), t
}

function AD(t) {
    Ba === null ? Ba = t : Ba.push.apply(Ba, t)
}

function set(t) {
    for (var e = t;;) {
        if (e.flags & 16384) {
            var n = e.updateQueue;
            if (n !== null && (n = n.stores, n !== null))
                for (var r = 0; r < n.length; r++) {
                    var i = n[r],
                        s = i.getSnapshot;
                    i = i.value;
                    try {
                        if (!$u(s(), i)) return !1
                    } catch {
                        return !1
                    }
                }
        }
        if (n = e.child, e.subtreeFlags & 16384 && n !== null) n.return = e, e = n;
        else {
            if (e === t) break;
            for (; e.sibling === null;) {
                if (e.return === null || e.return === t) return !0;
                e = e.return
            }
            e.sibling.return = e.return, e = e.sibling
        }
    }
    return !0
}

function $0(t, e) {
    for (e &= ~BF, e &= ~E7, t.suspendedLanes |= e, t.pingedLanes &= ~e, t = t.expirationTimes; 0 < e;) {
        var n = 31 - Cu(e),
            r = 1 << n;
        t[n] = -1, e &= ~r
    }
}

function jZ(t) {
    if (fr & 6) throw Error(Ye(327));
    wv();
    var e = uA(t, 0);
    if (!(e & 1)) return Wa(t, us()), null;
    var n = IA(t, e);
    if (t.tag !== 0 && n === 2) {
        var r = QM(t);
        r !== 0 && (e = r, n = CD(t, r))
    }
    if (n === 1) throw n = R6, sm(t, 0), $0(t, e), Wa(t, us()), n;
    if (n === 6) throw Error(Ye(345));
    return t.finishedWork = t.current.alternate, t.finishedLanes = e, qg(t, Ba, jd), Wa(t, us()), null
}

function UF(t, e) {
    var n = fr;
    fr |= 1;
    try {
        return t(e)
    } finally {
        fr = n, fr === 0 && (_2 = us() + 500, w7 && pg())
    }
}

function qm(t) {
    pp !== null && pp.tag === 0 && !(fr & 6) && wv();
    var e = fr;
    fr |= 1;
    var n = Ac.transition,
        r = Or;
    try {
        if (Ac.transition = null, Or = 1, t) return t()
    } finally {
        Or = r, Ac.transition = n, fr = e, !(fr & 6) && pg()
    }
}

function jF() {
    vl = Vw.current, oi(Vw)
}

function sm(t, e) {
    t.finishedWork = null, t.finishedLanes = 0;
    var n = t.timeoutHandle;
    if (n !== -1 && (t.timeoutHandle = -1, DXe(n)), _s !== null)
        for (n = _s.return; n !== null;) {
            var r = n;
            switch (_F(r), r.tag) {
                case 1:
                    r = r.type.childContextTypes, r != null && gA();
                    break;
                case 3:
                    v2(), oi(Ha), oi(Lo), OF();
                    break;
                case 5:
                    RF(r);
                    break;
                case 4:
                    v2();
                    break;
                case 13:
                    oi(Ii);
                    break;
                case 19:
                    oi(Ii);
                    break;
                case 10:
                    CF(r.type._context);
                    break;
                case 22:
                case 23:
                    jF()
            }
            n = n.return
        }
    if (Zs = t, _s = t = Op(t.current, null), ao = vl = e, Ns = 0, R6 = null, BF = E7 = Gm = 0, Ba = s_ = null, y1 !== null) {
        for (e = 0; e < y1.length; e++)
            if (n = y1[e], r = n.interleaved, r !== null) {
                n.interleaved = null;
                var i = r.next,
                    s = n.pending;
                if (s !== null) {
                    var o = s.next;
                    s.next = i, r.next = o
                }
                n.pending = r
            }
        y1 = null
    }
    return t
}

function Eue(t, e) {
    do {
        var n = _s;
        try {
            if (SF(), E8.current = SA, xA) {
                for (var r = Ni.memoizedState; r !== null;) {
                    var i = r.queue;
                    i !== null && (i.pending = null), r = r.next
                }
                xA = !1
            }
            if (Vm = 0, Vs = Rs = Ni = null, r_ = !1, A6 = 0, LF.current = null, n === null || n.return === null) {
                Ns = 1, R6 = e, _s = null;
                break
            }
            e: {
                var s = t,
                    o = n.return,
                    a = n,
                    l = e;
                if (e = ao, a.flags |= 32768, l !== null && typeof l == "object" && typeof l.then == "function") {
                    var c = l,
                        u = a,
                        f = u.tag;
                    if (!(u.mode & 1) && (f === 0 || f === 11 || f === 15)) {
                        var h = u.alternate;
                        h ? (u.updateQueue = h.updateQueue, u.memoizedState = h.memoizedState, u.lanes = h.lanes) : (u.updateQueue = null, u.memoizedState = null)
                    }
                    var g = IZ(o);
                    if (g !== null) {
                        g.flags &= -257, RZ(g, o, a, s, e), g.mode & 1 && TZ(s, c, e), e = g, l = c;
                        var y = e.updateQueue;
                        if (y === null) {
                            var _ = new Set;
                            _.add(l), e.updateQueue = _
                        } else y.add(l);
                        break e
                    } else {
                        if (!(e & 1)) {
                            TZ(s, c, e), HF();
                            break e
                        }
                        l = Error(Ye(426))
                    }
                } else if (mi && a.mode & 1) {
                    var C = IZ(o);
                    if (C !== null) {
                        !(C.flags & 65536) && (C.flags |= 256), RZ(C, o, a, s, e), EF(b2(l, a));
                        break e
                    }
                }
                s = l = b2(l, a),
                Ns !== 4 && (Ns = 2),
                s_ === null ? s_ = [s] : s_.push(s),
                s = o;do {
                    switch (s.tag) {
                        case 3:
                            s.flags |= 65536, e &= -e, s.lanes |= e;
                            var b = sue(s, l, e);
                            _Z(s, b);
                            break e;
                        case 1:
                            a = l;
                            var w = s.type,
                                S = s.stateNode;
                            if (!(s.flags & 128) && (typeof w.getDerivedStateFromError == "function" || S !== null && typeof S.componentDidCatch == "function" && (Ip === null || !Ip.has(S)))) {
                                s.flags |= 65536, e &= -e, s.lanes |= e;
                                var I = oue(s, a, e);
                                _Z(s, I);
                                break e
                            }
                    }
                    s = s.return
                } while (s !== null)
            }
            Cue(n)
        } catch (P) {
            e = P, _s === n && n !== null && (_s = n = n.return);
            continue
        }
        break
    } while (!0)
}

function xue() {
    var t = CA.current;
    return CA.current = SA, t === null ? SA : t
}

function HF() {
    (Ns === 0 || Ns === 3 || Ns === 2) && (Ns = 4), Zs === null || !(Gm & 268435455) && !(E7 & 268435455) || $0(Zs, ao)
}

function IA(t, e) {
    var n = fr;
    fr |= 2;
    var r = xue();
    (Zs !== t || ao !== e) && (jd = null, sm(t, e));
    do try {
        oet();
        break
    } catch (i) {
        Eue(t, i)
    }
    while (!0);
    if (SF(), fr = n, CA.current = r, _s !== null) throw Error(Ye(261));
    return Zs = null, ao = 0, Ns
}

function oet() {
    for (; _s !== null;) Sue(_s)
}

function aet() {
    for (; _s !== null && !PJe();) Sue(_s)
}

function Sue(t) {
    var e = Tue(t.alternate, t, vl);
    t.memoizedProps = t.pendingProps, e === null ? Cue(t) : _s = e, LF.current = null
}

function Cue(t) {
    var e = t;
    do {
        var n = e.alternate;
        if (t = e.return, e.flags & 32768) {
            if (n = eet(n, e), n !== null) {
                n.flags &= 32767, _s = n;
                return
            }
            if (t !== null) t.flags |= 32768, t.subtreeFlags = 0, t.deletions = null;
            else {
                Ns = 6, _s = null;
                return
            }
        } else if (n = XXe(n, e, vl), n !== null) {
            _s = n;
            return
        }
        if (e = e.sibling, e !== null) {
            _s = e;
            return
        }
        _s = e = t
    } while (e !== null);
    Ns === 0 && (Ns = 5)
}

function qg(t, e, n) {
    var r = Or,
        i = Ac.transition;
    try {
        Ac.transition = null, Or = 1, cet(t, e, n, r)
    } finally {
        Ac.transition = i, Or = r
    }
    return null
}

function cet(t, e, n, r) {
    do wv(); while (pp !== null);
    if (fr & 6) throw Error(Ye(327));
    n = t.finishedWork;
    var i = t.finishedLanes;
    if (n === null) return null;
    if (t.finishedWork = null, t.finishedLanes = 0, n === t.current) throw Error(Ye(177));
    t.callbackNode = null, t.callbackPriority = 0;
    var s = n.lanes | n.childLanes;
    if (HJe(t, s), t === Zs && (_s = Zs = null, ao = 0), !(n.subtreeFlags & 2064) && !(n.flags & 2064) || OS || (OS = !0, Iue(cA, function() {
            return wv(), null
        })), s = (n.flags & 15990) !== 0, n.subtreeFlags & 15990 || s) {
        s = Ac.transition, Ac.transition = null;
        var o = Or;
        Or = 1;
        var a = fr;
        fr |= 4, LF.current = null, net(t, n), vue(n, t), IXe(rD), fA = !!nD, rD = nD = null, t.current = n, ret(n), kJe(), fr = a, Or = o, Ac.transition = s
    } else t.current = n;
    if (OS && (OS = !1, pp = t, TA = i), s = t.pendingLanes, s === 0 && (Ip = null), $Je(n.stateNode), Wa(t, us()), e !== null)
        for (r = t.onRecoverableError, n = 0; n < e.length; n++) i = e[n], r(i.value, {
            componentStack: i.stack,
            digest: i.digest
        });
    if (AA) throw AA = !1, t = xD, xD = null, t;
    return TA & 1 && t.tag !== 0 && wv(), s = t.pendingLanes, s & 1 ? t === SD ? o_++ : (o_ = 0, SD = t) : o_ = 0, pg(), null
}

function wv() {
    if (pp !== null) {
        var t = sce(TA),
            e = Ac.transition,
            n = Or;
        try {
            if (Ac.transition = null, Or = 16 > t ? 16 : t, pp === null) var r = !1;
            else {
                if (t = pp, pp = null, TA = 0, fr & 6) throw Error(Ye(331));
                var i = fr;
                for (fr |= 4, It = t.current; It !== null;) {
                    var s = It,
                        o = s.child;
                    if (It.flags & 16) {
                        var a = s.deletions;
                        if (a !== null) {
                            for (var l = 0; l < a.length; l++) {
                                var c = a[l];
                                for (It = c; It !== null;) {
                                    var u = It;
                                    switch (u.tag) {
                                        case 0:
                                        case 11:
                                        case 15:
                                            i_(8, u, s)
                                    }
                                    var f = u.child;
                                    if (f !== null) f.return = u, It = f;
                                    else
                                        for (; It !== null;) {
                                            u = It;
                                            var h = u.sibling,
                                                g = u.return;
                                            if (mue(u), u === c) {
                                                It = null;
                                                break
                                            }
                                            if (h !== null) {
                                                h.return = g, It = h;
                                                break
                                            }
                                            It = g
                                        }
                                }
                            }
                            var y = s.alternate;
                            if (y !== null) {
                                var _ = y.child;
                                if (_ !== null) {
                                    y.child = null;
                                    do {
                                        var C = _.sibling;
                                        _.sibling = null, _ = C
                                    } while (_ !== null)
                                }
                            }
                            It = s
                        }
                    }
                    if (s.subtreeFlags & 2064 && o !== null) o.return = s, It = o;
                    else e: for (; It !== null;) {
                        if (s = It, s.flags & 2048) switch (s.tag) {
                            case 0:
                            case 11:
                            case 15:
                                i_(9, s, s.return)
                        }
                        var b = s.sibling;
                        if (b !== null) {
                            b.return = s.return, It = b;
                            break e
                        }
                        It = s.return
                    }
                }
                var w = t.current;
                for (It = w; It !== null;) {
                    o = It;
                    var S = o.child;
                    if (o.subtreeFlags & 2064 && S !== null) S.return = o, It = S;
                    else e: for (o = w; It !== null;) {
                        if (a = It, a.flags & 2048) try {
                            switch (a.tag) {
                                case 0:
                                case 11:
                                case 15:
                                    _7(9, a)
                            }
                        } catch (P) {
                            zi(a, a.return, P)
                        }
                        if (a === o) {
                            It = null;
                            break e
                        }
                        var I = a.sibling;
                        if (I !== null) {
                            I.return = a.return, It = I;
                            break e
                        }
                        It = a.return
                    }
                }
                if (fr = i, pg(), Yf && typeof Yf.onPostCommitFiberRoot == "function") try {
                    Yf.onPostCommitFiberRoot(h7, t)
                } catch {}
                r = !0
            }
            return r
        } finally {
            Or = n, Ac.transition = e
        }
    }
    return !1
}

function HZ(t, e, n) {
    e = b2(n, e), e = sue(t, e, 1), t = Tp(t, e, 1), e = ua(), t !== null && (c4(t, 1, e), Wa(t, e))
}

function zi(t, e, n) {
    if (t.tag === 3) HZ(t, t, n);
    else
        for (; e !== null;) {
            if (e.tag === 3) {
                HZ(e, t, n);
                break
            } else if (e.tag === 1) {
                var r = e.stateNode;
                if (typeof e.type.getDerivedStateFromError == "function" || typeof r.componentDidCatch == "function" && (Ip === null || !Ip.has(r))) {
                    t = b2(n, t), t = oue(e, t, 1), e = Tp(e, t, 1), t = ua(), e !== null && (c4(e, 1, t), Wa(e, t));
                    break
                }
            }
            e = e.return
        }
}

function uet(t, e, n) {
    var r = t.pingCache;
    r !== null && r.delete(e), e = ua(), t.pingedLanes |= t.suspendedLanes & n, Zs === t && (ao & n) === n && (Ns === 4 || Ns === 3 && (ao & 130023424) === ao && 500 > us() - FF ? sm(t, 0) : BF |= n), Wa(t, e)
}

function Aue(t, e) {
    e === 0 && (t.mode & 1 ? (e = bS, bS <<= 1, !(bS & 130023424) && (bS = 4194304)) : e = 1);
    var n = ua();
    t = Ph(t, e), t !== null && (c4(t, e, n), Wa(t, n))
}

function fet(t) {
    var e = t.memoizedState,
        n = 0;
    e !== null && (n = e.retryLane), Aue(t, n)
}

function det(t, e) {
    var n = 0;
    switch (t.tag) {
        case 13:
            var r = t.stateNode,
                i = t.memoizedState;
            i !== null && (n = i.retryLane);
            break;
        case 19:
            r = t.stateNode;
            break;
        default:
            throw Error(Ye(314))
    }
    r !== null && r.delete(e), Aue(t, n)
}
var Tue;
Tue = function(t, e, n) {
    if (t !== null)
        if (t.memoizedProps !== e.pendingProps || Ha.current) ja = !0;
        else {
            if (!(t.lanes & n) && !(e.flags & 128)) return ja = !1, JXe(t, e, n);
            ja = !!(t.flags & 131072)
        }
    else ja = !1, mi && e.flags & 1048576 && Nce(e, wA, e.index);
    switch (e.lanes = 0, e.tag) {
        case 2:
            var r = e.type;
            S8(t, e), t = e.pendingProps;
            var i = m2(e, Lo.current);
            yv(e, n), i = PF(null, e, r, t, i, n);
            var s = kF();
            return e.flags |= 1, typeof i == "object" && i !== null && typeof i.render == "function" && i.$$typeof === void 0 ? (e.tag = 1, e.memoizedState = null, e.updateQueue = null, za(r) ? (s = !0, mA(e)) : s = !1, e.memoizedState = i.state !== null && i.state !== void 0 ? i.state : null, TF(e), i.updater = b7, e.stateNode = i, i._reactInternals = e, dD(e, r, t, n), e = gD(null, e, r, !0, s, n)) : (e.tag = 0, mi && s && bF(e), ea(null, e, i, n), e = e.child), e;
        case 16:
            r = e.elementType;
            e: {
                switch (S8(t, e), t = e.pendingProps, i = r._init, r = i(r._payload), e.type = r, i = e.tag = pet(r), t = iu(r, t), i) {
                    case 0:
                        e = pD(null, e, r, t, n);
                        break e;
                    case 1:
                        e = PZ(null, e, r, t, n);
                        break e;
                    case 11:
                        e = OZ(null, e, r, t, n);
                        break e;
                    case 14:
                        e = NZ(null, e, r, iu(r.type, t), n);
                        break e
                }
                throw Error(Ye(306, r, ""))
            }
            return e;
        case 0:
            return r = e.type, i = e.pendingProps, i = e.elementType === r ? i : iu(r, i), pD(t, e, r, i, n);
        case 1:
            return r = e.type, i = e.pendingProps, i = e.elementType === r ? i : iu(r, i), PZ(t, e, r, i, n);
        case 3:
            e: {
                if (uue(e), t === null) throw Error(Ye(387));r = e.pendingProps,
                s = e.memoizedState,
                i = s.element,
                Lce(t, e),
                _A(e, r, null, n);
                var o = e.memoizedState;
                if (r = o.element, s.isDehydrated)
                    if (s = {
                            element: r,
                            isDehydrated: !1,
                            cache: o.cache,
                            pendingSuspenseBoundaries: o.pendingSuspenseBoundaries,
                            transitions: o.transitions
                        }, e.updateQueue.baseState = s, e.memoizedState = s, e.flags & 256) {
                        i = b2(Error(Ye(423)), e), e = kZ(t, e, r, n, i);
                        break e
                    } else if (r !== i) {
                    i = b2(Error(Ye(424)), e), e = kZ(t, e, r, n, i);
                    break e
                } else
                    for (Sl = Ap(e.stateNode.containerInfo.firstChild), Tl = e, mi = !0, yu = null, n = Dce(e, null, r, n), e.child = n; n;) n.flags = n.flags & -3 | 4096, n = n.sibling;
                else {
                    if (y2(), r === i) {
                        e = kh(t, e, n);
                        break e
                    }
                    ea(t, e, r, n)
                }
                e = e.child
            }
            return e;
        case 5:
            return Bce(e), t === null && cD(e), r = e.type, i = e.pendingProps, s = t !== null ? t.memoizedProps : null, o = i.children, iD(r, i) ? o = null : s !== null && iD(r, s) && (e.flags |= 32), cue(t, e), ea(t, e, o, n), e.child;
        case 6:
            return t === null && cD(e), null;
        case 13:
            return fue(t, e, n);
        case 4:
            return IF(e, e.stateNode.containerInfo), r = e.pendingProps, t === null ? e.child = w2(e, null, r, n) : ea(t, e, r, n), e.child;
        case 11:
            return r = e.type, i = e.pendingProps, i = e.elementType === r ? i : iu(r, i), OZ(t, e, r, i, n);
        case 7:
            return ea(t, e, e.pendingProps, n), e.child;
        case 8:
            return ea(t, e, e.pendingProps.children, n), e.child;
        case 12:
            return ea(t, e, e.pendingProps.children, n), e.child;
        case 10:
            e: {
                if (r = e.type._context, i = e.pendingProps, s = e.memoizedProps, o = i.value, Yr(vA, r._currentValue), r._currentValue = o, s !== null)
                    if ($u(s.value, o)) {
                        if (s.children === i.children && !Ha.current) {
                            e = kh(t, e, n);
                            break e
                        }
                    } else
                        for (s = e.child, s !== null && (s.return = e); s !== null;) {
                            var a = s.dependencies;
                            if (a !== null) {
                                o = s.child;
                                for (var l = a.firstContext; l !== null;) {
                                    if (l.context === r) {
                                        if (s.tag === 1) {
                                            l = yh(-1, n & -n), l.tag = 2;
                                            var c = s.updateQueue;
                                            if (c !== null) {
                                                c = c.shared;
                                                var u = c.pending;
                                                u === null ? l.next = l : (l.next = u.next, u.next = l), c.pending = l
                                            }
                                        }
                                        s.lanes |= n, l = s.alternate, l !== null && (l.lanes |= n), uD(s.return, n, e), a.lanes |= n;
                                        break
                                    }
                                    l = l.next
                                }
                            } else if (s.tag === 10) o = s.type === e.type ? null : s.child;
                            else if (s.tag === 18) {
                                if (o = s.return, o === null) throw Error(Ye(341));
                                o.lanes |= n, a = o.alternate, a !== null && (a.lanes |= n), uD(o, n, e), o = s.sibling
                            } else o = s.child;
                            if (o !== null) o.return = s;
                            else
                                for (o = s; o !== null;) {
                                    if (o === e) {
                                        o = null;
                                        break
                                    }
                                    if (s = o.sibling, s !== null) {
                                        s.return = o.return, o = s;
                                        break
                                    }
                                    o = o.return
                                }
                            s = o
                        }
                ea(t, e, i.children, n),
                e = e.child
            }
            return e;
        case 9:
            return i = e.type, r = e.pendingProps.children, yv(e, n), i = Nc(i), r = r(i), e.flags |= 1, ea(t, e, r, n), e.child;
        case 14:
            return r = e.type, i = iu(r, e.pendingProps), i = iu(r.type, i), NZ(t, e, r, i, n);
        case 15:
            return aue(t, e, e.type, e.pendingProps, n);
        case 17:
            return r = e.type, i = e.pendingProps, i = e.elementType === r ? i : iu(r, i), S8(t, e), e.tag = 1, za(r) ? (t = !0, mA(e)) : t = !1, yv(e, n), iue(e, r, i), dD(e, r, i, n), gD(null, e, r, !0, t, n);
        case 19:
            return due(t, e, n);
        case 22:
            return lue(t, e, n)
    }
    throw Error(Ye(156, e.tag))
};

function Iue(t, e) {
    return tce(t, e)
}

function het(t, e, n, r) {
    this.tag = t, this.key = n, this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null, this.index = 0, this.ref = null, this.pendingProps = e, this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null, this.mode = r, this.subtreeFlags = this.flags = 0, this.deletions = null, this.childLanes = this.lanes = 0, this.alternate = null
}

function Ec(t, e, n, r) {
    return new het(t, e, n, r)
}

function zF(t) {
    return t = t.prototype, !(!t || !t.isReactComponent)
}

function pet(t) {
    if (typeof t == "function") return zF(t) ? 1 : 0;
    if (t != null) {
        if (t = t.$$typeof, t === lF) return 11;
        if (t === cF) return 14
    }
    return 2
}

function Op(t, e) {
    var n = t.alternate;
    return n === null ? (n = Ec(t.tag, e, t.key, t.mode), n.elementType = t.elementType, n.type = t.type, n.stateNode = t.stateNode, n.alternate = t, t.alternate = n) : (n.pendingProps = e, n.type = t.type, n.flags = 0, n.subtreeFlags = 0, n.deletions = null), n.flags = t.flags & 14680064, n.childLanes = t.childLanes, n.lanes = t.lanes, n.child = t.child, n.memoizedProps = t.memoizedProps, n.memoizedState = t.memoizedState, n.updateQueue = t.updateQueue, e = t.dependencies, n.dependencies = e === null ? null : {
        lanes: e.lanes,
        firstContext: e.firstContext
    }, n.sibling = t.sibling, n.index = t.index, n.ref = t.ref, n
}

function T8(t, e, n, r, i, s) {
    var o = 2;
    if (r = t, typeof t == "function") zF(t) && (o = 1);
    else if (typeof t == "string") o = 5;
    else e: switch (t) {
        case Dw:
            return om(n.children, i, s, e);
        case aF:
            o = 8, i |= 8;
            break;
        case $M:
            return t = Ec(12, n, e, i | 2), t.elementType = $M, t.lanes = s, t;
        case LM:
            return t = Ec(13, n, e, i), t.elementType = LM, t.lanes = s, t;
        case BM:
            return t = Ec(19, n, e, i), t.elementType = BM, t.lanes = s, t;
        case Ble:
            return x7(n, i, s, e);
        default:
            if (typeof t == "object" && t !== null) switch (t.$$typeof) {
                case $le:
                    o = 10;
                    break e;
                case Lle:
                    o = 9;
                    break e;
                case lF:
                    o = 11;
                    break e;
                case cF:
                    o = 14;
                    break e;
                case A0:
                    o = 16, r = null;
                    break e
            }
            throw Error(Ye(130, t == null ? t : typeof t, ""))
    }
    return e = Ec(o, n, e, i), e.elementType = t, e.type = r, e.lanes = s, e
}

function om(t, e, n, r) {
    return t = Ec(7, t, r, e), t.lanes = n, t
}

function x7(t, e, n, r) {
    return t = Ec(22, t, r, e), t.elementType = Ble, t.lanes = n, t.stateNode = {
        isHidden: !1
    }, t
}

function VN(t, e, n) {
    return t = Ec(6, t, null, e), t.lanes = n, t
}

function GN(t, e, n) {
    return e = Ec(4, t.children !== null ? t.children : [], t.key, e), e.lanes = n, e.stateNode = {
        containerInfo: t.containerInfo,
        pendingChildren: null,
        implementation: t.implementation
    }, e
}

function get(t, e, n, r, i) {
    this.tag = e, this.containerInfo = t, this.finishedWork = this.pingCache = this.current = this.pendingChildren = null, this.timeoutHandle = -1, this.callbackNode = this.pendingContext = this.context = null, this.callbackPriority = 0, this.eventTimes = AN(0), this.expirationTimes = AN(-1), this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0, this.entanglements = AN(0), this.identifierPrefix = r, this.onRecoverableError = i, this.mutableSourceEagerHydrationData = null
}

function WF(t, e, n, r, i, s, o, a, l) {
    return t = new get(t, e, n, a, l), e === 1 ? (e = 1, s === !0 && (e |= 8)) : e = 0, s = Ec(3, null, null, e), t.current = s, s.stateNode = t, s.memoizedState = {
        element: r,
        isDehydrated: n,
        cache: null,
        transitions: null,
        pendingSuspenseBoundaries: null
    }, TF(s), t
}

function met(t, e, n) {
    var r = 3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null;
    return {
        $$typeof: Mw,
        key: r == null ? null : "" + r,
        children: t,
        containerInfo: e,
        implementation: n
    }
}

function Rue(t) {
    if (!t) return Qp;
    t = t._reactInternals;
    e: {
        if (Iy(t) !== t || t.tag !== 1) throw Error(Ye(170));
        var e = t;do {
            switch (e.tag) {
                case 3:
                    e = e.stateNode.context;
                    break e;
                case 1:
                    if (za(e.type)) {
                        e = e.stateNode.__reactInternalMemoizedMergedChildContext;
                        break e
                    }
            }
            e = e.return
        } while (e !== null);
        throw Error(Ye(171))
    }
    if (t.tag === 1) {
        var n = t.type;
        if (za(n)) return Rce(t, n, e)
    }
    return e
}

function Oue(t, e, n, r, i, s, o, a, l) {
    return t = WF(n, r, !0, t, i, s, o, a, l), t.context = Rue(null), n = t.current, r = ua(), i = Rp(n), s = yh(r, i), s.callback = e ? ? null, Tp(n, s, i), t.current.lanes = i, c4(t, i, r), Wa(t, r), t
}

function S7(t, e, n, r) {
    var i = e.current,
        s = ua(),
        o = Rp(i);
    return n = Rue(n), e.context === null ? e.context = n : e.pendingContext = n, e = yh(s, o), e.payload = {
        element: t
    }, r = r === void 0 ? null : r, r !== null && (e.callback = r), t = Tp(i, e, o), t !== null && (Au(t, i, o, s), _8(t, i, o)), o
}

function RA(t) {
    if (t = t.current, !t.child) return null;
    switch (t.child.tag) {
        case 5:
            return t.child.stateNode;
        default:
            return t.child.stateNode
    }
}

function zZ(t, e) {
    if (t = t.memoizedState, t !== null && t.dehydrated !== null) {
        var n = t.retryLane;
        t.retryLane = n !== 0 && n < e ? n : e
    }
}

function VF(t, e) {
    zZ(t, e), (t = t.alternate) && zZ(t, e)
}

function yet() {
    return null
}
var Nue = typeof reportError == "function" ? reportError : function(t) {
    console.error(t)
};

function GF(t) {
    this._internalRoot = t
}
C7.prototype.render = GF.prototype.render = function(t) {
    var e = this._internalRoot;
    if (e === null) throw Error(Ye(409));
    S7(t, e, null, null)
};
C7.prototype.unmount = GF.prototype.unmount = function() {
    var t = this._internalRoot;
    if (t !== null) {
        this._internalRoot = null;
        var e = t.containerInfo;
        qm(function() {
            S7(null, t, null, null)
        }), e[Nh] = null
    }
};

function C7(t) {
    this._internalRoot = t
}
C7.prototype.unstable_scheduleHydration = function(t) {
    if (t) {
        var e = lce();
        t = {
            blockedOn: null,
            target: t,
            priority: e
        };
        for (var n = 0; n < D0.length && e !== 0 && e < D0[n].priority; n++);
        D0.splice(n, 0, t), n === 0 && uce(t)
    }
};

function qF(t) {
    return !(!t || t.nodeType !== 1 && t.nodeType !== 9 && t.nodeType !== 11)
}

function A7(t) {
    return !(!t || t.nodeType !== 1 && t.nodeType !== 9 && t.nodeType !== 11 && (t.nodeType !== 8 || t.nodeValue !== " react-mount-point-unstable "))
}

function WZ() {}

function wet(t, e, n, r, i) {
    if (i) {
        if (typeof r == "function") {
            var s = r;
            r = function() {
                var c = RA(o);
                s.call(c)
            }
        }
        var o = Oue(e, r, t, 0, null, !1, !1, "", WZ);
        return t._reactRootContainer = o, t[Nh] = o.current, _6(t.nodeType === 8 ? t.parentNode : t), qm(), o
    }
    for (; i = t.lastChild;) t.removeChild(i);
    if (typeof r == "function") {
        var a = r;
        r = function() {
            var c = RA(l);
            a.call(c)
        }
    }
    var l = WF(t, 0, !1, null, null, !1, !1, "", WZ);
    return t._reactRootContainer = l, t[Nh] = l.current, _6(t.nodeType === 8 ? t.parentNode : t), qm(function() {
        S7(e, l, n, r)
    }), l
}

function T7(t, e, n, r, i) {
    var s = n._reactRootContainer;
    if (s) {
        var o = s;
        if (typeof i == "function") {
            var a = i;
            i = function() {
                var l = RA(o);
                a.call(l)
            }
        }
        S7(e, o, t, i)
    } else o = wet(n, e, t, i, r);
    return RA(o)
}
oce = function(t) {
    switch (t.tag) {
        case 3:
            var e = t.stateNode;
            if (e.current.memoizedState.isDehydrated) {
                var n = N3(e.pendingLanes);
                n !== 0 && (dF(e, n | 1), Wa(e, us()), !(fr & 6) && (_2 = us() + 500, pg()))
            }
            break;
        case 13:
            qm(function() {
                var r = Ph(t, 1);
                if (r !== null) {
                    var i = ua();
                    Au(r, t, 1, i)
                }
            }), VF(t, 1)
    }
};
hF = function(t) {
    if (t.tag === 13) {
        var e = Ph(t, 134217728);
        if (e !== null) {
            var n = ua();
            Au(e, t, 134217728, n)
        }
        VF(t, 134217728)
    }
};
ace = function(t) {
    if (t.tag === 13) {
        var e = Rp(t),
            n = Ph(t, e);
        if (n !== null) {
            var r = ua();
            Au(n, t, e, r)
        }
        VF(t, e)
    }
};
lce = function() {
    return Or
};
cce = function(t, e) {
    var n = Or;
    try {
        return Or = t, e()
    } finally {
        Or = n
    }
};
KM = function(t, e, n) {
    switch (e) {
        case "input":
            if (jM(t, n), e = n.name, n.type === "radio" && e != null) {
                for (n = t; n.parentNode;) n = n.parentNode;
                for (n = n.querySelectorAll("input[name=" + JSON.stringify("" + e) + '][type="radio"]'), e = 0; e < n.length; e++) {
                    var r = n[e];
                    if (r !== t && r.form === t.form) {
                        var i = y7(r);
                        if (!i) throw Error(Ye(90));
                        Ule(r), jM(r, i)
                    }
                }
            }
            break;
        case "textarea":
            Hle(t, n);
            break;
        case "select":
            e = n.value, e != null && hv(t, !!n.multiple, e, !1)
    }
};
Yle = UF;
Zle = qm;
var vet = {
        usingClientEntryPoint: !1,
        Events: [f4, Fw, y7, qle, Kle, UF]
    },
    s3 = {
        findFiberByHostInstance: m1,
        bundleType: 0,
        version: "18.3.1",
        rendererPackageName: "react-dom"
    },
    bet = {
        bundleType: s3.bundleType,
        version: s3.version,
        rendererPackageName: s3.rendererPackageName,
        rendererConfig: s3.rendererConfig,
        overrideHookState: null,
        overrideHookStateDeletePath: null,
        overrideHookStateRenamePath: null,
        overrideProps: null,
        overridePropsDeletePath: null,
        overridePropsRenamePath: null,
        setErrorHandler: null,
        setSuspenseHandler: null,
        scheduleUpdate: null,
        currentDispatcherRef: Wh.ReactCurrentDispatcher,
        findHostInstanceByFiber: function(t) {
            return t = Xle(t), t === null ? null : t.stateNode
        },
        findFiberByHostInstance: s3.findFiberByHostInstance || yet,
        findHostInstancesForRefresh: null,
        scheduleRefresh: null,
        scheduleRoot: null,
        setRefreshHandler: null,
        getCurrentFiber: null,
        reconcilerVersion: "18.3.1-next-f1338f8080-20240426"
    };
if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u") {
    var NS = __REACT_DEVTOOLS_GLOBAL_HOOK__;
    if (!NS.isDisabled && NS.supportsFiber) try {
        h7 = NS.inject(bet), Yf = NS
    } catch {}
}
$l.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = vet;
$l.createPortal = function(t, e) {
    var n = 2 < arguments.length && arguments[2] !== void 0 ? arguments[2] : null;
    if (!qF(e)) throw Error(Ye(200));
    return met(t, e, null, n)
};
$l.createRoot = function(t, e) {
    if (!qF(t)) throw Error(Ye(299));
    var n = !1,
        r = "",
        i = Nue;
    return e != null && (e.unstable_strictMode === !0 && (n = !0), e.identifierPrefix !== void 0 && (r = e.identifierPrefix), e.onRecoverableError !== void 0 && (i = e.onRecoverableError)), e = WF(t, 1, !1, null, null, n, !1, r, i), t[Nh] = e.current, _6(t.nodeType === 8 ? t.parentNode : t), new GF(e)
};
$l.findDOMNode = function(t) {
    if (t == null) return null;
    if (t.nodeType === 1) return t;
    var e = t._reactInternals;
    if (e === void 0) throw typeof t.render == "function" ? Error(Ye(188)) : (t = Object.keys(t).join(","), Error(Ye(268, t)));
    return t = Xle(e), t = t === null ? null : t.stateNode, t
};
$l.flushSync = function(t) {
    return qm(t)
};
$l.hydrate = function(t, e, n) {
    if (!A7(e)) throw Error(Ye(200));
    return T7(null, t, e, !0, n)
};
$l.hydrateRoot = function(t, e, n) {
    if (!qF(t)) throw Error(Ye(405));
    var r = n != null && n.hydratedSources || null,
        i = !1,
        s = "",
        o = Nue;
    if (n != null && (n.unstable_strictMode === !0 && (i = !0), n.identifierPrefix !== void 0 && (s = n.identifierPrefix), n.onRecoverableError !== void 0 && (o = n.onRecoverableError)), e = Oue(e, null, t, 1, n ? ? null, i, !1, s, o), t[Nh] = e.current, _6(t), r)
        for (t = 0; t < r.length; t++) n = r[t], i = n._getVersion, i = i(n._source), e.mutableSourceEagerHydrationData == null ? e.mutableSourceEagerHydrationData = [n, i] : e.mutableSourceEagerHydrationData.push(n, i);
    return new C7(e)
};
$l.render = function(t, e, n) {
    if (!A7(e)) throw Error(Ye(200));
    return T7(null, t, e, !1, n)
};
$l.unmountComponentAtNode = function(t) {
    if (!A7(t)) throw Error(Ye(40));
    return t._reactRootContainer ? (qm(function() {
        T7(null, null, t, !1, function() {
            t._reactRootContainer = null, t[Nh] = null
        })
    }), !0) : !1
};
$l.unstable_batchedUpdates = UF;
$l.unstable_renderSubtreeIntoContainer = function(t, e, n, r) {
    if (!A7(n)) throw Error(Ye(200));
    if (t == null || t._reactInternals === void 0) throw Error(Ye(38));
    return T7(t, e, n, !1, r)
};
$l.version = "18.3.1-next-f1338f8080-20240426";

function Pue() {
    if (!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE != "function")) try {
        __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(Pue)
    } catch (t) {
        console.error(t)
    }
}
Pue(), Ple.exports = $l;
var KF = Ple.exports;
const _et = co(KF),
    Eet = AX({
        __proto__: null,
        default: _et
    }, [KF]);
var VZ = KF;
MM.createRoot = VZ.createRoot, MM.hydrateRoot = VZ.hydrateRoot;
/**
 * @remix-run/router v1.19.2
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
function Ti() {
    return Ti = Object.assign ? Object.assign.bind() : function(t) {
        for (var e = 1; e < arguments.length; e++) {
            var n = arguments[e];
            for (var r in n) Object.prototype.hasOwnProperty.call(n, r) && (t[r] = n[r])
        }
        return t
    }, Ti.apply(this, arguments)
}
var vs;
(function(t) {
    t.Pop = "POP", t.Push = "PUSH", t.Replace = "REPLACE"
})(vs || (vs = {}));
const GZ = "popstate";

function xet(t) {
    t === void 0 && (t = {});

    function e(r, i) {
        let {
            pathname: s,
            search: o,
            hash: a
        } = r.location;
        return O6("", {
            pathname: s,
            search: o,
            hash: a
        }, i.state && i.state.usr || null, i.state && i.state.key || "default")
    }

    function n(r, i) {
        return typeof i == "string" ? i : Ym(i)
    }
    return Aet(e, n, null, t)
}

function Rn(t, e) {
    if (t === !1 || t === null || typeof t > "u") throw new Error(e)
}

function Km(t, e) {
    if (!t) {
        typeof console < "u" && console.warn(e);
        try {
            throw new Error(e)
        } catch {}
    }
}

function Cet() {
    return Math.random().toString(36).substr(2, 8)
}

function qZ(t, e) {
    return {
        usr: t.state,
        key: t.key,
        idx: e
    }
}

function O6(t, e, n, r) {
    return n === void 0 && (n = null), Ti({
        pathname: typeof t == "string" ? t : t.pathname,
        search: "",
        hash: ""
    }, typeof e == "string" ? gg(e) : e, {
        state: n,
        key: e && e.key || r || Cet()
    })
}

function Ym(t) {
    let {
        pathname: e = "/",
        search: n = "",
        hash: r = ""
    } = t;
    return n && n !== "?" && (e += n.charAt(0) === "?" ? n : "?" + n), r && r !== "#" && (e += r.charAt(0) === "#" ? r : "#" + r), e
}

function gg(t) {
    let e = {};
    if (t) {
        let n = t.indexOf("#");
        n >= 0 && (e.hash = t.substr(n), t = t.substr(0, n));
        let r = t.indexOf("?");
        r >= 0 && (e.search = t.substr(r), t = t.substr(0, r)), t && (e.pathname = t)
    }
    return e
}

function Aet(t, e, n, r) {
    r === void 0 && (r = {});
    let {
        window: i = document.defaultView,
        v5Compat: s = !1
    } = r, o = i.history, a = vs.Pop, l = null, c = u();
    c == null && (c = 0, o.replaceState(Ti({}, o.state, {
        idx: c
    }), ""));

    function u() {
        return (o.state || {
            idx: null
        }).idx
    }

    function f() {
        a = vs.Pop;
        let C = u(),
            b = C == null ? null : C - c;
        c = C, l && l({
            action: a,
            location: _.location,
            delta: b
        })
    }

    function h(C, b) {
        a = vs.Push;
        let w = O6(_.location, C, b);
        c = u() + 1;
        let S = qZ(w, c),
            I = _.createHref(w);
        try {
            o.pushState(S, "", I)
        } catch (P) {
            if (P instanceof DOMException && P.name === "DataCloneError") throw P;
            i.location.assign(I)
        }
        s && l && l({
            action: a,
            location: _.location,
            delta: 1
        })
    }

    function g(C, b) {
        a = vs.Replace;
        let w = O6(_.location, C, b);
        c = u();
        let S = qZ(w, c),
            I = _.createHref(w);
        o.replaceState(S, "", I), s && l && l({
            action: a,
            location: _.location,
            delta: 0
        })
    }

    function y(C) {
        let b = i.location.origin !== "null" ? i.location.origin : i.location.href,
            w = typeof C == "string" ? C : Ym(C);
        return w = w.replace(/ $/, "%20"), Rn(b, "No window.location.(origin|href) available to create URL for href: " + w), new URL(w, b)
    }
    let _ = {
        get action() {
            return a
        },
        get location() {
            return t(i, o)
        },
        listen(C) {
            if (l) throw new Error("A history only accepts one active listener");
            return i.addEventListener(GZ, f), l = C, () => {
                i.removeEventListener(GZ, f), l = null
            }
        },
        createHref(C) {
            return e(i, C)
        },
        createURL: y,
        encodeLocation(C) {
            let b = y(C);
            return {
                pathname: b.pathname,
                search: b.search,
                hash: b.hash
            }
        },
        push: h,
        replace: g,
        go(C) {
            return o.go(C)
        }
    };
    return _
}
var kr;
(function(t) {
    t.data = "data", t.deferred = "deferred", t.redirect = "redirect", t.error = "error"
})(kr || (kr = {}));
const Tet = new Set(["lazy", "caseSensitive", "path", "id", "index", "children"]);

function Iet(t) {
    return t.index === !0
}

function N6(t, e, n, r) {
    return n === void 0 && (n = []), r === void 0 && (r = {}), t.map((i, s) => {
        let o = [...n, String(s)],
            a = typeof i.id == "string" ? i.id : o.join("-");
        if (Rn(i.index !== !0 || !i.children, "Cannot specify children on an index route"), Rn(!r[a], 'Found a route id collision on id "' + a + `".  Route id's must be globally unique within Data Router usages`), Iet(i)) {
            let l = Ti({}, i, e(i), {
                id: a
            });
            return r[a] = l, l
        } else {
            let l = Ti({}, i, e(i), {
                id: a,
                children: void 0
            });
            return r[a] = l, i.children && (l.children = N6(i.children, e, o, r)), l
        }
    })
}

function n1(t, e, n) {
    return n === void 0 && (n = "/"), I8(t, e, n, !1)
}

function I8(t, e, n, r) {
    let i = typeof e == "string" ? gg(e) : e,
        s = Mh(i.pathname || "/", n);
    if (s == null) return null;
    let o = kue(t);
    Oet(o);
    let a = null;
    for (let l = 0; a == null && l < o.length; ++l) {
        let c = jet(s);
        a = Fet(o[l], c, r)
    }
    return a
}

function Ret(t, e) {
    let {
        route: n,
        pathname: r,
        params: i
    } = t;
    return {
        id: n.id,
        pathname: r,
        params: i,
        data: e[n.id],
        handle: n.handle
    }
}

function kue(t, e, n, r) {
    e === void 0 && (e = []), n === void 0 && (n = []), r === void 0 && (r = "");
    let i = (s, o, a) => {
        let l = {
            relativePath: a === void 0 ? s.path || "" : a,
            caseSensitive: s.caseSensitive === !0,
            childrenIndex: o,
            route: s
        };
        l.relativePath.startsWith("/") && (Rn(l.relativePath.startsWith(r), 'Absolute route path "' + l.relativePath + '" nested under path ' + ('"' + r + '" is not valid. An absolute child route path ') + "must start with the combined path of all its parent routes."), l.relativePath = l.relativePath.slice(r.length));
        let c = wh([r, l.relativePath]),
            u = n.concat(l);
        s.children && s.children.length > 0 && (Rn(s.index !== !0, "Index routes must not have child routes. Please remove " + ('all child routes from route path "' + c + '".')), kue(s.children, e, u, c)), !(s.path == null && !s.index) && e.push({
            path: c,
            score: Let(c, s.index),
            routesMeta: u
        })
    };
    return t.forEach((s, o) => {
        var a;
        if (s.path === "" || !((a = s.path) != null && a.includes("?"))) i(s, o);
        else
            for (let l of Mue(s.path)) i(s, o, l)
    }), e
}

function Mue(t) {
    let e = t.split("/");
    if (e.length === 0) return [];
    let [n, ...r] = e, i = n.endsWith("?"), s = n.replace(/\?$/, "");
    if (r.length === 0) return i ? [s, ""] : [s];
    let o = Mue(r.join("/")),
        a = [];
    return a.push(...o.map(l => l === "" ? s : [s, l].join("/"))), i && a.push(...o), a.map(l => t.startsWith("/") && l === "" ? "/" : l)
}

function Oet(t) {
    t.sort((e, n) => e.score !== n.score ? n.score - e.score : Bet(e.routesMeta.map(r => r.childrenIndex), n.routesMeta.map(r => r.childrenIndex)))
}
const Net = /^:[\w-]+$/,
    Pet = 3,
    ket = 2,
    Met = 1,
    Det = 10,
    $et = -2,
    KZ = t => t === "*";

function Let(t, e) {
    let n = t.split("/"),
        r = n.length;
    return n.some(KZ) && (r += $et), e && (r += ket), n.filter(i => !KZ(i)).reduce((i, s) => i + (Net.test(s) ? Pet : s === "" ? Met : Det), r)
}

function Bet(t, e) {
    return t.length === e.length && t.slice(0, -1).every((r, i) => r === e[i]) ? t[t.length - 1] - e[e.length - 1] : 0
}

function Fet(t, e, n) {
    n === void 0 && (n = !1);
    let {
        routesMeta: r
    } = t, i = {}, s = "/", o = [];
    for (let a = 0; a < r.length; ++a) {
        let l = r[a],
            c = a === r.length - 1,
            u = s === "/" ? e : e.slice(s.length) || "/",
            f = OA({
                path: l.relativePath,
                caseSensitive: l.caseSensitive,
                end: c
            }, u),
            h = l.route;
        if (!f && c && n && !r[r.length - 1].route.index && (f = OA({
                path: l.relativePath,
                caseSensitive: l.caseSensitive,
                end: !1
            }, u)), !f) return null;
        Object.assign(i, f.params), o.push({
            params: i,
            pathname: wh([s, f.pathname]),
            pathnameBase: Wet(wh([s, f.pathnameBase])),
            route: h
        }), f.pathnameBase !== "/" && (s = wh([s, f.pathnameBase]))
    }
    return o
}

function v3t(t, e) {
    e === void 0 && (e = {});
    let n = t;
    n.endsWith("*") && n !== "*" && !n.endsWith("/*") && (Km(!1, 'Route path "' + n + '" will be treated as if it were ' + ('"' + n.replace(/\*$/, "/*") + '" because the `*` character must ') + "always follow a `/` in the pattern. To get rid of this warning, " + ('please change the route path to "' + n.replace(/\*$/, "/*") + '".')), n = n.replace(/\*$/, "/*"));
    const r = n.startsWith("/") ? "/" : "",
        i = o => o == null ? "" : typeof o == "string" ? o : String(o),
        s = n.split(/\/+/).map((o, a, l) => {
            if (a === l.length - 1 && o === "*") return i(e["*"]);
            const u = o.match(/^:([\w-]+)(\??)$/);
            if (u) {
                const [, f, h] = u;
                let g = e[f];
                return Rn(h === "?" || g != null, 'Missing ":' + f + '" param'), i(g)
            }
            return o.replace(/\?$/g, "")
        }).filter(o => !!o);
    return r + s.join("/")
}

function OA(t, e) {
    typeof t == "string" && (t = {
        path: t,
        caseSensitive: !1,
        end: !0
    });
    let [n, r] = Uet(t.path, t.caseSensitive, t.end), i = e.match(n);
    if (!i) return null;
    let s = i[0],
        o = s.replace(/(.)\/+$/, "$1"),
        a = i.slice(1);
    return {
        params: r.reduce((c, u, f) => {
            let {
                paramName: h,
                isOptional: g
            } = u;
            if (h === "*") {
                let _ = a[f] || "";
                o = s.slice(0, s.length - _.length).replace(/(.)\/+$/, "$1")
            }
            const y = a[f];
            return g && !y ? c[h] = void 0 : c[h] = (y || "").replace(/%2F/g, "/"), c
        }, {}),
        pathname: s,
        pathnameBase: o,
        pattern: t
    }
}

function Uet(t, e, n) {
    e === void 0 && (e = !1), n === void 0 && (n = !0), Km(t === "*" || !t.endsWith("*") || t.endsWith("/*"), 'Route path "' + t + '" will be treated as if it were ' + ('"' + t.replace(/\*$/, "/*") + '" because the `*` character must ') + "always follow a `/` in the pattern. To get rid of this warning, " + ('please change the route path to "' + t.replace(/\*$/, "/*") + '".'));
    let r = [],
        i = "^" + t.replace(/\/*\*?$/, "").replace(/^\/*/, "/").replace(/[\\.*+^${}|()[\]]/g, "\\$&").replace(/\/:([\w-]+)(\?)?/g, (o, a, l) => (r.push({
            paramName: a,
            isOptional: l != null
        }), l ? "/?([^\\/]+)?" : "/([^\\/]+)"));
    return t.endsWith("*") ? (r.push({
        paramName: "*"
    }), i += t === "*" || t === "/*" ? "(.*)$" : "(?:\\/(.+)|\\/*)$") : n ? i += "\\/*$" : t !== "" && t !== "/" && (i += "(?:(?=\\/|$))"), [new RegExp(i, e ? void 0 : "i"), r]
}

function jet(t) {
    try {
        return t.split("/").map(e => decodeURIComponent(e).replace(/\//g, "%2F")).join("/")
    } catch (e) {
        return Km(!1, 'The URL path "' + t + '" could not be decoded because it is is a malformed URL segment. This is probably due to a bad percent ' + ("encoding (" + e + ").")), t
    }
}

function Mh(t, e) {
    if (e === "/") return t;
    if (!t.toLowerCase().startsWith(e.toLowerCase())) return null;
    let n = e.endsWith("/") ? e.length - 1 : e.length,
        r = t.charAt(n);
    return r && r !== "/" ? null : t.slice(n) || "/"
}

function Het(t, e) {
    e === void 0 && (e = "/");
    let {
        pathname: n,
        search: r = "",
        hash: i = ""
    } = typeof t == "string" ? gg(t) : t;
    return {
        pathname: n ? n.startsWith("/") ? n : zet(n, e) : e,
        search: Vet(r),
        hash: Get(i)
    }
}

function zet(t, e) {
    let n = e.replace(/\/+$/, "").split("/");
    return t.split("/").forEach(i => {
        i === ".." ? n.length > 1 && n.pop() : i !== "." && n.push(i)
    }), n.length > 1 ? n.join("/") : "/"
}

function qN(t, e, n, r) {
    return "Cannot include a '" + t + "' character in a manually specified " + ("`to." + e + "` field [" + JSON.stringify(r) + "].  Please separate it out to the ") + ("`to." + n + "` field. Alternatively you may provide the full path as ") + 'a string in <Link to="..."> and the router will parse it for you.'
}

function Due(t) {
    return t.filter((e, n) => n === 0 || e.route.path && e.route.path.length > 0)
}

function I7(t, e) {
    let n = Due(t);
    return e ? n.map((r, i) => i === n.length - 1 ? r.pathname : r.pathnameBase) : n.map(r => r.pathnameBase)
}

function R7(t, e, n, r) {
    r === void 0 && (r = !1);
    let i;
    typeof t == "string" ? i = gg(t) : (i = Ti({}, t), Rn(!i.pathname || !i.pathname.includes("?"), qN("?", "pathname", "search", i)), Rn(!i.pathname || !i.pathname.includes("#"), qN("#", "pathname", "hash", i)), Rn(!i.search || !i.search.includes("#"), qN("#", "search", "hash", i)));
    let s = t === "" || i.pathname === "",
        o = s ? "/" : i.pathname,
        a;
    if (o == null) a = n;
    else {
        let f = e.length - 1;
        if (!r && o.startsWith("..")) {
            let h = o.split("/");
            for (; h[0] === "..";) h.shift(), f -= 1;
            i.pathname = h.join("/")
        }
        a = f >= 0 ? e[f] : "/"
    }
    let l = Het(i, a),
        c = o && o !== "/" && o.endsWith("/"),
        u = (s || o === ".") && n.endsWith("/");
    return !l.pathname.endsWith("/") && (c || u) && (l.pathname += "/"), l
}
const wh = t => t.join("/").replace(/\/\/+/g, "/"),
    Wet = t => t.replace(/\/+$/, "").replace(/^\/*/, "/"),
    Vet = t => !t || t === "?" ? "" : t.startsWith("?") ? t : "?" + t,
    Get = t => !t || t === "#" ? "" : t.startsWith("#") ? t : "#" + t;
class NA {
    constructor(e, n, r, i) {
        i === void 0 && (i = !1), this.status = e, this.statusText = n || "", this.internal = i, r instanceof Error ? (this.data = r.toString(), this.error = r) : this.data = r
    }
}

function O7(t) {
    return t != null && typeof t.status == "number" && typeof t.statusText == "string" && typeof t.internal == "boolean" && "data" in t
}
const $ue = ["post", "put", "patch", "delete"],
    qet = new Set($ue),
    Ket = ["get", ...$ue],
    Yet = new Set(Ket),
    Zet = new Set([301, 302, 303, 307, 308]),
    Qet = new Set([307, 308]),
    KN = {
        state: "idle",
        location: void 0,
        formMethod: void 0,
        formAction: void 0,
        formEncType: void 0,
        formData: void 0,
        json: void 0,
        text: void 0
    },
    Jet = {
        state: "idle",
        data: void 0,
        formMethod: void 0,
        formAction: void 0,
        formEncType: void 0,
        formData: void 0,
        json: void 0,
        text: void 0
    },
    o3 = {
        state: "unblocked",
        proceed: void 0,
        reset: void 0,
        location: void 0
    },
    YF = /^(?:[a-z][a-z0-9+.-]*:|\/\/)/i,
    Xet = t => ({
        hasErrorBoundary: !!t.hasErrorBoundary
    }),
    Lue = "remix-router-transitions";

function ett(t) {
    const e = t.window ? t.window : typeof window < "u" ? window : void 0,
        n = typeof e < "u" && typeof e.document < "u" && typeof e.document.createElement < "u",
        r = !n;
    Rn(t.routes.length > 0, "You must provide a non-empty routes array to createRouter");
    let i;
    if (t.mapRouteProperties) i = t.mapRouteProperties;
    else if (t.detectErrorBoundary) {
        let fe = t.detectErrorBoundary;
        i = he => ({
            hasErrorBoundary: fe(he)
        })
    } else i = Xet;
    let s = {},
        o = N6(t.routes, i, void 0, s),
        a, l = t.basename || "/",
        c = t.unstable_dataStrategy || ott,
        u = t.unstable_patchRoutesOnNavigation,
        f = Ti({
            v7_fetcherPersist: !1,
            v7_normalizeFormMethod: !1,
            v7_partialHydration: !1,
            v7_prependBasename: !1,
            v7_relativeSplatPath: !1,
            v7_skipActionErrorRevalidation: !1
        }, t.future),
        h = null,
        g = new Set,
        y = 1e3,
        _ = new Set,
        C = null,
        b = null,
        w = null,
        S = t.hydrationData != null,
        I = n1(o, t.history.location, l),
        P = null;
    if (I == null && !u) {
        let fe = Qo(404, {
                pathname: t.history.location.pathname
            }),
            {
                matches: he,
                route: be
            } = rQ(o);
        I = he, P = {
            [be.id]: fe
        }
    }
    I && !t.hydrationData && Vt(I, o, t.history.location.pathname).active && (I = null);
    let M;
    if (I)
        if (I.some(fe => fe.route.lazy)) M = !1;
        else if (!I.some(fe => fe.route.loader)) M = !0;
    else if (f.v7_partialHydration) {
        let fe = t.hydrationData ? t.hydrationData.loaderData : null,
            he = t.hydrationData ? t.hydrationData.errors : null,
            be = Pe => Pe.route.loader ? typeof Pe.route.loader == "function" && Pe.route.loader.hydrate === !0 ? !1 : fe && fe[Pe.route.id] !== void 0 || he && he[Pe.route.id] !== void 0 : !0;
        if (he) {
            let Pe = I.findIndex(qe => he[qe.route.id] !== void 0);
            M = I.slice(0, Pe + 1).every(be)
        } else M = I.every(be)
    } else M = t.hydrationData != null;
    else if (M = !1, I = [], f.v7_partialHydration) {
        let fe = Vt(null, o, t.history.location.pathname);
        fe.active && fe.matches && (I = fe.matches)
    }
    let A, E = {
            historyAction: t.history.action,
            location: t.history.location,
            matches: I,
            initialized: M,
            navigation: KN,
            restoreScrollPosition: t.hydrationData != null ? !1 : null,
            preventScrollReset: !1,
            revalidation: "idle",
            loaderData: t.hydrationData && t.hydrationData.loaderData || {},
            actionData: t.hydrationData && t.hydrationData.actionData || null,
            errors: t.hydrationData && t.hydrationData.errors || P,
            fetchers: new Map,
            blockers: new Map
        },
        $ = vs.Pop,
        H = !1,
        K, te = !1,
        U = new Map,
        m = null,
        v = !1,
        T = !1,
        N = [],
        O = new Set,
        L = new Map,
        G = 0,
        j = -1,
        R = new Map,
        Y = new Set,
        ve = new Map,
        V = new Map,
        X = new Set,
        q = new Map,
        ne = new Map,
        ie = new Map,
        k;

    function z() {
        if (h = t.history.listen(fe => {
                let {
                    action: he,
                    location: be,
                    delta: Pe
                } = fe;
                if (k) {
                    k(), k = void 0;
                    return
                }
                Km(ne.size === 0 || Pe != null, "You are trying to use a blocker on a POP navigation to a location that was not created by @remix-run/router. This will fail silently in production. This can happen if you are navigating outside the router via `window.history.pushState`/`window.location.hash` instead of using router navigation APIs.  This can also happen if you are using createHashRouter and the user manually changes the URL.");
                let qe = On({
                    currentLocation: E.location,
                    nextLocation: be,
                    historyAction: he
                });
                if (qe && Pe != null) {
                    let Je = new Promise(Mt => {
                        k = Mt
                    });
                    t.history.go(Pe * -1), bn(qe, {
                        state: "blocked",
                        location: be,
                        proceed() {
                            bn(qe, {
                                state: "proceeding",
                                proceed: void 0,
                                reset: void 0,
                                location: be
                            }), Je.then(() => t.history.go(Pe))
                        },
                        reset() {
                            let Mt = new Map(E.blockers);
                            Mt.set(qe, o3), me({
                                blockers: Mt
                            })
                        }
                    });
                    return
                }
                return bt(he, be)
            }), n) {
            _tt(e, U);
            let fe = () => Ett(e, U);
            e.addEventListener("pagehide", fe), m = () => e.removeEventListener("pagehide", fe)
        }
        return E.initialized || bt(vs.Pop, E.location, {
            initialHydration: !0
        }), A
    }

    function Z() {
        h && h(), m && m(), g.clear(), K && K.abort(), E.fetchers.forEach((fe, he) => Se(he)), E.blockers.forEach((fe, he) => ui(he))
    }

    function ge(fe) {
        return g.add(fe), () => g.delete(fe)
    }

    function me(fe, he) {
        he === void 0 && (he = {}), E = Ti({}, E, fe);
        let be = [],
            Pe = [];
        f.v7_fetcherPersist && E.fetchers.forEach((qe, Je) => {
            qe.state === "idle" && (X.has(Je) ? Pe.push(Je) : be.push(Je))
        }), [...g].forEach(qe => qe(E, {
            deletedFetchers: Pe,
            unstable_viewTransitionOpts: he.viewTransitionOpts,
            unstable_flushSync: he.flushSync === !0
        })), f.v7_fetcherPersist && (be.forEach(qe => E.fetchers.delete(qe)), Pe.forEach(qe => Se(qe)))
    }

    function Re(fe, he, be) {
        var Pe, qe;
        let {
            flushSync: Je
        } = be === void 0 ? {} : be, Mt = E.actionData != null && E.navigation.formMethod != null && gu(E.navigation.formMethod) && E.navigation.state === "loading" && ((Pe = fe.state) == null ? void 0 : Pe._isRedirect) !== !0, Le;
        he.actionData ? Object.keys(he.actionData).length > 0 ? Le = he.actionData : Le = null : Mt ? Le = E.actionData : Le = null;
        let rt = he.loaderData ? tQ(E.loaderData, he.loaderData, he.matches || [], he.errors) : E.loaderData,
            ct = E.blockers;
        ct.size > 0 && (ct = new Map(ct), ct.forEach((pn, ln) => ct.set(ln, o3)));
        let ft = H === !0 || E.navigation.formMethod != null && gu(E.navigation.formMethod) && ((qe = fe.state) == null ? void 0 : qe._isRedirect) !== !0;
        a && (o = a, a = void 0), v || $ === vs.Pop || ($ === vs.Push ? t.history.push(fe, fe.state) : $ === vs.Replace && t.history.replace(fe, fe.state));
        let an;
        if ($ === vs.Pop) {
            let pn = U.get(E.location.pathname);
            pn && pn.has(fe.pathname) ? an = {
                currentLocation: E.location,
                nextLocation: fe
            } : U.has(fe.pathname) && (an = {
                currentLocation: fe,
                nextLocation: E.location
            })
        } else if (te) {
            let pn = U.get(E.location.pathname);
            pn ? pn.add(fe.pathname) : (pn = new Set([fe.pathname]), U.set(E.location.pathname, pn)), an = {
                currentLocation: E.location,
                nextLocation: fe
            }
        }
        me(Ti({}, he, {
            actionData: Le,
            loaderData: rt,
            historyAction: $,
            location: fe,
            initialized: !0,
            navigation: KN,
            revalidation: "idle",
            restoreScrollPosition: Jn(fe, he.matches || E.matches),
            preventScrollReset: ft,
            blockers: ct
        }), {
            viewTransitionOpts: an,
            flushSync: Je === !0
        }), $ = vs.Pop, H = !1, te = !1, v = !1, T = !1, N = []
    }
    async function He(fe, he) {
        if (typeof fe == "number") {
            t.history.go(fe);
            return
        }
        let be = TD(E.location, E.matches, l, f.v7_prependBasename, fe, f.v7_relativeSplatPath, he == null ? void 0 : he.fromRouteId, he == null ? void 0 : he.relative),
            {
                path: Pe,
                submission: qe,
                error: Je
            } = YZ(f.v7_normalizeFormMethod, !1, be, he),
            Mt = E.location,
            Le = O6(E.location, Pe, he && he.state);
        Le = Ti({}, Le, t.history.encodeLocation(Le));
        let rt = he && he.replace != null ? he.replace : void 0,
            ct = vs.Push;
        rt === !0 ? ct = vs.Replace : rt === !1 || qe != null && gu(qe.formMethod) && qe.formAction === E.location.pathname + E.location.search && (ct = vs.Replace);
        let ft = he && "preventScrollReset" in he ? he.preventScrollReset === !0 : void 0,
            an = (he && he.unstable_flushSync) === !0,
            pn = On({
                currentLocation: Mt,
                nextLocation: Le,
                historyAction: ct
            });
        if (pn) {
            bn(pn, {
                state: "blocked",
                location: Le,
                proceed() {
                    bn(pn, {
                        state: "proceeding",
                        proceed: void 0,
                        reset: void 0,
                        location: Le
                    }), He(fe, he)
                },
                reset() {
                    let ln = new Map(E.blockers);
                    ln.set(pn, o3), me({
                        blockers: ln
                    })
                }
            });
            return
        }
        return await bt(ct, Le, {
            submission: qe,
            pendingError: Je,
            preventScrollReset: ft,
            replace: he && he.replace,
            enableViewTransition: he && he.unstable_viewTransition,
            flushSync: an
        })
    }

    function Be() {
        if (B(), me({
                revalidation: "loading"
            }), E.navigation.state !== "submitting") {
            if (E.navigation.state === "idle") {
                bt(E.historyAction, E.location, {
                    startUninterruptedRevalidation: !0
                });
                return
            }
            bt($ || E.historyAction, E.navigation.location, {
                overrideNavigation: E.navigation,
                enableViewTransition: te === !0
            })
        }
    }
    async function bt(fe, he, be) {
        K && K.abort(), K = null, $ = fe, v = (be && be.startUninterruptedRevalidation) === !0, zt(E.location, E.matches), H = (be && be.preventScrollReset) === !0, te = (be && be.enableViewTransition) === !0;
        let Pe = a || o,
            qe = be && be.overrideNavigation,
            Je = n1(Pe, he, l),
            Mt = (be && be.flushSync) === !0,
            Le = Vt(Je, Pe, he.pathname);
        if (Le.active && Le.matches && (Je = Le.matches), !Je) {
            let {
                error: cn,
                notFoundMatches: Er,
                route: er
            } = Un(he.pathname);
            Re(he, {
                matches: Er,
                loaderData: {},
                errors: {
                    [er.id]: cn
                }
            }, {
                flushSync: Mt
            });
            return
        }
        if (E.initialized && !T && dtt(E.location, he) && !(be && be.submission && gu(be.submission.formMethod))) {
            Re(he, {
                matches: Je
            }, {
                flushSync: Mt
            });
            return
        }
        K = new AbortController;
        let rt = dw(t.history, he, K.signal, be && be.submission),
            ct;
        if (be && be.pendingError) ct = [Gw(Je).route.id, {
            type: kr.error,
            error: be.pendingError
        }];
        else if (be && be.submission && gu(be.submission.formMethod)) {
            let cn = await mn(rt, he, be.submission, Je, Le.active, {
                replace: be.replace,
                flushSync: Mt
            });
            if (cn.shortCircuited) return;
            if (cn.pendingActionResult) {
                let [Er, er] = cn.pendingActionResult;
                if (bl(er) && O7(er.error) && er.error.status === 404) {
                    K = null, Re(he, {
                        matches: cn.matches,
                        loaderData: {},
                        errors: {
                            [Er]: er.error
                        }
                    });
                    return
                }
            }
            Je = cn.matches || Je, ct = cn.pendingActionResult, qe = YN(he, be.submission), Mt = !1, Le.active = !1, rt = dw(t.history, rt.url, rt.signal)
        }
        let {
            shortCircuited: ft,
            matches: an,
            loaderData: pn,
            errors: ln
        } = await at(rt, he, Je, Le.active, qe, be && be.submission, be && be.fetcherSubmission, be && be.replace, be && be.initialHydration === !0, Mt, ct);
        ft || (K = null, Re(he, Ti({
            matches: an || Je
        }, nQ(ct), {
            loaderData: pn,
            errors: ln
        })))
    }
    async function mn(fe, he, be, Pe, qe, Je) {
        Je === void 0 && (Je = {}), B();
        let Mt = vtt(he, be);
        if (me({
                navigation: Mt
            }, {
                flushSync: Je.flushSync === !0
            }), qe) {
            let ct = await Ft(Pe, he.pathname, fe.signal);
            if (ct.type === "aborted") return {
                shortCircuited: !0
            };
            if (ct.type === "error") {
                let {
                    boundaryId: ft,
                    error: an
                } = Lt(he.pathname, ct);
                return {
                    matches: ct.partialMatches,
                    pendingActionResult: [ft, {
                        type: kr.error,
                        error: an
                    }]
                }
            } else if (ct.matches) Pe = ct.matches;
            else {
                let {
                    notFoundMatches: ft,
                    error: an,
                    route: pn
                } = Un(he.pathname);
                return {
                    matches: ft,
                    pendingActionResult: [pn.id, {
                        type: kr.error,
                        error: an
                    }]
                }
            }
        }
        let Le, rt = k3(Pe, he);
        if (!rt.route.action && !rt.route.lazy) Le = {
            type: kr.error,
            error: Qo(405, {
                method: fe.method,
                pathname: he.pathname,
                routeId: rt.route.id
            })
        };
        else if (Le = (await Q("action", E, fe, [rt], Pe, null))[rt.route.id], fe.signal.aborted) return {
            shortCircuited: !0
        };
        if (v1(Le)) {
            let ct;
            return Je && Je.replace != null ? ct = Je.replace : ct = JZ(Le.response.headers.get("Location"), new URL(fe.url), l) === E.location.pathname + E.location.search, await Xe(fe, Le, !0, {
                submission: be,
                replace: ct
            }), {
                shortCircuited: !0
            }
        }
        if (gp(Le)) throw Qo(400, {
            type: "defer-action"
        });
        if (bl(Le)) {
            let ct = Gw(Pe, rt.route.id);
            return (Je && Je.replace) !== !0 && ($ = vs.Push), {
                matches: Pe,
                pendingActionResult: [ct.route.id, Le]
            }
        }
        return {
            matches: Pe,
            pendingActionResult: [rt.route.id, Le]
        }
    }
    async function at(fe, he, be, Pe, qe, Je, Mt, Le, rt, ct, ft) {
        let an = qe || YN(he, Je),
            pn = Je || Mt || sQ(an),
            ln = !v && (!f.v7_partialHydration || !rt);
        if (Pe) {
            if (ln) {
                let wr = tt(ft);
                me(Ti({
                    navigation: an
                }, wr !== void 0 ? {
                    actionData: wr
                } : {}), {
                    flushSync: ct
                })
            }
            let un = await Ft(be, he.pathname, fe.signal);
            if (un.type === "aborted") return {
                shortCircuited: !0
            };
            if (un.type === "error") {
                let {
                    boundaryId: wr,
                    error: Ms
                } = Lt(he.pathname, un);
                return {
                    matches: un.partialMatches,
                    loaderData: {},
                    errors: {
                        [wr]: Ms
                    }
                }
            } else if (un.matches) be = un.matches;
            else {
                let {
                    error: wr,
                    notFoundMatches: Ms,
                    route: xr
                } = Un(he.pathname);
                return {
                    matches: Ms,
                    loaderData: {},
                    errors: {
                        [xr.id]: wr
                    }
                }
            }
        }
        let cn = a || o,
            [Er, er] = ZZ(t.history, E, be, pn, he, f.v7_partialHydration && rt === !0, f.v7_skipActionErrorRevalidation, T, N, O, X, ve, Y, cn, l, ft);
        if (jt(un => !(be && be.some(wr => wr.route.id === un)) || Er && Er.some(wr => wr.route.id === un)), j = ++G, Er.length === 0 && er.length === 0) {
            let un = en();
            return Re(he, Ti({
                matches: be,
                loaderData: {},
                errors: ft && bl(ft[1]) ? {
                    [ft[0]]: ft[1].error
                } : null
            }, nQ(ft), un ? {
                fetchers: new Map(E.fetchers)
            } : {}), {
                flushSync: ct
            }), {
                shortCircuited: !0
            }
        }
        if (ln) {
            let un = {};
            if (!Pe) {
                un.navigation = an;
                let wr = tt(ft);
                wr !== void 0 && (un.actionData = wr)
            }
            er.length > 0 && (un.fetchers = _t(er)), me(un, {
                flushSync: ct
            })
        }
        er.forEach(un => {
            L.has(un.key) && Ke(un.key), un.controller && L.set(un.key, un.controller)
        });
        let Js = () => er.forEach(un => Ke(un.key));
        K && K.signal.addEventListener("abort", Js);
        let {
            loaderResults: Qi,
            fetcherResults: Ji
        } = await D(E, be, Er, er, fe);
        if (fe.signal.aborted) return {
            shortCircuited: !0
        };
        K && K.signal.removeEventListener("abort", Js), er.forEach(un => L.delete(un.key));
        let Xi = PS(Qi);
        if (Xi) return await Xe(fe, Xi.result, !0, {
            replace: Le
        }), {
            shortCircuited: !0
        };
        if (Xi = PS(Ji), Xi) return Y.add(Xi.key), await Xe(fe, Xi.result, !0, {
            replace: Le
        }), {
            shortCircuited: !0
        };
        let {
            loaderData: Xs,
            errors: Tr
        } = eQ(E, be, Er, Qi, ft, er, Ji, q);
        q.forEach((un, wr) => {
            un.subscribe(Ms => {
                (Ms || un.done) && q.delete(wr)
            })
        }), f.v7_partialHydration && rt && E.errors && Object.entries(E.errors).filter(un => {
            let [wr] = un;
            return !Er.some(Ms => Ms.route.id === wr)
        }).forEach(un => {
            let [wr, Ms] = un;
            Tr = Object.assign(Tr || {}, {
                [wr]: Ms
            })
        });
        let Fl = en(),
            Ul = vt(j),
            jl = Fl || Ul || er.length > 0;
        return Ti({
            matches: be,
            loaderData: Xs,
            errors: Tr
        }, jl ? {
            fetchers: new Map(E.fetchers)
        } : {})
    }

    function tt(fe) {
        if (fe && !bl(fe[1])) return {
            [fe[0]]: fe[1].data
        };
        if (E.actionData) return Object.keys(E.actionData).length === 0 ? null : E.actionData
    }

    function _t(fe) {
        return fe.forEach(he => {
            let be = E.fetchers.get(he.key),
                Pe = a3(void 0, be ? be.data : void 0);
            E.fetchers.set(he.key, Pe)
        }), new Map(E.fetchers)
    }

    function ot(fe, he, be, Pe) {
        if (r) throw new Error("router.fetch() was called during the server render, but it shouldn't be. You are likely calling a useFetcher() method in the body of your component. Try moving it to a useEffect or a callback.");
        L.has(fe) && Ke(fe);
        let qe = (Pe && Pe.unstable_flushSync) === !0,
            Je = a || o,
            Mt = TD(E.location, E.matches, l, f.v7_prependBasename, be, f.v7_relativeSplatPath, he, Pe == null ? void 0 : Pe.relative),
            Le = n1(Je, Mt, l),
            rt = Vt(Le, Je, Mt);
        if (rt.active && rt.matches && (Le = rt.matches), !Le) {
            de(fe, he, Qo(404, {
                pathname: Mt
            }), {
                flushSync: qe
            });
            return
        }
        let {
            path: ct,
            submission: ft,
            error: an
        } = YZ(f.v7_normalizeFormMethod, !0, Mt, Pe);
        if (an) {
            de(fe, he, an, {
                flushSync: qe
            });
            return
        }
        let pn = k3(Le, ct);
        if (H = (Pe && Pe.preventScrollReset) === !0, ft && gu(ft.formMethod)) {
            lt(fe, he, ct, pn, Le, rt.active, qe, ft);
            return
        }
        ve.set(fe, {
            routeId: he,
            path: ct
        }), wt(fe, he, ct, pn, Le, rt.active, qe, ft)
    }
    async function lt(fe, he, be, Pe, qe, Je, Mt, Le) {
        B(), ve.delete(fe);

        function rt(xr) {
            if (!xr.route.action && !xr.route.lazy) {
                let jo = Qo(405, {
                    method: Le.formMethod,
                    pathname: be,
                    routeId: he
                });
                return de(fe, he, jo, {
                    flushSync: Mt
                }), !0
            }
            return !1
        }
        if (!Je && rt(Pe)) return;
        let ct = E.fetchers.get(fe);
        se(fe, btt(Le, ct), {
            flushSync: Mt
        });
        let ft = new AbortController,
            an = dw(t.history, be, ft.signal, Le);
        if (Je) {
            let xr = await Ft(qe, be, an.signal);
            if (xr.type === "aborted") return;
            if (xr.type === "error") {
                let {
                    error: jo
                } = Lt(be, xr);
                de(fe, he, jo, {
                    flushSync: Mt
                });
                return
            } else if (xr.matches) {
                if (qe = xr.matches, Pe = k3(qe, be), rt(Pe)) return
            } else {
                de(fe, he, Qo(404, {
                    pathname: be
                }), {
                    flushSync: Mt
                });
                return
            }
        }
        L.set(fe, ft);
        let pn = G,
            cn = (await Q("action", E, an, [Pe], qe, fe))[Pe.route.id];
        if (an.signal.aborted) {
            L.get(fe) === ft && L.delete(fe);
            return
        }
        if (f.v7_fetcherPersist && X.has(fe)) {
            if (v1(cn) || bl(cn)) {
                se(fe, _0(void 0));
                return
            }
        } else {
            if (v1(cn))
                if (L.delete(fe), j > pn) {
                    se(fe, _0(void 0));
                    return
                } else return Y.add(fe), se(fe, a3(Le)), Xe(an, cn, !1, {
                    fetcherSubmission: Le
                });
            if (bl(cn)) {
                de(fe, he, cn.error);
                return
            }
        }
        if (gp(cn)) throw Qo(400, {
            type: "defer-action"
        });
        let Er = E.navigation.location || E.location,
            er = dw(t.history, Er, ft.signal),
            Js = a || o,
            Qi = E.navigation.state !== "idle" ? n1(Js, E.navigation.location, l) : E.matches;
        Rn(Qi, "Didn't find any matches after fetcher action");
        let Ji = ++G;
        R.set(fe, Ji);
        let Xi = a3(Le, cn.data);
        E.fetchers.set(fe, Xi);
        let [Xs, Tr] = ZZ(t.history, E, Qi, Le, Er, !1, f.v7_skipActionErrorRevalidation, T, N, O, X, ve, Y, Js, l, [Pe.route.id, cn]);
        Tr.filter(xr => xr.key !== fe).forEach(xr => {
            let jo = xr.key,
                Yu = E.fetchers.get(jo),
                yg = a3(void 0, Yu ? Yu.data : void 0);
            E.fetchers.set(jo, yg), L.has(jo) && Ke(jo), xr.controller && L.set(jo, xr.controller)
        }), me({
            fetchers: new Map(E.fetchers)
        });
        let Fl = () => Tr.forEach(xr => Ke(xr.key));
        ft.signal.addEventListener("abort", Fl);
        let {
            loaderResults: Ul,
            fetcherResults: jl
        } = await D(E, Qi, Xs, Tr, er);
        if (ft.signal.aborted) return;
        ft.signal.removeEventListener("abort", Fl), R.delete(fe), L.delete(fe), Tr.forEach(xr => L.delete(xr.key));
        let un = PS(Ul);
        if (un) return Xe(er, un.result, !1);
        if (un = PS(jl), un) return Y.add(un.key), Xe(er, un.result, !1);
        let {
            loaderData: wr,
            errors: Ms
        } = eQ(E, Qi, Xs, Ul, void 0, Tr, jl, q);
        if (E.fetchers.has(fe)) {
            let xr = _0(cn.data);
            E.fetchers.set(fe, xr)
        }
        vt(Ji), E.navigation.state === "loading" && Ji > j ? (Rn($, "Expected pending action"), K && K.abort(), Re(E.navigation.location, {
            matches: Qi,
            loaderData: wr,
            errors: Ms,
            fetchers: new Map(E.fetchers)
        })) : (me({
            errors: Ms,
            loaderData: tQ(E.loaderData, wr, Qi, Ms),
            fetchers: new Map(E.fetchers)
        }), T = !1)
    }
    async function wt(fe, he, be, Pe, qe, Je, Mt, Le) {
        let rt = E.fetchers.get(fe);
        se(fe, a3(Le, rt ? rt.data : void 0), {
            flushSync: Mt
        });
        let ct = new AbortController,
            ft = dw(t.history, be, ct.signal);
        if (Je) {
            let cn = await Ft(qe, be, ft.signal);
            if (cn.type === "aborted") return;
            if (cn.type === "error") {
                let {
                    error: Er
                } = Lt(be, cn);
                de(fe, he, Er, {
                    flushSync: Mt
                });
                return
            } else if (cn.matches) qe = cn.matches, Pe = k3(qe, be);
            else {
                de(fe, he, Qo(404, {
                    pathname: be
                }), {
                    flushSync: Mt
                });
                return
            }
        }
        L.set(fe, ct);
        let an = G,
            ln = (await Q("loader", E, ft, [Pe], qe, fe))[Pe.route.id];
        if (gp(ln) && (ln = await ZF(ln, ft.signal, !0) || ln), L.get(fe) === ct && L.delete(fe), !ft.signal.aborted) {
            if (X.has(fe)) {
                se(fe, _0(void 0));
                return
            }
            if (v1(ln))
                if (j > an) {
                    se(fe, _0(void 0));
                    return
                } else {
                    Y.add(fe), await Xe(ft, ln, !1);
                    return
                }
            if (bl(ln)) {
                de(fe, he, ln.error);
                return
            }
            Rn(!gp(ln), "Unhandled fetcher deferred data"), se(fe, _0(ln.data))
        }
    }
    async function Xe(fe, he, be, Pe) {
        let {
            submission: qe,
            fetcherSubmission: Je,
            replace: Mt
        } = Pe === void 0 ? {} : Pe;
        he.response.headers.has("X-Remix-Revalidate") && (T = !0);
        let Le = he.response.headers.get("Location");
        Rn(Le, "Expected a Location header on the redirect Response"), Le = JZ(Le, new URL(fe.url), l);
        let rt = O6(E.location, Le, {
            _isRedirect: !0
        });
        if (n) {
            let cn = !1;
            if (he.response.headers.has("X-Remix-Reload-Document")) cn = !0;
            else if (YF.test(Le)) {
                const Er = t.history.createURL(Le);
                cn = Er.origin !== e.location.origin || Mh(Er.pathname, l) == null
            }
            if (cn) {
                Mt ? e.location.replace(Le) : e.location.assign(Le);
                return
            }
        }
        K = null;
        let ct = Mt === !0 || he.response.headers.has("X-Remix-Replace") ? vs.Replace : vs.Push,
            {
                formMethod: ft,
                formAction: an,
                formEncType: pn
            } = E.navigation;
        !qe && !Je && ft && an && pn && (qe = sQ(E.navigation));
        let ln = qe || Je;
        if (Qet.has(he.response.status) && ln && gu(ln.formMethod)) await bt(ct, rt, {
            submission: Ti({}, ln, {
                formAction: Le
            }),
            preventScrollReset: H,
            enableViewTransition: be ? te : void 0
        });
        else {
            let cn = YN(rt, qe);
            await bt(ct, rt, {
                overrideNavigation: cn,
                fetcherSubmission: Je,
                preventScrollReset: H,
                enableViewTransition: be ? te : void 0
            })
        }
    }
    async function Q(fe, he, be, Pe, qe, Je) {
        let Mt, Le = {};
        try {
            Mt = await att(c, fe, he, be, Pe, qe, Je, s, i)
        } catch (rt) {
            return Pe.forEach(ct => {
                Le[ct.route.id] = {
                    type: kr.error,
                    error: rt
                }
            }), Le
        }
        for (let [rt, ct] of Object.entries(Mt))
            if (ptt(ct)) {
                let ft = ct.result;
                Le[rt] = {
                    type: kr.redirect,
                    response: utt(ft, be, rt, qe, l, f.v7_relativeSplatPath)
                }
            } else Le[rt] = await ctt(ct);
        return Le
    }
    async function D(fe, he, be, Pe, qe) {
        let Je = fe.matches,
            Mt = Q("loader", fe, qe, be, he, null),
            Le = Promise.all(Pe.map(async ft => {
                if (ft.matches && ft.match && ft.controller) {
                    let pn = (await Q("loader", fe, dw(t.history, ft.path, ft.controller.signal), [ft.match], ft.matches, ft.key))[ft.match.route.id];
                    return {
                        [ft.key]: pn
                    }
                } else return Promise.resolve({
                    [ft.key]: {
                        type: kr.error,
                        error: Qo(404, {
                            pathname: ft.path
                        })
                    }
                })
            })),
            rt = await Mt,
            ct = (await Le).reduce((ft, an) => Object.assign(ft, an), {});
        return await Promise.all([ytt(he, rt, qe.signal, Je, fe.loaderData), wtt(he, ct, Pe)]), {
            loaderResults: rt,
            fetcherResults: ct
        }
    }

    function B() {
        T = !0, N.push(...jt()), ve.forEach((fe, he) => {
            L.has(he) && (O.add(he), Ke(he))
        })
    }

    function se(fe, he, be) {
        be === void 0 && (be = {}), E.fetchers.set(fe, he), me({
            fetchers: new Map(E.fetchers)
        }, {
            flushSync: (be && be.flushSync) === !0
        })
    }

    function de(fe, he, be, Pe) {
        Pe === void 0 && (Pe = {});
        let qe = Gw(E.matches, he);
        Se(fe), me({
            errors: {
                [qe.route.id]: be
            },
            fetchers: new Map(E.fetchers)
        }, {
            flushSync: (Pe && Pe.flushSync) === !0
        })
    }

    function ye(fe) {
        return f.v7_fetcherPersist && (V.set(fe, (V.get(fe) || 0) + 1), X.has(fe) && X.delete(fe)), E.fetchers.get(fe) || Jet
    }

    function Se(fe) {
        let he = E.fetchers.get(fe);
        L.has(fe) && !(he && he.state === "loading" && R.has(fe)) && Ke(fe), ve.delete(fe), R.delete(fe), Y.delete(fe), X.delete(fe), O.delete(fe), E.fetchers.delete(fe)
    }

    function nt(fe) {
        if (f.v7_fetcherPersist) {
            let he = (V.get(fe) || 0) - 1;
            he <= 0 ? (V.delete(fe), X.add(fe)) : V.set(fe, he)
        } else Se(fe);
        me({
            fetchers: new Map(E.fetchers)
        })
    }

    function Ke(fe) {
        let he = L.get(fe);
        Rn(he, "Expected fetch controller: " + fe), he.abort(), L.delete(fe)
    }

    function mt(fe) {
        for (let he of fe) {
            let be = ye(he),
                Pe = _0(be.data);
            E.fetchers.set(he, Pe)
        }
    }

    function en() {
        let fe = [],
            he = !1;
        for (let be of Y) {
            let Pe = E.fetchers.get(be);
            Rn(Pe, "Expected fetcher: " + be), Pe.state === "loading" && (Y.delete(be), fe.push(be), he = !0)
        }
        return mt(fe), he
    }

    function vt(fe) {
        let he = [];
        for (let [be, Pe] of R)
            if (Pe < fe) {
                let qe = E.fetchers.get(be);
                Rn(qe, "Expected fetcher: " + be), qe.state === "loading" && (Ke(be), R.delete(be), he.push(be))
            }
        return mt(he), he.length > 0
    }

    function hn(fe, he) {
        let be = E.blockers.get(fe) || o3;
        return ne.get(fe) !== he && ne.set(fe, he), be
    }

    function ui(fe) {
        E.blockers.delete(fe), ne.delete(fe)
    }

    function bn(fe, he) {
        let be = E.blockers.get(fe) || o3;
        Rn(be.state === "unblocked" && he.state === "blocked" || be.state === "blocked" && he.state === "blocked" || be.state === "blocked" && he.state === "proceeding" || be.state === "blocked" && he.state === "unblocked" || be.state === "proceeding" && he.state === "unblocked", "Invalid blocker state transition: " + be.state + " -> " + he.state);
        let Pe = new Map(E.blockers);
        Pe.set(fe, he), me({
            blockers: Pe
        })
    }

    function On(fe) {
        let {
            currentLocation: he,
            nextLocation: be,
            historyAction: Pe
        } = fe;
        if (ne.size === 0) return;
        ne.size > 1 && Km(!1, "A router only supports one blocker at a time");
        let qe = Array.from(ne.entries()),
            [Je, Mt] = qe[qe.length - 1],
            Le = E.blockers.get(Je);
        if (!(Le && Le.state === "proceeding") && Mt({
                currentLocation: he,
                nextLocation: be,
                historyAction: Pe
            })) return Je
    }

    function Un(fe) {
        let he = Qo(404, {
                pathname: fe
            }),
            be = a || o,
            {
                matches: Pe,
                route: qe
            } = rQ(be);
        return jt(), {
            notFoundMatches: Pe,
            route: qe,
            error: he
        }
    }

    function Lt(fe, he) {
        return {
            boundaryId: Gw(he.partialMatches).route.id,
            error: Qo(400, {
                type: "route-discovery",
                pathname: fe,
                message: he.error != null && "message" in he.error ? he.error : String(he.error)
            })
        }
    }

    function jt(fe) {
        let he = [];
        return q.forEach((be, Pe) => {
            (!fe || fe(Pe)) && (be.cancel(), he.push(Pe), q.delete(Pe))
        }), he
    }

    function qn(fe, he, be) {
        if (C = fe, w = he, b = be || null, !S && E.navigation === KN) {
            S = !0;
            let Pe = Jn(E.location, E.matches);
            Pe != null && me({
                restoreScrollPosition: Pe
            })
        }
        return () => {
            C = null, w = null, b = null
        }
    }

    function Ht(fe, he) {
        return b && b(fe, he.map(Pe => Ret(Pe, E.loaderData))) || fe.key
    }

    function zt(fe, he) {
        if (C && w) {
            let be = Ht(fe, he);
            C[be] = w()
        }
    }

    function Jn(fe, he) {
        if (C) {
            let be = Ht(fe, he),
                Pe = C[be];
            if (typeof Pe == "number") return Pe
        }
        return null
    }

    function Vt(fe, he, be) {
        if (u) {
            if (_.has(be)) return {
                active: !1,
                matches: fe
            };
            if (fe) {
                if (Object.keys(fe[0].params).length > 0) return {
                    active: !0,
                    matches: I8(he, be, l, !0)
                }
            } else return {
                active: !0,
                matches: I8(he, be, l, !0) || []
            }
        }
        return {
            active: !1,
            matches: null
        }
    }
    async function Ft(fe, he, be) {
        let Pe = fe;
        for (;;) {
            let qe = a == null,
                Je = a || o;
            try {
                await itt(u, he, Pe, Je, s, i, ie, be)
            } catch (rt) {
                return {
                    type: "error",
                    error: rt,
                    partialMatches: Pe
                }
            } finally {
                qe && (o = [...o])
            }
            if (be.aborted) return {
                type: "aborted"
            };
            let Mt = n1(Je, he, l);
            if (Mt) return Xn(he, _), {
                type: "success",
                matches: Mt
            };
            let Le = I8(Je, he, l, !0);
            if (!Le || Pe.length === Le.length && Pe.every((rt, ct) => rt.route.id === Le[ct].route.id)) return Xn(he, _), {
                type: "success",
                matches: null
            };
            Pe = Le
        }
    }

    function Xn(fe, he) {
        if (he.size >= y) {
            let be = he.values().next().value;
            he.delete(be)
        }
        he.add(fe)
    }

    function Kt(fe) {
        s = {}, a = N6(fe, i, void 0, s)
    }

    function Qt(fe, he) {
        let be = a == null;
        Fue(fe, he, a || o, s, i), be && (o = [...o], me({}))
    }
    return A = {
        get basename() {
            return l
        },
        get future() {
            return f
        },
        get state() {
            return E
        },
        get routes() {
            return o
        },
        get window() {
            return e
        },
        initialize: z,
        subscribe: ge,
        enableScrollRestoration: qn,
        navigate: He,
        fetch: ot,
        revalidate: Be,
        createHref: fe => t.history.createHref(fe),
        encodeLocation: fe => t.history.encodeLocation(fe),
        getFetcher: ye,
        deleteFetcher: nt,
        dispose: Z,
        getBlocker: hn,
        deleteBlocker: ui,
        patchRoutes: Qt,
        _internalFetchControllers: L,
        _internalActiveDeferreds: q,
        _internalSetRoutes: Kt
    }, A
}

function ttt(t) {
    return t != null && ("formData" in t && t.formData != null || "body" in t && t.body !== void 0)
}

function TD(t, e, n, r, i, s, o, a) {
    let l, c;
    if (o) {
        l = [];
        for (let f of e)
            if (l.push(f), f.route.id === o) {
                c = f;
                break
            }
    } else l = e, c = e[e.length - 1];
    let u = R7(i || ".", I7(l, s), Mh(t.pathname, n) || t.pathname, a === "path");
    return i == null && (u.search = t.search, u.hash = t.hash), (i == null || i === "" || i === ".") && c && c.route.index && !QF(u.search) && (u.search = u.search ? u.search.replace(/^\?/, "?index&") : "?index"), r && n !== "/" && (u.pathname = u.pathname === "/" ? n : wh([n, u.pathname])), Ym(u)
}

function YZ(t, e, n, r) {
    if (!r || !ttt(r)) return {
        path: n
    };
    if (r.formMethod && !mtt(r.formMethod)) return {
        path: n,
        error: Qo(405, {
            method: r.formMethod
        })
    };
    let i = () => ({
            path: n,
            error: Qo(400, {
                type: "invalid-body"
            })
        }),
        s = r.formMethod || "get",
        o = t ? s.toUpperCase() : s.toLowerCase(),
        a = Uue(n);
    if (r.body !== void 0) {
        if (r.formEncType === "text/plain") {
            if (!gu(o)) return i();
            let h = typeof r.body == "string" ? r.body : r.body instanceof FormData || r.body instanceof URLSearchParams ? Array.from(r.body.entries()).reduce((g, y) => {
                let [_, C] = y;
                return "" + g + _ + "=" + C + `
`
            }, "") : String(r.body);
            return {
                path: n,
                submission: {
                    formMethod: o,
                    formAction: a,
                    formEncType: r.formEncType,
                    formData: void 0,
                    json: void 0,
                    text: h
                }
            }
        } else if (r.formEncType === "application/json") {
            if (!gu(o)) return i();
            try {
                let h = typeof r.body == "string" ? JSON.parse(r.body) : r.body;
                return {
                    path: n,
                    submission: {
                        formMethod: o,
                        formAction: a,
                        formEncType: r.formEncType,
                        formData: void 0,
                        json: h,
                        text: void 0
                    }
                }
            } catch {
                return i()
            }
        }
    }
    Rn(typeof FormData == "function", "FormData is not available in this environment");
    let l, c;
    if (r.formData) l = ID(r.formData), c = r.formData;
    else if (r.body instanceof FormData) l = ID(r.body), c = r.body;
    else if (r.body instanceof URLSearchParams) l = r.body, c = XZ(l);
    else if (r.body == null) l = new URLSearchParams, c = new FormData;
    else try {
        l = new URLSearchParams(r.body), c = XZ(l)
    } catch {
        return i()
    }
    let u = {
        formMethod: o,
        formAction: a,
        formEncType: r && r.formEncType || "application/x-www-form-urlencoded",
        formData: c,
        json: void 0,
        text: void 0
    };
    if (gu(u.formMethod)) return {
        path: n,
        submission: u
    };
    let f = gg(n);
    return e && f.search && QF(f.search) && l.append("index", ""), f.search = "?" + l, {
        path: Ym(f),
        submission: u
    }
}

function ntt(t, e) {
    let n = t;
    if (e) {
        let r = t.findIndex(i => i.route.id === e);
        r >= 0 && (n = t.slice(0, r))
    }
    return n
}

function ZZ(t, e, n, r, i, s, o, a, l, c, u, f, h, g, y, _) {
    let C = _ ? bl(_[1]) ? _[1].error : _[1].data : void 0,
        b = t.createURL(e.location),
        w = t.createURL(i),
        S = _ && bl(_[1]) ? _[0] : void 0,
        I = S ? ntt(n, S) : n,
        P = _ ? _[1].statusCode : void 0,
        M = o && P && P >= 400,
        A = I.filter(($, H) => {
            let {
                route: K
            } = $;
            if (K.lazy) return !0;
            if (K.loader == null) return !1;
            if (s) return typeof K.loader != "function" || K.loader.hydrate ? !0 : e.loaderData[K.id] === void 0 && (!e.errors || e.errors[K.id] === void 0);
            if (rtt(e.loaderData, e.matches[H], $) || l.some(m => m === $.route.id)) return !0;
            let te = e.matches[H],
                U = $;
            return QZ($, Ti({
                currentUrl: b,
                currentParams: te.params,
                nextUrl: w,
                nextParams: U.params
            }, r, {
                actionResult: C,
                actionStatus: P,
                defaultShouldRevalidate: M ? !1 : a || b.pathname + b.search === w.pathname + w.search || b.search !== w.search || Bue(te, U)
            }))
        }),
        E = [];
    return f.forEach(($, H) => {
        if (s || !n.some(v => v.route.id === $.routeId) || u.has(H)) return;
        let K = n1(g, $.path, y);
        if (!K) {
            E.push({
                key: H,
                routeId: $.routeId,
                path: $.path,
                matches: null,
                match: null,
                controller: null
            });
            return
        }
        let te = e.fetchers.get(H),
            U = k3(K, $.path),
            m = !1;
        h.has(H) ? m = !1 : c.has(H) ? (c.delete(H), m = !0) : te && te.state !== "idle" && te.data === void 0 ? m = a : m = QZ(U, Ti({
            currentUrl: b,
            currentParams: e.matches[e.matches.length - 1].params,
            nextUrl: w,
            nextParams: n[n.length - 1].params
        }, r, {
            actionResult: C,
            actionStatus: P,
            defaultShouldRevalidate: M ? !1 : a
        })), m && E.push({
            key: H,
            routeId: $.routeId,
            path: $.path,
            matches: K,
            match: U,
            controller: new AbortController
        })
    }), [A, E]
}

function rtt(t, e, n) {
    let r = !e || n.route.id !== e.route.id,
        i = t[n.route.id] === void 0;
    return r || i
}

function Bue(t, e) {
    let n = t.route.path;
    return t.pathname !== e.pathname || n != null && n.endsWith("*") && t.params["*"] !== e.params["*"]
}

function QZ(t, e) {
    if (t.route.shouldRevalidate) {
        let n = t.route.shouldRevalidate(e);
        if (typeof n == "boolean") return n
    }
    return e.defaultShouldRevalidate
}
async function itt(t, e, n, r, i, s, o, a) {
    let l = [e, ...n.map(c => c.route.id)].join("-");
    try {
        let c = o.get(l);
        c || (c = t({
            path: e,
            matches: n,
            patch: (u, f) => {
                a.aborted || Fue(u, f, r, i, s)
            }
        }), o.set(l, c)), c && htt(c) && await c
    } finally {
        o.delete(l)
    }
}

function Fue(t, e, n, r, i) {
    if (t) {
        var s;
        let o = r[t];
        Rn(o, "No route found to patch children into: routeId = " + t);
        let a = N6(e, i, [t, "patch", String(((s = o.children) == null ? void 0 : s.length) || "0")], r);
        o.children ? o.children.push(...a) : o.children = a
    } else {
        let o = N6(e, i, ["patch", String(n.length || "0")], r);
        n.push(...o)
    }
}
async function stt(t, e, n) {
    if (!t.lazy) return;
    let r = await t.lazy();
    if (!t.lazy) return;
    let i = n[t.id];
    Rn(i, "No route found in manifest");
    let s = {};
    for (let o in r) {
        let l = i[o] !== void 0 && o !== "hasErrorBoundary";
        Km(!l, 'Route "' + i.id + '" has a static property "' + o + '" defined but its lazy function is also returning a value for this property. ' + ('The lazy route property "' + o + '" will be ignored.')), !l && !Tet.has(o) && (s[o] = r[o])
    }
    Object.assign(i, s), Object.assign(i, Ti({}, e(i), {
        lazy: void 0
    }))
}
async function ott(t) {
    let {
        matches: e
    } = t, n = e.filter(i => i.shouldLoad);
    return (await Promise.all(n.map(i => i.resolve()))).reduce((i, s, o) => Object.assign(i, {
        [n[o].route.id]: s
    }), {})
}
async function att(t, e, n, r, i, s, o, a, l, c) {
    let u = s.map(g => g.route.lazy ? stt(g.route, l, a) : void 0),
        f = s.map((g, y) => {
            let _ = u[y],
                C = i.some(w => w.route.id === g.route.id);
            return Ti({}, g, {
                shouldLoad: C,
                resolve: async w => (w && r.method === "GET" && (g.route.lazy || g.route.loader) && (C = !0), C ? ltt(e, r, g, _, w, c) : Promise.resolve({
                    type: kr.data,
                    result: void 0
                }))
            })
        }),
        h = await t({
            matches: f,
            request: r,
            params: s[0].params,
            fetcherKey: o,
            context: c
        });
    try {
        await Promise.all(u)
    } catch {}
    return h
}
async function ltt(t, e, n, r, i, s) {
    let o, a, l = c => {
        let u, f = new Promise((y, _) => u = _);
        a = () => u(), e.signal.addEventListener("abort", a);
        let h = y => typeof c != "function" ? Promise.reject(new Error("You cannot call the handler for a route which defines a boolean " + ('"' + t + '" [routeId: ' + n.route.id + "]"))) : c({
                request: e,
                params: n.params,
                context: s
            }, ...y !== void 0 ? [y] : []),
            g = (async () => {
                try {
                    return {
                        type: "data",
                        result: await (i ? i(_ => h(_)) : h())
                    }
                } catch (y) {
                    return {
                        type: "error",
                        result: y
                    }
                }
            })();
        return Promise.race([g, f])
    };
    try {
        let c = n.route[t];
        if (r)
            if (c) {
                let u, [f] = await Promise.all([l(c).catch(h => {
                    u = h
                }), r]);
                if (u !== void 0) throw u;
                o = f
            } else if (await r, c = n.route[t], c) o = await l(c);
        else if (t === "action") {
            let u = new URL(e.url),
                f = u.pathname + u.search;
            throw Qo(405, {
                method: e.method,
                pathname: f,
                routeId: n.route.id
            })
        } else return {
            type: kr.data,
            result: void 0
        };
        else if (c) o = await l(c);
        else {
            let u = new URL(e.url),
                f = u.pathname + u.search;
            throw Qo(404, {
                pathname: f
            })
        }
        Rn(o.result !== void 0, "You defined " + (t === "action" ? "an action" : "a loader") + " for route " + ('"' + n.route.id + "\" but didn't return anything from your `" + t + "` ") + "function. Please return a value or `null`.")
    } catch (c) {
        return {
            type: kr.error,
            result: c
        }
    } finally {
        a && e.signal.removeEventListener("abort", a)
    }
    return o
}
async function ctt(t) {
    let {
        result: e,
        type: n
    } = t;
    if (jue(e)) {
        let c;
        try {
            let u = e.headers.get("Content-Type");
            u && /\bapplication\/json\b/.test(u) ? e.body == null ? c = null : c = await e.json() : c = await e.text()
        } catch (u) {
            return {
                type: kr.error,
                error: u
            }
        }
        return n === kr.error ? {
            type: kr.error,
            error: new NA(e.status, e.statusText, c),
            statusCode: e.status,
            headers: e.headers
        } : {
            type: kr.data,
            data: c,
            statusCode: e.status,
            headers: e.headers
        }
    }
    if (n === kr.error) {
        if (iQ(e)) {
            var r;
            if (e.data instanceof Error) {
                var i;
                return {
                    type: kr.error,
                    error: e.data,
                    statusCode: (i = e.init) == null ? void 0 : i.status
                }
            }
            e = new NA(((r = e.init) == null ? void 0 : r.status) || 500, void 0, e.data)
        }
        return {
            type: kr.error,
            error: e,
            statusCode: O7(e) ? e.status : void 0
        }
    }
    if (gtt(e)) {
        var s, o;
        return {
            type: kr.deferred,
            deferredData: e,
            statusCode: (s = e.init) == null ? void 0 : s.status,
            headers: ((o = e.init) == null ? void 0 : o.headers) && new Headers(e.init.headers)
        }
    }
    if (iQ(e)) {
        var a, l;
        return {
            type: kr.data,
            data: e.data,
            statusCode: (a = e.init) == null ? void 0 : a.status,
            headers: (l = e.init) != null && l.headers ? new Headers(e.init.headers) : void 0
        }
    }
    return {
        type: kr.data,
        data: e
    }
}

function utt(t, e, n, r, i, s) {
    let o = t.headers.get("Location");
    if (Rn(o, "Redirects returned/thrown from loaders/actions must have a Location header"), !YF.test(o)) {
        let a = r.slice(0, r.findIndex(l => l.route.id === n) + 1);
        o = TD(new URL(e.url), a, i, !0, o, s), t.headers.set("Location", o)
    }
    return t
}

function JZ(t, e, n) {
    if (YF.test(t)) {
        let r = t,
            i = r.startsWith("//") ? new URL(e.protocol + r) : new URL(r),
            s = Mh(i.pathname, n) != null;
        if (i.origin === e.origin && s) return i.pathname + i.search + i.hash
    }
    return t
}

function dw(t, e, n, r) {
    let i = t.createURL(Uue(e)).toString(),
        s = {
            signal: n
        };
    if (r && gu(r.formMethod)) {
        let {
            formMethod: o,
            formEncType: a
        } = r;
        s.method = o.toUpperCase(), a === "application/json" ? (s.headers = new Headers({
            "Content-Type": a
        }), s.body = JSON.stringify(r.json)) : a === "text/plain" ? s.body = r.text : a === "application/x-www-form-urlencoded" && r.formData ? s.body = ID(r.formData) : s.body = r.formData
    }
    return new Request(i, s)
}

function ID(t) {
    let e = new URLSearchParams;
    for (let [n, r] of t.entries()) e.append(n, typeof r == "string" ? r : r.name);
    return e
}

function XZ(t) {
    let e = new FormData;
    for (let [n, r] of t.entries()) e.append(n, r);
    return e
}

function ftt(t, e, n, r, i) {
    let s = {},
        o = null,
        a, l = !1,
        c = {},
        u = n && bl(n[1]) ? n[1].error : void 0;
    return t.forEach(f => {
        if (!(f.route.id in e)) return;
        let h = f.route.id,
            g = e[h];
        if (Rn(!v1(g), "Cannot handle redirect results in processLoaderData"), bl(g)) {
            let y = g.error;
            u !== void 0 && (y = u, u = void 0), o = o || {}; {
                let _ = Gw(t, h);
                o[_.route.id] == null && (o[_.route.id] = y)
            }
            s[h] = void 0, l || (l = !0, a = O7(g.error) ? g.error.status : 500), g.headers && (c[h] = g.headers)
        } else gp(g) ? (r.set(h, g.deferredData), s[h] = g.deferredData.data, g.statusCode != null && g.statusCode !== 200 && !l && (a = g.statusCode), g.headers && (c[h] = g.headers)) : (s[h] = g.data, g.statusCode && g.statusCode !== 200 && !l && (a = g.statusCode), g.headers && (c[h] = g.headers))
    }), u !== void 0 && n && (o = {
        [n[0]]: u
    }, s[n[0]] = void 0), {
        loaderData: s,
        errors: o,
        statusCode: a || 200,
        loaderHeaders: c
    }
}

function eQ(t, e, n, r, i, s, o, a) {
    let {
        loaderData: l,
        errors: c
    } = ftt(e, r, i, a);
    return s.forEach(u => {
        let {
            key: f,
            match: h,
            controller: g
        } = u, y = o[f];
        if (Rn(y, "Did not find corresponding fetcher result"), !(g && g.signal.aborted))
            if (bl(y)) {
                let _ = Gw(t.matches, h == null ? void 0 : h.route.id);
                c && c[_.route.id] || (c = Ti({}, c, {
                    [_.route.id]: y.error
                })), t.fetchers.delete(f)
            } else if (v1(y)) Rn(!1, "Unhandled fetcher revalidation redirect");
        else if (gp(y)) Rn(!1, "Unhandled fetcher deferred data");
        else {
            let _ = _0(y.data);
            t.fetchers.set(f, _)
        }
    }), {
        loaderData: l,
        errors: c
    }
}

function tQ(t, e, n, r) {
    let i = Ti({}, e);
    for (let s of n) {
        let o = s.route.id;
        if (e.hasOwnProperty(o) ? e[o] !== void 0 && (i[o] = e[o]) : t[o] !== void 0 && s.route.loader && (i[o] = t[o]), r && r.hasOwnProperty(o)) break
    }
    return i
}

function nQ(t) {
    return t ? bl(t[1]) ? {
        actionData: {}
    } : {
        actionData: {
            [t[0]]: t[1].data
        }
    } : {}
}

function Gw(t, e) {
    return (e ? t.slice(0, t.findIndex(r => r.route.id === e) + 1) : [...t]).reverse().find(r => r.route.hasErrorBoundary === !0) || t[0]
}

function rQ(t) {
    let e = t.length === 1 ? t[0] : t.find(n => n.index || !n.path || n.path === "/") || {
        id: "__shim-error-route__"
    };
    return {
        matches: [{
            params: {},
            pathname: "",
            pathnameBase: "",
            route: e
        }],
        route: e
    }
}

function Qo(t, e) {
    let {
        pathname: n,
        routeId: r,
        method: i,
        type: s,
        message: o
    } = e === void 0 ? {} : e, a = "Unknown Server Error", l = "Unknown @remix-run/router error";
    return t === 400 ? (a = "Bad Request", s === "route-discovery" ? l = 'Unable to match URL "' + n + '" - the `unstable_patchRoutesOnNavigation()` ' + (`function threw the following error:
` + o) : i && n && r ? l = "You made a " + i + ' request to "' + n + '" but ' + ('did not provide a `loader` for route "' + r + '", ') + "so there is no way to handle the request." : s === "defer-action" ? l = "defer() is not supported in actions" : s === "invalid-body" && (l = "Unable to encode submission body")) : t === 403 ? (a = "Forbidden", l = 'Route "' + r + '" does not match URL "' + n + '"') : t === 404 ? (a = "Not Found", l = 'No route matches URL "' + n + '"') : t === 405 && (a = "Method Not Allowed", i && n && r ? l = "You made a " + i.toUpperCase() + ' request to "' + n + '" but ' + ('did not provide an `action` for route "' + r + '", ') + "so there is no way to handle the request." : i && (l = 'Invalid request method "' + i.toUpperCase() + '"')), new NA(t || 500, a, new Error(l), !0)
}

function PS(t) {
    let e = Object.entries(t);
    for (let n = e.length - 1; n >= 0; n--) {
        let [r, i] = e[n];
        if (v1(i)) return {
            key: r,
            result: i
        }
    }
}

function Uue(t) {
    let e = typeof t == "string" ? gg(t) : t;
    return Ym(Ti({}, e, {
        hash: ""
    }))
}

function dtt(t, e) {
    return t.pathname !== e.pathname || t.search !== e.search ? !1 : t.hash === "" ? e.hash !== "" : t.hash === e.hash ? !0 : e.hash !== ""
}

function htt(t) {
    return typeof t == "object" && t != null && "then" in t
}

function ptt(t) {
    return jue(t.result) && Zet.has(t.result.status)
}

function gp(t) {
    return t.type === kr.deferred
}

function bl(t) {
    return t.type === kr.error
}

function v1(t) {
    return (t && t.type) === kr.redirect
}

function iQ(t) {
    return typeof t == "object" && t != null && "type" in t && "data" in t && "init" in t && t.type === "DataWithResponseInit"
}

function gtt(t) {
    let e = t;
    return e && typeof e == "object" && typeof e.data == "object" && typeof e.subscribe == "function" && typeof e.cancel == "function" && typeof e.resolveData == "function"
}

function jue(t) {
    return t != null && typeof t.status == "number" && typeof t.statusText == "string" && typeof t.headers == "object" && typeof t.body < "u"
}

function mtt(t) {
    return Yet.has(t.toLowerCase())
}

function gu(t) {
    return qet.has(t.toLowerCase())
}
async function ytt(t, e, n, r, i) {
    let s = Object.entries(e);
    for (let o = 0; o < s.length; o++) {
        let [a, l] = s[o], c = t.find(h => (h == null ? void 0 : h.route.id) === a);
        if (!c) continue;
        let u = r.find(h => h.route.id === c.route.id),
            f = u != null && !Bue(u, c) && (i && i[c.route.id]) !== void 0;
        gp(l) && f && await ZF(l, n, !1).then(h => {
            h && (e[a] = h)
        })
    }
}
async function wtt(t, e, n) {
    for (let r = 0; r < n.length; r++) {
        let {
            key: i,
            routeId: s,
            controller: o
        } = n[r], a = e[i];
        t.find(c => (c == null ? void 0 : c.route.id) === s) && gp(a) && (Rn(o, "Expected an AbortController for revalidating fetcher deferred result"), await ZF(a, o.signal, !0).then(c => {
            c && (e[i] = c)
        }))
    }
}
async function ZF(t, e, n) {
    if (n === void 0 && (n = !1), !await t.deferredData.resolveData(e)) {
        if (n) try {
            return {
                type: kr.data,
                data: t.deferredData.unwrappedData
            }
        } catch (i) {
            return {
                type: kr.error,
                error: i
            }
        }
        return {
            type: kr.data,
            data: t.deferredData.data
        }
    }
}

function QF(t) {
    return new URLSearchParams(t).getAll("index").some(e => e === "")
}

function k3(t, e) {
    let n = typeof e == "string" ? gg(e).search : e.search;
    if (t[t.length - 1].route.index && QF(n || "")) return t[t.length - 1];
    let r = Due(t);
    return r[r.length - 1]
}

function sQ(t) {
    let {
        formMethod: e,
        formAction: n,
        formEncType: r,
        text: i,
        formData: s,
        json: o
    } = t;
    if (!(!e || !n || !r)) {
        if (i != null) return {
            formMethod: e,
            formAction: n,
            formEncType: r,
            formData: void 0,
            json: void 0,
            text: i
        };
        if (s != null) return {
            formMethod: e,
            formAction: n,
            formEncType: r,
            formData: s,
            json: void 0,
            text: void 0
        };
        if (o !== void 0) return {
            formMethod: e,
            formAction: n,
            formEncType: r,
            formData: void 0,
            json: o,
            text: void 0
        }
    }
}

function YN(t, e) {
    return e ? {
        state: "loading",
        location: t,
        formMethod: e.formMethod,
        formAction: e.formAction,
        formEncType: e.formEncType,
        formData: e.formData,
        json: e.json,
        text: e.text
    } : {
        state: "loading",
        location: t,
        formMethod: void 0,
        formAction: void 0,
        formEncType: void 0,
        formData: void 0,
        json: void 0,
        text: void 0
    }
}

function vtt(t, e) {
    return {
        state: "submitting",
        location: t,
        formMethod: e.formMethod,
        formAction: e.formAction,
        formEncType: e.formEncType,
        formData: e.formData,
        json: e.json,
        text: e.text
    }
}

function a3(t, e) {
    return t ? {
        state: "loading",
        formMethod: t.formMethod,
        formAction: t.formAction,
        formEncType: t.formEncType,
        formData: t.formData,
        json: t.json,
        text: t.text,
        data: e
    } : {
        state: "loading",
        formMethod: void 0,
        formAction: void 0,
        formEncType: void 0,
        formData: void 0,
        json: void 0,
        text: void 0,
        data: e
    }
}

function btt(t, e) {
    return {
        state: "submitting",
        formMethod: t.formMethod,
        formAction: t.formAction,
        formEncType: t.formEncType,
        formData: t.formData,
        json: t.json,
        text: t.text,
        data: e ? e.data : void 0
    }
}

function _0(t) {
    return {
        state: "idle",
        formMethod: void 0,
        formAction: void 0,
        formEncType: void 0,
        formData: void 0,
        json: void 0,
        text: void 0,
        data: t
    }
}

function _tt(t, e) {
    try {
        let n = t.sessionStorage.getItem(Lue);
        if (n) {
            let r = JSON.parse(n);
            for (let [i, s] of Object.entries(r || {})) s && Array.isArray(s) && e.set(i, new Set(s || []))
        }
    } catch {}
}

function Ett(t, e) {
    if (e.size > 0) {
        let n = {};
        for (let [r, i] of e) n[r] = [...i];
        try {
            t.sessionStorage.setItem(Lue, JSON.stringify(n))
        } catch (r) {
            Km(!1, "Failed to save applied view transitions in sessionStorage (" + r + ").")
        }
    }
}
/**
 * React Router v6.26.2
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
function PA() {
    return PA = Object.assign ? Object.assign.bind() : function(t) {
        for (var e = 1; e < arguments.length; e++) {
            var n = arguments[e];
            for (var r in n) Object.prototype.hasOwnProperty.call(n, r) && (t[r] = n[r])
        }
        return t
    }, PA.apply(this, arguments)
}
const h4 = ae.createContext(null),
    JF = ae.createContext(null),
    Vh = ae.createContext(null),
    XF = ae.createContext(null),
    dd = ae.createContext({
        outlet: null,
        matches: [],
        isDataRoute: !1
    }),
    Hue = ae.createContext(null);

function xtt(t, e) {
    let {
        relative: n
    } = e === void 0 ? {} : e;
    Q2() || Rn(!1);
    let {
        basename: r,
        navigator: i
    } = ae.useContext(Vh), {
        hash: s,
        pathname: o,
        search: a
    } = N7(t, {
        relative: n
    }), l = o;
    return r !== "/" && (l = o === "/" ? r : wh([r, o])), i.createHref({
        pathname: l,
        search: a,
        hash: s
    })
}

function Q2() {
    return ae.useContext(XF) != null
}

function Ry() {
    return Q2() || Rn(!1), ae.useContext(XF).location
}

function zue(t) {
    ae.useContext(Vh).static || ae.useLayoutEffect(t)
}

function eU() {
    let {
        isDataRoute: t
    } = ae.useContext(dd);
    return t ? Ltt() : Stt()
}

function Stt() {
    Q2() || Rn(!1);
    let t = ae.useContext(h4),
        {
            basename: e,
            future: n,
            navigator: r
        } = ae.useContext(Vh),
        {
            matches: i
        } = ae.useContext(dd),
        {
            pathname: s
        } = Ry(),
        o = JSON.stringify(I7(i, n.v7_relativeSplatPath)),
        a = ae.useRef(!1);
    return zue(() => {
        a.current = !0
    }), ae.useCallback(function(c, u) {
        if (u === void 0 && (u = {}), !a.current) return;
        if (typeof c == "number") {
            r.go(c);
            return
        }
        let f = R7(c, JSON.parse(o), s, u.relative === "path");
        t == null && e !== "/" && (f.pathname = f.pathname === "/" ? e : wh([e, f.pathname])), (u.replace ? r.replace : r.push)(f, u.state, u)
    }, [e, r, o, s, t])
}
const Ctt = ae.createContext(null);

function Att(t) {
    let e = ae.useContext(dd).outlet;
    return e && ae.createElement(Ctt.Provider, {
        value: t
    }, e)
}

function b3t() {
    let {
        matches: t
    } = ae.useContext(dd), e = t[t.length - 1];
    return e ? e.params : {}
}

function N7(t, e) {
    let {
        relative: n
    } = e === void 0 ? {} : e, {
        future: r
    } = ae.useContext(Vh), {
        matches: i
    } = ae.useContext(dd), {
        pathname: s
    } = Ry(), o = JSON.stringify(I7(i, r.v7_relativeSplatPath));
    return ae.useMemo(() => R7(t, JSON.parse(o), s, n === "path"), [t, o, s, n])
}

function Ttt(t, e, n, r) {
    Q2() || Rn(!1);
    let {
        navigator: i
    } = ae.useContext(Vh), {
        matches: s
    } = ae.useContext(dd), o = s[s.length - 1], a = o ? o.params : {};
    o && o.pathname;
    let l = o ? o.pathnameBase : "/";
    o && o.route;
    let c = Ry(),
        u;
    u = c;
    let f = u.pathname || "/",
        h = f;
    if (l !== "/") {
        let _ = l.replace(/^\//, "").split("/");
        h = "/" + f.replace(/^\//, "").split("/").slice(_.length).join("/")
    }
    let g = n1(t, {
        pathname: h
    });
    return Ptt(g && g.map(_ => Object.assign({}, _, {
        params: Object.assign({}, a, _.params),
        pathname: wh([l, i.encodeLocation ? i.encodeLocation(_.pathname).pathname : _.pathname]),
        pathnameBase: _.pathnameBase === "/" ? l : wh([l, i.encodeLocation ? i.encodeLocation(_.pathnameBase).pathname : _.pathnameBase])
    })), s, n, r)
}

function Itt() {
    let t = $tt(),
        e = O7(t) ? t.status + " " + t.statusText : t instanceof Error ? t.message : JSON.stringify(t),
        n = t instanceof Error ? t.stack : null,
        i = {
            padding: "0.5rem",
            backgroundColor: "rgba(200,200,200, 0.5)"
        };
    return ae.createElement(ae.Fragment, null, ae.createElement("h2", null, "Unexpected Application Error!"), ae.createElement("h3", {
        style: {
            fontStyle: "italic"
        }
    }, e), n ? ae.createElement("pre", {
        style: i
    }, n) : null, null)
}
const Rtt = ae.createElement(Itt, null);
class Ott extends ae.Component {
    constructor(e) {
        super(e), this.state = {
            location: e.location,
            revalidation: e.revalidation,
            error: e.error
        }
    }
    static getDerivedStateFromError(e) {
        return {
            error: e
        }
    }
    static getDerivedStateFromProps(e, n) {
        return n.location !== e.location || n.revalidation !== "idle" && e.revalidation === "idle" ? {
            error: e.error,
            location: e.location,
            revalidation: e.revalidation
        } : {
            error: e.error !== void 0 ? e.error : n.error,
            location: n.location,
            revalidation: e.revalidation || n.revalidation
        }
    }
    componentDidCatch(e, n) {
        console.error("React Router caught the following error during render", e, n)
    }
    render() {
        return this.state.error !== void 0 ? ae.createElement(dd.Provider, {
            value: this.props.routeContext
        }, ae.createElement(Hue.Provider, {
            value: this.state.error,
            children: this.props.component
        })) : this.props.children
    }
}

function Ntt(t) {
    let {
        routeContext: e,
        match: n,
        children: r
    } = t, i = ae.useContext(h4);
    return i && i.static && i.staticContext && (n.route.errorElement || n.route.ErrorBoundary) && (i.staticContext._deepestRenderedBoundaryId = n.route.id), ae.createElement(dd.Provider, {
        value: e
    }, r)
}

function Ptt(t, e, n, r) {
    var i;
    if (e === void 0 && (e = []), n === void 0 && (n = null), r === void 0 && (r = null), t == null) {
        var s;
        if (!n) return null;
        if (n.errors) t = n.matches;
        else if ((s = r) != null && s.v7_partialHydration && e.length === 0 && !n.initialized && n.matches.length > 0) t = n.matches;
        else return null
    }
    let o = t,
        a = (i = n) == null ? void 0 : i.errors;
    if (a != null) {
        let u = o.findIndex(f => f.route.id && (a == null ? void 0 : a[f.route.id]) !== void 0);
        u >= 0 || Rn(!1), o = o.slice(0, Math.min(o.length, u + 1))
    }
    let l = !1,
        c = -1;
    if (n && r && r.v7_partialHydration)
        for (let u = 0; u < o.length; u++) {
            let f = o[u];
            if ((f.route.HydrateFallback || f.route.hydrateFallbackElement) && (c = u), f.route.id) {
                let {
                    loaderData: h,
                    errors: g
                } = n, y = f.route.loader && h[f.route.id] === void 0 && (!g || g[f.route.id] === void 0);
                if (f.route.lazy || y) {
                    l = !0, c >= 0 ? o = o.slice(0, c + 1) : o = [o[0]];
                    break
                }
            }
        }
    return o.reduceRight((u, f, h) => {
        let g, y = !1,
            _ = null,
            C = null;
        n && (g = a && f.route.id ? a[f.route.id] : void 0, _ = f.route.errorElement || Rtt, l && (c < 0 && h === 0 ? (y = !0, C = null) : c === h && (y = !0, C = f.route.hydrateFallbackElement || null)));
        let b = e.concat(o.slice(0, h + 1)),
            w = () => {
                let S;
                return g ? S = _ : y ? S = C : f.route.Component ? S = ae.createElement(f.route.Component, null) : f.route.element ? S = f.route.element : S = u, ae.createElement(Ntt, {
                    match: f,
                    routeContext: {
                        outlet: u,
                        matches: b,
                        isDataRoute: n != null
                    },
                    children: S
                })
            };
        return n && (f.route.ErrorBoundary || f.route.errorElement || h === 0) ? ae.createElement(Ott, {
            location: n.location,
            revalidation: n.revalidation,
            component: _,
            error: g,
            children: w(),
            routeContext: {
                outlet: null,
                matches: b,
                isDataRoute: !0
            }
        }) : w()
    }, null)
}
var Wue = function(t) {
        return t.UseBlocker = "useBlocker", t.UseRevalidator = "useRevalidator", t.UseNavigateStable = "useNavigate", t
    }(Wue || {}),
    kA = function(t) {
        return t.UseBlocker = "useBlocker", t.UseLoaderData = "useLoaderData", t.UseActionData = "useActionData", t.UseRouteError = "useRouteError", t.UseNavigation = "useNavigation", t.UseRouteLoaderData = "useRouteLoaderData", t.UseMatches = "useMatches", t.UseRevalidator = "useRevalidator", t.UseNavigateStable = "useNavigate", t.UseRouteId = "useRouteId", t
    }(kA || {});

function ktt(t) {
    let e = ae.useContext(h4);
    return e || Rn(!1), e
}

function Mtt(t) {
    let e = ae.useContext(JF);
    return e || Rn(!1), e
}

function Dtt(t) {
    let e = ae.useContext(dd);
    return e || Rn(!1), e
}

function Vue(t) {
    let e = Dtt(),
        n = e.matches[e.matches.length - 1];
    return n.route.id || Rn(!1), n.route.id
}

function $tt() {
    var t;
    let e = ae.useContext(Hue),
        n = Mtt(kA.UseRouteError),
        r = Vue(kA.UseRouteError);
    return e !== void 0 ? e : (t = n.errors) == null ? void 0 : t[r]
}

function Ltt() {
    let {
        router: t
    } = ktt(Wue.UseNavigateStable), e = Vue(kA.UseNavigateStable), n = ae.useRef(!1);
    return zue(() => {
        n.current = !0
    }), ae.useCallback(function(i, s) {
        s === void 0 && (s = {}), n.current && (typeof i == "number" ? t.navigate(i) : t.navigate(i, PA({
            fromRouteId: e
        }, s)))
    }, [t, e])
}

function Btt(t) {
    let {
        to: e,
        replace: n,
        state: r,
        relative: i
    } = t;
    Q2() || Rn(!1);
    let {
        future: s,
        static: o
    } = ae.useContext(Vh), {
        matches: a
    } = ae.useContext(dd), {
        pathname: l
    } = Ry(), c = eU(), u = R7(e, I7(a, s.v7_relativeSplatPath), l, i === "path"), f = JSON.stringify(u);
    return ae.useEffect(() => c(JSON.parse(f), {
        replace: n,
        state: r,
        relative: i
    }), [c, f, i, n, r]), null
}

function tU(t) {
    return Att(t.context)
}

function Ftt(t) {
    let {
        basename: e = "/",
        children: n = null,
        location: r,
        navigationType: i = vs.Pop,
        navigator: s,
        static: o = !1,
        future: a
    } = t;
    Q2() && Rn(!1);
    let l = e.replace(/^\/*/, "/"),
        c = ae.useMemo(() => ({
            basename: l,
            navigator: s,
            static: o,
            future: PA({
                v7_relativeSplatPath: !1
            }, a)
        }), [l, a, s, o]);
    typeof r == "string" && (r = gg(r));
    let {
        pathname: u = "/",
        search: f = "",
        hash: h = "",
        state: g = null,
        key: y = "default"
    } = r, _ = ae.useMemo(() => {
        let C = Mh(u, l);
        return C == null ? null : {
            location: {
                pathname: C,
                search: f,
                hash: h,
                state: g,
                key: y
            },
            navigationType: i
        }
    }, [l, u, f, h, g, y, i]);
    return _ == null ? null : ae.createElement(Vh.Provider, {
        value: c
    }, ae.createElement(XF.Provider, {
        children: n,
        value: _
    }))
}
new Promise(() => {});

function Utt(t) {
    let e = {
        hasErrorBoundary: t.ErrorBoundary != null || t.errorElement != null
    };
    return t.Component && Object.assign(e, {
        element: ae.createElement(t.Component),
        Component: void 0
    }), t.HydrateFallback && Object.assign(e, {
        hydrateFallbackElement: ae.createElement(t.HydrateFallback),
        HydrateFallback: void 0
    }), t.ErrorBoundary && Object.assign(e, {
        errorElement: ae.createElement(t.ErrorBoundary),
        ErrorBoundary: void 0
    }), e
}
/**
 * React Router DOM v6.26.2
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
function E2() {
    return E2 = Object.assign ? Object.assign.bind() : function(t) {
        for (var e = 1; e < arguments.length; e++) {
            var n = arguments[e];
            for (var r in n) Object.prototype.hasOwnProperty.call(n, r) && (t[r] = n[r])
        }
        return t
    }, E2.apply(this, arguments)
}

function Gue(t, e) {
    if (t == null) return {};
    var n = {},
        r = Object.keys(t),
        i, s;
    for (s = 0; s < r.length; s++) i = r[s], !(e.indexOf(i) >= 0) && (n[i] = t[i]);
    return n
}

function jtt(t) {
    return !!(t.metaKey || t.altKey || t.ctrlKey || t.shiftKey)
}

function Htt(t, e) {
    return t.button === 0 && (!e || e === "_self") && !jtt(t)
}

function RD(t) {
    return t === void 0 && (t = ""), new URLSearchParams(typeof t == "string" || Array.isArray(t) || t instanceof URLSearchParams ? t : Object.keys(t).reduce((e, n) => {
        let r = t[n];
        return e.concat(Array.isArray(r) ? r.map(i => [n, i]) : [
            [n, r]
        ])
    }, []))
}

function ztt(t, e) {
    let n = RD(t);
    return e && e.forEach((r, i) => {
        n.has(i) || e.getAll(i).forEach(s => {
            n.append(i, s)
        })
    }), n
}
const Wtt = ["onClick", "relative", "reloadDocument", "replace", "state", "target", "to", "preventScrollReset", "unstable_viewTransition"],
    Vtt = ["aria-current", "caseSensitive", "className", "end", "style", "to", "unstable_viewTransition", "children"],
    Gtt = "6";
try {
    window.__reactRouterVersion = Gtt
} catch {}

function qtt(t, e) {
    return ett({
        basename: void 0,
        future: E2({}, void 0, {
            v7_prependBasename: !0
        }),
        history: xet({
            window: void 0
        }),
        hydrationData: Ktt(),
        routes: t,
        mapRouteProperties: Utt,
        unstable_dataStrategy: void 0,
        unstable_patchRoutesOnNavigation: void 0,
        window: void 0
    }).initialize()
}

function Ktt() {
    var t;
    let e = (t = window) == null ? void 0 : t.__staticRouterHydrationData;
    return e && e.errors && (e = E2({}, e, {
        errors: Ytt(e.errors)
    })), e
}

function Ytt(t) {
    if (!t) return null;
    let e = Object.entries(t),
        n = {};
    for (let [r, i] of e)
        if (i && i.__type === "RouteErrorResponse") n[r] = new NA(i.status, i.statusText, i.data, i.internal === !0);
        else if (i && i.__type === "Error") {
        if (i.__subType) {
            let s = window[i.__subType];
            if (typeof s == "function") try {
                let o = new s(i.message);
                o.stack = "", n[r] = o
            } catch {}
        }
        if (n[r] == null) {
            let s = new Error(i.message);
            s.stack = "", n[r] = s
        }
    } else n[r] = i;
    return n
}
const que = ae.createContext({
        isTransitioning: !1
    }),
    Ztt = ae.createContext(new Map),
    Qtt = "startTransition",
    oQ = Mwe[Qtt],
    Jtt = "flushSync",
    aQ = Eet[Jtt];

function Xtt(t) {
    oQ ? oQ(t) : t()
}

function l3(t) {
    aQ ? aQ(t) : t()
}
class ent {
    constructor() {
        this.status = "pending", this.promise = new Promise((e, n) => {
            this.resolve = r => {
                this.status === "pending" && (this.status = "resolved", e(r))
            }, this.reject = r => {
                this.status === "pending" && (this.status = "rejected", n(r))
            }
        })
    }
}

function tnt(t) {
    let {
        fallbackElement: e,
        router: n,
        future: r
    } = t, [i, s] = ae.useState(n.state), [o, a] = ae.useState(), [l, c] = ae.useState({
        isTransitioning: !1
    }), [u, f] = ae.useState(), [h, g] = ae.useState(), [y, _] = ae.useState(), C = ae.useRef(new Map), {
        v7_startTransition: b
    } = r || {}, w = ae.useCallback(E => {
        b ? Xtt(E) : E()
    }, [b]), S = ae.useCallback((E, $) => {
        let {
            deletedFetchers: H,
            unstable_flushSync: K,
            unstable_viewTransitionOpts: te
        } = $;
        H.forEach(m => C.current.delete(m)), E.fetchers.forEach((m, v) => {
            m.data !== void 0 && C.current.set(v, m.data)
        });
        let U = n.window == null || n.window.document == null || typeof n.window.document.startViewTransition != "function";
        if (!te || U) {
            K ? l3(() => s(E)) : w(() => s(E));
            return
        }
        if (K) {
            l3(() => {
                h && (u && u.resolve(), h.skipTransition()), c({
                    isTransitioning: !0,
                    flushSync: !0,
                    currentLocation: te.currentLocation,
                    nextLocation: te.nextLocation
                })
            });
            let m = n.window.document.startViewTransition(() => {
                l3(() => s(E))
            });
            m.finished.finally(() => {
                l3(() => {
                    f(void 0), g(void 0), a(void 0), c({
                        isTransitioning: !1
                    })
                })
            }), l3(() => g(m));
            return
        }
        h ? (u && u.resolve(), h.skipTransition(), _({
            state: E,
            currentLocation: te.currentLocation,
            nextLocation: te.nextLocation
        })) : (a(E), c({
            isTransitioning: !0,
            flushSync: !1,
            currentLocation: te.currentLocation,
            nextLocation: te.nextLocation
        }))
    }, [n.window, h, u, C, w]);
    ae.useLayoutEffect(() => n.subscribe(S), [n, S]), ae.useEffect(() => {
        l.isTransitioning && !l.flushSync && f(new ent)
    }, [l]), ae.useEffect(() => {
        if (u && o && n.window) {
            let E = o,
                $ = u.promise,
                H = n.window.document.startViewTransition(async () => {
                    w(() => s(E)), await $
                });
            H.finished.finally(() => {
                f(void 0), g(void 0), a(void 0), c({
                    isTransitioning: !1
                })
            }), g(H)
        }
    }, [w, o, u, n.window]), ae.useEffect(() => {
        u && o && i.location.key === o.location.key && u.resolve()
    }, [u, h, i.location, o]), ae.useEffect(() => {
        !l.isTransitioning && y && (a(y.state), c({
            isTransitioning: !0,
            flushSync: !1,
            currentLocation: y.currentLocation,
            nextLocation: y.nextLocation
        }), _(void 0))
    }, [l.isTransitioning, y]), ae.useEffect(() => {}, []);
    let I = ae.useMemo(() => ({
            createHref: n.createHref,
            encodeLocation: n.encodeLocation,
            go: E => n.navigate(E),
            push: (E, $, H) => n.navigate(E, {
                state: $,
                preventScrollReset: H == null ? void 0 : H.preventScrollReset
            }),
            replace: (E, $, H) => n.navigate(E, {
                replace: !0,
                state: $,
                preventScrollReset: H == null ? void 0 : H.preventScrollReset
            })
        }), [n]),
        P = n.basename || "/",
        M = ae.useMemo(() => ({
            router: n,
            navigator: I,
            static: !1,
            basename: P
        }), [n, I, P]),
        A = ae.useMemo(() => ({
            v7_relativeSplatPath: n.future.v7_relativeSplatPath
        }), [n.future.v7_relativeSplatPath]);
    return ae.createElement(ae.Fragment, null, ae.createElement(h4.Provider, {
        value: M
    }, ae.createElement(JF.Provider, {
        value: i
    }, ae.createElement(Ztt.Provider, {
        value: C.current
    }, ae.createElement(que.Provider, {
        value: l
    }, ae.createElement(Ftt, {
        basename: P,
        location: i.location,
        navigationType: i.historyAction,
        navigator: I,
        future: A
    }, i.initialized || n.future.v7_partialHydration ? ae.createElement(nnt, {
        routes: n.routes,
        future: n.future,
        state: i
    }) : e))))), null)
}
const nnt = ae.memo(rnt);

function rnt(t) {
    let {
        routes: e,
        future: n,
        state: r
    } = t;
    return Ttt(e, void 0, r, n)
}
const int = typeof window < "u" && typeof window.document < "u" && typeof window.document.createElement < "u",
    snt = /^(?:[a-z][a-z0-9+.-]*:|\/\/)/i,
    ont = ae.forwardRef(function(e, n) {
        let {
            onClick: r,
            relative: i,
            reloadDocument: s,
            replace: o,
            state: a,
            target: l,
            to: c,
            preventScrollReset: u,
            unstable_viewTransition: f
        } = e, h = Gue(e, Wtt), {
            basename: g
        } = ae.useContext(Vh), y, _ = !1;
        if (typeof c == "string" && snt.test(c) && (y = c, int)) try {
            let S = new URL(window.location.href),
                I = c.startsWith("//") ? new URL(S.protocol + c) : new URL(c),
                P = Mh(I.pathname, g);
            I.origin === S.origin && P != null ? c = P + I.search + I.hash : _ = !0
        } catch {}
        let C = xtt(c, {
                relative: i
            }),
            b = cnt(c, {
                replace: o,
                state: a,
                target: l,
                preventScrollReset: u,
                relative: i,
                unstable_viewTransition: f
            });

        function w(S) {
            r && r(S), S.defaultPrevented || b(S)
        }
        return ae.createElement("a", E2({}, h, {
            href: y || C,
            onClick: _ || s ? r : w,
            ref: n,
            target: l
        }))
    }),
    ant = ae.forwardRef(function(e, n) {
        let {
            "aria-current": r = "page",
            caseSensitive: i = !1,
            className: s = "",
            end: o = !1,
            style: a,
            to: l,
            unstable_viewTransition: c,
            children: u
        } = e, f = Gue(e, Vtt), h = N7(l, {
            relative: f.relative
        }), g = Ry(), y = ae.useContext(JF), {
            navigator: _,
            basename: C
        } = ae.useContext(Vh), b = y != null && fnt(h) && c === !0, w = _.encodeLocation ? _.encodeLocation(h).pathname : h.pathname, S = g.pathname, I = y && y.navigation && y.navigation.location ? y.navigation.location.pathname : null;
        i || (S = S.toLowerCase(), I = I ? I.toLowerCase() : null, w = w.toLowerCase()), I && C && (I = Mh(I, C) || I);
        const P = w !== "/" && w.endsWith("/") ? w.length - 1 : w.length;
        let M = S === w || !o && S.startsWith(w) && S.charAt(P) === "/",
            A = I != null && (I === w || !o && I.startsWith(w) && I.charAt(w.length) === "/"),
            E = {
                isActive: M,
                isPending: A,
                isTransitioning: b
            },
            $ = M ? r : void 0,
            H;
        typeof s == "function" ? H = s(E) : H = [s, M ? "active" : null, A ? "pending" : null, b ? "transitioning" : null].filter(Boolean).join(" ");
        let K = typeof a == "function" ? a(E) : a;
        return ae.createElement(ont, E2({}, f, {
            "aria-current": $,
            className: H,
            ref: n,
            style: K,
            to: l,
            unstable_viewTransition: c
        }), typeof u == "function" ? u(E) : u)
    });
var OD;
(function(t) {
    t.UseScrollRestoration = "useScrollRestoration", t.UseSubmit = "useSubmit", t.UseSubmitFetcher = "useSubmitFetcher", t.UseFetcher = "useFetcher", t.useViewTransitionState = "useViewTransitionState"
})(OD || (OD = {}));
var lQ;
(function(t) {
    t.UseFetcher = "useFetcher", t.UseFetchers = "useFetchers", t.UseScrollRestoration = "useScrollRestoration"
})(lQ || (lQ = {}));

function lnt(t) {
    let e = ae.useContext(h4);
    return e || Rn(!1), e
}

function cnt(t, e) {
    let {
        target: n,
        replace: r,
        state: i,
        preventScrollReset: s,
        relative: o,
        unstable_viewTransition: a
    } = e === void 0 ? {} : e, l = eU(), c = Ry(), u = N7(t, {
        relative: o
    });
    return ae.useCallback(f => {
        if (Htt(f, n)) {
            f.preventDefault();
            let h = r !== void 0 ? r : Ym(c) === Ym(u);
            l(t, {
                replace: h,
                state: i,
                preventScrollReset: s,
                relative: o,
                unstable_viewTransition: a
            })
        }
    }, [c, l, u, r, i, n, t, s, o, a])
}

function unt(t) {
    let e = ae.useRef(RD(t)),
        n = ae.useRef(!1),
        r = Ry(),
        i = ae.useMemo(() => ztt(r.search, n.current ? null : e.current), [r.search]),
        s = eU(),
        o = ae.useCallback((a, l) => {
            const c = RD(typeof a == "function" ? a(i) : a);
            n.current = !0, s("?" + c, l)
        }, [s, i]);
    return [i, o]
}

function fnt(t, e) {
    e === void 0 && (e = {});
    let n = ae.useContext(que);
    n == null && Rn(!1);
    let {
        basename: r
    } = lnt(OD.useViewTransitionState), i = N7(t, {
        relative: e.relative
    });
    if (!n.isTransitioning) return !1;
    let s = Mh(n.currentLocation.pathname, r) || n.currentLocation.pathname,
        o = Mh(n.nextLocation.pathname, r) || n.nextLocation.pathname;
    return OA(i.pathname, o) != null || OA(i.pathname, s) != null
}
let dnt = {
        data: ""
    },
    hnt = t => typeof window == "object" ? ((t ? t.querySelector("#_goober") : window._goober) || Object.assign((t || document.head).appendChild(document.createElement("style")), {
        innerHTML: " ",
        id: "_goober"
    })).firstChild : t || dnt,
    pnt = /(?:([\u0080-\uFFFF\w-%@]+) *:? *([^{;]+?);|([^;}{]*?) *{)|(}\s*)/g,
    gnt = /\/\*[^]*?\*\/|  +/g,
    cQ = /\n+/g,
    L0 = (t, e) => {
        let n = "",
            r = "",
            i = "";
        for (let s in t) {
            let o = t[s];
            s[0] == "@" ? s[1] == "i" ? n = s + " " + o + ";" : r += s[1] == "f" ? L0(o, s) : s + "{" + L0(o, s[1] == "k" ? "" : e) + "}" : typeof o == "object" ? r += L0(o, e ? e.replace(/([^,])+/g, a => s.replace(/(^:.*)|([^,])+/g, l => /&/.test(l) ? l.replace(/&/g, a) : a ? a + " " + l : l)) : s) : o != null && (s = /^--/.test(s) ? s : s.replace(/[A-Z]/g, "-$&").toLowerCase(), i += L0.p ? L0.p(s, o) : s + ":" + o + ";")
        }
        return n + (e && i ? e + "{" + i + "}" : i) + r
    },
    Pd = {},
    Kue = t => {
        if (typeof t == "object") {
            let e = "";
            for (let n in t) e += n + Kue(t[n]);
            return e
        }
        return t
    },
    mnt = (t, e, n, r, i) => {
        let s = Kue(t),
            o = Pd[s] || (Pd[s] = (l => {
                let c = 0,
                    u = 11;
                for (; c < l.length;) u = 101 * u + l.charCodeAt(c++) >>> 0;
                return "go" + u
            })(s));
        if (!Pd[o]) {
            let l = s !== t ? t : (c => {
                let u, f, h = [{}];
                for (; u = pnt.exec(c.replace(gnt, ""));) u[4] ? h.shift() : u[3] ? (f = u[3].replace(cQ, " ").trim(), h.unshift(h[0][f] = h[0][f] || {})) : h[0][u[1]] = u[2].replace(cQ, " ").trim();
                return h[0]
            })(t);
            Pd[o] = L0(i ? {
                ["@keyframes " + o]: l
            } : l, n ? "" : "." + o)
        }
        let a = n && Pd.g ? Pd.g : null;
        return n && (Pd.g = Pd[o]), ((l, c, u, f) => {
            f ? c.data = c.data.replace(f, l) : c.data.indexOf(l) === -1 && (c.data = u ? l + c.data : c.data + l)
        })(Pd[o], e, r, a), o
    },
    ynt = (t, e, n) => t.reduce((r, i, s) => {
        let o = e[s];
        if (o && o.call) {
            let a = o(n),
                l = a && a.props && a.props.className || /^go/.test(a) && a;
            o = l ? "." + l : a && typeof a == "object" ? a.props ? "" : L0(a, "") : a === !1 ? "" : a
        }
        return r + i + (o ? ? "")
    }, "");

function P7(t) {
    let e = this || {},
        n = t.call ? t(e.p) : t;
    return mnt(n.unshift ? n.raw ? ynt(n, [].slice.call(arguments, 1), e.p) : n.reduce((r, i) => Object.assign(r, i && i.call ? i(e.p) : i), {}) : n, hnt(e.target), e.g, e.o, e.k)
}
let Yue, ND, PD;
P7.bind({
    g: 1
});
let Dh = P7.bind({
    k: 1
});

function wnt(t, e, n, r) {
    L0.p = e, Yue = t, ND = n, PD = r
}

function mg(t, e) {
    let n = this || {};
    return function() {
        let r = arguments;

        function i(s, o) {
            let a = Object.assign({}, s),
                l = a.className || i.className;
            n.p = Object.assign({
                theme: ND && ND()
            }, a), n.o = / *go\d+/.test(l), a.className = P7.apply(n, r) + (l ? " " + l : "");
            let c = t;
            return t[0] && (c = a.as || t, delete a.as), PD && c[0] && PD(a), Yue(c, a)
        }
        return i
    }
}
var vnt = t => typeof t == "function",
    MA = (t, e) => vnt(t) ? t(e) : t,
    bnt = (() => {
        let t = 0;
        return () => (++t).toString()
    })(),
    Zue = (() => {
        let t;
        return () => {
            if (t === void 0 && typeof window < "u") {
                let e = matchMedia("(prefers-reduced-motion: reduce)");
                t = !e || e.matches
            }
            return t
        }
    })(),
    _nt = 20,
    R8 = new Map,
    Ent = 1e3,
    uQ = t => {
        if (R8.has(t)) return;
        let e = setTimeout(() => {
            R8.delete(t), Oy({
                type: 4,
                toastId: t
            })
        }, Ent);
        R8.set(t, e)
    },
    xnt = t => {
        let e = R8.get(t);
        e && clearTimeout(e)
    },
    kD = (t, e) => {
        switch (e.type) {
            case 0:
                return { ...t,
                    toasts: [e.toast, ...t.toasts].slice(0, _nt)
                };
            case 1:
                return e.toast.id && xnt(e.toast.id), { ...t,
                    toasts: t.toasts.map(s => s.id === e.toast.id ? { ...s,
                        ...e.toast
                    } : s)
                };
            case 2:
                let {
                    toast: n
                } = e;
                return t.toasts.find(s => s.id === n.id) ? kD(t, {
                    type: 1,
                    toast: n
                }) : kD(t, {
                    type: 0,
                    toast: n
                });
            case 3:
                let {
                    toastId: r
                } = e;
                return r ? uQ(r) : t.toasts.forEach(s => {
                    uQ(s.id)
                }), { ...t,
                    toasts: t.toasts.map(s => s.id === r || r === void 0 ? { ...s,
                        visible: !1
                    } : s)
                };
            case 4:
                return e.toastId === void 0 ? { ...t,
                    toasts: []
                } : { ...t,
                    toasts: t.toasts.filter(s => s.id !== e.toastId)
                };
            case 5:
                return { ...t,
                    pausedAt: e.time
                };
            case 6:
                let i = e.time - (t.pausedAt || 0);
                return { ...t,
                    pausedAt: void 0,
                    toasts: t.toasts.map(s => ({ ...s,
                        pauseDuration: s.pauseDuration + i
                    }))
                }
        }
    },
    O8 = [],
    N8 = {
        toasts: [],
        pausedAt: void 0
    },
    Oy = t => {
        N8 = kD(N8, t), O8.forEach(e => {
            e(N8)
        })
    },
    Snt = {
        blank: 4e3,
        error: 4e3,
        success: 2e3,
        loading: 1 / 0,
        custom: 4e3
    },
    Cnt = (t = {}) => {
        let [e, n] = ae.useState(N8);
        ae.useEffect(() => (O8.push(n), () => {
            let i = O8.indexOf(n);
            i > -1 && O8.splice(i, 1)
        }), [e]);
        let r = e.toasts.map(i => {
            var s, o;
            return { ...t,
                ...t[i.type],
                ...i,
                duration: i.duration || ((s = t[i.type]) == null ? void 0 : s.duration) || (t == null ? void 0 : t.duration) || Snt[i.type],
                style: { ...t.style,
                    ...(o = t[i.type]) == null ? void 0 : o.style,
                    ...i.style
                }
            }
        });
        return { ...e,
            toasts: r
        }
    },
    Ant = (t, e = "blank", n) => ({
        createdAt: Date.now(),
        visible: !0,
        type: e,
        ariaProps: {
            role: "status",
            "aria-live": "polite"
        },
        message: t,
        pauseDuration: 0,
        ...n,
        id: (n == null ? void 0 : n.id) || bnt()
    }),
    p4 = t => (e, n) => {
        let r = Ant(e, t, n);
        return Oy({
            type: 2,
            toast: r
        }), r.id
    },
    Cl = (t, e) => p4("blank")(t, e);
Cl.error = p4("error");
Cl.success = p4("success");
Cl.loading = p4("loading");
Cl.custom = p4("custom");
Cl.dismiss = t => {
    Oy({
        type: 3,
        toastId: t
    })
};
Cl.remove = t => Oy({
    type: 4,
    toastId: t
});
Cl.promise = (t, e, n) => {
    let r = Cl.loading(e.loading, { ...n,
        ...n == null ? void 0 : n.loading
    });
    return t.then(i => (Cl.success(MA(e.success, i), {
        id: r,
        ...n,
        ...n == null ? void 0 : n.success
    }), i)).catch(i => {
        Cl.error(MA(e.error, i), {
            id: r,
            ...n,
            ...n == null ? void 0 : n.error
        })
    }), t
};
var Tnt = (t, e) => {
        Oy({
            type: 1,
            toast: {
                id: t,
                height: e
            }
        })
    },
    Int = () => {
        Oy({
            type: 5,
            time: Date.now()
        })
    },
    Rnt = t => {
        let {
            toasts: e,
            pausedAt: n
        } = Cnt(t);
        ae.useEffect(() => {
            if (n) return;
            let s = Date.now(),
                o = e.map(a => {
                    if (a.duration === 1 / 0) return;
                    let l = (a.duration || 0) + a.pauseDuration - (s - a.createdAt);
                    if (l < 0) {
                        a.visible && Cl.dismiss(a.id);
                        return
                    }
                    return setTimeout(() => Cl.dismiss(a.id), l)
                });
            return () => {
                o.forEach(a => a && clearTimeout(a))
            }
        }, [e, n]);
        let r = ae.useCallback(() => {
                n && Oy({
                    type: 6,
                    time: Date.now()
                })
            }, [n]),
            i = ae.useCallback((s, o) => {
                let {
                    reverseOrder: a = !1,
                    gutter: l = 8,
                    defaultPosition: c
                } = o || {}, u = e.filter(g => (g.position || c) === (s.position || c) && g.height), f = u.findIndex(g => g.id === s.id), h = u.filter((g, y) => y < f && g.visible).length;
                return u.filter(g => g.visible).slice(...a ? [h + 1] : [0, h]).reduce((g, y) => g + (y.height || 0) + l, 0)
            }, [e]);
        return {
            toasts: e,
            handlers: {
                updateHeight: Tnt,
                startPause: Int,
                endPause: r,
                calculateOffset: i
            }
        }
    },
    Ont = Dh `
from {
  transform: scale(0) rotate(45deg);
	opacity: 0;
}
to {
 transform: scale(1) rotate(45deg);
  opacity: 1;
}`,
    Nnt = Dh `
from {
  transform: scale(0);
  opacity: 0;
}
to {
  transform: scale(1);
  opacity: 1;
}`,
    Pnt = Dh `
from {
  transform: scale(0) rotate(90deg);
	opacity: 0;
}
to {
  transform: scale(1) rotate(90deg);
	opacity: 1;
}`,
    knt = mg("div")
`
  width: 20px;
  opacity: 0;
  height: 20px;
  border-radius: 10px;
  background: ${t=>t.primary||"#ff4b4b"};
  position: relative;
  transform: rotate(45deg);

  animation: ${Ont} 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275)
    forwards;
  animation-delay: 100ms;

  &:after,
  &:before {
    content: '';
    animation: ${Nnt} 0.15s ease-out forwards;
    animation-delay: 150ms;
    position: absolute;
    border-radius: 3px;
    opacity: 0;
    background: ${t=>t.secondary||"#fff"};
    bottom: 9px;
    left: 4px;
    height: 2px;
    width: 12px;
  }

  &:before {
    animation: ${Pnt} 0.15s ease-out forwards;
    animation-delay: 180ms;
    transform: rotate(90deg);
  }
`, Mnt = Dh `
  from {
    transform: rotate(0deg);
  }
  to {
    transform: rotate(360deg);
  }
`, Dnt = mg("div")
`
  width: 12px;
  height: 12px;
  box-sizing: border-box;
  border: 2px solid;
  border-radius: 100%;
  border-color: ${t=>t.secondary||"#e0e0e0"};
  border-right-color: ${t=>t.primary||"#616161"};
  animation: ${Mnt} 1s linear infinite;
`, $nt = Dh `
from {
  transform: scale(0) rotate(45deg);
	opacity: 0;
}
to {
  transform: scale(1) rotate(45deg);
	opacity: 1;
}`, Lnt = Dh `
0% {
	height: 0;
	width: 0;
	opacity: 0;
}
40% {
  height: 0;
	width: 6px;
	opacity: 1;
}
100% {
  opacity: 1;
  height: 10px;
}`, Bnt = mg("div")
`
  width: 20px;
  opacity: 0;
  height: 20px;
  border-radius: 10px;
  background: ${t=>t.primary||"#61d345"};
  position: relative;
  transform: rotate(45deg);

  animation: ${$nt} 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275)
    forwards;
  animation-delay: 100ms;
  &:after {
    content: '';
    box-sizing: border-box;
    animation: ${Lnt} 0.2s ease-out forwards;
    opacity: 0;
    animation-delay: 200ms;
    position: absolute;
    border-right: 2px solid;
    border-bottom: 2px solid;
    border-color: ${t=>t.secondary||"#fff"};
    bottom: 6px;
    left: 6px;
    height: 10px;
    width: 6px;
  }
`, Fnt = mg("div")
`
  position: absolute;
`, Unt = mg("div")
`
  position: relative;
  display: flex;
  justify-content: center;
  align-items: center;
  min-width: 20px;
  min-height: 20px;
`, jnt = Dh `
from {
  transform: scale(0.6);
  opacity: 0.4;
}
to {
  transform: scale(1);
  opacity: 1;
}`, Hnt = mg("div")
`
  position: relative;
  transform: scale(0.6);
  opacity: 0.4;
  min-width: 20px;
  animation: ${jnt} 0.3s 0.12s cubic-bezier(0.175, 0.885, 0.32, 1.275)
    forwards;
`, znt = ({
    toast: t
}) => {
    let {
        icon: e,
        type: n,
        iconTheme: r
    } = t;
    return e !== void 0 ? typeof e == "string" ? ae.createElement(Hnt, null, e) : e : n === "blank" ? null : ae.createElement(Unt, null, ae.createElement(Dnt, { ...r
    }), n !== "loading" && ae.createElement(Fnt, null, n === "error" ? ae.createElement(knt, { ...r
    }) : ae.createElement(Bnt, { ...r
    })))
}, Wnt = t => `
0% {transform: translate3d(0,${t*-200}%,0) scale(.6); opacity:.5;}
100% {transform: translate3d(0,0,0) scale(1); opacity:1;}
`, Vnt = t => `
0% {transform: translate3d(0,0,-1px) scale(1); opacity:1;}
100% {transform: translate3d(0,${t*-150}%,-1px) scale(.6); opacity:0;}
`, Gnt = "0%{opacity:0;} 100%{opacity:1;}", qnt = "0%{opacity:1;} 100%{opacity:0;}", Knt = mg("div")
`
  display: flex;
  align-items: center;
  background: #fff;
  color: #363636;
  line-height: 1.3;
  will-change: transform;
  box-shadow: 0 3px 10px rgba(0, 0, 0, 0.1), 0 3px 3px rgba(0, 0, 0, 0.05);
  max-width: 350px;
  pointer-events: auto;
  padding: 8px 10px;
  border-radius: 8px;
`, Ynt = mg("div")
`
  display: flex;
  justify-content: center;
  margin: 4px 10px;
  color: inherit;
  flex: 1 1 auto;
  white-space: pre-line;
`, Znt = (t, e) => {
    let n = t.includes("top") ? 1 : -1,
        [r, i] = Zue() ? [Gnt, qnt] : [Wnt(n), Vnt(n)];
    return {
        animation: e ? `${Dh(r)} 0.35s cubic-bezier(.21,1.02,.73,1) forwards` : `${Dh(i)} 0.4s forwards cubic-bezier(.06,.71,.55,1)`
    }
}, Que = ae.memo(({
    toast: t,
    position: e,
    style: n,
    children: r
}) => {
    let i = t.height ? Znt(t.position || e || "top-center", t.visible) : {
            opacity: 0
        },
        s = ae.createElement(znt, {
            toast: t
        }),
        o = ae.createElement(Ynt, { ...t.ariaProps
        }, MA(t.message, t));
    return ae.createElement(Knt, {
        className: t.className,
        style: { ...i,
            ...n,
            ...t.style
        }
    }, typeof r == "function" ? r({
        icon: s,
        message: o
    }) : ae.createElement(ae.Fragment, null, s, o))
});
wnt(ae.createElement);
var Qnt = ({
        id: t,
        className: e,
        style: n,
        onHeightUpdate: r,
        children: i
    }) => {
        let s = ae.useCallback(o => {
            if (o) {
                let a = () => {
                    let l = o.getBoundingClientRect().height;
                    r(t, l)
                };
                a(), new MutationObserver(a).observe(o, {
                    subtree: !0,
                    childList: !0,
                    characterData: !0
                })
            }
        }, [t, r]);
        return ae.createElement("div", {
            ref: s,
            className: e,
            style: n
        }, i)
    },
    Jnt = (t, e) => {
        let n = t.includes("top"),
            r = n ? {
                top: 0
            } : {
                bottom: 0
            },
            i = t.includes("center") ? {
                justifyContent: "center"
            } : t.includes("right") ? {
                justifyContent: "flex-end"
            } : {};
        return {
            left: 0,
            right: 0,
            display: "flex",
            position: "absolute",
            transition: Zue() ? void 0 : "all 230ms cubic-bezier(.21,1.02,.73,1)",
            transform: `translateY(${e*(n?1:-1)}px)`,
            ...r,
            ...i
        }
    },
    Xnt = P7 `
  z-index: 9999;
  > * {
    pointer-events: auto;
  }
`,
    kS = 16,
    ert = ({
        reverseOrder: t,
        position: e = "top-center",
        toastOptions: n,
        gutter: r,
        children: i,
        containerStyle: s,
        containerClassName: o
    }) => {
        let {
            toasts: a,
            handlers: l
        } = Rnt(n);
        return ae.createElement("div", {
            style: {
                position: "fixed",
                zIndex: 9999,
                top: kS,
                left: kS,
                right: kS,
                bottom: kS,
                pointerEvents: "none",
                ...s
            },
            className: o,
            onMouseEnter: l.startPause,
            onMouseLeave: l.endPause
        }, a.map(c => {
            let u = c.position || e,
                f = l.calculateOffset(c, {
                    reverseOrder: t,
                    gutter: r,
                    defaultPosition: e
                }),
                h = Jnt(u, f);
            return ae.createElement(Qnt, {
                id: c.id,
                key: c.id,
                onHeightUpdate: l.updateHeight,
                className: c.visible ? Xnt : "",
                style: h
            }, c.type === "custom" ? MA(c.message, c) : i ? i(c) : ae.createElement(Que, {
                toast: c,
                position: u
            }))
        }))
    },
    xc = Cl;
const a_ = /^[a-z0-9]+(-[a-z0-9]+)*$/,
    k7 = (t, e, n, r = "") => {
        const i = t.split(":");
        if (t.slice(0, 1) === "@") {
            if (i.length < 2 || i.length > 3) return null;
            r = i.shift().slice(1)
        }
        if (i.length > 3 || !i.length) return null;
        if (i.length > 1) {
            const a = i.pop(),
                l = i.pop(),
                c = {
                    provider: i.length > 0 ? i[0] : r,
                    prefix: l,
                    name: a
                };
            return e && !P8(c) ? null : c
        }
        const s = i[0],
            o = s.split("-");
        if (o.length > 1) {
            const a = {
                provider: r,
                prefix: o.shift(),
                name: o.join("-")
            };
            return e && !P8(a) ? null : a
        }
        if (n && r === "") {
            const a = {
                provider: r,
                prefix: "",
                name: s
            };
            return e && !P8(a, n) ? null : a
        }
        return null
    },
    P8 = (t, e) => t ? !!((t.provider === "" || t.provider.match(a_)) && (e && t.prefix === "" || t.prefix.match(a_)) && t.name.match(a_)) : !1,
    Jue = Object.freeze({
        left: 0,
        top: 0,
        width: 16,
        height: 16
    }),
    DA = Object.freeze({
        rotate: 0,
        vFlip: !1,
        hFlip: !1
    }),
    nU = Object.freeze({ ...Jue,
        ...DA
    }),
    MD = Object.freeze({ ...nU,
        body: "",
        hidden: !1
    });

function trt(t, e) {
    const n = {};
    !t.hFlip != !e.hFlip && (n.hFlip = !0), !t.vFlip != !e.vFlip && (n.vFlip = !0);
    const r = ((t.rotate || 0) + (e.rotate || 0)) % 4;
    return r && (n.rotate = r), n
}

function fQ(t, e) {
    const n = trt(t, e);
    for (const r in MD) r in DA ? r in t && !(r in n) && (n[r] = DA[r]) : r in e ? n[r] = e[r] : r in t && (n[r] = t[r]);
    return n
}

function nrt(t, e) {
    const n = t.icons,
        r = t.aliases || Object.create(null),
        i = Object.create(null);

    function s(o) {
        if (n[o]) return i[o] = [];
        if (!(o in i)) {
            i[o] = null;
            const a = r[o] && r[o].parent,
                l = a && s(a);
            l && (i[o] = [a].concat(l))
        }
        return i[o]
    }
    return Object.keys(n).concat(Object.keys(r)).forEach(s), i
}

function rrt(t, e, n) {
    const r = t.icons,
        i = t.aliases || Object.create(null);
    let s = {};

    function o(a) {
        s = fQ(r[a] || i[a], s)
    }
    return o(e), n.forEach(o), fQ(t, s)
}

function Xue(t, e) {
    const n = [];
    if (typeof t != "object" || typeof t.icons != "object") return n;
    t.not_found instanceof Array && t.not_found.forEach(i => {
        e(i, null), n.push(i)
    });
    const r = nrt(t);
    for (const i in r) {
        const s = r[i];
        s && (e(i, rrt(t, i, s)), n.push(i))
    }
    return n
}
const irt = {
    provider: "",
    aliases: {},
    not_found: {},
    ...Jue
};

function ZN(t, e) {
    for (const n in e)
        if (n in t && typeof t[n] != typeof e[n]) return !1;
    return !0
}

function efe(t) {
    if (typeof t != "object" || t === null) return null;
    const e = t;
    if (typeof e.prefix != "string" || !t.icons || typeof t.icons != "object" || !ZN(t, irt)) return null;
    const n = e.icons;
    for (const i in n) {
        const s = n[i];
        if (!i.match(a_) || typeof s.body != "string" || !ZN(s, MD)) return null
    }
    const r = e.aliases || Object.create(null);
    for (const i in r) {
        const s = r[i],
            o = s.parent;
        if (!i.match(a_) || typeof o != "string" || !n[o] && !r[o] || !ZN(s, MD)) return null
    }
    return e
}
const dQ = Object.create(null);

function srt(t, e) {
    return {
        provider: t,
        prefix: e,
        icons: Object.create(null),
        missing: new Set
    }
}

function Zm(t, e) {
    const n = dQ[t] || (dQ[t] = Object.create(null));
    return n[e] || (n[e] = srt(t, e))
}

function rU(t, e) {
    return efe(e) ? Xue(e, (n, r) => {
        r ? t.icons[n] = r : t.missing.add(n)
    }) : []
}

function ort(t, e, n) {
    try {
        if (typeof n.body == "string") return t.icons[e] = { ...n
        }, !0
    } catch {}
    return !1
}
let P6 = !1;

function tfe(t) {
    return typeof t == "boolean" && (P6 = t), P6
}

function art(t) {
    const e = typeof t == "string" ? k7(t, !0, P6) : t;
    if (e) {
        const n = Zm(e.provider, e.prefix),
            r = e.name;
        return n.icons[r] || (n.missing.has(r) ? null : void 0)
    }
}

function lrt(t, e) {
    const n = k7(t, !0, P6);
    if (!n) return !1;
    const r = Zm(n.provider, n.prefix);
    return ort(r, n.name, e)
}

function crt(t, e) {
    if (typeof t != "object") return !1;
    if (typeof e != "string" && (e = t.provider || ""), P6 && !e && !t.prefix) {
        let i = !1;
        return efe(t) && (t.prefix = "", Xue(t, (s, o) => {
            o && lrt(s, o) && (i = !0)
        })), i
    }
    const n = t.prefix;
    if (!P8({
            provider: e,
            prefix: n,
            name: "a"
        })) return !1;
    const r = Zm(e, n);
    return !!rU(r, t)
}
const nfe = Object.freeze({
        width: null,
        height: null
    }),
    rfe = Object.freeze({ ...nfe,
        ...DA
    }),
    urt = /(-?[0-9.]*[0-9]+[0-9.]*)/g,
    frt = /^-?[0-9.]*[0-9]+[0-9.]*$/g;

function hQ(t, e, n) {
    if (e === 1) return t;
    if (n = n || 100, typeof t == "number") return Math.ceil(t * e * n) / n;
    if (typeof t != "string") return t;
    const r = t.split(urt);
    if (r === null || !r.length) return t;
    const i = [];
    let s = r.shift(),
        o = frt.test(s);
    for (;;) {
        if (o) {
            const a = parseFloat(s);
            isNaN(a) ? i.push(s) : i.push(Math.ceil(a * e * n) / n)
        } else i.push(s);
        if (s = r.shift(), s === void 0) return i.join("");
        o = !o
    }
}
const drt = t => t === "unset" || t === "undefined" || t === "none";

function hrt(t, e) {
    const n = { ...nU,
            ...t
        },
        r = { ...rfe,
            ...e
        },
        i = {
            left: n.left,
            top: n.top,
            width: n.width,
            height: n.height
        };
    let s = n.body;
    [n, r].forEach(y => {
        const _ = [],
            C = y.hFlip,
            b = y.vFlip;
        let w = y.rotate;
        C ? b ? w += 2 : (_.push("translate(" + (i.width + i.left).toString() + " " + (0 - i.top).toString() + ")"), _.push("scale(-1 1)"), i.top = i.left = 0) : b && (_.push("translate(" + (0 - i.left).toString() + " " + (i.height + i.top).toString() + ")"), _.push("scale(1 -1)"), i.top = i.left = 0);
        let S;
        switch (w < 0 && (w -= Math.floor(w / 4) * 4), w = w % 4, w) {
            case 1:
                S = i.height / 2 + i.top, _.unshift("rotate(90 " + S.toString() + " " + S.toString() + ")");
                break;
            case 2:
                _.unshift("rotate(180 " + (i.width / 2 + i.left).toString() + " " + (i.height / 2 + i.top).toString() + ")");
                break;
            case 3:
                S = i.width / 2 + i.left, _.unshift("rotate(-90 " + S.toString() + " " + S.toString() + ")");
                break
        }
        w % 2 === 1 && (i.left !== i.top && (S = i.left, i.left = i.top, i.top = S), i.width !== i.height && (S = i.width, i.width = i.height, i.height = S)), _.length && (s = '<g transform="' + _.join(" ") + '">' + s + "</g>")
    });
    const o = r.width,
        a = r.height,
        l = i.width,
        c = i.height;
    let u, f;
    o === null ? (f = a === null ? "1em" : a === "auto" ? c : a, u = hQ(f, l / c)) : (u = o === "auto" ? l : o, f = a === null ? hQ(u, c / l) : a === "auto" ? c : a);
    const h = {},
        g = (y, _) => {
            drt(_) || (h[y] = _.toString())
        };
    return g("width", u), g("height", f), h.viewBox = i.left.toString() + " " + i.top.toString() + " " + l.toString() + " " + c.toString(), {
        attributes: h,
        body: s
    }
}
const prt = /\sid="(\S+)"/g,
    grt = "IconifyId" + Date.now().toString(16) + (Math.random() * 16777216 | 0).toString(16);
let mrt = 0;

function yrt(t, e = grt) {
    const n = [];
    let r;
    for (; r = prt.exec(t);) n.push(r[1]);
    if (!n.length) return t;
    const i = "suffix" + (Math.random() * 16777216 | Date.now()).toString(16);
    return n.forEach(s => {
        const o = typeof e == "function" ? e(s) : e + (mrt++).toString(),
            a = s.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
        t = t.replace(new RegExp('([#;"])(' + a + ')([")]|\\.[a-z])', "g"), "$1" + o + i + "$3")
    }), t = t.replace(new RegExp(i, "g"), ""), t
}
const DD = Object.create(null);

function wrt(t, e) {
    DD[t] = e
}

function $D(t) {
    return DD[t] || DD[""]
}

function iU(t) {
    let e;
    if (typeof t.resources == "string") e = [t.resources];
    else if (e = t.resources, !(e instanceof Array) || !e.length) return null;
    return {
        resources: e,
        path: t.path || "/",
        maxURL: t.maxURL || 500,
        rotate: t.rotate || 750,
        timeout: t.timeout || 5e3,
        random: t.random === !0,
        index: t.index || 0,
        dataAfterTimeout: t.dataAfterTimeout !== !1
    }
}
const sU = Object.create(null),
    c3 = ["https://api.simplesvg.com", "https://api.unisvg.com"],
    k8 = [];
for (; c3.length > 0;) c3.length === 1 || Math.random() > .5 ? k8.push(c3.shift()) : k8.push(c3.pop());
sU[""] = iU({
    resources: ["https://api.iconify.design"].concat(k8)
});

function vrt(t, e) {
    const n = iU(e);
    return n === null ? !1 : (sU[t] = n, !0)
}

function oU(t) {
    return sU[t]
}
const brt = () => {
    let t;
    try {
        if (t = fetch, typeof t == "function") return t
    } catch {}
};
let pQ = brt();

function _rt(t, e) {
    const n = oU(t);
    if (!n) return 0;
    let r;
    if (!n.maxURL) r = 0;
    else {
        let i = 0;
        n.resources.forEach(o => {
            i = Math.max(i, o.length)
        });
        const s = e + ".json?icons=";
        r = n.maxURL - i - n.path.length - s.length
    }
    return r
}

function Ert(t) {
    return t === 404
}
const xrt = (t, e, n) => {
    const r = [],
        i = _rt(t, e),
        s = "icons";
    let o = {
            type: s,
            provider: t,
            prefix: e,
            icons: []
        },
        a = 0;
    return n.forEach((l, c) => {
        a += l.length + 1, a >= i && c > 0 && (r.push(o), o = {
            type: s,
            provider: t,
            prefix: e,
            icons: []
        }, a = l.length), o.icons.push(l)
    }), r.push(o), r
};

function Srt(t) {
    if (typeof t == "string") {
        const e = oU(t);
        if (e) return e.path
    }
    return "/"
}
const Crt = (t, e, n) => {
        if (!pQ) {
            n("abort", 424);
            return
        }
        let r = Srt(e.provider);
        switch (e.type) {
            case "icons":
                {
                    const s = e.prefix,
                        a = e.icons.join(","),
                        l = new URLSearchParams({
                            icons: a
                        });r += s + ".json?" + l.toString();
                    break
                }
            case "custom":
                {
                    const s = e.uri;r += s.slice(0, 1) === "/" ? s.slice(1) : s;
                    break
                }
            default:
                n("abort", 400);
                return
        }
        let i = 503;
        pQ(t + r).then(s => {
            const o = s.status;
            if (o !== 200) {
                setTimeout(() => {
                    n(Ert(o) ? "abort" : "next", o)
                });
                return
            }
            return i = 501, s.json()
        }).then(s => {
            if (typeof s != "object" || s === null) {
                setTimeout(() => {
                    s === 404 ? n("abort", s) : n("next", i)
                });
                return
            }
            setTimeout(() => {
                n("success", s)
            })
        }).catch(() => {
            n("next", i)
        })
    },
    Art = {
        prepare: xrt,
        send: Crt
    };

function Trt(t) {
    const e = {
            loaded: [],
            missing: [],
            pending: []
        },
        n = Object.create(null);
    t.sort((i, s) => i.provider !== s.provider ? i.provider.localeCompare(s.provider) : i.prefix !== s.prefix ? i.prefix.localeCompare(s.prefix) : i.name.localeCompare(s.name));
    let r = {
        provider: "",
        prefix: "",
        name: ""
    };
    return t.forEach(i => {
        if (r.name === i.name && r.prefix === i.prefix && r.provider === i.provider) return;
        r = i;
        const s = i.provider,
            o = i.prefix,
            a = i.name,
            l = n[s] || (n[s] = Object.create(null)),
            c = l[o] || (l[o] = Zm(s, o));
        let u;
        a in c.icons ? u = e.loaded : o === "" || c.missing.has(a) ? u = e.missing : u = e.pending;
        const f = {
            provider: s,
            prefix: o,
            name: a
        };
        u.push(f)
    }), e
}

function ife(t, e) {
    t.forEach(n => {
        const r = n.loaderCallbacks;
        r && (n.loaderCallbacks = r.filter(i => i.id !== e))
    })
}

function Irt(t) {
    t.pendingCallbacksFlag || (t.pendingCallbacksFlag = !0, setTimeout(() => {
        t.pendingCallbacksFlag = !1;
        const e = t.loaderCallbacks ? t.loaderCallbacks.slice(0) : [];
        if (!e.length) return;
        let n = !1;
        const r = t.provider,
            i = t.prefix;
        e.forEach(s => {
            const o = s.icons,
                a = o.pending.length;
            o.pending = o.pending.filter(l => {
                if (l.prefix !== i) return !0;
                const c = l.name;
                if (t.icons[c]) o.loaded.push({
                    provider: r,
                    prefix: i,
                    name: c
                });
                else if (t.missing.has(c)) o.missing.push({
                    provider: r,
                    prefix: i,
                    name: c
                });
                else return n = !0, !0;
                return !1
            }), o.pending.length !== a && (n || ife([t], s.id), s.callback(o.loaded.slice(0), o.missing.slice(0), o.pending.slice(0), s.abort))
        })
    }))
}
let Rrt = 0;

function Ort(t, e, n) {
    const r = Rrt++,
        i = ife.bind(null, n, r);
    if (!e.pending.length) return i;
    const s = {
        id: r,
        icons: e,
        callback: t,
        abort: i
    };
    return n.forEach(o => {
        (o.loaderCallbacks || (o.loaderCallbacks = [])).push(s)
    }), i
}

function Nrt(t, e = !0, n = !1) {
    const r = [];
    return t.forEach(i => {
        const s = typeof i == "string" ? k7(i, e, n) : i;
        s && r.push(s)
    }), r
}
var Prt = {
    resources: [],
    index: 0,
    timeout: 2e3,
    rotate: 750,
    random: !1,
    dataAfterTimeout: !1
};

function krt(t, e, n, r) {
    const i = t.resources.length,
        s = t.random ? Math.floor(Math.random() * i) : t.index;
    let o;
    if (t.random) {
        let M = t.resources.slice(0);
        for (o = []; M.length > 1;) {
            const A = Math.floor(Math.random() * M.length);
            o.push(M[A]), M = M.slice(0, A).concat(M.slice(A + 1))
        }
        o = o.concat(M)
    } else o = t.resources.slice(s).concat(t.resources.slice(0, s));
    const a = Date.now();
    let l = "pending",
        c = 0,
        u, f = null,
        h = [],
        g = [];
    typeof r == "function" && g.push(r);

    function y() {
        f && (clearTimeout(f), f = null)
    }

    function _() {
        l === "pending" && (l = "aborted"), y(), h.forEach(M => {
            M.status === "pending" && (M.status = "aborted")
        }), h = []
    }

    function C(M, A) {
        A && (g = []), typeof M == "function" && g.push(M)
    }

    function b() {
        return {
            startTime: a,
            payload: e,
            status: l,
            queriesSent: c,
            queriesPending: h.length,
            subscribe: C,
            abort: _
        }
    }

    function w() {
        l = "failed", g.forEach(M => {
            M(void 0, u)
        })
    }

    function S() {
        h.forEach(M => {
            M.status === "pending" && (M.status = "aborted")
        }), h = []
    }

    function I(M, A, E) {
        const $ = A !== "success";
        switch (h = h.filter(H => H !== M), l) {
            case "pending":
                break;
            case "failed":
                if ($ || !t.dataAfterTimeout) return;
                break;
            default:
                return
        }
        if (A === "abort") {
            u = E, w();
            return
        }
        if ($) {
            u = E, h.length || (o.length ? P() : w());
            return
        }
        if (y(), S(), !t.random) {
            const H = t.resources.indexOf(M.resource);
            H !== -1 && H !== t.index && (t.index = H)
        }
        l = "completed", g.forEach(H => {
            H(E)
        })
    }

    function P() {
        if (l !== "pending") return;
        y();
        const M = o.shift();
        if (M === void 0) {
            if (h.length) {
                f = setTimeout(() => {
                    y(), l === "pending" && (S(), w())
                }, t.timeout);
                return
            }
            w();
            return
        }
        const A = {
            status: "pending",
            resource: M,
            callback: (E, $) => {
                I(A, E, $)
            }
        };
        h.push(A), c++, f = setTimeout(P, t.rotate), n(M, e, A.callback)
    }
    return setTimeout(P), b
}

function sfe(t) {
    const e = { ...Prt,
        ...t
    };
    let n = [];

    function r() {
        n = n.filter(a => a().status === "pending")
    }

    function i(a, l, c) {
        const u = krt(e, a, l, (f, h) => {
            r(), c && c(f, h)
        });
        return n.push(u), u
    }

    function s(a) {
        return n.find(l => a(l)) || null
    }
    return {
        query: i,
        find: s,
        setIndex: a => {
            e.index = a
        },
        getIndex: () => e.index,
        cleanup: r
    }
}

function gQ() {}
const QN = Object.create(null);

function Mrt(t) {
    if (!QN[t]) {
        const e = oU(t);
        if (!e) return;
        const n = sfe(e),
            r = {
                config: e,
                redundancy: n
            };
        QN[t] = r
    }
    return QN[t]
}

function Drt(t, e, n) {
    let r, i;
    if (typeof t == "string") {
        const s = $D(t);
        if (!s) return n(void 0, 424), gQ;
        i = s.send;
        const o = Mrt(t);
        o && (r = o.redundancy)
    } else {
        const s = iU(t);
        if (s) {
            r = sfe(s);
            const o = t.resources ? t.resources[0] : "",
                a = $D(o);
            a && (i = a.send)
        }
    }
    return !r || !i ? (n(void 0, 424), gQ) : r.query(e, i, n)().abort
}
const mQ = "iconify2",
    k6 = "iconify",
    ofe = k6 + "-count",
    yQ = k6 + "-version",
    afe = 36e5,
    $rt = 168;

function LD(t, e) {
    try {
        return t.getItem(e)
    } catch {}
}

function aU(t, e, n) {
    try {
        return t.setItem(e, n), !0
    } catch {}
}

function wQ(t, e) {
    try {
        t.removeItem(e)
    } catch {}
}

function BD(t, e) {
    return aU(t, ofe, e.toString())
}

function FD(t) {
    return parseInt(LD(t, ofe)) || 0
}
const M7 = {
        local: !0,
        session: !0
    },
    lfe = {
        local: new Set,
        session: new Set
    };
let lU = !1;

function Lrt(t) {
    lU = t
}
let MS = typeof window > "u" ? {} : window;

function cfe(t) {
    const e = t + "Storage";
    try {
        if (MS && MS[e] && typeof MS[e].length == "number") return MS[e]
    } catch {}
    M7[t] = !1
}

function ufe(t, e) {
    const n = cfe(t);
    if (!n) return;
    const r = LD(n, yQ);
    if (r !== mQ) {
        if (r) {
            const a = FD(n);
            for (let l = 0; l < a; l++) wQ(n, k6 + l.toString())
        }
        aU(n, yQ, mQ), BD(n, 0);
        return
    }
    const i = Math.floor(Date.now() / afe) - $rt,
        s = a => {
            const l = k6 + a.toString(),
                c = LD(n, l);
            if (typeof c == "string") {
                try {
                    const u = JSON.parse(c);
                    if (typeof u == "object" && typeof u.cached == "number" && u.cached > i && typeof u.provider == "string" && typeof u.data == "object" && typeof u.data.prefix == "string" && e(u, a)) return !0
                } catch {}
                wQ(n, l)
            }
        };
    let o = FD(n);
    for (let a = o - 1; a >= 0; a--) s(a) || (a === o - 1 ? (o--, BD(n, o)) : lfe[t].add(a))
}

function ffe() {
    if (!lU) {
        Lrt(!0);
        for (const t in M7) ufe(t, e => {
            const n = e.data,
                r = e.provider,
                i = n.prefix,
                s = Zm(r, i);
            if (!rU(s, n).length) return !1;
            const o = n.lastModified || -1;
            return s.lastModifiedCached = s.lastModifiedCached ? Math.min(s.lastModifiedCached, o) : o, !0
        })
    }
}

function Brt(t, e) {
    const n = t.lastModifiedCached;
    if (n && n >= e) return n === e;
    if (t.lastModifiedCached = e, n)
        for (const r in M7) ufe(r, i => {
            const s = i.data;
            return i.provider !== t.provider || s.prefix !== t.prefix || s.lastModified === e
        });
    return !0
}

function Frt(t, e) {
    lU || ffe();

    function n(r) {
        let i;
        if (!M7[r] || !(i = cfe(r))) return;
        const s = lfe[r];
        let o;
        if (s.size) s.delete(o = Array.from(s).shift());
        else if (o = FD(i), !BD(i, o + 1)) return;
        const a = {
            cached: Math.floor(Date.now() / afe),
            provider: t.provider,
            data: e
        };
        return aU(i, k6 + o.toString(), JSON.stringify(a))
    }
    e.lastModified && !Brt(t, e.lastModified) || Object.keys(e.icons).length && (e.not_found && (e = Object.assign({}, e), delete e.not_found), n("local") || n("session"))
}

function vQ() {}

function Urt(t) {
    t.iconsLoaderFlag || (t.iconsLoaderFlag = !0, setTimeout(() => {
        t.iconsLoaderFlag = !1, Irt(t)
    }))
}

function jrt(t, e) {
    t.iconsToLoad ? t.iconsToLoad = t.iconsToLoad.concat(e).sort() : t.iconsToLoad = e, t.iconsQueueFlag || (t.iconsQueueFlag = !0, setTimeout(() => {
        t.iconsQueueFlag = !1;
        const {
            provider: n,
            prefix: r
        } = t, i = t.iconsToLoad;
        delete t.iconsToLoad;
        let s;
        if (!i || !(s = $D(n))) return;
        s.prepare(n, r, i).forEach(a => {
            Drt(n, a, l => {
                if (typeof l != "object") a.icons.forEach(c => {
                    t.missing.add(c)
                });
                else try {
                    const c = rU(t, l);
                    if (!c.length) return;
                    const u = t.pendingIcons;
                    u && c.forEach(f => {
                        u.delete(f)
                    }), Frt(t, l)
                } catch (c) {
                    console.error(c)
                }
                Urt(t)
            })
        })
    }))
}
const Hrt = (t, e) => {
    const n = Nrt(t, !0, tfe()),
        r = Trt(n);
    if (!r.pending.length) {
        let l = !0;
        return e && setTimeout(() => {
            l && e(r.loaded, r.missing, r.pending, vQ)
        }), () => {
            l = !1
        }
    }
    const i = Object.create(null),
        s = [];
    let o, a;
    return r.pending.forEach(l => {
        const {
            provider: c,
            prefix: u
        } = l;
        if (u === a && c === o) return;
        o = c, a = u, s.push(Zm(c, u));
        const f = i[c] || (i[c] = Object.create(null));
        f[u] || (f[u] = [])
    }), r.pending.forEach(l => {
        const {
            provider: c,
            prefix: u,
            name: f
        } = l, h = Zm(c, u), g = h.pendingIcons || (h.pendingIcons = new Set);
        g.has(f) || (g.add(f), i[c][u].push(f))
    }), s.forEach(l => {
        const {
            provider: c,
            prefix: u
        } = l;
        i[c][u].length && jrt(l, i[c][u])
    }), e ? Ort(e, r, s) : vQ
};

function zrt(t, e) {
    const n = { ...t
    };
    for (const r in e) {
        const i = e[r],
            s = typeof i;
        r in nfe ? (i === null || i && (s === "string" || s === "number")) && (n[r] = i) : s === typeof n[r] && (n[r] = r === "rotate" ? i % 4 : i)
    }
    return n
}
const Wrt = /[\s,]+/;

function Vrt(t, e) {
    e.split(Wrt).forEach(n => {
        switch (n.trim()) {
            case "horizontal":
                t.hFlip = !0;
                break;
            case "vertical":
                t.vFlip = !0;
                break
        }
    })
}

function Grt(t, e = 0) {
    const n = t.replace(/^-?[0-9.]*/, "");

    function r(i) {
        for (; i < 0;) i += 4;
        return i % 4
    }
    if (n === "") {
        const i = parseInt(t);
        return isNaN(i) ? 0 : r(i)
    } else if (n !== t) {
        let i = 0;
        switch (n) {
            case "%":
                i = 25;
                break;
            case "deg":
                i = 90
        }
        if (i) {
            let s = parseFloat(t.slice(0, t.length - n.length));
            return isNaN(s) ? 0 : (s = s / i, s % 1 === 0 ? r(s) : 0)
        }
    }
    return e
}

function qrt(t, e) {
    let n = t.indexOf("xlink:") === -1 ? "" : ' xmlns:xlink="http://www.w3.org/1999/xlink"';
    for (const r in e) n += " " + r + '="' + e[r] + '"';
    return '<svg xmlns="http://www.w3.org/2000/svg"' + n + ">" + t + "</svg>"
}

function Krt(t) {
    return t.replace(/"/g, "'").replace(/%/g, "%25").replace(/#/g, "%23").replace(/</g, "%3C").replace(/>/g, "%3E").replace(/\s+/g, " ")
}

function Yrt(t) {
    return "data:image/svg+xml," + Krt(t)
}

function Zrt(t) {
    return 'url("' + Yrt(t) + '")'
}
let l_;

function Qrt() {
    try {
        l_ = window.trustedTypes.createPolicy("iconify", {
            createHTML: t => t
        })
    } catch {
        l_ = null
    }
}

function Jrt(t) {
    return l_ === void 0 && Qrt(), l_ ? l_.createHTML(t) : t
}
const dfe = { ...rfe,
        inline: !1
    },
    Xrt = {
        xmlns: "http://www.w3.org/2000/svg",
        xmlnsXlink: "http://www.w3.org/1999/xlink",
        "aria-hidden": !0,
        role: "img"
    },
    eit = {
        display: "inline-block"
    },
    UD = {
        backgroundColor: "currentColor"
    },
    hfe = {
        backgroundColor: "transparent"
    },
    bQ = {
        Image: "var(--svg)",
        Repeat: "no-repeat",
        Size: "100% 100%"
    },
    _Q = {
        WebkitMask: UD,
        mask: UD,
        background: hfe
    };
for (const t in _Q) {
    const e = _Q[t];
    for (const n in bQ) e[t + n] = bQ[n]
}
const tit = { ...dfe,
    inline: !0
};

function EQ(t) {
    return t + (t.match(/^[-0-9.]+$/) ? "px" : "")
}
const nit = (t, e, n, r) => {
    const i = n ? tit : dfe,
        s = zrt(i, e),
        o = e.mode || "svg",
        a = {},
        l = e.style || {},
        c = { ...o === "svg" ? Xrt : {},
            ref: r
        };
    for (let b in e) {
        const w = e[b];
        if (w !== void 0) switch (b) {
            case "icon":
            case "style":
            case "children":
            case "onLoad":
            case "mode":
            case "_ref":
            case "_inline":
                break;
            case "inline":
            case "hFlip":
            case "vFlip":
                s[b] = w === !0 || w === "true" || w === 1;
                break;
            case "flip":
                typeof w == "string" && Vrt(s, w);
                break;
            case "color":
                a.color = w;
                break;
            case "rotate":
                typeof w == "string" ? s[b] = Grt(w) : typeof w == "number" && (s[b] = w);
                break;
            case "ariaHidden":
            case "aria-hidden":
                w !== !0 && w !== "true" && delete c["aria-hidden"];
                break;
            default:
                i[b] === void 0 && (c[b] = w)
        }
    }
    const u = hrt(t, s),
        f = u.attributes;
    if (s.inline && (a.verticalAlign = "-0.125em"), o === "svg") {
        c.style = { ...a,
            ...l
        }, Object.assign(c, f);
        let b = 0,
            w = e.id;
        return typeof w == "string" && (w = w.replace(/-/g, "_")), c.dangerouslySetInnerHTML = {
            __html: Jrt(yrt(u.body, w ? () => w + "ID" + b++ : "iconifyReact"))
        }, Tu.createElement("svg", c)
    }
    const {
        body: h,
        width: g,
        height: y
    } = t, _ = o === "mask" || (o === "bg" ? !1 : h.indexOf("currentColor") !== -1), C = qrt(h, { ...f,
        width: g + "",
        height: y + ""
    });
    return c.style = { ...a,
        "--svg": Zrt(C),
        width: EQ(f.width),
        height: EQ(f.height),
        ...eit,
        ..._ ? UD : hfe,
        ...l
    }, Tu.createElement("span", c)
};
tfe(!0);
wrt("", Art);
if (typeof document < "u" && typeof window < "u") {
    ffe();
    const t = window;
    if (t.IconifyPreload !== void 0) {
        const e = t.IconifyPreload,
            n = "Invalid IconifyPreload syntax.";
        typeof e == "object" && e !== null && (e instanceof Array ? e : [e]).forEach(r => {
            try {
                (typeof r != "object" || r === null || r instanceof Array || typeof r.icons != "object" || typeof r.prefix != "string" || !crt(r)) && console.error(n)
            } catch {
                console.error(n)
            }
        })
    }
    if (t.IconifyProviders !== void 0) {
        const e = t.IconifyProviders;
        if (typeof e == "object" && e !== null)
            for (let n in e) {
                const r = "IconifyProviders[" + n + "] is invalid.";
                try {
                    const i = e[n];
                    if (typeof i != "object" || !i || i.resources === void 0) continue;
                    vrt(n, i) || console.error(r)
                } catch {
                    console.error(r)
                }
            }
    }
}
class pfe extends Tu.Component {
    constructor(e) {
        super(e), this.state = {
            icon: null
        }
    }
    _abortLoading() {
        this._loading && (this._loading.abort(), this._loading = null)
    }
    _setData(e) {
        this.state.icon !== e && this.setState({
            icon: e
        })
    }
    _checkIcon(e) {
        const n = this.state,
            r = this.props.icon;
        if (typeof r == "object" && r !== null && typeof r.body == "string") {
            this._icon = "", this._abortLoading(), (e || n.icon === null) && this._setData({
                data: r
            });
            return
        }
        let i;
        if (typeof r != "string" || (i = k7(r, !1, !0)) === null) {
            this._abortLoading(), this._setData(null);
            return
        }
        const s = art(i);
        if (!s) {
            (!this._loading || this._loading.name !== r) && (this._abortLoading(), this._icon = "", this._setData(null), s !== null && (this._loading = {
                name: r,
                abort: Hrt([i], this._checkIcon.bind(this, !1))
            }));
            return
        }
        if (this._icon !== r || n.icon === null) {
            this._abortLoading(), this._icon = r;
            const o = ["iconify"];
            i.prefix !== "" && o.push("iconify--" + i.prefix), i.provider !== "" && o.push("iconify--" + i.provider), this._setData({
                data: s,
                classes: o
            }), this.props.onLoad && this.props.onLoad(r)
        }
    }
    componentDidMount() {
        this._checkIcon(!1)
    }
    componentDidUpdate(e) {
        e.icon !== this.props.icon && this._checkIcon(!0)
    }
    componentWillUnmount() {
        this._abortLoading()
    }
    render() {
        const e = this.props,
            n = this.state.icon;
        if (n === null) return e.children ? e.children : Tu.createElement("span", {});
        let r = e;
        return n.classes && (r = { ...e,
            className: (typeof e.className == "string" ? e.className + " " : "") + n.classes.join(" ")
        }), nit({ ...nU,
            ...n.data
        }, r, e._inline, e._ref)
    }
}
const Xr = Tu.forwardRef(function(e, n) {
    const r = { ...e,
        _ref: n,
        _inline: !1
    };
    return Tu.createElement(pfe, r)
});
Tu.forwardRef(function(e, n) {
    const r = { ...e,
        _ref: n,
        _inline: !0
    };
    return Tu.createElement(pfe, r)
});
const rit = t => {
        const e = ae.useRef(t);
        return e.current = t, e
    },
    Qm = t => {
        const e = rit(t);
        return ae.useCallback((...n) => e.current(...n), [e])
    },
    gfe = null,
    cU = ae.createContext([gfe, () => null]),
    iit = ({
        children: t
    }) => {
        const e = ae.useState(gfe);
        return J.jsx(cU.Provider, {
            value: e,
            children: t
        })
    },
    sit = () => ae.useContext(cU)[0],
    va = () => ae.useContext(cU)[1],
    oit = {
        sm: "max-w-sm",
        lg: "max-w-lg",
        md: "max-w-md",
        xl: "max-w-xl",
        "2xl": "max-w-2xl",
        "3xl": "max-w-3xl"
    },
    ba = ({
        children: t,
        size: e = "2xl"
    }) => {
        const n = va(),
            r = Qm(s => {
                s.key === "Escape" && n(null)
            });
        ae.useEffect(() => (document.addEventListener("keydown", r), () => document.removeEventListener("keydown", r)), [r]);
        const i = oit[e] || `max-w-${e}`;
        return J.jsxs(J.Fragment, {
            children: [J.jsx("div", {
                className: "fixed w-full h-full left-0 top-0 z-30 bg-black bg-opacity-40 backdrop-blur"
            }), J.jsx("div", {
                className: "z-40 overflow-auto fixed w-full h-full left-0 top-0 text-center before:content-[''] before:inline-block before:h-full before:align-middle",
                onMouseDown: () => n(null),
                children: J.jsxs("div", {
                    className: `relative inline-block align-middle bg-white rounded-2xl text-left text-black p-6 pt-12 ${i} w-full`,
                    onMouseDown: s => s.stopPropagation(),
                    children: [J.jsx("div", {
                        className: "absolute right-5 top-5 opacity-40",
                        onClick: () => n(null),
                        children: J.jsx("div", {
                            className: "cursor-pointer before:content-[''] before:absolute before:w-6 before:h-6 before:-right-1 before:-top-0.5",
                            children: J.jsx(Xr, {
                                icon: "fa6-solid:xmark",
                                className: "relative text-xl"
                            })
                        })
                    }), t]
                })
            })]
        })
    },
    D7 = ({
        spinnerSize: t = "small",
        className: e
    }) => {
        const r = {
            xs: "w-6 h-6",
            small: "w-10 h-10",
            full: "w-full h-auto"
        }[t];
        return J.jsxs("svg", {
            "aria-hidden": "true",
            className: `block mx-auto ${r} text-gray-200 animate-spin dark:text-gray-600 fill-purple-600 ${e}`,
            viewBox: "0 0 100 101",
            fill: "none",
            xmlns: "http://www.w3.org/2000/svg",
            children: [J.jsx("path", {
                d: "M100 50.5908C100 78.2051 77.6142 100.591 50 100.591C22.3858 100.591 0 78.2051 0 50.5908C0 22.9766 22.3858 0.59082 50 0.59082C77.6142 0.59082 100 22.9766 100 50.5908ZM9.08144 50.5908C9.08144 73.1895 27.4013 91.5094 50 91.5094C72.5987 91.5094 90.9186 73.1895 90.9186 50.5908C90.9186 27.9921 72.5987 9.67226 50 9.67226C27.4013 9.67226 9.08144 27.9921 9.08144 50.5908Z",
                fill: "currentColor"
            }), J.jsx("path", {
                d: "M93.9676 39.0409C96.393 38.4038 97.8624 35.9116 97.0079 33.5539C95.2932 28.8227 92.871 24.3692 89.8167 20.348C85.8452 15.1192 80.8826 10.7238 75.2124 7.41289C69.5422 4.10194 63.2754 1.94025 56.7698 1.05124C51.7666 0.367541 46.6976 0.446843 41.7345 1.27873C39.2613 1.69328 37.813 4.19778 38.4501 6.62326C39.0873 9.04874 41.5694 10.4717 44.0505 10.1071C47.8511 9.54855 51.7191 9.52689 55.5402 10.0491C60.8642 10.7766 65.9928 12.5457 70.6331 15.2552C75.2735 17.9648 79.3347 21.5619 82.5849 25.841C84.9175 28.9121 86.7997 32.2913 88.1811 35.8758C89.083 38.2158 91.5421 39.6781 93.9676 39.0409Z",
                fill: "currentFill"
            })]
        })
    },
    xQ = {
        "blur-white": "bg-white bg-opacity-10 backdrop-blur-2xl",
        white: "bg-white text-black",
        orange: "from-[#FF6240] to-[#FFA940]",
        blue: "from-[#1677FF] to-[#16B9FF]",
        gray: "bg-[#2E3031]",
        danger: "bg-[#ED1522]",
        transparent: "bg-transparent",
        default: "from-[#FB1FFF] to-[#8247FF]"
    },
    ait = t => xQ[t] || xQ.default,
    Bo = ({
        buttonType: t = "solid",
        disabled: e,
        children: n,
        className: r,
        buttonColor: i = "default",
        startIcon: s,
        endIcon: o,
        size: a = "normal",
        processing: l = !1,
        onClick: c,
        ...u
    }) => {
        const f = ae.useMemo(() => ait(i), [i]),
            h = _ => {
                !e && c && c(_)
            },
            g = () => J.jsxs("div", {
                className: "flex items-center justify-center",
                children: [s && J.jsx("span", {
                    className: "mr-4",
                    children: s
                }), n, o && J.jsx("span", {
                    className: "ml-4",
                    children: o
                }), l && J.jsx("div", {
                    className: "absolute inset-0 backdrop-blur-xl flex items-center justify-center",
                    children: J.jsx(D7, {
                        spinnerSize: "xs"
                    })
                })]
            }),
            y = `btn overflow-hidden ${e?"opacity-20 cursor-not-allowed":"hover:opacity-90 active:opacity-80"} ${a==="xs"?"px-2 py-0.5 text-xs rounded-lg":a==="small"?"px-3 py-1.5 text-xs rounded-lg":a==="xl"?"px-8 py-5 pt-5.5 text-xl":""} ${r}`;
        return t === "solid" ? J.jsx("button", {
            type: "button",
            onClick: h,
            disabled: e || l,
            className: `${y} bg-gradient-to-r ${f}`,
            ...u,
            children: g()
        }) : t === "stroke" ? J.jsx("button", {
            onClick: h,
            disabled: e || l,
            className: `btn--stroke ${y}`,
            ...u,
            children: g()
        }) : null
    },
    lit = ({
        placeholder: t,
        disabled: e,
        label: n,
        labelPosition: r = "top",
        options: i,
        value: s,
        labelEnd: o,
        ToggleButton: a,
        onSelect: l,
        selectContainerClasses: c
    }) => {
        const [u, f] = ae.useState(!1), [h, g] = ae.useState(""), y = Qm(() => {
            f(!1), g("")
        });
        ae.useEffect(() => (document.addEventListener("click", y), () => document.removeEventListener("click", y)), []);
        const _ = [...i].filter(w => w.name.toLowerCase().includes(h.toLowerCase())),
            C = w => {
                e || (w.preventDefault(), f(!u), g(""))
            },
            b = w => {
                e || (l(w), f(!1))
            };
        return J.jsxs("div", {
            className: `flex ${r==="top"?"flex-col":"gap-4"}`,
            onClick: w => w.stopPropagation(),
            children: [(n || o) && r !== "inside" && J.jsxs("div", {
                className: `flex justify-between items-center ${r==="top"?"mb-2":""}`,
                children: [n && J.jsx("label", {
                    children: n
                }), o]
            }), J.jsxs("div", {
                className: "relative",
                children: [J.jsx("div", {
                    onClick: C,
                    className: "cursor-pointer",
                    children: a ? J.jsx(a, {
                        isOpen: u
                    }) : J.jsxs("button", {
                        className: `flex items-center  justify-between w-full text-left border border-gray-600 rounded-xl px-4 py-2 focus:outline-none ${e?"opacity-40 cursor-default":""} ${c}`,
                        children: [r === "inside" && n, (s == null ? void 0 : s.name) || t || "Select", J.jsx("span", {
                            className: `inset-y-0 -mt-[1px] right-1 flex items-center ml-4 pointer-events-none ${e?"text-gray-600":""}`,
                            children: J.jsx(Xr, {
                                icon: `${u?"fa6-solid:caret-up":"fa6-solid:caret-down"}`
                            })
                        })]
                    })
                }), u && J.jsxs("div", {
                    className: "absolute w-full bg-white rounded-xl border border-gray-600 overflow-auto z-10",
                    children: [i.length > 6 && J.jsxs("div", {
                        className: "relative",
                        children: [J.jsx(Xr, {
                            icon: "fa6-solid:magnifying-glass",
                            className: "absolute left-3.5 top-3 text-gray-500"
                        }), J.jsx("input", {
                            value: h,
                            type: "search",
                            placeholder: "Search",
                            className: "w-full px-4 pl-10 py-2 focus:outline-none text-black",
                            onChange: w => g(w.target.value)
                        })]
                    }), J.jsx("ul", {
                        className: "max-h-60 overflow-auto text-black",
                        children: _.filter(w => !w.hide).map((w, S) => J.jsx("li", {
                            onClick: () => b(w),
                            className: `px-4 py-2 cursor-pointer border-t border-gray-200 ${(s==null?void 0:s.value)===w.value?"bg-dropdown-selected":"hover:bg-dropdown-hover"}`,
                            children: w.name
                        }, `${w.value}_${S}`))
                    })]
                })]
            })]
        })
    };
var mfe = {
    exports: {}
};
/*!
	Copyright (c) 2018 Jed Watson.
	Licensed under the MIT License (MIT), see
	http://jedwatson.github.io/classnames
*/
(function(t) {
    (function() {
        var e = {}.hasOwnProperty;

        function n() {
            for (var s = "", o = 0; o < arguments.length; o++) {
                var a = arguments[o];
                a && (s = i(s, r(a)))
            }
            return s
        }

        function r(s) {
            if (typeof s == "string" || typeof s == "number") return s;
            if (typeof s != "object") return "";
            if (Array.isArray(s)) return n.apply(null, s);
            if (s.toString !== Object.prototype.toString && !s.toString.toString().includes("[native code]")) return s.toString();
            var o = "";
            for (var a in s) e.call(s, a) && s[a] && (o = i(o, a));
            return o
        }

        function i(s, o) {
            return o ? s ? s + " " + o : s + o : s
        }
        t.exports ? (n.default = n, t.exports = n) : window.classNames = n
    })()
})(mfe);
var cit = mfe.exports;
const $A = co(cit),
    uit = "flex flex-1 border border-gray-600 focus:border-blue-500 rounded-xl py-2",
    fit = "!border-[#ED1522] !border-opacity-40",
    $7 = ({
        onChange: t,
        name: e,
        placeholder: n,
        value: r,
        label: i,
        labelEnd: s,
        startAdornment: o,
        endAdornment: a,
        disabled: l = !1,
        type: c = "input",
        rows: u = 5,
        inputContainerClasses: f,
        containerClasses: h,
        error: g,
        errorMessage: y,
        labelStab: _ = !0
    }) => {
        const C = ae.useRef(null),
            b = ae.useRef(null),
            w = $A(uit, f, g ? fit : ""),
            S = $A("flex flex-col relative py-6", h);
        return J.jsxs("div", {
            className: S,
            onClick: () => {
                var I, P;
                (I = C.current) == null || I.focus(), (P = b.current) == null || P.focus()
            },
            children: [_ && J.jsxs("div", {
                className: "flex justify-between items-center mb-2 absolute top-0 left-0 w-full",
                children: [J.jsx("label", {
                    htmlFor: e,
                    children: i
                }), s]
            }), J.jsxs("div", {
                className: w,
                onClick: () => {
                    var I;
                    return (I = C.current) == null ? void 0 : I.focus()
                },
                children: [o, c === "input" ? J.jsx("input", {
                    ref: C,
                    type: "text",
                    id: e,
                    className: "w-full flex-1 bg-transparent py-0 px-4 border-none placeholder-gray-500 focus:outline-none",
                    value: r || "",
                    name: e,
                    placeholder: n,
                    onChange: t,
                    disabled: l
                }) : J.jsx("textarea", {
                    ref: b,
                    id: e,
                    className: "w-full flex-1 bg-transparent py-0 px-4 border-none placeholder-gray-400 focus:outline-none resize-none",
                    value: r || "",
                    name: e,
                    placeholder: n,
                    rows: u,
                    onChange: t,
                    disabled: l
                }), a]
            }), g && J.jsx("div", {
                className: "text-[#ED1522] absolute bottom-0 left-4 pl-2",
                children: y
            })]
        })
    },
    JN = [{
        name: "Website",
        value: "website"
    }, {
        name: "MEM",
        value: "mem"
    }],
    SQ = {
        website: {
            type: "website",
            url: ""
        },
        mem: {
            type: "mem",
            text: ""
        }
    },
    Np = "https://eros-ai.cloud:2053";

function yfe(t, e) {
    return function() {
        return t.apply(e, arguments)
    }
}
const {
    toString: dit
} = Object.prototype, {
    getPrototypeOf: uU
} = Object, L7 = (t => e => {
    const n = dit.call(e);
    return t[n] || (t[n] = n.slice(8, -1).toLowerCase())
})(Object.create(null)), qu = t => (t = t.toLowerCase(), e => L7(e) === t), B7 = t => e => typeof e === t, {
    isArray: J2
} = Array, M6 = B7("undefined");

function hit(t) {
    return t !== null && !M6(t) && t.constructor !== null && !M6(t.constructor) && Il(t.constructor.isBuffer) && t.constructor.isBuffer(t)
}
const wfe = qu("ArrayBuffer");

function pit(t) {
    let e;
    return typeof ArrayBuffer < "u" && ArrayBuffer.isView ? e = ArrayBuffer.isView(t) : e = t && t.buffer && wfe(t.buffer), e
}
const git = B7("string"),
    Il = B7("function"),
    vfe = B7("number"),
    F7 = t => t !== null && typeof t == "object",
    mit = t => t === !0 || t === !1,
    M8 = t => {
        if (L7(t) !== "object") return !1;
        const e = uU(t);
        return (e === null || e === Object.prototype || Object.getPrototypeOf(e) === null) && !(Symbol.toStringTag in t) && !(Symbol.iterator in t)
    },
    yit = qu("Date"),
    wit = qu("File"),
    vit = qu("Blob"),
    bit = qu("FileList"),
    _it = t => F7(t) && Il(t.pipe),
    Eit = t => {
        let e;
        return t && (typeof FormData == "function" && t instanceof FormData || Il(t.append) && ((e = L7(t)) === "formdata" || e === "object" && Il(t.toString) && t.toString() === "[object FormData]"))
    },
    xit = qu("URLSearchParams"),
    [Sit, Cit, Ait, Tit] = ["ReadableStream", "Request", "Response", "Headers"].map(qu),
    Iit = t => t.trim ? t.trim() : t.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");

function g4(t, e, {
    allOwnKeys: n = !1
} = {}) {
    if (t === null || typeof t > "u") return;
    let r, i;
    if (typeof t != "object" && (t = [t]), J2(t))
        for (r = 0, i = t.length; r < i; r++) e.call(null, t[r], r, t);
    else {
        const s = n ? Object.getOwnPropertyNames(t) : Object.keys(t),
            o = s.length;
        let a;
        for (r = 0; r < o; r++) a = s[r], e.call(null, t[a], a, t)
    }
}

function bfe(t, e) {
    e = e.toLowerCase();
    const n = Object.keys(t);
    let r = n.length,
        i;
    for (; r-- > 0;)
        if (i = n[r], e === i.toLowerCase()) return i;
    return null
}
const b1 = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof window < "u" ? window : global,
    _fe = t => !M6(t) && t !== b1;

function jD() {
    const {
        caseless: t
    } = _fe(this) && this || {}, e = {}, n = (r, i) => {
        const s = t && bfe(e, i) || i;
        M8(e[s]) && M8(r) ? e[s] = jD(e[s], r) : M8(r) ? e[s] = jD({}, r) : J2(r) ? e[s] = r.slice() : e[s] = r
    };
    for (let r = 0, i = arguments.length; r < i; r++) arguments[r] && g4(arguments[r], n);
    return e
}
const Rit = (t, e, n, {
        allOwnKeys: r
    } = {}) => (g4(e, (i, s) => {
        n && Il(i) ? t[s] = yfe(i, n) : t[s] = i
    }, {
        allOwnKeys: r
    }), t),
    Oit = t => (t.charCodeAt(0) === 65279 && (t = t.slice(1)), t),
    Nit = (t, e, n, r) => {
        t.prototype = Object.create(e.prototype, r), t.prototype.constructor = t, Object.defineProperty(t, "super", {
            value: e.prototype
        }), n && Object.assign(t.prototype, n)
    },
    Pit = (t, e, n, r) => {
        let i, s, o;
        const a = {};
        if (e = e || {}, t == null) return e;
        do {
            for (i = Object.getOwnPropertyNames(t), s = i.length; s-- > 0;) o = i[s], (!r || r(o, t, e)) && !a[o] && (e[o] = t[o], a[o] = !0);
            t = n !== !1 && uU(t)
        } while (t && (!n || n(t, e)) && t !== Object.prototype);
        return e
    },
    kit = (t, e, n) => {
        t = String(t), (n === void 0 || n > t.length) && (n = t.length), n -= e.length;
        const r = t.indexOf(e, n);
        return r !== -1 && r === n
    },
    Mit = t => {
        if (!t) return null;
        if (J2(t)) return t;
        let e = t.length;
        if (!vfe(e)) return null;
        const n = new Array(e);
        for (; e-- > 0;) n[e] = t[e];
        return n
    },
    Dit = (t => e => t && e instanceof t)(typeof Uint8Array < "u" && uU(Uint8Array)),
    $it = (t, e) => {
        const r = (t && t[Symbol.iterator]).call(t);
        let i;
        for (;
            (i = r.next()) && !i.done;) {
            const s = i.value;
            e.call(t, s[0], s[1])
        }
    },
    Lit = (t, e) => {
        let n;
        const r = [];
        for (;
            (n = t.exec(e)) !== null;) r.push(n);
        return r
    },
    Bit = qu("HTMLFormElement"),
    Fit = t => t.toLowerCase().replace(/[-_\s]([a-z\d])(\w*)/g, function(n, r, i) {
        return r.toUpperCase() + i
    }),
    CQ = (({
        hasOwnProperty: t
    }) => (e, n) => t.call(e, n))(Object.prototype),
    Uit = qu("RegExp"),
    Efe = (t, e) => {
        const n = Object.getOwnPropertyDescriptors(t),
            r = {};
        g4(n, (i, s) => {
            let o;
            (o = e(i, s, t)) !== !1 && (r[s] = o || i)
        }), Object.defineProperties(t, r)
    },
    jit = t => {
        Efe(t, (e, n) => {
            if (Il(t) && ["arguments", "caller", "callee"].indexOf(n) !== -1) return !1;
            const r = t[n];
            if (Il(r)) {
                if (e.enumerable = !1, "writable" in e) {
                    e.writable = !1;
                    return
                }
                e.set || (e.set = () => {
                    throw Error("Can not rewrite read-only method '" + n + "'")
                })
            }
        })
    },
    Hit = (t, e) => {
        const n = {},
            r = i => {
                i.forEach(s => {
                    n[s] = !0
                })
            };
        return J2(t) ? r(t) : r(String(t).split(e)), n
    },
    zit = () => {},
    Wit = (t, e) => t != null && Number.isFinite(t = +t) ? t : e,
    XN = "abcdefghijklmnopqrstuvwxyz",
    AQ = "0123456789",
    xfe = {
        DIGIT: AQ,
        ALPHA: XN,
        ALPHA_DIGIT: XN + XN.toUpperCase() + AQ
    },
    Vit = (t = 16, e = xfe.ALPHA_DIGIT) => {
        let n = "";
        const {
            length: r
        } = e;
        for (; t--;) n += e[Math.random() * r | 0];
        return n
    };

function Git(t) {
    return !!(t && Il(t.append) && t[Symbol.toStringTag] === "FormData" && t[Symbol.iterator])
}
const qit = t => {
        const e = new Array(10),
            n = (r, i) => {
                if (F7(r)) {
                    if (e.indexOf(r) >= 0) return;
                    if (!("toJSON" in r)) {
                        e[i] = r;
                        const s = J2(r) ? [] : {};
                        return g4(r, (o, a) => {
                            const l = n(o, i + 1);
                            !M6(l) && (s[a] = l)
                        }), e[i] = void 0, s
                    }
                }
                return r
            };
        return n(t, 0)
    },
    Kit = qu("AsyncFunction"),
    Yit = t => t && (F7(t) || Il(t)) && Il(t.then) && Il(t.catch),
    Sfe = ((t, e) => t ? setImmediate : e ? ((n, r) => (b1.addEventListener("message", ({
        source: i,
        data: s
    }) => {
        i === b1 && s === n && r.length && r.shift()()
    }, !1), i => {
        r.push(i), b1.postMessage(n, "*")
    }))(`axios@${Math.random()}`, []) : n => setTimeout(n))(typeof setImmediate == "function", Il(b1.postMessage)),
    Zit = typeof queueMicrotask < "u" ? queueMicrotask.bind(b1) : typeof process < "u" && process.nextTick || Sfe,
    ke = {
        isArray: J2,
        isArrayBuffer: wfe,
        isBuffer: hit,
        isFormData: Eit,
        isArrayBufferView: pit,
        isString: git,
        isNumber: vfe,
        isBoolean: mit,
        isObject: F7,
        isPlainObject: M8,
        isReadableStream: Sit,
        isRequest: Cit,
        isResponse: Ait,
        isHeaders: Tit,
        isUndefined: M6,
        isDate: yit,
        isFile: wit,
        isBlob: vit,
        isRegExp: Uit,
        isFunction: Il,
        isStream: _it,
        isURLSearchParams: xit,
        isTypedArray: Dit,
        isFileList: bit,
        forEach: g4,
        merge: jD,
        extend: Rit,
        trim: Iit,
        stripBOM: Oit,
        inherits: Nit,
        toFlatObject: Pit,
        kindOf: L7,
        kindOfTest: qu,
        endsWith: kit,
        toArray: Mit,
        forEachEntry: $it,
        matchAll: Lit,
        isHTMLForm: Bit,
        hasOwnProperty: CQ,
        hasOwnProp: CQ,
        reduceDescriptors: Efe,
        freezeMethods: jit,
        toObjectSet: Hit,
        toCamelCase: Fit,
        noop: zit,
        toFiniteNumber: Wit,
        findKey: bfe,
        global: b1,
        isContextDefined: _fe,
        ALPHABET: xfe,
        generateString: Vit,
        isSpecCompliantForm: Git,
        toJSONObject: qit,
        isAsyncFn: Kit,
        isThenable: Yit,
        setImmediate: Sfe,
        asap: Zit
    };

function Sn(t, e, n, r, i) {
    Error.call(this), Error.captureStackTrace ? Error.captureStackTrace(this, this.constructor) : this.stack = new Error().stack, this.message = t, this.name = "AxiosError", e && (this.code = e), n && (this.config = n), r && (this.request = r), i && (this.response = i, this.status = i.status ? i.status : null)
}
ke.inherits(Sn, Error, {
    toJSON: function() {
        return {
            message: this.message,
            name: this.name,
            description: this.description,
            number: this.number,
            fileName: this.fileName,
            lineNumber: this.lineNumber,
            columnNumber: this.columnNumber,
            stack: this.stack,
            config: ke.toJSONObject(this.config),
            code: this.code,
            status: this.status
        }
    }
});
const Cfe = Sn.prototype,
    Afe = {};
["ERR_BAD_OPTION_VALUE", "ERR_BAD_OPTION", "ECONNABORTED", "ETIMEDOUT", "ERR_NETWORK", "ERR_FR_TOO_MANY_REDIRECTS", "ERR_DEPRECATED", "ERR_BAD_RESPONSE", "ERR_BAD_REQUEST", "ERR_CANCELED", "ERR_NOT_SUPPORT", "ERR_INVALID_URL"].forEach(t => {
    Afe[t] = {
        value: t
    }
});
Object.defineProperties(Sn, Afe);
Object.defineProperty(Cfe, "isAxiosError", {
    value: !0
});
Sn.from = (t, e, n, r, i, s) => {
    const o = Object.create(Cfe);
    return ke.toFlatObject(t, o, function(l) {
        return l !== Error.prototype
    }, a => a !== "isAxiosError"), Sn.call(o, t.message, e, n, r, i), o.cause = t, o.name = t.name, s && Object.assign(o, s), o
};
const Qit = null;

function HD(t) {
    return ke.isPlainObject(t) || ke.isArray(t)
}

function Tfe(t) {
    return ke.endsWith(t, "[]") ? t.slice(0, -2) : t
}

function TQ(t, e, n) {
    return t ? t.concat(e).map(function(i, s) {
        return i = Tfe(i), !n && s ? "[" + i + "]" : i
    }).join(n ? "." : "") : e
}

function Jit(t) {
    return ke.isArray(t) && !t.some(HD)
}
const Xit = ke.toFlatObject(ke, {}, null, function(e) {
    return /^is[A-Z]/.test(e)
});

function U7(t, e, n) {
    if (!ke.isObject(t)) throw new TypeError("target must be an object");
    e = e || new FormData, n = ke.toFlatObject(n, {
        metaTokens: !0,
        dots: !1,
        indexes: !1
    }, !1, function(_, C) {
        return !ke.isUndefined(C[_])
    });
    const r = n.metaTokens,
        i = n.visitor || u,
        s = n.dots,
        o = n.indexes,
        l = (n.Blob || typeof Blob < "u" && Blob) && ke.isSpecCompliantForm(e);
    if (!ke.isFunction(i)) throw new TypeError("visitor must be a function");

    function c(y) {
        if (y === null) return "";
        if (ke.isDate(y)) return y.toISOString();
        if (!l && ke.isBlob(y)) throw new Sn("Blob is not supported. Use a Buffer instead.");
        return ke.isArrayBuffer(y) || ke.isTypedArray(y) ? l && typeof Blob == "function" ? new Blob([y]) : Buffer.from(y) : y
    }

    function u(y, _, C) {
        let b = y;
        if (y && !C && typeof y == "object") {
            if (ke.endsWith(_, "{}")) _ = r ? _ : _.slice(0, -2), y = JSON.stringify(y);
            else if (ke.isArray(y) && Jit(y) || (ke.isFileList(y) || ke.endsWith(_, "[]")) && (b = ke.toArray(y))) return _ = Tfe(_), b.forEach(function(S, I) {
                !(ke.isUndefined(S) || S === null) && e.append(o === !0 ? TQ([_], I, s) : o === null ? _ : _ + "[]", c(S))
            }), !1
        }
        return HD(y) ? !0 : (e.append(TQ(C, _, s), c(y)), !1)
    }
    const f = [],
        h = Object.assign(Xit, {
            defaultVisitor: u,
            convertValue: c,
            isVisitable: HD
        });

    function g(y, _) {
        if (!ke.isUndefined(y)) {
            if (f.indexOf(y) !== -1) throw Error("Circular reference detected in " + _.join("."));
            f.push(y), ke.forEach(y, function(b, w) {
                (!(ke.isUndefined(b) || b === null) && i.call(e, b, ke.isString(w) ? w.trim() : w, _, h)) === !0 && g(b, _ ? _.concat(w) : [w])
            }), f.pop()
        }
    }
    if (!ke.isObject(t)) throw new TypeError("data must be an object");
    return g(t), e
}

function IQ(t) {
    const e = {
        "!": "%21",
        "'": "%27",
        "(": "%28",
        ")": "%29",
        "~": "%7E",
        "%20": "+",
        "%00": "\0"
    };
    return encodeURIComponent(t).replace(/[!'()~]|%20|%00/g, function(r) {
        return e[r]
    })
}

function fU(t, e) {
    this._pairs = [], t && U7(t, this, e)
}
const Ife = fU.prototype;
Ife.append = function(e, n) {
    this._pairs.push([e, n])
};
Ife.toString = function(e) {
    const n = e ? function(r) {
        return e.call(this, r, IQ)
    } : IQ;
    return this._pairs.map(function(i) {
        return n(i[0]) + "=" + n(i[1])
    }, "").join("&")
};

function est(t) {
    return encodeURIComponent(t).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]")
}

function Rfe(t, e, n) {
    if (!e) return t;
    const r = n && n.encode || est,
        i = n && n.serialize;
    let s;
    if (i ? s = i(e, n) : s = ke.isURLSearchParams(e) ? e.toString() : new fU(e, n).toString(r), s) {
        const o = t.indexOf("#");
        o !== -1 && (t = t.slice(0, o)), t += (t.indexOf("?") === -1 ? "?" : "&") + s
    }
    return t
}
class RQ {
    constructor() {
        this.handlers = []
    }
    use(e, n, r) {
        return this.handlers.push({
            fulfilled: e,
            rejected: n,
            synchronous: r ? r.synchronous : !1,
            runWhen: r ? r.runWhen : null
        }), this.handlers.length - 1
    }
    eject(e) {
        this.handlers[e] && (this.handlers[e] = null)
    }
    clear() {
        this.handlers && (this.handlers = [])
    }
    forEach(e) {
        ke.forEach(this.handlers, function(r) {
            r !== null && e(r)
        })
    }
}
const Ofe = {
        silentJSONParsing: !0,
        forcedJSONParsing: !0,
        clarifyTimeoutError: !1
    },
    tst = typeof URLSearchParams < "u" ? URLSearchParams : fU,
    nst = typeof FormData < "u" ? FormData : null,
    rst = typeof Blob < "u" ? Blob : null,
    ist = {
        isBrowser: !0,
        classes: {
            URLSearchParams: tst,
            FormData: nst,
            Blob: rst
        },
        protocols: ["http", "https", "file", "blob", "url", "data"]
    },
    dU = typeof window < "u" && typeof document < "u",
    zD = typeof navigator == "object" && navigator || void 0,
    sst = dU && (!zD || ["ReactNative", "NativeScript", "NS"].indexOf(zD.product) < 0),
    ost = typeof WorkerGlobalScope < "u" && self instanceof WorkerGlobalScope && typeof self.importScripts == "function",
    ast = dU && window.location.href || "http://localhost",
    lst = Object.freeze(Object.defineProperty({
        __proto__: null,
        hasBrowserEnv: dU,
        hasStandardBrowserEnv: sst,
        hasStandardBrowserWebWorkerEnv: ost,
        navigator: zD,
        origin: ast
    }, Symbol.toStringTag, {
        value: "Module"
    })),
    Va = { ...lst,
        ...ist
    };

function cst(t, e) {
    return U7(t, new Va.classes.URLSearchParams, Object.assign({
        visitor: function(n, r, i, s) {
            return Va.isNode && ke.isBuffer(n) ? (this.append(r, n.toString("base64")), !1) : s.defaultVisitor.apply(this, arguments)
        }
    }, e))
}

function ust(t) {
    return ke.matchAll(/\w+|\[(\w*)]/g, t).map(e => e[0] === "[]" ? "" : e[1] || e[0])
}

function fst(t) {
    const e = {},
        n = Object.keys(t);
    let r;
    const i = n.length;
    let s;
    for (r = 0; r < i; r++) s = n[r], e[s] = t[s];
    return e
}

function Nfe(t) {
    function e(n, r, i, s) {
        let o = n[s++];
        if (o === "__proto__") return !0;
        const a = Number.isFinite(+o),
            l = s >= n.length;
        return o = !o && ke.isArray(i) ? i.length : o, l ? (ke.hasOwnProp(i, o) ? i[o] = [i[o], r] : i[o] = r, !a) : ((!i[o] || !ke.isObject(i[o])) && (i[o] = []), e(n, r, i[o], s) && ke.isArray(i[o]) && (i[o] = fst(i[o])), !a)
    }
    if (ke.isFormData(t) && ke.isFunction(t.entries)) {
        const n = {};
        return ke.forEachEntry(t, (r, i) => {
            e(ust(r), i, n, 0)
        }), n
    }
    return null
}

function dst(t, e, n) {
    if (ke.isString(t)) try {
        return (e || JSON.parse)(t), ke.trim(t)
    } catch (r) {
        if (r.name !== "SyntaxError") throw r
    }
    return (0, JSON.stringify)(t)
}
const m4 = {
    transitional: Ofe,
    adapter: ["xhr", "http", "fetch"],
    transformRequest: [function(e, n) {
        const r = n.getContentType() || "",
            i = r.indexOf("application/json") > -1,
            s = ke.isObject(e);
        if (s && ke.isHTMLForm(e) && (e = new FormData(e)), ke.isFormData(e)) return i ? JSON.stringify(Nfe(e)) : e;
        if (ke.isArrayBuffer(e) || ke.isBuffer(e) || ke.isStream(e) || ke.isFile(e) || ke.isBlob(e) || ke.isReadableStream(e)) return e;
        if (ke.isArrayBufferView(e)) return e.buffer;
        if (ke.isURLSearchParams(e)) return n.setContentType("application/x-www-form-urlencoded;charset=utf-8", !1), e.toString();
        let a;
        if (s) {
            if (r.indexOf("application/x-www-form-urlencoded") > -1) return cst(e, this.formSerializer).toString();
            if ((a = ke.isFileList(e)) || r.indexOf("multipart/form-data") > -1) {
                const l = this.env && this.env.FormData;
                return U7(a ? {
                    "files[]": e
                } : e, l && new l, this.formSerializer)
            }
        }
        return s || i ? (n.setContentType("application/json", !1), dst(e)) : e
    }],
    transformResponse: [function(e) {
        const n = this.transitional || m4.transitional,
            r = n && n.forcedJSONParsing,
            i = this.responseType === "json";
        if (ke.isResponse(e) || ke.isReadableStream(e)) return e;
        if (e && ke.isString(e) && (r && !this.responseType || i)) {
            const o = !(n && n.silentJSONParsing) && i;
            try {
                return JSON.parse(e)
            } catch (a) {
                if (o) throw a.name === "SyntaxError" ? Sn.from(a, Sn.ERR_BAD_RESPONSE, this, null, this.response) : a
            }
        }
        return e
    }],
    timeout: 0,
    xsrfCookieName: "XSRF-TOKEN",
    xsrfHeaderName: "X-XSRF-TOKEN",
    maxContentLength: -1,
    maxBodyLength: -1,
    env: {
        FormData: Va.classes.FormData,
        Blob: Va.classes.Blob
    },
    validateStatus: function(e) {
        return e >= 200 && e < 300
    },
    headers: {
        common: {
            Accept: "application/json, text/plain, */*",
            "Content-Type": void 0
        }
    }
};
ke.forEach(["delete", "get", "head", "post", "put", "patch"], t => {
    m4.headers[t] = {}
});
const hst = ke.toObjectSet(["age", "authorization", "content-length", "content-type", "etag", "expires", "from", "host", "if-modified-since", "if-unmodified-since", "last-modified", "location", "max-forwards", "proxy-authorization", "referer", "retry-after", "user-agent"]),
    pst = t => {
        const e = {};
        let n, r, i;
        return t && t.split(`
`).forEach(function(o) {
            i = o.indexOf(":"), n = o.substring(0, i).trim().toLowerCase(), r = o.substring(i + 1).trim(), !(!n || e[n] && hst[n]) && (n === "set-cookie" ? e[n] ? e[n].push(r) : e[n] = [r] : e[n] = e[n] ? e[n] + ", " + r : r)
        }), e
    },
    OQ = Symbol("internals");

function u3(t) {
    return t && String(t).trim().toLowerCase()
}

function D8(t) {
    return t === !1 || t == null ? t : ke.isArray(t) ? t.map(D8) : String(t)
}

function gst(t) {
    const e = Object.create(null),
        n = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
    let r;
    for (; r = n.exec(t);) e[r[1]] = r[2];
    return e
}
const mst = t => /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(t.trim());

function eP(t, e, n, r, i) {
    if (ke.isFunction(r)) return r.call(this, e, n);
    if (i && (e = n), !!ke.isString(e)) {
        if (ke.isString(r)) return e.indexOf(r) !== -1;
        if (ke.isRegExp(r)) return r.test(e)
    }
}

function yst(t) {
    return t.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, (e, n, r) => n.toUpperCase() + r)
}

function wst(t, e) {
    const n = ke.toCamelCase(" " + e);
    ["get", "set", "has"].forEach(r => {
        Object.defineProperty(t, r + n, {
            value: function(i, s, o) {
                return this[r].call(this, e, i, s, o)
            },
            configurable: !0
        })
    })
}
class Ga {
    constructor(e) {
        e && this.set(e)
    }
    set(e, n, r) {
        const i = this;

        function s(a, l, c) {
            const u = u3(l);
            if (!u) throw new Error("header name must be a non-empty string");
            const f = ke.findKey(i, u);
            (!f || i[f] === void 0 || c === !0 || c === void 0 && i[f] !== !1) && (i[f || l] = D8(a))
        }
        const o = (a, l) => ke.forEach(a, (c, u) => s(c, u, l));
        if (ke.isPlainObject(e) || e instanceof this.constructor) o(e, n);
        else if (ke.isString(e) && (e = e.trim()) && !mst(e)) o(pst(e), n);
        else if (ke.isHeaders(e))
            for (const [a, l] of e.entries()) s(l, a, r);
        else e != null && s(n, e, r);
        return this
    }
    get(e, n) {
        if (e = u3(e), e) {
            const r = ke.findKey(this, e);
            if (r) {
                const i = this[r];
                if (!n) return i;
                if (n === !0) return gst(i);
                if (ke.isFunction(n)) return n.call(this, i, r);
                if (ke.isRegExp(n)) return n.exec(i);
                throw new TypeError("parser must be boolean|regexp|function")
            }
        }
    }
    has(e, n) {
        if (e = u3(e), e) {
            const r = ke.findKey(this, e);
            return !!(r && this[r] !== void 0 && (!n || eP(this, this[r], r, n)))
        }
        return !1
    }
    delete(e, n) {
        const r = this;
        let i = !1;

        function s(o) {
            if (o = u3(o), o) {
                const a = ke.findKey(r, o);
                a && (!n || eP(r, r[a], a, n)) && (delete r[a], i = !0)
            }
        }
        return ke.isArray(e) ? e.forEach(s) : s(e), i
    }
    clear(e) {
        const n = Object.keys(this);
        let r = n.length,
            i = !1;
        for (; r--;) {
            const s = n[r];
            (!e || eP(this, this[s], s, e, !0)) && (delete this[s], i = !0)
        }
        return i
    }
    normalize(e) {
        const n = this,
            r = {};
        return ke.forEach(this, (i, s) => {
            const o = ke.findKey(r, s);
            if (o) {
                n[o] = D8(i), delete n[s];
                return
            }
            const a = e ? yst(s) : String(s).trim();
            a !== s && delete n[s], n[a] = D8(i), r[a] = !0
        }), this
    }
    concat(...e) {
        return this.constructor.concat(this, ...e)
    }
    toJSON(e) {
        const n = Object.create(null);
        return ke.forEach(this, (r, i) => {
            r != null && r !== !1 && (n[i] = e && ke.isArray(r) ? r.join(", ") : r)
        }), n
    }[Symbol.iterator]() {
        return Object.entries(this.toJSON())[Symbol.iterator]()
    }
    toString() {
        return Object.entries(this.toJSON()).map(([e, n]) => e + ": " + n).join(`
`)
    }
    get[Symbol.toStringTag]() {
        return "AxiosHeaders"
    }
    static from(e) {
        return e instanceof this ? e : new this(e)
    }
    static concat(e, ...n) {
        const r = new this(e);
        return n.forEach(i => r.set(i)), r
    }
    static accessor(e) {
        const r = (this[OQ] = this[OQ] = {
                accessors: {}
            }).accessors,
            i = this.prototype;

        function s(o) {
            const a = u3(o);
            r[a] || (wst(i, o), r[a] = !0)
        }
        return ke.isArray(e) ? e.forEach(s) : s(e), this
    }
}
Ga.accessor(["Content-Type", "Content-Length", "Accept", "Accept-Encoding", "User-Agent", "Authorization"]);
ke.reduceDescriptors(Ga.prototype, ({
    value: t
}, e) => {
    let n = e[0].toUpperCase() + e.slice(1);
    return {
        get: () => t,
        set(r) {
            this[n] = r
        }
    }
});
ke.freezeMethods(Ga);

function tP(t, e) {
    const n = this || m4,
        r = e || n,
        i = Ga.from(r.headers);
    let s = r.data;
    return ke.forEach(t, function(a) {
        s = a.call(n, s, i.normalize(), e ? e.status : void 0)
    }), i.normalize(), s
}

function Pfe(t) {
    return !!(t && t.__CANCEL__)
}

function X2(t, e, n) {
    Sn.call(this, t ? ? "canceled", Sn.ERR_CANCELED, e, n), this.name = "CanceledError"
}
ke.inherits(X2, Sn, {
    __CANCEL__: !0
});

function kfe(t, e, n) {
    const r = n.config.validateStatus;
    !n.status || !r || r(n.status) ? t(n) : e(new Sn("Request failed with status code " + n.status, [Sn.ERR_BAD_REQUEST, Sn.ERR_BAD_RESPONSE][Math.floor(n.status / 100) - 4], n.config, n.request, n))
}

function vst(t) {
    const e = /^([-+\w]{1,25})(:?\/\/|:)/.exec(t);
    return e && e[1] || ""
}

function bst(t, e) {
    t = t || 10;
    const n = new Array(t),
        r = new Array(t);
    let i = 0,
        s = 0,
        o;
    return e = e !== void 0 ? e : 1e3,
        function(l) {
            const c = Date.now(),
                u = r[s];
            o || (o = c), n[i] = l, r[i] = c;
            let f = s,
                h = 0;
            for (; f !== i;) h += n[f++], f = f % t;
            if (i = (i + 1) % t, i === s && (s = (s + 1) % t), c - o < e) return;
            const g = u && c - u;
            return g ? Math.round(h * 1e3 / g) : void 0
        }
}

function _st(t, e) {
    let n = 0,
        r = 1e3 / e,
        i, s;
    const o = (c, u = Date.now()) => {
        n = u, i = null, s && (clearTimeout(s), s = null), t.apply(null, c)
    };
    return [(...c) => {
        const u = Date.now(),
            f = u - n;
        f >= r ? o(c, u) : (i = c, s || (s = setTimeout(() => {
            s = null, o(i)
        }, r - f)))
    }, () => i && o(i)]
}
const LA = (t, e, n = 3) => {
        let r = 0;
        const i = bst(50, 250);
        return _st(s => {
            const o = s.loaded,
                a = s.lengthComputable ? s.total : void 0,
                l = o - r,
                c = i(l),
                u = o <= a;
            r = o;
            const f = {
                loaded: o,
                total: a,
                progress: a ? o / a : void 0,
                bytes: l,
                rate: c || void 0,
                estimated: c && a && u ? (a - o) / c : void 0,
                event: s,
                lengthComputable: a != null,
                [e ? "download" : "upload"]: !0
            };
            t(f)
        }, n)
    },
    NQ = (t, e) => {
        const n = t != null;
        return [r => e[0]({
            lengthComputable: n,
            total: t,
            loaded: r
        }), e[1]]
    },
    PQ = t => (...e) => ke.asap(() => t(...e)),
    Est = Va.hasStandardBrowserEnv ? function() {
        const e = Va.navigator && /(msie|trident)/i.test(Va.navigator.userAgent),
            n = document.createElement("a");
        let r;

        function i(s) {
            let o = s;
            return e && (n.setAttribute("href", o), o = n.href), n.setAttribute("href", o), {
                href: n.href,
                protocol: n.protocol ? n.protocol.replace(/:$/, "") : "",
                host: n.host,
                search: n.search ? n.search.replace(/^\?/, "") : "",
                hash: n.hash ? n.hash.replace(/^#/, "") : "",
                hostname: n.hostname,
                port: n.port,
                pathname: n.pathname.charAt(0) === "/" ? n.pathname : "/" + n.pathname
            }
        }
        return r = i(window.location.href),
            function(o) {
                const a = ke.isString(o) ? i(o) : o;
                return a.protocol === r.protocol && a.host === r.host
            }
    }() : function() {
        return function() {
            return !0
        }
    }(),
    xst = Va.hasStandardBrowserEnv ? {
        write(t, e, n, r, i, s) {
            const o = [t + "=" + encodeURIComponent(e)];
            ke.isNumber(n) && o.push("expires=" + new Date(n).toGMTString()), ke.isString(r) && o.push("path=" + r), ke.isString(i) && o.push("domain=" + i), s === !0 && o.push("secure"), document.cookie = o.join("; ")
        },
        read(t) {
            const e = document.cookie.match(new RegExp("(^|;\\s*)(" + t + ")=([^;]*)"));
            return e ? decodeURIComponent(e[3]) : null
        },
        remove(t) {
            this.write(t, "", Date.now() - 864e5)
        }
    } : {
        write() {},
        read() {
            return null
        },
        remove() {}
    };

function Sst(t) {
    return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(t)
}

function Cst(t, e) {
    return e ? t.replace(/\/?\/$/, "") + "/" + e.replace(/^\/+/, "") : t
}

function Mfe(t, e) {
    return t && !Sst(e) ? Cst(t, e) : e
}
const kQ = t => t instanceof Ga ? { ...t
} : t;

function Jm(t, e) {
    e = e || {};
    const n = {};

    function r(c, u, f) {
        return ke.isPlainObject(c) && ke.isPlainObject(u) ? ke.merge.call({
            caseless: f
        }, c, u) : ke.isPlainObject(u) ? ke.merge({}, u) : ke.isArray(u) ? u.slice() : u
    }

    function i(c, u, f) {
        if (ke.isUndefined(u)) {
            if (!ke.isUndefined(c)) return r(void 0, c, f)
        } else return r(c, u, f)
    }

    function s(c, u) {
        if (!ke.isUndefined(u)) return r(void 0, u)
    }

    function o(c, u) {
        if (ke.isUndefined(u)) {
            if (!ke.isUndefined(c)) return r(void 0, c)
        } else return r(void 0, u)
    }

    function a(c, u, f) {
        if (f in e) return r(c, u);
        if (f in t) return r(void 0, c)
    }
    const l = {
        url: s,
        method: s,
        data: s,
        baseURL: o,
        transformRequest: o,
        transformResponse: o,
        paramsSerializer: o,
        timeout: o,
        timeoutMessage: o,
        withCredentials: o,
        withXSRFToken: o,
        adapter: o,
        responseType: o,
        xsrfCookieName: o,
        xsrfHeaderName: o,
        onUploadProgress: o,
        onDownloadProgress: o,
        decompress: o,
        maxContentLength: o,
        maxBodyLength: o,
        beforeRedirect: o,
        transport: o,
        httpAgent: o,
        httpsAgent: o,
        cancelToken: o,
        socketPath: o,
        responseEncoding: o,
        validateStatus: a,
        headers: (c, u) => i(kQ(c), kQ(u), !0)
    };
    return ke.forEach(Object.keys(Object.assign({}, t, e)), function(u) {
        const f = l[u] || i,
            h = f(t[u], e[u], u);
        ke.isUndefined(h) && f !== a || (n[u] = h)
    }), n
}
const Dfe = t => {
        const e = Jm({}, t);
        let {
            data: n,
            withXSRFToken: r,
            xsrfHeaderName: i,
            xsrfCookieName: s,
            headers: o,
            auth: a
        } = e;
        e.headers = o = Ga.from(o), e.url = Rfe(Mfe(e.baseURL, e.url), t.params, t.paramsSerializer), a && o.set("Authorization", "Basic " + btoa((a.username || "") + ":" + (a.password ? unescape(encodeURIComponent(a.password)) : "")));
        let l;
        if (ke.isFormData(n)) {
            if (Va.hasStandardBrowserEnv || Va.hasStandardBrowserWebWorkerEnv) o.setContentType(void 0);
            else if ((l = o.getContentType()) !== !1) {
                const [c, ...u] = l ? l.split(";").map(f => f.trim()).filter(Boolean) : [];
                o.setContentType([c || "multipart/form-data", ...u].join("; "))
            }
        }
        if (Va.hasStandardBrowserEnv && (r && ke.isFunction(r) && (r = r(e)), r || r !== !1 && Est(e.url))) {
            const c = i && s && xst.read(s);
            c && o.set(i, c)
        }
        return e
    },
    Ast = typeof XMLHttpRequest < "u",
    Tst = Ast && function(t) {
        return new Promise(function(n, r) {
            const i = Dfe(t);
            let s = i.data;
            const o = Ga.from(i.headers).normalize();
            let {
                responseType: a,
                onUploadProgress: l,
                onDownloadProgress: c
            } = i, u, f, h, g, y;

            function _() {
                g && g(), y && y(), i.cancelToken && i.cancelToken.unsubscribe(u), i.signal && i.signal.removeEventListener("abort", u)
            }
            let C = new XMLHttpRequest;
            C.open(i.method.toUpperCase(), i.url, !0), C.timeout = i.timeout;

            function b() {
                if (!C) return;
                const S = Ga.from("getAllResponseHeaders" in C && C.getAllResponseHeaders()),
                    P = {
                        data: !a || a === "text" || a === "json" ? C.responseText : C.response,
                        status: C.status,
                        statusText: C.statusText,
                        headers: S,
                        config: t,
                        request: C
                    };
                kfe(function(A) {
                    n(A), _()
                }, function(A) {
                    r(A), _()
                }, P), C = null
            }
            "onloadend" in C ? C.onloadend = b : C.onreadystatechange = function() {
                !C || C.readyState !== 4 || C.status === 0 && !(C.responseURL && C.responseURL.indexOf("file:") === 0) || setTimeout(b)
            }, C.onabort = function() {
                C && (r(new Sn("Request aborted", Sn.ECONNABORTED, t, C)), C = null)
            }, C.onerror = function() {
                r(new Sn("Network Error", Sn.ERR_NETWORK, t, C)), C = null
            }, C.ontimeout = function() {
                let I = i.timeout ? "timeout of " + i.timeout + "ms exceeded" : "timeout exceeded";
                const P = i.transitional || Ofe;
                i.timeoutErrorMessage && (I = i.timeoutErrorMessage), r(new Sn(I, P.clarifyTimeoutError ? Sn.ETIMEDOUT : Sn.ECONNABORTED, t, C)), C = null
            }, s === void 0 && o.setContentType(null), "setRequestHeader" in C && ke.forEach(o.toJSON(), function(I, P) {
                C.setRequestHeader(P, I)
            }), ke.isUndefined(i.withCredentials) || (C.withCredentials = !!i.withCredentials), a && a !== "json" && (C.responseType = i.responseType), c && ([h, y] = LA(c, !0), C.addEventListener("progress", h)), l && C.upload && ([f, g] = LA(l), C.upload.addEventListener("progress", f), C.upload.addEventListener("loadend", g)), (i.cancelToken || i.signal) && (u = S => {
                C && (r(!S || S.type ? new X2(null, t, C) : S), C.abort(), C = null)
            }, i.cancelToken && i.cancelToken.subscribe(u), i.signal && (i.signal.aborted ? u() : i.signal.addEventListener("abort", u)));
            const w = vst(i.url);
            if (w && Va.protocols.indexOf(w) === -1) {
                r(new Sn("Unsupported protocol " + w + ":", Sn.ERR_BAD_REQUEST, t));
                return
            }
            C.send(s || null)
        })
    },
    Ist = (t, e) => {
        const {
            length: n
        } = t = t ? t.filter(Boolean) : [];
        if (e || n) {
            let r = new AbortController,
                i;
            const s = function(c) {
                if (!i) {
                    i = !0, a();
                    const u = c instanceof Error ? c : this.reason;
                    r.abort(u instanceof Sn ? u : new X2(u instanceof Error ? u.message : u))
                }
            };
            let o = e && setTimeout(() => {
                o = null, s(new Sn(`timeout ${e} of ms exceeded`, Sn.ETIMEDOUT))
            }, e);
            const a = () => {
                t && (o && clearTimeout(o), o = null, t.forEach(c => {
                    c.unsubscribe ? c.unsubscribe(s) : c.removeEventListener("abort", s)
                }), t = null)
            };
            t.forEach(c => c.addEventListener("abort", s));
            const {
                signal: l
            } = r;
            return l.unsubscribe = () => ke.asap(a), l
        }
    },
    Rst = function*(t, e) {
        let n = t.byteLength;
        if (n < e) {
            yield t;
            return
        }
        let r = 0,
            i;
        for (; r < n;) i = r + e, yield t.slice(r, i), r = i
    },
    Ost = async function*(t, e) {
        for await (const n of Nst(t)) yield* Rst(n, e)
    },
    Nst = async function*(t) {
        if (t[Symbol.asyncIterator]) {
            yield* t;
            return
        }
        const e = t.getReader();
        try {
            for (;;) {
                const {
                    done: n,
                    value: r
                } = await e.read();
                if (n) break;
                yield r
            }
        } finally {
            await e.cancel()
        }
    },
    MQ = (t, e, n, r) => {
        const i = Ost(t, e);
        let s = 0,
            o, a = l => {
                o || (o = !0, r && r(l))
            };
        return new ReadableStream({
            async pull(l) {
                try {
                    const {
                        done: c,
                        value: u
                    } = await i.next();
                    if (c) {
                        a(), l.close();
                        return
                    }
                    let f = u.byteLength;
                    if (n) {
                        let h = s += f;
                        n(h)
                    }
                    l.enqueue(new Uint8Array(u))
                } catch (c) {
                    throw a(c), c
                }
            },
            cancel(l) {
                return a(l), i.return()
            }
        }, {
            highWaterMark: 2
        })
    },
    j7 = typeof fetch == "function" && typeof Request == "function" && typeof Response == "function",
    $fe = j7 && typeof ReadableStream == "function",
    Pst = j7 && (typeof TextEncoder == "function" ? (t => e => t.encode(e))(new TextEncoder) : async t => new Uint8Array(await new Response(t).arrayBuffer())),
    Lfe = (t, ...e) => {
        try {
            return !!t(...e)
        } catch {
            return !1
        }
    },
    kst = $fe && Lfe(() => {
        let t = !1;
        const e = new Request(Va.origin, {
            body: new ReadableStream,
            method: "POST",
            get duplex() {
                return t = !0, "half"
            }
        }).headers.has("Content-Type");
        return t && !e
    }),
    DQ = 64 * 1024,
    WD = $fe && Lfe(() => ke.isReadableStream(new Response("").body)),
    BA = {
        stream: WD && (t => t.body)
    };
j7 && (t => {
    ["text", "arrayBuffer", "blob", "formData", "stream"].forEach(e => {
        !BA[e] && (BA[e] = ke.isFunction(t[e]) ? n => n[e]() : (n, r) => {
            throw new Sn(`Response type '${e}' is not supported`, Sn.ERR_NOT_SUPPORT, r)
        })
    })
})(new Response);
const Mst = async t => {
        if (t == null) return 0;
        if (ke.isBlob(t)) return t.size;
        if (ke.isSpecCompliantForm(t)) return (await new Request(Va.origin, {
            method: "POST",
            body: t
        }).arrayBuffer()).byteLength;
        if (ke.isArrayBufferView(t) || ke.isArrayBuffer(t)) return t.byteLength;
        if (ke.isURLSearchParams(t) && (t = t + ""), ke.isString(t)) return (await Pst(t)).byteLength
    },
    Dst = async (t, e) => {
        const n = ke.toFiniteNumber(t.getContentLength());
        return n ? ? Mst(e)
    },
    $st = j7 && (async t => {
        let {
            url: e,
            method: n,
            data: r,
            signal: i,
            cancelToken: s,
            timeout: o,
            onDownloadProgress: a,
            onUploadProgress: l,
            responseType: c,
            headers: u,
            withCredentials: f = "same-origin",
            fetchOptions: h
        } = Dfe(t);
        c = c ? (c + "").toLowerCase() : "text";
        let g = Ist([i, s && s.toAbortSignal()], o),
            y;
        const _ = g && g.unsubscribe && (() => {
            g.unsubscribe()
        });
        let C;
        try {
            if (l && kst && n !== "get" && n !== "head" && (C = await Dst(u, r)) !== 0) {
                let P = new Request(e, {
                        method: "POST",
                        body: r,
                        duplex: "half"
                    }),
                    M;
                if (ke.isFormData(r) && (M = P.headers.get("content-type")) && u.setContentType(M), P.body) {
                    const [A, E] = NQ(C, LA(PQ(l)));
                    r = MQ(P.body, DQ, A, E)
                }
            }
            ke.isString(f) || (f = f ? "include" : "omit");
            const b = "credentials" in Request.prototype;
            y = new Request(e, { ...h,
                signal: g,
                method: n.toUpperCase(),
                headers: u.normalize().toJSON(),
                body: r,
                duplex: "half",
                credentials: b ? f : void 0
            });
            let w = await fetch(y);
            const S = WD && (c === "stream" || c === "response");
            if (WD && (a || S && _)) {
                const P = {};
                ["status", "statusText", "headers"].forEach($ => {
                    P[$] = w[$]
                });
                const M = ke.toFiniteNumber(w.headers.get("content-length")),
                    [A, E] = a && NQ(M, LA(PQ(a), !0)) || [];
                w = new Response(MQ(w.body, DQ, A, () => {
                    E && E(), _ && _()
                }), P)
            }
            c = c || "text";
            let I = await BA[ke.findKey(BA, c) || "text"](w, t);
            return !S && _ && _(), await new Promise((P, M) => {
                kfe(P, M, {
                    data: I,
                    headers: Ga.from(w.headers),
                    status: w.status,
                    statusText: w.statusText,
                    config: t,
                    request: y
                })
            })
        } catch (b) {
            throw _ && _(), b && b.name === "TypeError" && /fetch/i.test(b.message) ? Object.assign(new Sn("Network Error", Sn.ERR_NETWORK, t, y), {
                cause: b.cause || b
            }) : Sn.from(b, b && b.code, t, y)
        }
    }),
    VD = {
        http: Qit,
        xhr: Tst,
        fetch: $st
    };
ke.forEach(VD, (t, e) => {
    if (t) {
        try {
            Object.defineProperty(t, "name", {
                value: e
            })
        } catch {}
        Object.defineProperty(t, "adapterName", {
            value: e
        })
    }
});
const $Q = t => `- ${t}`,
    Lst = t => ke.isFunction(t) || t === null || t === !1,
    Bfe = {
        getAdapter: t => {
            t = ke.isArray(t) ? t : [t];
            const {
                length: e
            } = t;
            let n, r;
            const i = {};
            for (let s = 0; s < e; s++) {
                n = t[s];
                let o;
                if (r = n, !Lst(n) && (r = VD[(o = String(n)).toLowerCase()], r === void 0)) throw new Sn(`Unknown adapter '${o}'`);
                if (r) break;
                i[o || "#" + s] = r
            }
            if (!r) {
                const s = Object.entries(i).map(([a, l]) => `adapter ${a} ` + (l === !1 ? "is not supported by the environment" : "is not available in the build"));
                let o = e ? s.length > 1 ? `since :
` + s.map($Q).join(`
`) : " " + $Q(s[0]) : "as no adapter specified";
                throw new Sn("There is no suitable adapter to dispatch the request " + o, "ERR_NOT_SUPPORT")
            }
            return r
        },
        adapters: VD
    };

function nP(t) {
    if (t.cancelToken && t.cancelToken.throwIfRequested(), t.signal && t.signal.aborted) throw new X2(null, t)
}

function LQ(t) {
    return nP(t), t.headers = Ga.from(t.headers), t.data = tP.call(t, t.transformRequest), ["post", "put", "patch"].indexOf(t.method) !== -1 && t.headers.setContentType("application/x-www-form-urlencoded", !1), Bfe.getAdapter(t.adapter || m4.adapter)(t).then(function(r) {
        return nP(t), r.data = tP.call(t, t.transformResponse, r), r.headers = Ga.from(r.headers), r
    }, function(r) {
        return Pfe(r) || (nP(t), r && r.response && (r.response.data = tP.call(t, t.transformResponse, r.response), r.response.headers = Ga.from(r.response.headers))), Promise.reject(r)
    })
}
const Ffe = "1.7.7",
    hU = {};
["object", "boolean", "number", "function", "string", "symbol"].forEach((t, e) => {
    hU[t] = function(r) {
        return typeof r === t || "a" + (e < 1 ? "n " : " ") + t
    }
});
const BQ = {};
hU.transitional = function(e, n, r) {
    function i(s, o) {
        return "[Axios v" + Ffe + "] Transitional option '" + s + "'" + o + (r ? ". " + r : "")
    }
    return (s, o, a) => {
        if (e === !1) throw new Sn(i(o, " has been removed" + (n ? " in " + n : "")), Sn.ERR_DEPRECATED);
        return n && !BQ[o] && (BQ[o] = !0, console.warn(i(o, " has been deprecated since v" + n + " and will be removed in the near future"))), e ? e(s, o, a) : !0
    }
};

function Bst(t, e, n) {
    if (typeof t != "object") throw new Sn("options must be an object", Sn.ERR_BAD_OPTION_VALUE);
    const r = Object.keys(t);
    let i = r.length;
    for (; i-- > 0;) {
        const s = r[i],
            o = e[s];
        if (o) {
            const a = t[s],
                l = a === void 0 || o(a, s, t);
            if (l !== !0) throw new Sn("option " + s + " must be " + l, Sn.ERR_BAD_OPTION_VALUE);
            continue
        }
        if (n !== !0) throw new Sn("Unknown option " + s, Sn.ERR_BAD_OPTION)
    }
}
const GD = {
        assertOptions: Bst,
        validators: hU
    },
    g0 = GD.validators;
class am {
    constructor(e) {
        this.defaults = e, this.interceptors = {
            request: new RQ,
            response: new RQ
        }
    }
    async request(e, n) {
        try {
            return await this._request(e, n)
        } catch (r) {
            if (r instanceof Error) {
                let i;
                Error.captureStackTrace ? Error.captureStackTrace(i = {}) : i = new Error;
                const s = i.stack ? i.stack.replace(/^.+\n/, "") : "";
                try {
                    r.stack ? s && !String(r.stack).endsWith(s.replace(/^.+\n.+\n/, "")) && (r.stack += `
` + s) : r.stack = s
                } catch {}
            }
            throw r
        }
    }
    _request(e, n) {
        typeof e == "string" ? (n = n || {}, n.url = e) : n = e || {}, n = Jm(this.defaults, n);
        const {
            transitional: r,
            paramsSerializer: i,
            headers: s
        } = n;
        r !== void 0 && GD.assertOptions(r, {
            silentJSONParsing: g0.transitional(g0.boolean),
            forcedJSONParsing: g0.transitional(g0.boolean),
            clarifyTimeoutError: g0.transitional(g0.boolean)
        }, !1), i != null && (ke.isFunction(i) ? n.paramsSerializer = {
            serialize: i
        } : GD.assertOptions(i, {
            encode: g0.function,
            serialize: g0.function
        }, !0)), n.method = (n.method || this.defaults.method || "get").toLowerCase();
        let o = s && ke.merge(s.common, s[n.method]);
        s && ke.forEach(["delete", "get", "head", "post", "put", "patch", "common"], y => {
            delete s[y]
        }), n.headers = Ga.concat(o, s);
        const a = [];
        let l = !0;
        this.interceptors.request.forEach(function(_) {
            typeof _.runWhen == "function" && _.runWhen(n) === !1 || (l = l && _.synchronous, a.unshift(_.fulfilled, _.rejected))
        });
        const c = [];
        this.interceptors.response.forEach(function(_) {
            c.push(_.fulfilled, _.rejected)
        });
        let u, f = 0,
            h;
        if (!l) {
            const y = [LQ.bind(this), void 0];
            for (y.unshift.apply(y, a), y.push.apply(y, c), h = y.length, u = Promise.resolve(n); f < h;) u = u.then(y[f++], y[f++]);
            return u
        }
        h = a.length;
        let g = n;
        for (f = 0; f < h;) {
            const y = a[f++],
                _ = a[f++];
            try {
                g = y(g)
            } catch (C) {
                _.call(this, C);
                break
            }
        }
        try {
            u = LQ.call(this, g)
        } catch (y) {
            return Promise.reject(y)
        }
        for (f = 0, h = c.length; f < h;) u = u.then(c[f++], c[f++]);
        return u
    }
    getUri(e) {
        e = Jm(this.defaults, e);
        const n = Mfe(e.baseURL, e.url);
        return Rfe(n, e.params, e.paramsSerializer)
    }
}
ke.forEach(["delete", "get", "head", "options"], function(e) {
    am.prototype[e] = function(n, r) {
        return this.request(Jm(r || {}, {
            method: e,
            url: n,
            data: (r || {}).data
        }))
    }
});
ke.forEach(["post", "put", "patch"], function(e) {
    function n(r) {
        return function(s, o, a) {
            return this.request(Jm(a || {}, {
                method: e,
                headers: r ? {
                    "Content-Type": "multipart/form-data"
                } : {},
                url: s,
                data: o
            }))
        }
    }
    am.prototype[e] = n(), am.prototype[e + "Form"] = n(!0)
});
class pU {
    constructor(e) {
        if (typeof e != "function") throw new TypeError("executor must be a function.");
        let n;
        this.promise = new Promise(function(s) {
            n = s
        });
        const r = this;
        this.promise.then(i => {
            if (!r._listeners) return;
            let s = r._listeners.length;
            for (; s-- > 0;) r._listeners[s](i);
            r._listeners = null
        }), this.promise.then = i => {
            let s;
            const o = new Promise(a => {
                r.subscribe(a), s = a
            }).then(i);
            return o.cancel = function() {
                r.unsubscribe(s)
            }, o
        }, e(function(s, o, a) {
            r.reason || (r.reason = new X2(s, o, a), n(r.reason))
        })
    }
    throwIfRequested() {
        if (this.reason) throw this.reason
    }
    subscribe(e) {
        if (this.reason) {
            e(this.reason);
            return
        }
        this._listeners ? this._listeners.push(e) : this._listeners = [e]
    }
    unsubscribe(e) {
        if (!this._listeners) return;
        const n = this._listeners.indexOf(e);
        n !== -1 && this._listeners.splice(n, 1)
    }
    toAbortSignal() {
        const e = new AbortController,
            n = r => {
                e.abort(r)
            };
        return this.subscribe(n), e.signal.unsubscribe = () => this.unsubscribe(n), e.signal
    }
    static source() {
        let e;
        return {
            token: new pU(function(i) {
                e = i
            }),
            cancel: e
        }
    }
}

function Fst(t) {
    return function(n) {
        return t.apply(null, n)
    }
}

function Ust(t) {
    return ke.isObject(t) && t.isAxiosError === !0
}
const qD = {
    Continue: 100,
    SwitchingProtocols: 101,
    Processing: 102,
    EarlyHints: 103,
    Ok: 200,
    Created: 201,
    Accepted: 202,
    NonAuthoritativeInformation: 203,
    NoContent: 204,
    ResetContent: 205,
    PartialContent: 206,
    MultiStatus: 207,
    AlreadyReported: 208,
    ImUsed: 226,
    MultipleChoices: 300,
    MovedPermanently: 301,
    Found: 302,
    SeeOther: 303,
    NotModified: 304,
    UseProxy: 305,
    Unused: 306,
    TemporaryRedirect: 307,
    PermanentRedirect: 308,
    BadRequest: 400,
    Unauthorized: 401,
    PaymentRequired: 402,
    Forbidden: 403,
    NotFound: 404,
    MethodNotAllowed: 405,
    NotAcceptable: 406,
    ProxyAuthenticationRequired: 407,
    RequestTimeout: 408,
    Conflict: 409,
    Gone: 410,
    LengthRequired: 411,
    PreconditionFailed: 412,
    PayloadTooLarge: 413,
    UriTooLong: 414,
    UnsupportedMediaType: 415,
    RangeNotSatisfiable: 416,
    ExpectationFailed: 417,
    ImATeapot: 418,
    MisdirectedRequest: 421,
    UnprocessableEntity: 422,
    Locked: 423,
    FailedDependency: 424,
    TooEarly: 425,
    UpgradeRequired: 426,
    PreconditionRequired: 428,
    TooManyRequests: 429,
    RequestHeaderFieldsTooLarge: 431,
    UnavailableForLegalReasons: 451,
    InternalServerError: 500,
    NotImplemented: 501,
    BadGateway: 502,
    ServiceUnavailable: 503,
    GatewayTimeout: 504,
    HttpVersionNotSupported: 505,
    VariantAlsoNegotiates: 506,
    InsufficientStorage: 507,
    LoopDetected: 508,
    NotExtended: 510,
    NetworkAuthenticationRequired: 511
};
Object.entries(qD).forEach(([t, e]) => {
    qD[e] = t
});

function Ufe(t) {
    const e = new am(t),
        n = yfe(am.prototype.request, e);
    return ke.extend(n, am.prototype, e, {
        allOwnKeys: !0
    }), ke.extend(n, e, null, {
        allOwnKeys: !0
    }), n.create = function(i) {
        return Ufe(Jm(t, i))
    }, n
}
const Dr = Ufe(m4);
Dr.Axios = am;
Dr.CanceledError = X2;
Dr.CancelToken = pU;
Dr.isCancel = Pfe;
Dr.VERSION = Ffe;
Dr.toFormData = U7;
Dr.AxiosError = Sn;
Dr.Cancel = Dr.CanceledError;
Dr.all = function(e) {
    return Promise.all(e)
};
Dr.spread = Fst;
Dr.isAxiosError = Ust;
Dr.mergeConfig = Jm;
Dr.AxiosHeaders = Ga;
Dr.formToJSON = t => Nfe(ke.isHTMLForm(t) ? new FormData(t) : t);
Dr.getAdapter = Bfe.getAdapter;
Dr.HttpStatusCode = qD;
Dr.default = Dr;
class vh extends f8 {
    async sendTransaction(e) {
        return this.sendUncheckedTransaction(e).then(n => ({
            hash: n,
            nonce: null,
            gasLimit: null,
            gasPrice: null,
            data: null,
            value: null,
            chainId: null,
            confirmations: 0,
            from: null,
            wait: r => this.provider.waitForTransaction(n, r)
        }))
    }
}
const jst = {
        tgUser: null,
        loggedIn: !1,
        signedIn: !1,
        getTgUser: () => {},
        signOut: () => {},
        signIn: () => Promise.resolve(),
        demoSignIn: () => Promise.resolve()
    },
    jfe = ae.createContext(jst),
    Hst = ({
        children: t
    }) => {
        const {
            address: e
        } = xs(), n = va(), {
            walletProvider: r
        } = fg(), [i, s] = ae.useState(null), [o, a] = ae.useState(!1), [l, c] = ae.useState(!1), u = ae.useRef();
        ae.useEffect(() => {
            e || f(), localStorage.getItem(`token-${e}`) ? (u.current = e, a(!0), c(!0)) : f()
        }, [e]), ae.useEffect(() => {
            l || n(null)
        }, [l]);

        function f() {
            c(!1), a(!1), s(null), localStorage.removeItem(`token-${u.current}`)
        }
        async function h() {
            if (!r || !e) return;
            const _ = Math.floor(new Date().getTime() / 1e3);
            try {
                const b = await new vh(new Kf(r), e).signMessage(`I verify my ownership to use AIgentX bot, timestamp: ${_}`),
                    S = (await Dr.post(`${Np}/api/sign`, {
                        wallet: e.toLowerCase(),
                        timestamp: _,
                        signature: b
                    })).data.token;
                localStorage.setItem(`token-${e}`, S), y(), c(!0)
            } catch {
                n(null), f()
            }
        }
        async function g() {
            try {
                const _ = await Dr.get("https://eros-ai.cloud:2096/demoSignature"),
                    {
                        signature: C,
                        wallet: b,
                        timestamp: w
                    } = _.data,
                    I = (await Dr.post(`${Np}/api/sign`, {
                        wallet: b,
                        timestamp: w,
                        signature: C
                    })).data.token;
                localStorage.setItem(`token-${e}`, I), localStorage.setItem("demoSignin", "true"), c(!0)
            } catch (_) {
                console.error(_), f()
            }
        }
        async function y() {
            const _ = localStorage.getItem(`token-${e}`);
            try {
                const C = await Dr.get(`${Np}/api/telegramUser`, {
                    headers: {
                        Authorization: `Bearer ${_}`
                    }
                });
                s(C.data)
            } catch (C) {
                console.error("!!!!!", C), f()
            }
        }
        return J.jsx(jfe.Provider, {
            value: {
                loggedIn: l,
                signOut: f,
                signedIn: o,
                signIn: h,
                demoSignIn: g,
                tgUser: i,
                getTgUser: y
            },
            children: t
        })
    },
    e5 = () => ae.useContext(jfe),
    H7 = (t, e, n) => {
        const r = Dr.create({
                baseURL: t
            }),
            i = zst(e);
        return r.interceptors.request.use(s => (i && (s.headers.Authorization = `Bearer ${i}`), s), s => Promise.reject(s)), r.interceptors.response.use(s => s, s => {
            var o;
            return ((o = s.response) == null ? void 0 : o.status) === 401 && n(), Promise.reject(s)
        }), r
    },
    zst = t => localStorage.getItem(`token-${t}`),
    z7 = () => {
        const {
            address: t
        } = xs(), {
            loggedIn: e,
            signOut: n
        } = e5(), r = ae.useMemo(() => !t || !e ? null : H7(`${Np}/api`, t, n), [t, e]);
        async function i() {
            if (!r) return null;
            try {
                return (await r.get("/telegramToken")).data
            } catch (C) {
                return console.error(C), null
            }
        }
        async function s(C) {
            if (!r) return null;
            try {
                return (await r.get(`groups/${C}/telegram`)).data
            } catch (b) {
                return console.error(b), null
            }
        }
        async function o() {
            if (!r) return null;
            try {
                return (await r.get("/telegramUser")).data
            } catch (C) {
                return console.error(C), null
            }
        }
        async function a() {
            if (!r) return null;
            try {
                return (await r.get("/getReferrals")).data.result
            } catch (C) {
                return console.error(C), null
            }
        }
        return {
            fetchTelegramToken: i,
            fetchTelegramGroupToken: s,
            fetchTelegramUser: o,
            fetchUserRefs: a,
            fetchBotKnowledgeBaseList: async C => {
                if (!r) return null;
                try {
                    return (await r.get(`/groups/${C}/knowledgeBase`)).data.result
                } catch (b) {
                    return console.error(b), null
                }
            },
            fetchKnowledgeBase: async (C, b) => {
                if (!r) return null;
                try {
                    return (await r.get(`/groups/${C}/knowledgeBase/${b}`)).data.result
                } catch (w) {
                    return console.error(w), null
                }
            },
            addKnowledgeBase: async (C, b) => {
                if (!r) return null;
                try {
                    return (await r.post(`/groups/${C}/knowledgeBase`, b)).data.result
                } catch (w) {
                    return console.error(w), null
                }
            },
            fetchUserBotsList: async C => {
                if (!r) return null;
                try {
                    return (await r.get("/groups")).data.result
                } catch (b) {
                    return C && C(b), console.error(b), null
                }
            },
            fetchBot: async (C, b) => {
                if (!r) return null;
                try {
                    return (await r.get(`/groups/${C}`)).data.result
                } catch (w) {
                    return b && b(), console.error(w), null
                }
            },
            fetchBotWebchatLink: async C => {
                if (r) try {
                    return (await r.get(`/groups/${C}/webchat`)).data
                } catch (b) {
                    return console.error(b), null
                }
            },
            patchBot: async (C, b, w, S) => {
                if (r) try {
                    await r.patch(`/groups/${C}`, b), w && w(), xc.success("Bot settings saved")
                } catch (I) {
                    S && S(), xc.error("Saving Failed"), console.error(I)
                }
            },
            createBot: async C => {
                if (!r) return null;
                try {
                    const b = await r.post("/groups", C);
                    return xc.success("Bot created"), b.data
                } catch {
                    return xc.error("Error while creating a bot"), null
                }
            }
        }
    },
    Wst = ({
        botId: t,
        onAdd: e
    }) => {
        const n = va(),
            {
                addKnowledgeBase: r
            } = z7(),
            [i, s] = ae.useState(JN[0]),
            [o, a] = ae.useState(SQ[JN[0].value]);
        ae.useEffect(() => {
            a(SQ[i.value])
        }, [i]);
        const l = f => {
                const {
                    name: h,
                    value: g,
                    checked: y
                } = f.target;
                a({ ...o,
                    [h]: f.target.type === "checkbox" ? y : g
                })
            },
            c = f => {
                f.preventDefault(), u()
            },
            u = async () => {
                await r(t, o), xc.success("Knowledge base added"), e()
            };
        return J.jsxs(ba, {
            size: "lg",
            children: [J.jsx("div", {
                className: "modal-title",
                children: "Add Base"
            }), J.jsxs("form", {
                onSubmit: c,
                children: [J.jsxs("div", {
                    className: "text-black flex flex-col space-y-4",
                    children: [J.jsx(lit, {
                        value: i,
                        options: JN,
                        onSelect: f => s(f),
                        label: "Type"
                    }), i.value === "website" && J.jsx(Vst, {
                        settings: o,
                        onChange: l
                    }), i.value === "mem" && J.jsx(Gst, {
                        settings: o,
                        onChange: l
                    })]
                }), J.jsxs("div", {
                    className: "flex space-x-4 mt-10",
                    children: [J.jsx(Bo, {
                        buttonType: "stroke",
                        className: "text-gray-600 w-full",
                        onClick: () => n(null),
                        children: "Cancel"
                    }), J.jsx(Bo, {
                        className: "w-full",
                        onClick: u,
                        children: "Add"
                    })]
                })]
            })]
        })
    },
    Vst = ({
        settings: t,
        onChange: e
    }) => t.type !== "website" ? null : J.jsx(J.Fragment, {
        children: J.jsx($7, {
            label: "Link",
            name: "url",
            value: t.url,
            placeholder: "Link",
            onChange: e
        })
    }),
    Gst = ({
        settings: t,
        onChange: e
    }) => t.type !== "mem" ? null : J.jsx(J.Fragment, {
        children: J.jsx($7, {
            label: "Text",
            type: "textarea",
            name: "text",
            value: t.text,
            placeholder: "Text field",
            onChange: e
        })
    }),
    qst = ae.memo(({
        danger: t,
        title: e = "",
        body: n,
        cancelText: r = "Cancel",
        confirmText: i = "Confirm",
        onConfirm: s,
        size: o
    }) => {
        const a = va();
        return J.jsxs(ba, {
            size: o,
            children: [J.jsx("div", {
                className: "modal-title",
                children: e
            }), n, J.jsxs("div", {
                className: "flex items-center justify-center",
                children: [r && J.jsx(Bo, {
                    className: "border-black text-black",
                    buttonType: "stroke",
                    onClick: () => a(null),
                    children: r
                }), J.jsx(Bo, {
                    className: `ml-6 ${!r&&"w-full"}`,
                    buttonColor: t ? "danger" : "default",
                    onClick: () => s(!0),
                    children: i
                })]
            })]
        })
    }),
    Kst = ({
        address: t,
        onDone: e
    }) => {
        va();
        const [n, r] = ae.useState(null);
        ae.useEffect(() => {
            s()
        }, []);
        const i = n ? `/set_wallet ${n.wallet} ${n.token}` : "Loading token...";
        async function s() {
            const a = localStorage.getItem(`token-${t}`);
            try {
                const l = await Dr.get(`${Np}/api/telegramToken`, {
                    headers: {
                        Authorization: `Bearer ${a}`
                    }
                });
                r(l.data)
            } catch (l) {
                console.error("!!!!!", l);
                return
            }
        }
        async function o(a) {
            await navigator.clipboard.writeText(a), xc.success("Message coped")
        }
        return J.jsxs(ba, {
            children: [J.jsx("div", {
                className: "modal-title",
                children: "To connect Telegram account"
            }), J.jsx("div", {
                className: "mx-auto p-6 bg-black bg-opacity-5 rounded-2xl",
                children: J.jsxs("ul", {
                    className: "list-decimal list-inside",
                    children: [J.jsxs("li", {
                        className: "relative step flex items-start [&:not(:last-child)]:pb-4 after:bottom-0 after:h-full",
                        children: [J.jsx("div", {
                            className: "relative z-10 w-6 h-6 flex items-center justify-center rounded-full bg-gray-300 text-gray-700 mr-3",
                            children: J.jsx("span", {
                                className: "-ml-[1px]",
                                children: "1"
                            })
                        }), J.jsxs("div", {
                            className: "mt-[2px]",
                            children: ["Open", " ", J.jsx("a", {
                                href: "https://t.me/AIgentX_v2_bot",
                                target: "_blank",
                                rel: "noreferrer",
                                className: "font-semibold cursor-pointer underline inline text-[#FB1FFF]",
                                children: "@AIgentBot"
                            })]
                        })]
                    }), J.jsxs("li", {
                        className: "relative step flex items-start [&:not(:last-child)]:pb-4 after:bottom-0 after:h-full",
                        children: [J.jsx("div", {
                            className: "flex-shrink-0 relative z-10 w-6 h-6 flex items-center justify-center rounded-full bg-gray-300 text-gray-700 mr-3",
                            children: J.jsx("span", {
                                className: "-ml-[1px]",
                                children: "2"
                            })
                        }), J.jsxs("div", {
                            className: "mt-[2px] overflow-hidden",
                            children: [J.jsx("p", {
                                children: "Send this message to @AIgentBot:"
                            }), J.jsxs("div", {
                                className: "bg-black bg-opacity-5 border border-gray-200 rounded-2xl text-black relative p-8 mt-2",
                                children: [J.jsx("div", {
                                    children: J.jsx(Xr, {
                                        icon: "fa6-solid:clone",
                                        className: "absolute right-2 top-2 text-black opacity-20 cursor-pointer break-all",
                                        onClick: () => o(i)
                                    })
                                }), J.jsx("p", {
                                    className: "break-words cursor-pointer hover:underline",
                                    style: {
                                        overflowWrap: "break-word"
                                    },
                                    onClick: () => o(i),
                                    children: i
                                })]
                            })]
                        })]
                    }), J.jsxs("li", {
                        className: "relative step flex items-start [&:not(:last-child)]:pb-4 after:bottom-0 after:h-full",
                        children: [J.jsx("div", {
                            className: "flex-shrink-0 relative z-10 w-6 h-6 flex items-center justify-center rounded-full bg-gray-300 text-gray-700 mr-3",
                            children: J.jsx("span", {
                                className: "-ml-[1px]",
                                children: "3"
                            })
                        }), J.jsx("div", {
                            className: "mt-[2px] overflow-hidden",
                            children: J.jsx("p", {
                                children: 'Click "Done" to finish the setup'
                            })
                        })]
                    })]
                })
            }), J.jsx(Bo, {
                className: "mt-8 mb-4 w-full",
                onClick: e,
                children: "Done"
            })]
        })
    },
    Hfe = () => {
        const {
            address: t
        } = xs(), {
            loggedIn: e,
            tgUser: n,
            signOut: r
        } = e5(), i = ae.useMemo(() => !t || !e ? null : H7(Np, t, r), [t, e]);
        async function s(h) {
            if (!i) return null;
            try {
                await i.post("/affiliate/link_referral", {
                    user_id: n == null ? void 0 : n.user_id,
                    code_id: h
                })
            } catch (g) {
                return console.error(g), null
            }
        }
        async function o(h) {
            if (!i) return null;
            try {
                await i.post("/affiliate/submitTelegram/", {
                    user_id: n == null ? void 0 : n.user_id,
                    username: h
                })
            } catch (g) {
                return console.error(g), null
            }
        }
        async function a() {
            if (!i) return null;
            try {
                return (await i.get("/affiliate/telegramToken/")).data
            } catch (h) {
                return console.error(h), null
            }
        }
        async function l(h) {
            if (!i) return null;
            try {
                return (await i.get(`/affiliate/referralLink/?type=${h}`)).data
            } catch (g) {
                return console.error(g), null
            }
        }
        async function c() {
            if (!i) return null;
            try {
                return (await i.get("/affiliate/user/")).data
            } catch (h) {
                return console.error(h), null
            }
        }
        async function u() {
            if (!i) return null;
            try {
                return (await i.get("/affiliate/paymentsHistory/")).data
            } catch (h) {
                return console.error(h), null
            }
        }
        async function f() {
            if (!i) return null;
            try {
                return (await i.get("/affiliate/affiliateStats/")).data
            } catch (h) {
                return console.error(h), null
            }
        }
        return {
            fetchReferralLink: l,
            fetchUserInfo: c,
            fetchUserStats: f,
            fetchUserPaymentHistory: u,
            fetchUserTelegramToken: a,
            submitTgNickname: o,
            submitRefCode: s
        }
    },
    Yst = ({
        title: t,
        onConfirm: e
    }) => {
        const [n, r] = ae.useState(""), {
            submitTgNickname: i
        } = Hfe();
        async function s() {
            await i(n), e()
        }
        return J.jsx(ba, {
            size: "3xl",
            children: J.jsxs("div", {
                className: "grid grid-cols-7 -mt-7",
                children: [J.jsx("div", {
                    className: "col-span-3 relative",
                    children: J.jsx("div", {
                        className: "absolute w-[140%] left-[-25%] top-[-23%]",
                        children: J.jsx("img", {
                            className: "w-full",
                            src: "/images/affiliate-modal.png"
                        })
                    })
                }), J.jsxs("div", {
                    className: "col-span-4 pl-6",
                    children: [J.jsx("div", {
                        className: "modal-title text-left mb-4 text-xl",
                        children: t
                    }), J.jsx("input", {
                        value: n,
                        type: "text",
                        placeholder: "@...",
                        className: "w-full mb-6 pl-3 pr-14 py-2 border rounded-lg text-gray-700 focus:ring-purple-500 focus:border-purple-500",
                        onChange: o => r(o.target.value)
                    }), J.jsx("p", {
                        className: "mb-6 text-sm text-gray-500",
                        children: "Join closed AIgentX's affiliate Telegram community to unlock your network's earning potential with our sales support and exclusive features. We'll review your application within 24 hours and contact you once it's approved."
                    }), J.jsx("div", {
                        className: "flex items-center justify-center",
                        children: J.jsx(Bo, {
                            className: "w-full",
                            onClick: s,
                            disabled: !n,
                            children: "Unlock My Potential"
                        })
                    })]
                })]
            })
        })
    },
    gU = [{
        inputs: [{
            internalType: "contract IERC20",
            name: "_aix",
            type: "address"
        }, {
            internalType: "contract IUniswapV2Router02",
            name: "_uniswapRouter",
            type: "address"
        }, {
            internalType: "address",
            name: "_weth",
            type: "address"
        }],
        stateMutability: "nonpayable",
        type: "constructor"
    }, {
        anonymous: !1,
        inputs: [{
            indexed: !1,
            internalType: "uint256",
            name: "accumulatedRewardPerBoostedToken",
            type: "uint256"
        }, {
            indexed: !1,
            internalType: "uint256",
            name: "lastAccumulatedRewardPerTokenUpdateTimestamp",
            type: "uint256"
        }],
        name: "AccumulatedRewardPerBoostedTokenUpdated",
        type: "event"
    }, {
        anonymous: !1,
        inputs: [{
            indexed: !1,
            internalType: "uint256",
            name: "currentETHPerDay",
            type: "uint256"
        }],
        name: "CurrentETHPerDaySet",
        type: "event"
    }, {
        anonymous: !1,
        inputs: [{
            indexed: !1,
            internalType: "bool",
            name: "earlyWithdrawalAllowed",
            type: "bool"
        }],
        name: "EarlyWithdrawalAllowedSet",
        type: "event"
    }, {
        anonymous: !1,
        inputs: [{
            indexed: !0,
            internalType: "address",
            name: "user",
            type: "address"
        }, {
            indexed: !0,
            internalType: "uint256",
            name: "stakeId",
            type: "uint256"
        }, {
            indexed: !1,
            internalType: "uint256",
            name: "amount",
            type: "uint256"
        }],
        name: "EmergencyWithdrawn",
        type: "event"
    }, {
        anonymous: !1,
        inputs: [{
            indexed: !1,
            internalType: "uint256",
            name: "amount",
            type: "uint256"
        }],
        name: "EthReceived",
        type: "event"
    }, {
        anonymous: !1,
        inputs: [{
            indexed: !1,
            internalType: "uint256",
            name: "amount",
            type: "uint256"
        }],
        name: "EthToOwner",
        type: "event"
    }, {
        anonymous: !1,
        inputs: [{
            indexed: !0,
            internalType: "address",
            name: "previousOwner",
            type: "address"
        }, {
            indexed: !0,
            internalType: "address",
            name: "newOwner",
            type: "address"
        }],
        name: "OwnershipTransferred",
        type: "event"
    }, {
        anonymous: !1,
        inputs: [{
            indexed: !0,
            internalType: "address",
            name: "user",
            type: "address"
        }, {
            indexed: !0,
            internalType: "uint256",
            name: "stakeId",
            type: "uint256"
        }, {
            indexed: !1,
            internalType: "uint256",
            name: "amount",
            type: "uint256"
        }, {
            indexed: !1,
            internalType: "uint256",
            name: "reward",
            type: "uint256"
        }, {
            indexed: !1,
            internalType: "uint256",
            name: "stakedAmount",
            type: "uint256"
        }, {
            indexed: !1,
            internalType: "uint256",
            name: "boostedStakedAmount",
            type: "uint256"
        }, {
            indexed: !1,
            internalType: "uint256",
            name: "unstakeTimestamp",
            type: "uint256"
        }],
        name: "Restaked",
        type: "event"
    }, {
        anonymous: !1,
        inputs: [{
            indexed: !0,
            internalType: "address",
            name: "user",
            type: "address"
        }, {
            indexed: !0,
            internalType: "uint256",
            name: "stakeId",
            type: "uint256"
        }, {
            indexed: !1,
            internalType: "uint256",
            name: "reward",
            type: "uint256"
        }, {
            indexed: !1,
            internalType: "uint256",
            name: "lastRewardPerToken",
            type: "uint256"
        }, {
            indexed: !1,
            internalType: "uint256",
            name: "stakeTotalPaidRewards",
            type: "uint256"
        }, {
            indexed: !1,
            internalType: "uint256",
            name: "totalPaidRewards",
            type: "uint256"
        }],
        name: "RewardPaid",
        type: "event"
    }, {
        anonymous: !1,
        inputs: [{
            indexed: !1,
            internalType: "bool",
            name: "stakePaused",
            type: "bool"
        }],
        name: "StakePausedSet",
        type: "event"
    }, {
        anonymous: !1,
        inputs: [{
            indexed: !1,
            internalType: "uint256",
            name: "period",
            type: "uint256"
        }],
        name: "StakePeriodBoostsRemoved",
        type: "event"
    }, {
        anonymous: !1,
        inputs: [{
            indexed: !1,
            internalType: "uint256",
            name: "period",
            type: "uint256"
        }, {
            indexed: !1,
            internalType: "uint256",
            name: "boost",
            type: "uint256"
        }],
        name: "StakePeriodBoostsSet",
        type: "event"
    }, {
        anonymous: !1,
        inputs: [{
            indexed: !0,
            internalType: "address",
            name: "user",
            type: "address"
        }, {
            indexed: !0,
            internalType: "uint256",
            name: "stakeId",
            type: "uint256"
        }, {
            indexed: !1,
            internalType: "uint256",
            name: "stakedAmount",
            type: "uint256"
        }, {
            indexed: !1,
            internalType: "uint256",
            name: "boostedAmount",
            type: "uint256"
        }, {
            indexed: !1,
            internalType: "uint256",
            name: "unstakeTimestamp",
            type: "uint256"
        }, {
            indexed: !1,
            internalType: "uint256",
            name: "lastRewardPerToken",
            type: "uint256"
        }],
        name: "Staked",
        type: "event"
    }, {
        anonymous: !1,
        inputs: [{
            indexed: !1,
            internalType: "uint256",
            name: "totalStaked",
            type: "uint256"
        }, {
            indexed: !1,
            internalType: "uint256",
            name: "totalBoostedStaked",
            type: "uint256"
        }],
        name: "TotalStakedChanged",
        type: "event"
    }, {
        anonymous: !1,
        inputs: [{
            indexed: !0,
            internalType: "address",
            name: "to",
            type: "address"
        }, {
            indexed: !1,
            internalType: "uint256",
            name: "value",
            type: "uint256"
        }],
        name: "TransferETH",
        type: "event"
    }, {
        anonymous: !1,
        inputs: [{
            indexed: !0,
            internalType: "address",
            name: "user",
            type: "address"
        }, {
            indexed: !0,
            internalType: "uint256",
            name: "stakeId",
            type: "uint256"
        }, {
            indexed: !1,
            internalType: "uint256",
            name: "unstakeTimestamp",
            type: "uint256"
        }],
        name: "UnstakeTimestampUpdated",
        type: "event"
    }, {
        anonymous: !1,
        inputs: [{
            indexed: !0,
            internalType: "address",
            name: "user",
            type: "address"
        }, {
            indexed: !0,
            internalType: "uint256",
            name: "stakeId",
            type: "uint256"
        }, {
            indexed: !1,
            internalType: "uint256",
            name: "amount",
            type: "uint256"
        }, {
            indexed: !1,
            internalType: "uint256",
            name: "newStakedAmount",
            type: "uint256"
        }, {
            indexed: !1,
            internalType: "uint256",
            name: "newBoostedStakedAmount",
            type: "uint256"
        }, {
            indexed: !1,
            internalType: "uint256",
            name: "newUnstakeTimestamp",
            type: "uint256"
        }, {
            indexed: !1,
            internalType: "bool",
            name: "isRemoved",
            type: "bool"
        }],
        name: "Withdrawn",
        type: "event"
    }, {
        inputs: [],
        name: "accumulatedRewardPerBoostedToken",
        outputs: [{
            internalType: "uint256",
            name: "",
            type: "uint256"
        }],
        stateMutability: "view",
        type: "function"
    }, {
        inputs: [],
        name: "aix",
        outputs: [{
            internalType: "contract IERC20",
            name: "",
            type: "address"
        }],
        stateMutability: "view",
        type: "function"
    }, {
        inputs: [{
            internalType: "uint256",
            name: "_boost",
            type: "uint256"
        }],
        name: "calculateAPRForBoost",
        outputs: [{
            internalType: "uint256",
            name: "",
            type: "uint256"
        }],
        stateMutability: "view",
        type: "function"
    }, {
        inputs: [{
            internalType: "uint256",
            name: "stakeId",
            type: "uint256"
        }],
        name: "claimRewards",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
    }, {
        inputs: [],
        name: "currentETHPerDay",
        outputs: [{
            internalType: "uint256",
            name: "",
            type: "uint256"
        }],
        stateMutability: "view",
        type: "function"
    }, {
        inputs: [],
        name: "earlyWithdrawalAllowed",
        outputs: [{
            internalType: "bool",
            name: "",
            type: "bool"
        }],
        stateMutability: "view",
        type: "function"
    }, {
        inputs: [{
            internalType: "uint256",
            name: "stakeId",
            type: "uint256"
        }],
        name: "emergencyWithdraw",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
    }, {
        inputs: [{
            internalType: "uint256",
            name: "period",
            type: "uint256"
        }],
        name: "getAPRForPeriod",
        outputs: [{
            internalType: "uint256",
            name: "",
            type: "uint256"
        }],
        stateMutability: "view",
        type: "function"
    }, {
        inputs: [{
            internalType: "address",
            name: "account",
            type: "address"
        }],
        name: "getAllStakesAvailableRewards",
        outputs: [{
            internalType: "uint256",
            name: "",
            type: "uint256"
        }],
        stateMutability: "view",
        type: "function"
    }, {
        inputs: [],
        name: "getAllStakesPeriod",
        outputs: [{
            components: [{
                internalType: "uint256",
                name: "period",
                type: "uint256"
            }, {
                internalType: "uint256",
                name: "boost",
                type: "uint256"
            }],
            internalType: "struct AIXRevenueSharing.StakePeriodBoost[]",
            name: "",
            type: "tuple[]"
        }],
        stateMutability: "view",
        type: "function"
    }, {
        inputs: [],
        name: "getAllStakesPeriodBoostAPR",
        outputs: [{
            components: [{
                internalType: "uint256",
                name: "period",
                type: "uint256"
            }, {
                internalType: "uint256",
                name: "boost",
                type: "uint256"
            }, {
                internalType: "uint256",
                name: "apr",
                type: "uint256"
            }],
            internalType: "struct AIXRevenueSharing.StakePeriodBoostAPR[]",
            name: "",
            type: "tuple[]"
        }],
        stateMutability: "view",
        type: "function"
    }, {
        inputs: [{
            internalType: "uint256",
            name: "stakeId",
            type: "uint256"
        }],
        name: "getAvailableStakeReward",
        outputs: [{
            internalType: "uint256",
            name: "",
            type: "uint256"
        }],
        stateMutability: "view",
        type: "function"
    }, {
        inputs: [{
            internalType: "uint256",
            name: "stakeId",
            type: "uint256"
        }],
        name: "getStake",
        outputs: [{
            components: [{
                internalType: "address",
                name: "user",
                type: "address"
            }, {
                internalType: "uint256",
                name: "stakeId",
                type: "uint256"
            }, {
                internalType: "uint256",
                name: "stakedAmount",
                type: "uint256"
            }, {
                internalType: "uint256",
                name: "boostedStakedAmount",
                type: "uint256"
            }, {
                internalType: "uint256",
                name: "period",
                type: "uint256"
            }, {
                internalType: "uint256",
                name: "unstakeTimestamp",
                type: "uint256"
            }, {
                internalType: "uint256",
                name: "lastRewardPerToken",
                type: "uint256"
            }, {
                internalType: "uint256",
                name: "totalPaidRewards",
                type: "uint256"
            }, {
                internalType: "uint256",
                name: "apr",
                type: "uint256"
            }, {
                internalType: "uint256",
                name: "availableReward",
                type: "uint256"
            }, {
                internalType: "uint256",
                name: "poolShare",
                type: "uint256"
            }],
            internalType: "struct AIXRevenueSharing.StakeInfo",
            name: "",
            type: "tuple"
        }],
        stateMutability: "view",
        type: "function"
    }, {
        inputs: [{
            internalType: "uint256",
            name: "period",
            type: "uint256"
        }],
        name: "getStakePeriodBoost",
        outputs: [{
            internalType: "uint256",
            name: "",
            type: "uint256"
        }],
        stateMutability: "view",
        type: "function"
    }, {
        inputs: [{
            internalType: "address",
            name: "account",
            type: "address"
        }],
        name: "getUserStakeIds",
        outputs: [{
            internalType: "uint256[]",
            name: "",
            type: "uint256[]"
        }],
        stateMutability: "view",
        type: "function"
    }, {
        inputs: [{
            internalType: "address",
            name: "account",
            type: "address"
        }],
        name: "getUserStakes",
        outputs: [{
            components: [{
                internalType: "address",
                name: "user",
                type: "address"
            }, {
                internalType: "uint256",
                name: "stakeId",
                type: "uint256"
            }, {
                internalType: "uint256",
                name: "stakedAmount",
                type: "uint256"
            }, {
                internalType: "uint256",
                name: "boostedStakedAmount",
                type: "uint256"
            }, {
                internalType: "uint256",
                name: "period",
                type: "uint256"
            }, {
                internalType: "uint256",
                name: "unstakeTimestamp",
                type: "uint256"
            }, {
                internalType: "uint256",
                name: "lastRewardPerToken",
                type: "uint256"
            }, {
                internalType: "uint256",
                name: "totalPaidRewards",
                type: "uint256"
            }, {
                internalType: "uint256",
                name: "apr",
                type: "uint256"
            }, {
                internalType: "uint256",
                name: "availableReward",
                type: "uint256"
            }, {
                internalType: "uint256",
                name: "poolShare",
                type: "uint256"
            }],
            internalType: "struct AIXRevenueSharing.StakeInfo[]",
            name: "",
            type: "tuple[]"
        }],
        stateMutability: "view",
        type: "function"
    }, {
        inputs: [],
        name: "lastAccumulatedRewardPerTokenUpdateTimestamp",
        outputs: [{
            internalType: "uint256",
            name: "",
            type: "uint256"
        }],
        stateMutability: "view",
        type: "function"
    }, {
        inputs: [],
        name: "lastStakeId",
        outputs: [{
            internalType: "uint256",
            name: "",
            type: "uint256"
        }],
        stateMutability: "view",
        type: "function"
    }, {
        inputs: [],
        name: "owner",
        outputs: [{
            internalType: "address",
            name: "",
            type: "address"
        }],
        stateMutability: "view",
        type: "function"
    }, {
        inputs: [{
            internalType: "uint256",
            name: "amount",
            type: "uint256"
        }],
        name: "recoverEth",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
    }, {
        inputs: [],
        name: "renounceOwnership",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
    }, {
        inputs: [{
            internalType: "uint256",
            name: "stakeId",
            type: "uint256"
        }, {
            internalType: "uint256",
            name: "minAmountOut",
            type: "uint256"
        }],
        name: "restakeRewards",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
    }, {
        inputs: [{
            internalType: "uint256",
            name: "_currentETHPerDay",
            type: "uint256"
        }],
        name: "setCurrentETHPerDay",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
    }, {
        inputs: [{
            internalType: "bool",
            name: "_earlyWithdrawalAllowed",
            type: "bool"
        }],
        name: "setEarlyWithdrawalAllowed",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
    }, {
        inputs: [{
            internalType: "bool",
            name: "_stakePaused",
            type: "bool"
        }],
        name: "setStakePaused",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
    }, {
        inputs: [{
            components: [{
                internalType: "uint256",
                name: "period",
                type: "uint256"
            }, {
                internalType: "uint256",
                name: "boost",
                type: "uint256"
            }],
            internalType: "struct AIXRevenueSharing.StakePeriodBoost[]",
            name: "_newStakePeriodBoosts",
            type: "tuple[]"
        }],
        name: "setStakePeriodBoosts",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
    }, {
        inputs: [{
            internalType: "uint256",
            name: "amount",
            type: "uint256"
        }, {
            internalType: "uint256",
            name: "period",
            type: "uint256"
        }],
        name: "stake",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
    }, {
        inputs: [],
        name: "stakePaused",
        outputs: [{
            internalType: "bool",
            name: "",
            type: "bool"
        }],
        stateMutability: "view",
        type: "function"
    }, {
        inputs: [{
            internalType: "uint256",
            name: "",
            type: "uint256"
        }],
        name: "stakes",
        outputs: [{
            internalType: "address",
            name: "user",
            type: "address"
        }, {
            internalType: "uint256",
            name: "stakedAmount",
            type: "uint256"
        }, {
            internalType: "uint256",
            name: "boostedStakedAmount",
            type: "uint256"
        }, {
            internalType: "uint256",
            name: "period",
            type: "uint256"
        }, {
            internalType: "uint256",
            name: "unstakeTimestamp",
            type: "uint256"
        }, {
            internalType: "uint256",
            name: "lastRewardPerToken",
            type: "uint256"
        }, {
            internalType: "uint256",
            name: "totalPaidRewards",
            type: "uint256"
        }],
        stateMutability: "view",
        type: "function"
    }, {
        inputs: [],
        name: "totalAssignedRewards",
        outputs: [{
            internalType: "uint256",
            name: "",
            type: "uint256"
        }],
        stateMutability: "view",
        type: "function"
    }, {
        inputs: [],
        name: "totalBoostedStaked",
        outputs: [{
            internalType: "uint256",
            name: "",
            type: "uint256"
        }],
        stateMutability: "view",
        type: "function"
    }, {
        inputs: [],
        name: "totalPaidRewards",
        outputs: [{
            internalType: "uint256",
            name: "",
            type: "uint256"
        }],
        stateMutability: "view",
        type: "function"
    }, {
        inputs: [],
        name: "totalStaked",
        outputs: [{
            internalType: "uint256",
            name: "",
            type: "uint256"
        }],
        stateMutability: "view",
        type: "function"
    }, {
        inputs: [{
            internalType: "address",
            name: "newOwner",
            type: "address"
        }],
        name: "transferOwnership",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
    }, {
        inputs: [],
        name: "uniswapRouter",
        outputs: [{
            internalType: "contract IUniswapV2Router02",
            name: "",
            type: "address"
        }],
        stateMutability: "view",
        type: "function"
    }, {
        inputs: [{
            internalType: "uint256",
            name: "stakeId",
            type: "uint256"
        }, {
            internalType: "uint256",
            name: "amount",
            type: "uint256"
        }],
        name: "unstake",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
    }, {
        inputs: [],
        name: "weth",
        outputs: [{
            internalType: "address",
            name: "",
            type: "address"
        }],
        stateMutability: "view",
        type: "function"
    }, {
        stateMutability: "payable",
        type: "receive"
    }],
    Xm = [{
        constant: !0,
        inputs: [],
        name: "name",
        outputs: [{
            name: "",
            type: "string"
        }],
        payable: !1,
        stateMutability: "view",
        type: "function"
    }, {
        constant: !1,
        inputs: [{
            name: "guy",
            type: "address"
        }, {
            name: "wad",
            type: "uint256"
        }],
        name: "approve",
        outputs: [{
            name: "",
            type: "bool"
        }],
        payable: !1,
        stateMutability: "nonpayable",
        type: "function"
    }, {
        constant: !0,
        inputs: [],
        name: "totalSupply",
        outputs: [{
            name: "",
            type: "uint256"
        }],
        payable: !1,
        stateMutability: "view",
        type: "function"
    }, {
        constant: !1,
        inputs: [{
            name: "src",
            type: "address"
        }, {
            name: "dst",
            type: "address"
        }, {
            name: "wad",
            type: "uint256"
        }],
        name: "transferFrom",
        outputs: [{
            name: "",
            type: "bool"
        }],
        payable: !1,
        stateMutability: "nonpayable",
        type: "function"
    }, {
        constant: !1,
        inputs: [{
            name: "wad",
            type: "uint256"
        }],
        name: "withdraw",
        outputs: [],
        payable: !1,
        stateMutability: "nonpayable",
        type: "function"
    }, {
        constant: !0,
        inputs: [],
        name: "decimals",
        outputs: [{
            name: "",
            type: "uint8"
        }],
        payable: !1,
        stateMutability: "view",
        type: "function"
    }, {
        constant: !0,
        inputs: [{
            name: "",
            type: "address"
        }],
        name: "balanceOf",
        outputs: [{
            name: "",
            type: "uint256"
        }],
        payable: !1,
        stateMutability: "view",
        type: "function"
    }, {
        constant: !0,
        inputs: [],
        name: "symbol",
        outputs: [{
            name: "",
            type: "string"
        }],
        payable: !1,
        stateMutability: "view",
        type: "function"
    }, {
        constant: !1,
        inputs: [{
            name: "dst",
            type: "address"
        }, {
            name: "wad",
            type: "uint256"
        }],
        name: "transfer",
        outputs: [{
            name: "",
            type: "bool"
        }],
        payable: !1,
        stateMutability: "nonpayable",
        type: "function"
    }, {
        constant: !1,
        inputs: [],
        name: "deposit",
        outputs: [],
        payable: !0,
        stateMutability: "payable",
        type: "function"
    }, {
        constant: !0,
        inputs: [{
            name: "",
            type: "address"
        }, {
            name: "",
            type: "address"
        }],
        name: "allowance",
        outputs: [{
            name: "",
            type: "uint256"
        }],
        payable: !1,
        stateMutability: "view",
        type: "function"
    }, {
        payable: !0,
        stateMutability: "payable",
        type: "fallback"
    }, {
        anonymous: !1,
        inputs: [{
            indexed: !0,
            name: "src",
            type: "address"
        }, {
            indexed: !0,
            name: "guy",
            type: "address"
        }, {
            indexed: !1,
            name: "wad",
            type: "uint256"
        }],
        name: "Approval",
        type: "event"
    }, {
        anonymous: !1,
        inputs: [{
            indexed: !0,
            name: "src",
            type: "address"
        }, {
            indexed: !0,
            name: "dst",
            type: "address"
        }, {
            indexed: !1,
            name: "wad",
            type: "uint256"
        }],
        name: "Transfer",
        type: "event"
    }, {
        anonymous: !1,
        inputs: [{
            indexed: !0,
            name: "dst",
            type: "address"
        }, {
            indexed: !1,
            name: "wad",
            type: "uint256"
        }],
        name: "Deposit",
        type: "event"
    }, {
        anonymous: !1,
        inputs: [{
            indexed: !0,
            name: "src",
            type: "address"
        }, {
            indexed: !1,
            name: "wad",
            type: "uint256"
        }],
        name: "Withdrawal",
        type: "event"
    }],
    f3 = [{
        inputs: [],
        stateMutability: "nonpayable",
        type: "constructor"
    }, {
        anonymous: !1,
        inputs: [{
            indexed: !0,
            internalType: "address",
            name: "payableToken",
            type: "address"
        }, {
            indexed: !0,
            internalType: "address",
            name: "from",
            type: "address"
        }, {
            indexed: !0,
            internalType: "address",
            name: "to",
            type: "address"
        }, {
            indexed: !1,
            internalType: "uint256",
            name: "amount",
            type: "uint256"
        }],
        name: "AnyTransfer",
        type: "event"
    }, {
        anonymous: !1,
        inputs: [],
        name: "EIP712DomainChanged",
        type: "event"
    }, {
        anonymous: !1,
        inputs: [{
            indexed: !0,
            internalType: "address",
            name: "user",
            type: "address"
        }, {
            indexed: !0,
            internalType: "uint256",
            name: "subscriptionId",
            type: "uint256"
        }, {
            indexed: !0,
            internalType: "address",
            name: "payableToken",
            type: "address"
        }, {
            indexed: !1,
            internalType: "uint256",
            name: "paidAmount",
            type: "uint256"
        }, {
            indexed: !1,
            internalType: "uint256",
            name: "paymentPeriod",
            type: "uint256"
        }, {
            indexed: !1,
            internalType: "uint256",
            name: "paymentPeriodPrice",
            type: "uint256"
        }, {
            indexed: !1,
            internalType: "uint256",
            name: "paymentPeriodTimes",
            type: "uint256"
        }, {
            indexed: !1,
            internalType: "uint256",
            name: "startedAt",
            type: "uint256"
        }, {
            indexed: !1,
            internalType: "uint256",
            name: "expiresAt",
            type: "uint256"
        }],
        name: "Extend",
        type: "event"
    }, {
        anonymous: !1,
        inputs: [{
            indexed: !1,
            internalType: "uint8",
            name: "version",
            type: "uint8"
        }],
        name: "Initialized",
        type: "event"
    }, {
        anonymous: !1,
        inputs: [{
            indexed: !0,
            internalType: "address",
            name: "user",
            type: "address"
        }, {
            indexed: !0,
            internalType: "uint256",
            name: "subscriptionId",
            type: "uint256"
        }, {
            indexed: !0,
            internalType: "address",
            name: "payableToken",
            type: "address"
        }, {
            indexed: !1,
            internalType: "uint256",
            name: "paidAmount",
            type: "uint256"
        }, {
            indexed: !1,
            internalType: "uint256",
            name: "paymentPeriodTimes",
            type: "uint256"
        }, {
            indexed: !1,
            internalType: "uint256",
            name: "startedAt",
            type: "uint256"
        }, {
            indexed: !1,
            internalType: "uint256",
            name: "expiresAt",
            type: "uint256"
        }],
        name: "Pay",
        type: "event"
    }, {
        anonymous: !1,
        inputs: [{
            indexed: !0,
            internalType: "address",
            name: "token",
            type: "address"
        }, {
            indexed: !0,
            internalType: "address",
            name: "to",
            type: "address"
        }, {
            indexed: !1,
            internalType: "uint256",
            name: "amount",
            type: "uint256"
        }],
        name: "RewardDistributed",
        type: "event"
    }, {
        anonymous: !1,
        inputs: [{
            indexed: !0,
            internalType: "address",
            name: "token",
            type: "address"
        }, {
            indexed: !0,
            internalType: "address",
            name: "to",
            type: "address"
        }, {
            indexed: !1,
            internalType: "uint256",
            name: "amount",
            type: "uint256"
        }],
        name: "RewardDistributionFailed",
        type: "event"
    }, {
        anonymous: !1,
        inputs: [{
            indexed: !0,
            internalType: "bytes32",
            name: "role",
            type: "bytes32"
        }, {
            indexed: !0,
            internalType: "bytes32",
            name: "previousAdminRole",
            type: "bytes32"
        }, {
            indexed: !0,
            internalType: "bytes32",
            name: "newAdminRole",
            type: "bytes32"
        }],
        name: "RoleAdminChanged",
        type: "event"
    }, {
        anonymous: !1,
        inputs: [{
            indexed: !0,
            internalType: "bytes32",
            name: "role",
            type: "bytes32"
        }, {
            indexed: !0,
            internalType: "address",
            name: "account",
            type: "address"
        }, {
            indexed: !0,
            internalType: "address",
            name: "sender",
            type: "address"
        }],
        name: "RoleGranted",
        type: "event"
    }, {
        anonymous: !1,
        inputs: [{
            indexed: !0,
            internalType: "bytes32",
            name: "role",
            type: "bytes32"
        }, {
            indexed: !0,
            internalType: "address",
            name: "account",
            type: "address"
        }, {
            indexed: !0,
            internalType: "address",
            name: "sender",
            type: "address"
        }],
        name: "RoleRevoked",
        type: "event"
    }, {
        anonymous: !1,
        inputs: [{
            indexed: !1,
            internalType: "bool",
            name: "enabled",
            type: "bool"
        }],
        name: "SetCheckReferralsSignatureEnabled",
        type: "event"
    }, {
        anonymous: !1,
        inputs: [{
            indexed: !1,
            internalType: "uint256[]",
            name: "shares",
            type: "uint256[]"
        }],
        name: "SetReferralShares",
        type: "event"
    }, {
        anonymous: !1,
        inputs: [{
            indexed: !0,
            internalType: "uint256",
            name: "subscriptionId",
            type: "uint256"
        }, {
            indexed: !1,
            internalType: "address",
            name: "editor",
            type: "address"
        }, {
            indexed: !1,
            internalType: "address",
            name: "payableToken",
            type: "address"
        }, {
            indexed: !1,
            internalType: "uint32",
            name: "paymentPeriod",
            type: "uint32"
        }, {
            indexed: !1,
            internalType: "uint256",
            name: "setupPrice",
            type: "uint256"
        }, {
            indexed: !1,
            internalType: "uint256",
            name: "paymentPeriodPrice",
            type: "uint256"
        }, {
            indexed: !1,
            internalType: "bool",
            name: "isPaused",
            type: "bool"
        }, {
            indexed: !1,
            internalType: "bool",
            name: "extendable",
            type: "bool"
        }],
        name: "SubscriptionEdited",
        type: "event"
    }, {
        anonymous: !1,
        inputs: [{
            indexed: !0,
            internalType: "uint256",
            name: "fromSubscriptionId",
            type: "uint256"
        }, {
            indexed: !0,
            internalType: "uint256",
            name: "toSubscriptionId",
            type: "uint256"
        }, {
            indexed: !0,
            internalType: "address",
            name: "user",
            type: "address"
        }, {
            indexed: !1,
            internalType: "address",
            name: "payableToken",
            type: "address"
        }, {
            indexed: !1,
            internalType: "uint32",
            name: "paymentPeriod",
            type: "uint32"
        }, {
            indexed: !1,
            internalType: "uint256",
            name: "paymentPeriodPrice",
            type: "uint256"
        }, {
            indexed: !1,
            internalType: "uint256",
            name: "compensation",
            type: "uint256"
        }, {
            indexed: !1,
            internalType: "uint256",
            name: "paidAmount",
            type: "uint256"
        }, {
            indexed: !1,
            internalType: "uint256",
            name: "setupPrice",
            type: "uint256"
        }, {
            indexed: !1,
            internalType: "uint256",
            name: "startedAt",
            type: "uint256"
        }, {
            indexed: !1,
            internalType: "uint256",
            name: "expiresAt",
            type: "uint256"
        }],
        name: "SubscriptionUpgraded",
        type: "event"
    }, {
        anonymous: !1,
        inputs: [{
            indexed: !1,
            internalType: "address",
            name: "treasury",
            type: "address"
        }],
        name: "TreasuryChanged",
        type: "event"
    }, {
        inputs: [],
        name: "DEFAULT_ADMIN_ROLE",
        outputs: [{
            internalType: "bytes32",
            name: "",
            type: "bytes32"
        }],
        stateMutability: "view",
        type: "function"
    }, {
        inputs: [],
        name: "DENOMINATOR",
        outputs: [{
            internalType: "uint256",
            name: "",
            type: "uint256"
        }],
        stateMutability: "view",
        type: "function"
    }, {
        inputs: [],
        name: "VERIFIER_ROLE",
        outputs: [{
            internalType: "bytes32",
            name: "",
            type: "bytes32"
        }],
        stateMutability: "view",
        type: "function"
    }, {
        inputs: [{
            internalType: "address",
            name: "user",
            type: "address"
        }, {
            internalType: "uint256",
            name: "subscriptionId",
            type: "uint256"
        }],
        name: "checkActiveUserSubscription",
        outputs: [{
            internalType: "bool",
            name: "",
            type: "bool"
        }],
        stateMutability: "view",
        type: "function"
    }, {
        inputs: [{
            internalType: "address",
            name: "user",
            type: "address"
        }, {
            internalType: "uint256[]",
            name: "subscriptionIds",
            type: "uint256[]"
        }],
        name: "checkActiveUserSubscriptions",
        outputs: [{
            internalType: "bool[]",
            name: "",
            type: "bool[]"
        }],
        stateMutability: "view",
        type: "function"
    }, {
        inputs: [{
            internalType: "address",
            name: "user",
            type: "address"
        }, {
            internalType: "uint256[]",
            name: "subscriptionIds",
            type: "uint256[]"
        }],
        name: "checkAnyActiveUserSubscriptions",
        outputs: [{
            internalType: "bool",
            name: "",
            type: "bool"
        }],
        stateMutability: "view",
        type: "function"
    }, {
        inputs: [],
        name: "checkReferralsSignatureEnabled",
        outputs: [{
            internalType: "bool",
            name: "",
            type: "bool"
        }],
        stateMutability: "view",
        type: "function"
    }, {
        inputs: [{
            internalType: "uint256",
            name: "subscriptionId",
            type: "uint256"
        }, {
            internalType: "address",
            name: "payableToken",
            type: "address"
        }, {
            internalType: "uint32",
            name: "paymentPeriod",
            type: "uint32"
        }, {
            internalType: "uint256",
            name: "setupPrice",
            type: "uint256"
        }, {
            internalType: "uint256",
            name: "paymentPeriodPrice",
            type: "uint256"
        }, {
            internalType: "bool",
            name: "isPaused",
            type: "bool"
        }, {
            internalType: "bool",
            name: "extendable",
            type: "bool"
        }],
        name: "createSubscription",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
    }, {
        inputs: [{
            internalType: "uint256",
            name: "subscriptionId",
            type: "uint256"
        }, {
            internalType: "uint32",
            name: "paymentPeriod",
            type: "uint32"
        }, {
            internalType: "uint256",
            name: "paymentPeriodPrice",
            type: "uint256"
        }, {
            internalType: "uint256",
            name: "setupPrice",
            type: "uint256"
        }, {
            internalType: "bool",
            name: "isPaused",
            type: "bool"
        }, {
            internalType: "bool",
            name: "extendable",
            type: "bool"
        }],
        name: "editSubscription",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
    }, {
        inputs: [],
        name: "eip712Domain",
        outputs: [{
            internalType: "bytes1",
            name: "fields",
            type: "bytes1"
        }, {
            internalType: "string",
            name: "name",
            type: "string"
        }, {
            internalType: "string",
            name: "version",
            type: "string"
        }, {
            internalType: "uint256",
            name: "chainId",
            type: "uint256"
        }, {
            internalType: "address",
            name: "verifyingContract",
            type: "address"
        }, {
            internalType: "bytes32",
            name: "salt",
            type: "bytes32"
        }, {
            internalType: "uint256[]",
            name: "extensions",
            type: "uint256[]"
        }],
        stateMutability: "view",
        type: "function"
    }, {
        inputs: [{
            internalType: "uint256",
            name: "subscriptionId",
            type: "uint256"
        }, {
            internalType: "uint32",
            name: "paymentPeriodTimes",
            type: "uint32"
        }, {
            internalType: "address[]",
            name: "referrals",
            type: "address[]"
        }, {
            internalType: "uint256",
            name: "signatureTimestamp",
            type: "uint256"
        }, {
            internalType: "bytes",
            name: "signature",
            type: "bytes"
        }],
        name: "extend",
        outputs: [],
        stateMutability: "payable",
        type: "function"
    }, {
        inputs: [],
        name: "getReferralShares",
        outputs: [{
            internalType: "uint256[]",
            name: "",
            type: "uint256[]"
        }],
        stateMutability: "view",
        type: "function"
    }, {
        inputs: [{
            internalType: "bytes32",
            name: "role",
            type: "bytes32"
        }],
        name: "getRoleAdmin",
        outputs: [{
            internalType: "bytes32",
            name: "",
            type: "bytes32"
        }],
        stateMutability: "view",
        type: "function"
    }, {
        inputs: [{
            internalType: "bytes32",
            name: "role",
            type: "bytes32"
        }, {
            internalType: "uint256",
            name: "index",
            type: "uint256"
        }],
        name: "getRoleMember",
        outputs: [{
            internalType: "address",
            name: "",
            type: "address"
        }],
        stateMutability: "view",
        type: "function"
    }, {
        inputs: [{
            internalType: "bytes32",
            name: "role",
            type: "bytes32"
        }],
        name: "getRoleMemberCount",
        outputs: [{
            internalType: "uint256",
            name: "",
            type: "uint256"
        }],
        stateMutability: "view",
        type: "function"
    }, {
        inputs: [{
            internalType: "address",
            name: "user",
            type: "address"
        }, {
            internalType: "uint256",
            name: "subscriptionId",
            type: "uint256"
        }],
        name: "getUserSubscription",
        outputs: [{
            components: [{
                internalType: "uint32",
                name: "startedAt",
                type: "uint32"
            }, {
                internalType: "uint32",
                name: "expiresAt",
                type: "uint32"
            }, {
                internalType: "uint128",
                name: "periodsPayment",
                type: "uint128"
            }],
            internalType: "struct AIXPayments.UserSubscription",
            name: "",
            type: "tuple"
        }],
        stateMutability: "view",
        type: "function"
    }, {
        inputs: [{
            internalType: "address",
            name: "user",
            type: "address"
        }, {
            internalType: "uint256[]",
            name: "subscriptionIds",
            type: "uint256[]"
        }],
        name: "getUserSubscriptions",
        outputs: [{
            components: [{
                internalType: "uint32",
                name: "startedAt",
                type: "uint32"
            }, {
                internalType: "uint32",
                name: "expiresAt",
                type: "uint32"
            }, {
                internalType: "uint128",
                name: "periodsPayment",
                type: "uint128"
            }],
            internalType: "struct AIXPayments.UserSubscription[]",
            name: "",
            type: "tuple[]"
        }],
        stateMutability: "view",
        type: "function"
    }, {
        inputs: [{
            internalType: "bytes32",
            name: "role",
            type: "bytes32"
        }, {
            internalType: "address",
            name: "account",
            type: "address"
        }],
        name: "grantRole",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
    }, {
        inputs: [{
            internalType: "bytes32",
            name: "role",
            type: "bytes32"
        }, {
            internalType: "address",
            name: "account",
            type: "address"
        }],
        name: "hasRole",
        outputs: [{
            internalType: "bool",
            name: "",
            type: "bool"
        }],
        stateMutability: "view",
        type: "function"
    }, {
        inputs: [{
            internalType: "address",
            name: "_treasury",
            type: "address"
        }],
        name: "initialize",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
    }, {
        inputs: [{
            internalType: "uint256",
            name: "subscriptionId",
            type: "uint256"
        }, {
            internalType: "uint32",
            name: "paymentPeriodTimes",
            type: "uint32"
        }, {
            internalType: "address[]",
            name: "referrals",
            type: "address[]"
        }, {
            internalType: "uint256",
            name: "signatureTimestamp",
            type: "uint256"
        }, {
            internalType: "bytes",
            name: "signature",
            type: "bytes"
        }],
        name: "pay",
        outputs: [],
        stateMutability: "payable",
        type: "function"
    }, {
        inputs: [{
            internalType: "bytes32",
            name: "role",
            type: "bytes32"
        }, {
            internalType: "address",
            name: "account",
            type: "address"
        }],
        name: "renounceRole",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
    }, {
        inputs: [{
            internalType: "bytes32",
            name: "role",
            type: "bytes32"
        }, {
            internalType: "address",
            name: "account",
            type: "address"
        }],
        name: "revokeRole",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
    }, {
        inputs: [{
            internalType: "bool",
            name: "enabled",
            type: "bool"
        }],
        name: "setCheckReferralsSignatureEnabled",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
    }, {
        inputs: [{
            internalType: "uint256[]",
            name: "shares",
            type: "uint256[]"
        }],
        name: "setReferralShares",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
    }, {
        inputs: [{
            internalType: "address",
            name: "_treasury",
            type: "address"
        }],
        name: "setTreasury",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
    }, {
        inputs: [{
            internalType: "uint256",
            name: "",
            type: "uint256"
        }],
        name: "subscriptions",
        outputs: [{
            internalType: "address",
            name: "payableToken",
            type: "address"
        }, {
            internalType: "uint32",
            name: "paymentPeriod",
            type: "uint32"
        }, {
            internalType: "bool",
            name: "isPaused",
            type: "bool"
        }, {
            internalType: "bool",
            name: "extendable",
            type: "bool"
        }, {
            internalType: "uint128",
            name: "setupPrice",
            type: "uint128"
        }, {
            internalType: "uint128",
            name: "paymentPeriodPrice",
            type: "uint128"
        }],
        stateMutability: "view",
        type: "function"
    }, {
        inputs: [{
            internalType: "bytes4",
            name: "interfaceId",
            type: "bytes4"
        }],
        name: "supportsInterface",
        outputs: [{
            internalType: "bool",
            name: "",
            type: "bool"
        }],
        stateMutability: "view",
        type: "function"
    }, {
        inputs: [],
        name: "treasury",
        outputs: [{
            internalType: "address",
            name: "",
            type: "address"
        }],
        stateMutability: "view",
        type: "function"
    }, {
        inputs: [{
            internalType: "uint256",
            name: "fromSubscriptionId",
            type: "uint256"
        }, {
            internalType: "uint256",
            name: "toSubscriptionId",
            type: "uint256"
        }, {
            internalType: "uint32",
            name: "paymentPeriodTimes",
            type: "uint32"
        }, {
            internalType: "address[]",
            name: "referrals",
            type: "address[]"
        }, {
            internalType: "uint256",
            name: "signatureTimestamp",
            type: "uint256"
        }, {
            internalType: "bytes",
            name: "signature",
            type: "bytes"
        }],
        name: "upgrade",
        outputs: [],
        stateMutability: "payable",
        type: "function"
    }, {
        inputs: [{
            internalType: "uint256",
            name: "signatureTimestamp",
            type: "uint256"
        }, {
            internalType: "address",
            name: "user",
            type: "address"
        }, {
            internalType: "address[]",
            name: "referrals",
            type: "address[]"
        }, {
            internalType: "bytes",
            name: "signature",
            type: "bytes"
        }],
        name: "verifySignature",
        outputs: [],
        stateMutability: "view",
        type: "function"
    }],
    Zst = [{
        anonymous: !1,
        inputs: [{
            indexed: !0,
            internalType: "address",
            name: "owner",
            type: "address"
        }, {
            indexed: !0,
            internalType: "address",
            name: "spender",
            type: "address"
        }, {
            indexed: !1,
            internalType: "uint256",
            name: "value",
            type: "uint256"
        }],
        name: "Approval",
        type: "event"
    }, {
        anonymous: !1,
        inputs: [{
            indexed: !0,
            internalType: "address",
            name: "sender",
            type: "address"
        }, {
            indexed: !1,
            internalType: "uint256",
            name: "amount0",
            type: "uint256"
        }, {
            indexed: !1,
            internalType: "uint256",
            name: "amount1",
            type: "uint256"
        }, {
            indexed: !0,
            internalType: "address",
            name: "to",
            type: "address"
        }],
        name: "Burn",
        type: "event"
    }, {
        anonymous: !1,
        inputs: [{
            indexed: !0,
            internalType: "address",
            name: "sender",
            type: "address"
        }, {
            indexed: !1,
            internalType: "uint256",
            name: "amount0",
            type: "uint256"
        }, {
            indexed: !1,
            internalType: "uint256",
            name: "amount1",
            type: "uint256"
        }],
        name: "Mint",
        type: "event"
    }, {
        anonymous: !1,
        inputs: [{
            indexed: !0,
            internalType: "address",
            name: "sender",
            type: "address"
        }, {
            indexed: !1,
            internalType: "uint256",
            name: "amount0In",
            type: "uint256"
        }, {
            indexed: !1,
            internalType: "uint256",
            name: "amount1In",
            type: "uint256"
        }, {
            indexed: !1,
            internalType: "uint256",
            name: "amount0Out",
            type: "uint256"
        }, {
            indexed: !1,
            internalType: "uint256",
            name: "amount1Out",
            type: "uint256"
        }, {
            indexed: !0,
            internalType: "address",
            name: "to",
            type: "address"
        }],
        name: "Swap",
        type: "event"
    }, {
        anonymous: !1,
        inputs: [{
            indexed: !1,
            internalType: "uint112",
            name: "reserve0",
            type: "uint112"
        }, {
            indexed: !1,
            internalType: "uint112",
            name: "reserve1",
            type: "uint112"
        }],
        name: "Sync",
        type: "event"
    }, {
        anonymous: !1,
        inputs: [{
            indexed: !0,
            internalType: "address",
            name: "from",
            type: "address"
        }, {
            indexed: !0,
            internalType: "address",
            name: "to",
            type: "address"
        }, {
            indexed: !1,
            internalType: "uint256",
            name: "value",
            type: "uint256"
        }],
        name: "Transfer",
        type: "event"
    }, {
        inputs: [],
        name: "DOMAIN_SEPARATOR",
        outputs: [{
            internalType: "bytes32",
            name: "",
            type: "bytes32"
        }],
        stateMutability: "view",
        type: "function"
    }, {
        inputs: [],
        name: "MINIMUM_LIQUIDITY",
        outputs: [{
            internalType: "uint256",
            name: "",
            type: "uint256"
        }],
        stateMutability: "pure",
        type: "function"
    }, {
        inputs: [],
        name: "PERMIT_TYPEHASH",
        outputs: [{
            internalType: "bytes32",
            name: "",
            type: "bytes32"
        }],
        stateMutability: "pure",
        type: "function"
    }, {
        inputs: [{
            internalType: "address",
            name: "owner",
            type: "address"
        }, {
            internalType: "address",
            name: "spender",
            type: "address"
        }],
        name: "allowance",
        outputs: [{
            internalType: "uint256",
            name: "",
            type: "uint256"
        }],
        stateMutability: "view",
        type: "function"
    }, {
        inputs: [{
            internalType: "address",
            name: "spender",
            type: "address"
        }, {
            internalType: "uint256",
            name: "value",
            type: "uint256"
        }],
        name: "approve",
        outputs: [{
            internalType: "bool",
            name: "",
            type: "bool"
        }],
        stateMutability: "nonpayable",
        type: "function"
    }, {
        inputs: [{
            internalType: "address",
            name: "owner",
            type: "address"
        }],
        name: "balanceOf",
        outputs: [{
            internalType: "uint256",
            name: "",
            type: "uint256"
        }],
        stateMutability: "view",
        type: "function"
    }, {
        inputs: [{
            internalType: "address",
            name: "to",
            type: "address"
        }],
        name: "burn",
        outputs: [{
            internalType: "uint256",
            name: "amount0",
            type: "uint256"
        }, {
            internalType: "uint256",
            name: "amount1",
            type: "uint256"
        }],
        stateMutability: "nonpayable",
        type: "function"
    }, {
        inputs: [],
        name: "decimals",
        outputs: [{
            internalType: "uint8",
            name: "",
            type: "uint8"
        }],
        stateMutability: "pure",
        type: "function"
    }, {
        inputs: [],
        name: "factory",
        outputs: [{
            internalType: "address",
            name: "",
            type: "address"
        }],
        stateMutability: "view",
        type: "function"
    }, {
        inputs: [],
        name: "getReserves",
        outputs: [{
            internalType: "uint112",
            name: "reserve0",
            type: "uint112"
        }, {
            internalType: "uint112",
            name: "reserve1",
            type: "uint112"
        }, {
            internalType: "uint32",
            name: "blockTimestampLast",
            type: "uint32"
        }],
        stateMutability: "view",
        type: "function"
    }, {
        inputs: [{
            internalType: "address",
            name: "",
            type: "address"
        }, {
            internalType: "address",
            name: "",
            type: "address"
        }],
        name: "initialize",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
    }, {
        inputs: [],
        name: "kLast",
        outputs: [{
            internalType: "uint256",
            name: "",
            type: "uint256"
        }],
        stateMutability: "view",
        type: "function"
    }, {
        inputs: [{
            internalType: "address",
            name: "to",
            type: "address"
        }],
        name: "mint",
        outputs: [{
            internalType: "uint256",
            name: "liquidity",
            type: "uint256"
        }],
        stateMutability: "nonpayable",
        type: "function"
    }, {
        inputs: [],
        name: "name",
        outputs: [{
            internalType: "string",
            name: "",
            type: "string"
        }],
        stateMutability: "pure",
        type: "function"
    }, {
        inputs: [{
            internalType: "address",
            name: "owner",
            type: "address"
        }],
        name: "nonces",
        outputs: [{
            internalType: "uint256",
            name: "",
            type: "uint256"
        }],
        stateMutability: "view",
        type: "function"
    }, {
        inputs: [{
            internalType: "address",
            name: "owner",
            type: "address"
        }, {
            internalType: "address",
            name: "spender",
            type: "address"
        }, {
            internalType: "uint256",
            name: "value",
            type: "uint256"
        }, {
            internalType: "uint256",
            name: "deadline",
            type: "uint256"
        }, {
            internalType: "uint8",
            name: "v",
            type: "uint8"
        }, {
            internalType: "bytes32",
            name: "r",
            type: "bytes32"
        }, {
            internalType: "bytes32",
            name: "s",
            type: "bytes32"
        }],
        name: "permit",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
    }, {
        inputs: [],
        name: "price0CumulativeLast",
        outputs: [{
            internalType: "uint256",
            name: "",
            type: "uint256"
        }],
        stateMutability: "view",
        type: "function"
    }, {
        inputs: [],
        name: "price1CumulativeLast",
        outputs: [{
            internalType: "uint256",
            name: "",
            type: "uint256"
        }],
        stateMutability: "view",
        type: "function"
    }, {
        inputs: [{
            internalType: "address",
            name: "to",
            type: "address"
        }],
        name: "skim",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
    }, {
        inputs: [{
            internalType: "uint256",
            name: "amount0Out",
            type: "uint256"
        }, {
            internalType: "uint256",
            name: "amount1Out",
            type: "uint256"
        }, {
            internalType: "address",
            name: "to",
            type: "address"
        }, {
            internalType: "bytes",
            name: "data",
            type: "bytes"
        }],
        name: "swap",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
    }, {
        inputs: [],
        name: "symbol",
        outputs: [{
            internalType: "string",
            name: "",
            type: "string"
        }],
        stateMutability: "pure",
        type: "function"
    }, {
        inputs: [],
        name: "sync",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
    }, {
        inputs: [],
        name: "token0",
        outputs: [{
            internalType: "address",
            name: "",
            type: "address"
        }],
        stateMutability: "view",
        type: "function"
    }, {
        inputs: [],
        name: "token1",
        outputs: [{
            internalType: "address",
            name: "",
            type: "address"
        }],
        stateMutability: "view",
        type: "function"
    }, {
        inputs: [],
        name: "totalSupply",
        outputs: [{
            internalType: "uint256",
            name: "",
            type: "uint256"
        }],
        stateMutability: "view",
        type: "function"
    }, {
        inputs: [{
            internalType: "address",
            name: "to",
            type: "address"
        }, {
            internalType: "uint256",
            name: "value",
            type: "uint256"
        }],
        name: "transfer",
        outputs: [{
            internalType: "bool",
            name: "",
            type: "bool"
        }],
        stateMutability: "nonpayable",
        type: "function"
    }, {
        inputs: [{
            internalType: "address",
            name: "from",
            type: "address"
        }, {
            internalType: "address",
            name: "to",
            type: "address"
        }, {
            internalType: "uint256",
            name: "value",
            type: "uint256"
        }],
        name: "transferFrom",
        outputs: [{
            internalType: "bool",
            name: "",
            type: "bool"
        }],
        stateMutability: "nonpayable",
        type: "function"
    }],
    Qst = [{
        inputs: [{
            internalType: "address",
            name: "_factoryV2",
            type: "address"
        }],
        stateMutability: "nonpayable",
        type: "constructor"
    }, {
        inputs: [],
        name: "PairLookupFailed",
        type: "error"
    }, {
        inputs: [],
        name: "SameToken",
        type: "error"
    }, {
        inputs: [{
            internalType: "address[]",
            name: "tokens",
            type: "address[]"
        }, {
            internalType: "address",
            name: "baseToken",
            type: "address"
        }, {
            internalType: "uint256",
            name: "amountToBorrow",
            type: "uint256"
        }],
        name: "batchValidate",
        outputs: [{
            components: [{
                internalType: "uint256",
                name: "buyFeeBps",
                type: "uint256"
            }, {
                internalType: "uint256",
                name: "sellFeeBps",
                type: "uint256"
            }],
            internalType: "struct TokenFees[]",
            name: "fotResults",
            type: "tuple[]"
        }],
        stateMutability: "nonpayable",
        type: "function"
    }, {
        inputs: [{
            internalType: "address",
            name: "",
            type: "address"
        }, {
            internalType: "uint256",
            name: "amount0",
            type: "uint256"
        }, {
            internalType: "uint256",
            name: "",
            type: "uint256"
        }, {
            internalType: "bytes",
            name: "data",
            type: "bytes"
        }],
        name: "uniswapV2Call",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
    }, {
        inputs: [{
            internalType: "address",
            name: "token",
            type: "address"
        }, {
            internalType: "address",
            name: "baseToken",
            type: "address"
        }, {
            internalType: "uint256",
            name: "amountToBorrow",
            type: "uint256"
        }],
        name: "validate",
        outputs: [{
            components: [{
                internalType: "uint256",
                name: "buyFeeBps",
                type: "uint256"
            }, {
                internalType: "uint256",
                name: "sellFeeBps",
                type: "uint256"
            }],
            internalType: "struct TokenFees",
            name: "fotResult",
            type: "tuple"
        }],
        stateMutability: "nonpayable",
        type: "function"
    }],
    FQ = [{
        inputs: [{
            internalType: "address",
            name: "_AIX",
            type: "address"
        }, {
            internalType: "address",
            name: "_AIXRevenueSharing",
            type: "address"
        }, {
            internalType: "uint256",
            name: "_minimumAIX",
            type: "uint256"
        }, {
            internalType: "address payable",
            name: "_treasury",
            type: "address"
        }],
        stateMutability: "nonpayable",
        type: "constructor"
    }, {
        anonymous: !1,
        inputs: [{
            indexed: !0,
            internalType: "address",
            name: "buyer",
            type: "address"
        }, {
            indexed: !1,
            internalType: "uint256",
            name: "ethAmount",
            type: "uint256"
        }, {
            indexed: !1,
            internalType: "uint256",
            name: "power",
            type: "uint256"
        }, {
            indexed: !1,
            internalType: "uint256",
            name: "newAccountPower",
            type: "uint256"
        }, {
            indexed: !1,
            internalType: "uint256",
            name: "totalPower",
            type: "uint256"
        }],
        name: "Bought",
        type: "event"
    }, {
        anonymous: !1,
        inputs: [{
            indexed: !1,
            internalType: "uint256",
            name: "newMinimumAIX",
            type: "uint256"
        }],
        name: "MinimumAIXChanged",
        type: "event"
    }, {
        anonymous: !1,
        inputs: [{
            indexed: !0,
            internalType: "address",
            name: "previousOwner",
            type: "address"
        }, {
            indexed: !0,
            internalType: "address",
            name: "newOwner",
            type: "address"
        }],
        name: "OwnershipTransferred",
        type: "event"
    }, {
        anonymous: !1,
        inputs: [{
            indexed: !1,
            internalType: "address",
            name: "account",
            type: "address"
        }],
        name: "Paused",
        type: "event"
    }, {
        anonymous: !1,
        inputs: [{
            indexed: !0,
            internalType: "address",
            name: "newTreasury",
            type: "address"
        }],
        name: "TreasuryChanged",
        type: "event"
    }, {
        anonymous: !1,
        inputs: [{
            indexed: !1,
            internalType: "address",
            name: "account",
            type: "address"
        }],
        name: "Unpaused",
        type: "event"
    }, {
        inputs: [],
        name: "AIX",
        outputs: [{
            internalType: "contract IERC20",
            name: "",
            type: "address"
        }],
        stateMutability: "view",
        type: "function"
    }, {
        inputs: [],
        name: "AIXRevenueSharing",
        outputs: [{
            internalType: "contract IAIXRevenueSharing",
            name: "",
            type: "address"
        }],
        stateMutability: "view",
        type: "function"
    }, {
        inputs: [{
            internalType: "address",
            name: "",
            type: "address"
        }],
        name: "accountPower",
        outputs: [{
            internalType: "uint256",
            name: "",
            type: "uint256"
        }],
        stateMutability: "view",
        type: "function"
    }, {
        inputs: [],
        name: "buy",
        outputs: [],
        stateMutability: "payable",
        type: "function"
    }, {
        inputs: [{
            internalType: "uint256",
            name: "ethValue",
            type: "uint256"
        }, {
            internalType: "uint256",
            name: "aixBalance",
            type: "uint256"
        }, {
            internalType: "uint256",
            name: "aixStaked",
            type: "uint256"
        }],
        name: "calculatePower",
        outputs: [{
            internalType: "uint256",
            name: "power",
            type: "uint256"
        }],
        stateMutability: "view",
        type: "function"
    }, {
        inputs: [],
        name: "minimumAIX",
        outputs: [{
            internalType: "uint256",
            name: "",
            type: "uint256"
        }],
        stateMutability: "view",
        type: "function"
    }, {
        inputs: [],
        name: "owner",
        outputs: [{
            internalType: "address",
            name: "",
            type: "address"
        }],
        stateMutability: "view",
        type: "function"
    }, {
        inputs: [],
        name: "pause",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
    }, {
        inputs: [],
        name: "paused",
        outputs: [{
            internalType: "bool",
            name: "",
            type: "bool"
        }],
        stateMutability: "view",
        type: "function"
    }, {
        inputs: [],
        name: "renounceOwnership",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
    }, {
        inputs: [{
            internalType: "uint256",
            name: "newMinimumAIX",
            type: "uint256"
        }],
        name: "setMinimumAIX",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
    }, {
        inputs: [{
            internalType: "address payable",
            name: "newTreasury",
            type: "address"
        }],
        name: "setTreasury",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
    }, {
        inputs: [],
        name: "totalPower",
        outputs: [{
            internalType: "uint256",
            name: "",
            type: "uint256"
        }],
        stateMutability: "view",
        type: "function"
    }, {
        inputs: [{
            internalType: "address",
            name: "newOwner",
            type: "address"
        }],
        name: "transferOwnership",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
    }, {
        inputs: [],
        name: "treasury",
        outputs: [{
            internalType: "address payable",
            name: "",
            type: "address"
        }],
        stateMutability: "view",
        type: "function"
    }, {
        inputs: [],
        name: "unpause",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
    }],
    Jst = [{
        inputs: [{
            internalType: "address",
            name: "_factory",
            type: "address"
        }, {
            internalType: "address",
            name: "_WETH",
            type: "address"
        }],
        stateMutability: "nonpayable",
        type: "constructor"
    }, {
        inputs: [],
        name: "WETH",
        outputs: [{
            internalType: "address",
            name: "",
            type: "address"
        }],
        stateMutability: "view",
        type: "function"
    }, {
        inputs: [{
            internalType: "address",
            name: "tokenA",
            type: "address"
        }, {
            internalType: "address",
            name: "tokenB",
            type: "address"
        }, {
            internalType: "uint256",
            name: "amountADesired",
            type: "uint256"
        }, {
            internalType: "uint256",
            name: "amountBDesired",
            type: "uint256"
        }, {
            internalType: "uint256",
            name: "amountAMin",
            type: "uint256"
        }, {
            internalType: "uint256",
            name: "amountBMin",
            type: "uint256"
        }, {
            internalType: "address",
            name: "to",
            type: "address"
        }, {
            internalType: "uint256",
            name: "deadline",
            type: "uint256"
        }],
        name: "addLiquidity",
        outputs: [{
            internalType: "uint256",
            name: "amountA",
            type: "uint256"
        }, {
            internalType: "uint256",
            name: "amountB",
            type: "uint256"
        }, {
            internalType: "uint256",
            name: "liquidity",
            type: "uint256"
        }],
        stateMutability: "nonpayable",
        type: "function"
    }, {
        inputs: [{
            internalType: "address",
            name: "token",
            type: "address"
        }, {
            internalType: "uint256",
            name: "amountTokenDesired",
            type: "uint256"
        }, {
            internalType: "uint256",
            name: "amountTokenMin",
            type: "uint256"
        }, {
            internalType: "uint256",
            name: "amountETHMin",
            type: "uint256"
        }, {
            internalType: "address",
            name: "to",
            type: "address"
        }, {
            internalType: "uint256",
            name: "deadline",
            type: "uint256"
        }],
        name: "addLiquidityETH",
        outputs: [{
            internalType: "uint256",
            name: "amountToken",
            type: "uint256"
        }, {
            internalType: "uint256",
            name: "amountETH",
            type: "uint256"
        }, {
            internalType: "uint256",
            name: "liquidity",
            type: "uint256"
        }],
        stateMutability: "payable",
        type: "function"
    }, {
        inputs: [],
        name: "factory",
        outputs: [{
            internalType: "address",
            name: "",
            type: "address"
        }],
        stateMutability: "view",
        type: "function"
    }, {
        inputs: [{
            internalType: "uint256",
            name: "amountOut",
            type: "uint256"
        }, {
            internalType: "uint256",
            name: "reserveIn",
            type: "uint256"
        }, {
            internalType: "uint256",
            name: "reserveOut",
            type: "uint256"
        }],
        name: "getAmountIn",
        outputs: [{
            internalType: "uint256",
            name: "amountIn",
            type: "uint256"
        }],
        stateMutability: "pure",
        type: "function"
    }, {
        inputs: [{
            internalType: "uint256",
            name: "amountIn",
            type: "uint256"
        }, {
            internalType: "uint256",
            name: "reserveIn",
            type: "uint256"
        }, {
            internalType: "uint256",
            name: "reserveOut",
            type: "uint256"
        }],
        name: "getAmountOut",
        outputs: [{
            internalType: "uint256",
            name: "amountOut",
            type: "uint256"
        }],
        stateMutability: "pure",
        type: "function"
    }, {
        inputs: [{
            internalType: "uint256",
            name: "amountOut",
            type: "uint256"
        }, {
            internalType: "address[]",
            name: "path",
            type: "address[]"
        }],
        name: "getAmountsIn",
        outputs: [{
            internalType: "uint256[]",
            name: "amounts",
            type: "uint256[]"
        }],
        stateMutability: "view",
        type: "function"
    }, {
        inputs: [{
            internalType: "uint256",
            name: "amountIn",
            type: "uint256"
        }, {
            internalType: "address[]",
            name: "path",
            type: "address[]"
        }],
        name: "getAmountsOut",
        outputs: [{
            internalType: "uint256[]",
            name: "amounts",
            type: "uint256[]"
        }],
        stateMutability: "view",
        type: "function"
    }, {
        inputs: [{
            internalType: "uint256",
            name: "amountA",
            type: "uint256"
        }, {
            internalType: "uint256",
            name: "reserveA",
            type: "uint256"
        }, {
            internalType: "uint256",
            name: "reserveB",
            type: "uint256"
        }],
        name: "quote",
        outputs: [{
            internalType: "uint256",
            name: "amountB",
            type: "uint256"
        }],
        stateMutability: "pure",
        type: "function"
    }, {
        inputs: [{
            internalType: "address",
            name: "tokenA",
            type: "address"
        }, {
            internalType: "address",
            name: "tokenB",
            type: "address"
        }, {
            internalType: "uint256",
            name: "liquidity",
            type: "uint256"
        }, {
            internalType: "uint256",
            name: "amountAMin",
            type: "uint256"
        }, {
            internalType: "uint256",
            name: "amountBMin",
            type: "uint256"
        }, {
            internalType: "address",
            name: "to",
            type: "address"
        }, {
            internalType: "uint256",
            name: "deadline",
            type: "uint256"
        }],
        name: "removeLiquidity",
        outputs: [{
            internalType: "uint256",
            name: "amountA",
            type: "uint256"
        }, {
            internalType: "uint256",
            name: "amountB",
            type: "uint256"
        }],
        stateMutability: "nonpayable",
        type: "function"
    }, {
        inputs: [{
            internalType: "address",
            name: "token",
            type: "address"
        }, {
            internalType: "uint256",
            name: "liquidity",
            type: "uint256"
        }, {
            internalType: "uint256",
            name: "amountTokenMin",
            type: "uint256"
        }, {
            internalType: "uint256",
            name: "amountETHMin",
            type: "uint256"
        }, {
            internalType: "address",
            name: "to",
            type: "address"
        }, {
            internalType: "uint256",
            name: "deadline",
            type: "uint256"
        }],
        name: "removeLiquidityETH",
        outputs: [{
            internalType: "uint256",
            name: "amountToken",
            type: "uint256"
        }, {
            internalType: "uint256",
            name: "amountETH",
            type: "uint256"
        }],
        stateMutability: "nonpayable",
        type: "function"
    }, {
        inputs: [{
            internalType: "address",
            name: "token",
            type: "address"
        }, {
            internalType: "uint256",
            name: "liquidity",
            type: "uint256"
        }, {
            internalType: "uint256",
            name: "amountTokenMin",
            type: "uint256"
        }, {
            internalType: "uint256",
            name: "amountETHMin",
            type: "uint256"
        }, {
            internalType: "address",
            name: "to",
            type: "address"
        }, {
            internalType: "uint256",
            name: "deadline",
            type: "uint256"
        }],
        name: "removeLiquidityETHSupportingFeeOnTransferTokens",
        outputs: [{
            internalType: "uint256",
            name: "amountETH",
            type: "uint256"
        }],
        stateMutability: "nonpayable",
        type: "function"
    }, {
        inputs: [{
            internalType: "address",
            name: "token",
            type: "address"
        }, {
            internalType: "uint256",
            name: "liquidity",
            type: "uint256"
        }, {
            internalType: "uint256",
            name: "amountTokenMin",
            type: "uint256"
        }, {
            internalType: "uint256",
            name: "amountETHMin",
            type: "uint256"
        }, {
            internalType: "address",
            name: "to",
            type: "address"
        }, {
            internalType: "uint256",
            name: "deadline",
            type: "uint256"
        }, {
            internalType: "bool",
            name: "approveMax",
            type: "bool"
        }, {
            internalType: "uint8",
            name: "v",
            type: "uint8"
        }, {
            internalType: "bytes32",
            name: "r",
            type: "bytes32"
        }, {
            internalType: "bytes32",
            name: "s",
            type: "bytes32"
        }],
        name: "removeLiquidityETHWithPermit",
        outputs: [{
            internalType: "uint256",
            name: "amountToken",
            type: "uint256"
        }, {
            internalType: "uint256",
            name: "amountETH",
            type: "uint256"
        }],
        stateMutability: "nonpayable",
        type: "function"
    }, {
        inputs: [{
            internalType: "address",
            name: "token",
            type: "address"
        }, {
            internalType: "uint256",
            name: "liquidity",
            type: "uint256"
        }, {
            internalType: "uint256",
            name: "amountTokenMin",
            type: "uint256"
        }, {
            internalType: "uint256",
            name: "amountETHMin",
            type: "uint256"
        }, {
            internalType: "address",
            name: "to",
            type: "address"
        }, {
            internalType: "uint256",
            name: "deadline",
            type: "uint256"
        }, {
            internalType: "bool",
            name: "approveMax",
            type: "bool"
        }, {
            internalType: "uint8",
            name: "v",
            type: "uint8"
        }, {
            internalType: "bytes32",
            name: "r",
            type: "bytes32"
        }, {
            internalType: "bytes32",
            name: "s",
            type: "bytes32"
        }],
        name: "removeLiquidityETHWithPermitSupportingFeeOnTransferTokens",
        outputs: [{
            internalType: "uint256",
            name: "amountETH",
            type: "uint256"
        }],
        stateMutability: "nonpayable",
        type: "function"
    }, {
        inputs: [{
            internalType: "address",
            name: "tokenA",
            type: "address"
        }, {
            internalType: "address",
            name: "tokenB",
            type: "address"
        }, {
            internalType: "uint256",
            name: "liquidity",
            type: "uint256"
        }, {
            internalType: "uint256",
            name: "amountAMin",
            type: "uint256"
        }, {
            internalType: "uint256",
            name: "amountBMin",
            type: "uint256"
        }, {
            internalType: "address",
            name: "to",
            type: "address"
        }, {
            internalType: "uint256",
            name: "deadline",
            type: "uint256"
        }, {
            internalType: "bool",
            name: "approveMax",
            type: "bool"
        }, {
            internalType: "uint8",
            name: "v",
            type: "uint8"
        }, {
            internalType: "bytes32",
            name: "r",
            type: "bytes32"
        }, {
            internalType: "bytes32",
            name: "s",
            type: "bytes32"
        }],
        name: "removeLiquidityWithPermit",
        outputs: [{
            internalType: "uint256",
            name: "amountA",
            type: "uint256"
        }, {
            internalType: "uint256",
            name: "amountB",
            type: "uint256"
        }],
        stateMutability: "nonpayable",
        type: "function"
    }, {
        inputs: [{
            internalType: "uint256",
            name: "amountOut",
            type: "uint256"
        }, {
            internalType: "address[]",
            name: "path",
            type: "address[]"
        }, {
            internalType: "address",
            name: "to",
            type: "address"
        }, {
            internalType: "uint256",
            name: "deadline",
            type: "uint256"
        }],
        name: "swapETHForExactTokens",
        outputs: [{
            internalType: "uint256[]",
            name: "amounts",
            type: "uint256[]"
        }],
        stateMutability: "payable",
        type: "function"
    }, {
        inputs: [{
            internalType: "uint256",
            name: "amountOutMin",
            type: "uint256"
        }, {
            internalType: "address[]",
            name: "path",
            type: "address[]"
        }, {
            internalType: "address",
            name: "to",
            type: "address"
        }, {
            internalType: "uint256",
            name: "deadline",
            type: "uint256"
        }],
        name: "swapExactETHForTokens",
        outputs: [{
            internalType: "uint256[]",
            name: "amounts",
            type: "uint256[]"
        }],
        stateMutability: "payable",
        type: "function"
    }, {
        inputs: [{
            internalType: "uint256",
            name: "amountOutMin",
            type: "uint256"
        }, {
            internalType: "address[]",
            name: "path",
            type: "address[]"
        }, {
            internalType: "address",
            name: "to",
            type: "address"
        }, {
            internalType: "uint256",
            name: "deadline",
            type: "uint256"
        }],
        name: "swapExactETHForTokensSupportingFeeOnTransferTokens",
        outputs: [],
        stateMutability: "payable",
        type: "function"
    }, {
        inputs: [{
            internalType: "uint256",
            name: "amountIn",
            type: "uint256"
        }, {
            internalType: "uint256",
            name: "amountOutMin",
            type: "uint256"
        }, {
            internalType: "address[]",
            name: "path",
            type: "address[]"
        }, {
            internalType: "address",
            name: "to",
            type: "address"
        }, {
            internalType: "uint256",
            name: "deadline",
            type: "uint256"
        }],
        name: "swapExactTokensForETH",
        outputs: [{
            internalType: "uint256[]",
            name: "amounts",
            type: "uint256[]"
        }],
        stateMutability: "nonpayable",
        type: "function"
    }, {
        inputs: [{
            internalType: "uint256",
            name: "amountIn",
            type: "uint256"
        }, {
            internalType: "uint256",
            name: "amountOutMin",
            type: "uint256"
        }, {
            internalType: "address[]",
            name: "path",
            type: "address[]"
        }, {
            internalType: "address",
            name: "to",
            type: "address"
        }, {
            internalType: "uint256",
            name: "deadline",
            type: "uint256"
        }],
        name: "swapExactTokensForETHSupportingFeeOnTransferTokens",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
    }, {
        inputs: [{
            internalType: "uint256",
            name: "amountIn",
            type: "uint256"
        }, {
            internalType: "uint256",
            name: "amountOutMin",
            type: "uint256"
        }, {
            internalType: "address[]",
            name: "path",
            type: "address[]"
        }, {
            internalType: "address",
            name: "to",
            type: "address"
        }, {
            internalType: "uint256",
            name: "deadline",
            type: "uint256"
        }],
        name: "swapExactTokensForTokens",
        outputs: [{
            internalType: "uint256[]",
            name: "amounts",
            type: "uint256[]"
        }],
        stateMutability: "nonpayable",
        type: "function"
    }, {
        inputs: [{
            internalType: "uint256",
            name: "amountIn",
            type: "uint256"
        }, {
            internalType: "uint256",
            name: "amountOutMin",
            type: "uint256"
        }, {
            internalType: "address[]",
            name: "path",
            type: "address[]"
        }, {
            internalType: "address",
            name: "to",
            type: "address"
        }, {
            internalType: "uint256",
            name: "deadline",
            type: "uint256"
        }],
        name: "swapExactTokensForTokensSupportingFeeOnTransferTokens",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
    }, {
        inputs: [{
            internalType: "uint256",
            name: "amountOut",
            type: "uint256"
        }, {
            internalType: "uint256",
            name: "amountInMax",
            type: "uint256"
        }, {
            internalType: "address[]",
            name: "path",
            type: "address[]"
        }, {
            internalType: "address",
            name: "to",
            type: "address"
        }, {
            internalType: "uint256",
            name: "deadline",
            type: "uint256"
        }],
        name: "swapTokensForExactETH",
        outputs: [{
            internalType: "uint256[]",
            name: "amounts",
            type: "uint256[]"
        }],
        stateMutability: "nonpayable",
        type: "function"
    }, {
        inputs: [{
            internalType: "uint256",
            name: "amountOut",
            type: "uint256"
        }, {
            internalType: "uint256",
            name: "amountInMax",
            type: "uint256"
        }, {
            internalType: "address[]",
            name: "path",
            type: "address[]"
        }, {
            internalType: "address",
            name: "to",
            type: "address"
        }, {
            internalType: "uint256",
            name: "deadline",
            type: "uint256"
        }],
        name: "swapTokensForExactTokens",
        outputs: [{
            internalType: "uint256[]",
            name: "amounts",
            type: "uint256[]"
        }],
        stateMutability: "nonpayable",
        type: "function"
    }, {
        stateMutability: "payable",
        type: "receive"
    }],
    Xst = [{
        inputs: [],
        stateMutability: "nonpayable",
        type: "constructor"
    }, {
        inputs: [],
        name: "InvalidShortString",
        type: "error"
    }, {
        inputs: [{
            internalType: "string",
            name: "str",
            type: "string"
        }],
        name: "StringTooLong",
        type: "error"
    }, {
        anonymous: !1,
        inputs: [{
            indexed: !0,
            internalType: "address",
            name: "owner",
            type: "address"
        }, {
            indexed: !0,
            internalType: "address",
            name: "approved",
            type: "address"
        }, {
            indexed: !0,
            internalType: "uint256",
            name: "tokenId",
            type: "uint256"
        }],
        name: "Approval",
        type: "event"
    }, {
        anonymous: !1,
        inputs: [{
            indexed: !0,
            internalType: "address",
            name: "owner",
            type: "address"
        }, {
            indexed: !0,
            internalType: "address",
            name: "operator",
            type: "address"
        }, {
            indexed: !1,
            internalType: "bool",
            name: "approved",
            type: "bool"
        }],
        name: "ApprovalForAll",
        type: "event"
    }, {
        anonymous: !1,
        inputs: [],
        name: "EIP712DomainChanged",
        type: "event"
    }, {
        anonymous: !1,
        inputs: [{
            indexed: !0,
            internalType: "address",
            name: "previousOwner",
            type: "address"
        }, {
            indexed: !0,
            internalType: "address",
            name: "newOwner",
            type: "address"
        }],
        name: "OwnershipTransferred",
        type: "event"
    }, {
        anonymous: !1,
        inputs: [{
            indexed: !0,
            internalType: "address",
            name: "from",
            type: "address"
        }, {
            indexed: !0,
            internalType: "address",
            name: "to",
            type: "address"
        }, {
            indexed: !0,
            internalType: "uint256",
            name: "tokenId",
            type: "uint256"
        }],
        name: "Transfer",
        type: "event"
    }, {
        inputs: [{
            internalType: "address",
            name: "to",
            type: "address"
        }, {
            internalType: "uint256",
            name: "tokenId",
            type: "uint256"
        }],
        name: "approve",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
    }, {
        inputs: [{
            internalType: "address",
            name: "owner",
            type: "address"
        }],
        name: "balanceOf",
        outputs: [{
            internalType: "uint256",
            name: "",
            type: "uint256"
        }],
        stateMutability: "view",
        type: "function"
    }, {
        inputs: [],
        name: "baseTokenURI",
        outputs: [{
            internalType: "string",
            name: "",
            type: "string"
        }],
        stateMutability: "view",
        type: "function"
    }, {
        inputs: [],
        name: "contractURI",
        outputs: [{
            internalType: "string",
            name: "",
            type: "string"
        }],
        stateMutability: "view",
        type: "function"
    }, {
        inputs: [],
        name: "eip712Domain",
        outputs: [{
            internalType: "bytes1",
            name: "fields",
            type: "bytes1"
        }, {
            internalType: "string",
            name: "name",
            type: "string"
        }, {
            internalType: "string",
            name: "version",
            type: "string"
        }, {
            internalType: "uint256",
            name: "chainId",
            type: "uint256"
        }, {
            internalType: "address",
            name: "verifyingContract",
            type: "address"
        }, {
            internalType: "bytes32",
            name: "salt",
            type: "bytes32"
        }, {
            internalType: "uint256[]",
            name: "extensions",
            type: "uint256[]"
        }],
        stateMutability: "view",
        type: "function"
    }, {
        inputs: [{
            internalType: "uint256",
            name: "tokenId",
            type: "uint256"
        }],
        name: "getApproved",
        outputs: [{
            internalType: "address",
            name: "",
            type: "address"
        }],
        stateMutability: "view",
        type: "function"
    }, {
        inputs: [{
            internalType: "address",
            name: "owner",
            type: "address"
        }, {
            internalType: "address",
            name: "operator",
            type: "address"
        }],
        name: "isApprovedForAll",
        outputs: [{
            internalType: "bool",
            name: "",
            type: "bool"
        }],
        stateMutability: "view",
        type: "function"
    }, {
        inputs: [{
            internalType: "uint256",
            name: "tokenId",
            type: "uint256"
        }, {
            internalType: "address",
            name: "to",
            type: "address"
        }],
        name: "mintNFT",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
    }, {
        inputs: [],
        name: "name",
        outputs: [{
            internalType: "string",
            name: "",
            type: "string"
        }],
        stateMutability: "view",
        type: "function"
    }, {
        inputs: [],
        name: "owner",
        outputs: [{
            internalType: "address",
            name: "",
            type: "address"
        }],
        stateMutability: "view",
        type: "function"
    }, {
        inputs: [{
            internalType: "uint256",
            name: "tokenId",
            type: "uint256"
        }],
        name: "ownerOf",
        outputs: [{
            internalType: "address",
            name: "",
            type: "address"
        }],
        stateMutability: "view",
        type: "function"
    }, {
        inputs: [],
        name: "renounceOwnership",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
    }, {
        inputs: [{
            internalType: "address",
            name: "to",
            type: "address"
        }, {
            internalType: "uint256",
            name: "tokenId",
            type: "uint256"
        }, {
            internalType: "uint256",
            name: "deadline",
            type: "uint256"
        }, {
            internalType: "bytes",
            name: "verifierSignature",
            type: "bytes"
        }],
        name: "safeMint",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
    }, {
        inputs: [{
            internalType: "address",
            name: "from",
            type: "address"
        }, {
            internalType: "address",
            name: "to",
            type: "address"
        }, {
            internalType: "uint256",
            name: "tokenId",
            type: "uint256"
        }],
        name: "safeTransferFrom",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
    }, {
        inputs: [{
            internalType: "address",
            name: "from",
            type: "address"
        }, {
            internalType: "address",
            name: "to",
            type: "address"
        }, {
            internalType: "uint256",
            name: "tokenId",
            type: "uint256"
        }, {
            internalType: "bytes",
            name: "data",
            type: "bytes"
        }],
        name: "safeTransferFrom",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
    }, {
        inputs: [{
            internalType: "address",
            name: "operator",
            type: "address"
        }, {
            internalType: "bool",
            name: "approved",
            type: "bool"
        }],
        name: "setApprovalForAll",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
    }, {
        inputs: [{
            internalType: "string",
            name: "_baseTokenURI",
            type: "string"
        }],
        name: "setBaseTokenURI",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
    }, {
        inputs: [{
            internalType: "string",
            name: "contractURI_",
            type: "string"
        }],
        name: "setContractURI",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
    }, {
        inputs: [{
            internalType: "bool",
            name: "_strictMode",
            type: "bool"
        }],
        name: "setStrictMode",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
    }, {
        inputs: [{
            internalType: "address",
            name: "verifier_",
            type: "address"
        }],
        name: "setVerifier",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
    }, {
        inputs: [],
        name: "strictMode",
        outputs: [{
            internalType: "bool",
            name: "",
            type: "bool"
        }],
        stateMutability: "view",
        type: "function"
    }, {
        inputs: [{
            internalType: "bytes4",
            name: "interfaceId",
            type: "bytes4"
        }],
        name: "supportsInterface",
        outputs: [{
            internalType: "bool",
            name: "",
            type: "bool"
        }],
        stateMutability: "view",
        type: "function"
    }, {
        inputs: [],
        name: "symbol",
        outputs: [{
            internalType: "string",
            name: "",
            type: "string"
        }],
        stateMutability: "view",
        type: "function"
    }, {
        inputs: [{
            internalType: "uint256",
            name: "tokenId",
            type: "uint256"
        }],
        name: "tokenURI",
        outputs: [{
            internalType: "string",
            name: "",
            type: "string"
        }],
        stateMutability: "view",
        type: "function"
    }, {
        inputs: [{
            internalType: "address",
            name: "from",
            type: "address"
        }, {
            internalType: "address",
            name: "to",
            type: "address"
        }, {
            internalType: "uint256",
            name: "tokenId",
            type: "uint256"
        }],
        name: "transferFrom",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
    }, {
        inputs: [{
            internalType: "address",
            name: "newOwner",
            type: "address"
        }],
        name: "transferOwnership",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
    }, {
        inputs: [],
        name: "verifier",
        outputs: [{
            internalType: "address",
            name: "",
            type: "address"
        }],
        stateMutability: "view",
        type: "function"
    }],
    mU = {
        id: 1,
        name: "Mainnet network",
        explorer: "https://etherscan.io",
        rpcProviderUrl: "https://mainnet.infura.io/v3/92eb829b550743f2a839c803401503fc",
        wsProviderUrl: "wss://mainnet.infura.io/ws/v3/92eb829b550743f2a839c803401503fc",
        contracts: {
            AIXRevenueSharing: "0xd051eF3DBBEA636Fa009A0318ac51e9eE2CBc3bD",
            AIXMigration: "0x84D14D320Df1Aa0d689FcEb0F290F5D08fd86247",
            AIX: "0x40e9187078032AfE1a30cfcF76E4fe3D7aB5c6C5",
            payments: "0xC889891630598a90D2A2360f891f492CAd5aA887",
            privateSale: "0x6ba4c6854a0CD66F39D41e0a9a8D8C52179dcF86",
            AIX_NFT: "0x0b5dd12b1f116E37172B8Daa687887cdc7AEdCD6"
        },
        paramsForAdding: {
            rpcProvider: "https://mainnet.infura.io/v3/",
            nativeCurrency: {
                name: "ETH",
                symbol: "ETH",
                decimals: 18
            },
            hexId: u1(1)
        },
        coingecko: {
            chainName: "ethereum",
            categoryId: "ethereum-ecosystem"
        },
        additionalTokens: [],
        predefinedTokens: {
            "0x9f8f72aa9304c8b593d555f12ef6589cc3a579a2": {
                name: "Maker",
                symbol: "MKR",
                decimals: 18
            }
        }
    },
    eot = () => new HL(mU.rpcProviderUrl),
    tot = () => new jie(mU.wsProviderUrl),
    not = () => ({
        chainConfig: mU,
        appRpcProvider: eot(),
        appWsProvider: tot()
    }),
    zfe = not(),
    Wfe = ae.createContext([zfe, () => null]),
    rot = ({
        children: t
    }) => {
        const e = ae.useState(zfe);
        return J.jsx(Wfe.Provider, {
            value: e,
            children: t
        })
    },
    Uo = () => ae.useContext(Wfe),
    Vfe = () => {
        const [{
            chainConfig: t
        }] = Uo();
        return async function() {
            if (window.ethereum && window.ethereum.isMetaMask && t) {
                const {
                    paramsForAdding: {
                        hexId: n,
                        nativeCurrency: r
                    },
                    name: i,
                    rpcProviderUrl: s,
                    explorer: o
                } = t;
                try {
                    await window.ethereum.request({
                        method: "wallet_switchEthereumChain",
                        params: [{
                            chainId: n
                        }]
                    })
                } catch (a) {
                    if (console.error(a), a.code === 4902) try {
                        await window.ethereum.request({
                            method: "wallet_addEthereumChain",
                            params: [{
                                chainId: n,
                                chainName: i,
                                rpcProviderUrl: s,
                                nativeCurrency: r,
                                blockExplorerUrls: [o]
                            }]
                        })
                    } catch (l) {
                        console.error(l)
                    }
                }
            }
        }
    },
    W7 = ({
        label: t,
        disabled: e,
        onClick: n,
        ...r
    }) => {
        const {
            open: i
        } = WL(), {
            chainId: s,
            isConnected: o
        } = xs(), [{
            chainConfig: a
        }] = Uo(), l = Vfe(), c = o && s !== a.id;
        return J.jsx(Bo, {
            disabled: o && !c && e,
            onClick: c ? l : o ? n : () => i(),
            ...r,
            children: o ? c ? "Change network" : t : "Connect wallet"
        })
    };
var B0 = (t => (t[t.Failed = 0] = "Failed", t[t.Mined = 1] = "Mined", t[t.Pending = 2] = "Pending", t))(B0 || {});
const iot = Ml("components:TransactionsProvider"),
    sot = {
        transactions: {},
        trackTx: async () => {},
        trackError: () => {},
        resetTransactionsStore: () => {},
        getTransactionsFromStorage: () => ({})
    },
    Gfe = ae.createContext(sot),
    oot = ({
        children: t
    }) => {
        const [{
            chainConfig: e
        }] = Uo(), {
            address: n
        } = xs(), [r, i] = ae.useState({}), s = b => {
            i(w => ({ ...w,
                ...b
            }))
        }, o = b => r[b], a = b => {
            var w;
            return ((w = o(b)) == null ? void 0 : w.status) === B0.Pending
        }, l = b => {
            C(b), iot("new lastTransaction:", b), s({
                [b.hash]: b
            })
        };

        function c(b, w) {
            l({
                hash: b,
                from: w,
                status: B0.Pending,
                error: null
            })
        }

        function u(b, w, S) {
            l({
                hash: b,
                from: w,
                status: B0.Failed,
                error: S
            })
        }

        function f(b, w) {
            l({
                hash: b,
                from: w,
                status: B0.Mined,
                error: null
            })
        }
        async function h(b, w) {
            if (a(b.hash)) return;
            c(b.hash, b.from);
            const S = await b.wait();
            if (!(!n || !_()[Hn(n)][b.hash])) {
                if ((S == null ? void 0 : S.status) === B0.Mined) {
                    f(b.hash, b.from), xc.success("Transaction Confirmed", {
                        id: `${e.explorer}/tx/${b.hash}`
                    }), w && w();
                    return
                }
                u(b.hash, b.from), xc.error("Transaction Failed", {
                    id: `${e.explorer}/tx/${b.hash}`
                })
            }
        }

        function g(b, w) {
            w ? u(w.hash, w.from, b) : xc.error("Transaction Failed")
        }
        const y = () => {
                i({})
            },
            _ = () => JSON.parse(sessionStorage.getItem("transactions") || "{}"),
            C = b => {
                sessionStorage.setItem("transactions", JSON.stringify({ ..._(),
                    [b.from]: { ..._()[b.from],
                        [b.hash]: {
                            hash: b.hash,
                            status: b.status
                        }
                    }
                }))
            };
        return J.jsx(Gfe.Provider, {
            value: {
                transactions: r,
                trackTx: h,
                trackError: g,
                resetTransactionsStore: y,
                getTransactionsFromStorage: _
            },
            children: t
        })
    },
    Ny = () => ae.useContext(Gfe);
var aot = /^-?(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?$/i,
    rP = Math.ceil,
    nc = Math.floor,
    Oa = "[BigNumber Error] ",
    UQ = Oa + "Number primitive has more than 15 significant digits: ",
    Yc = 1e14,
    xn = 14,
    iP = 9007199254740991,
    sP = [1, 10, 100, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9, 1e10, 1e11, 1e12, 1e13],
    m0 = 1e7,
    Fs = 1e9;

function qfe(t) {
    var e, n, r, i = w.prototype = {
            constructor: w,
            toString: null,
            valueOf: null
        },
        s = new w(1),
        o = 20,
        a = 4,
        l = -7,
        c = 21,
        u = -1e7,
        f = 1e7,
        h = !1,
        g = 1,
        y = 0,
        _ = {
            prefix: "",
            groupSize: 3,
            secondaryGroupSize: 0,
            groupSeparator: ",",
            decimalSeparator: ".",
            fractionGroupSize: 0,
            fractionGroupSeparator: "",
            suffix: ""
        },
        C = "0123456789abcdefghijklmnopqrstuvwxyz",
        b = !0;

    function w(E, $) {
        var H, K, te, U, m, v, T, N, O = this;
        if (!(O instanceof w)) return new w(E, $);
        if ($ == null) {
            if (E && E._isBigNumber === !0) {
                O.s = E.s, !E.c || E.e > f ? O.c = O.e = null : E.e < u ? O.c = [O.e = 0] : (O.e = E.e, O.c = E.c.slice());
                return
            }
            if ((v = typeof E == "number") && E * 0 == 0) {
                if (O.s = 1 / E < 0 ? (E = -E, -1) : 1, E === ~~E) {
                    for (U = 0, m = E; m >= 10; m /= 10, U++);
                    U > f ? O.c = O.e = null : (O.e = U, O.c = [E]);
                    return
                }
                N = String(E)
            } else {
                if (!aot.test(N = String(E))) return r(O, N, v);
                O.s = N.charCodeAt(0) == 45 ? (N = N.slice(1), -1) : 1
            }(U = N.indexOf(".")) > -1 && (N = N.replace(".", "")), (m = N.search(/e/i)) > 0 ? (U < 0 && (U = m), U += +N.slice(m + 1), N = N.substring(0, m)) : U < 0 && (U = N.length)
        } else {
            if (xi($, 2, C.length, "Base"), $ == 10 && b) return O = new w(E), M(O, o + O.e + 1, a);
            if (N = String(E), v = typeof E == "number") {
                if (E * 0 != 0) return r(O, N, v, $);
                if (O.s = 1 / E < 0 ? (N = N.slice(1), -1) : 1, w.DEBUG && N.replace(/^0\.0*|\./, "").length > 15) throw Error(UQ + E)
            } else O.s = N.charCodeAt(0) === 45 ? (N = N.slice(1), -1) : 1;
            for (H = C.slice(0, $), U = m = 0, T = N.length; m < T; m++)
                if (H.indexOf(K = N.charAt(m)) < 0) {
                    if (K == ".") {
                        if (m > U) {
                            U = T;
                            continue
                        }
                    } else if (!te && (N == N.toUpperCase() && (N = N.toLowerCase()) || N == N.toLowerCase() && (N = N.toUpperCase()))) {
                        te = !0, m = -1, U = 0;
                        continue
                    }
                    return r(O, String(E), v, $)
                }
            v = !1, N = n(N, $, 10, O.s), (U = N.indexOf(".")) > -1 ? N = N.replace(".", "") : U = N.length
        }
        for (m = 0; N.charCodeAt(m) === 48; m++);
        for (T = N.length; N.charCodeAt(--T) === 48;);
        if (N = N.slice(m, ++T)) {
            if (T -= m, v && w.DEBUG && T > 15 && (E > iP || E !== nc(E))) throw Error(UQ + O.s * E);
            if ((U = U - m - 1) > f) O.c = O.e = null;
            else if (U < u) O.c = [O.e = 0];
            else {
                if (O.e = U, O.c = [], m = (U + 1) % xn, U < 0 && (m += xn), m < T) {
                    for (m && O.c.push(+N.slice(0, m)), T -= xn; m < T;) O.c.push(+N.slice(m, m += xn));
                    m = xn - (N = N.slice(m)).length
                } else m -= T;
                for (; m--; N += "0");
                O.c.push(+N)
            }
        } else O.c = [O.e = 0]
    }
    w.clone = qfe, w.ROUND_UP = 0, w.ROUND_DOWN = 1, w.ROUND_CEIL = 2, w.ROUND_FLOOR = 3, w.ROUND_HALF_UP = 4, w.ROUND_HALF_DOWN = 5, w.ROUND_HALF_EVEN = 6, w.ROUND_HALF_CEIL = 7, w.ROUND_HALF_FLOOR = 8, w.EUCLID = 9, w.config = w.set = function(E) {
        var $, H;
        if (E != null)
            if (typeof E == "object") {
                if (E.hasOwnProperty($ = "DECIMAL_PLACES") && (H = E[$], xi(H, 0, Fs, $), o = H), E.hasOwnProperty($ = "ROUNDING_MODE") && (H = E[$], xi(H, 0, 8, $), a = H), E.hasOwnProperty($ = "EXPONENTIAL_AT") && (H = E[$], H && H.pop ? (xi(H[0], -Fs, 0, $), xi(H[1], 0, Fs, $), l = H[0], c = H[1]) : (xi(H, -Fs, Fs, $), l = -(c = H < 0 ? -H : H))), E.hasOwnProperty($ = "RANGE"))
                    if (H = E[$], H && H.pop) xi(H[0], -Fs, -1, $), xi(H[1], 1, Fs, $), u = H[0], f = H[1];
                    else if (xi(H, -Fs, Fs, $), H) u = -(f = H < 0 ? -H : H);
                else throw Error(Oa + $ + " cannot be zero: " + H);
                if (E.hasOwnProperty($ = "CRYPTO"))
                    if (H = E[$], H === !!H)
                        if (H)
                            if (typeof crypto < "u" && crypto && (crypto.getRandomValues || crypto.randomBytes)) h = H;
                            else throw h = !H, Error(Oa + "crypto unavailable");
                else h = H;
                else throw Error(Oa + $ + " not true or false: " + H);
                if (E.hasOwnProperty($ = "MODULO_MODE") && (H = E[$], xi(H, 0, 9, $), g = H), E.hasOwnProperty($ = "POW_PRECISION") && (H = E[$], xi(H, 0, Fs, $), y = H), E.hasOwnProperty($ = "FORMAT"))
                    if (H = E[$], typeof H == "object") _ = H;
                    else throw Error(Oa + $ + " not an object: " + H);
                if (E.hasOwnProperty($ = "ALPHABET"))
                    if (H = E[$], typeof H == "string" && !/^.?$|[+\-.\s]|(.).*\1/.test(H)) b = H.slice(0, 10) == "0123456789", C = H;
                    else throw Error(Oa + $ + " invalid: " + H)
            } else throw Error(Oa + "Object expected: " + E);
        return {
            DECIMAL_PLACES: o,
            ROUNDING_MODE: a,
            EXPONENTIAL_AT: [l, c],
            RANGE: [u, f],
            CRYPTO: h,
            MODULO_MODE: g,
            POW_PRECISION: y,
            FORMAT: _,
            ALPHABET: C
        }
    }, w.isBigNumber = function(E) {
        if (!E || E._isBigNumber !== !0) return !1;
        if (!w.DEBUG) return !0;
        var $, H, K = E.c,
            te = E.e,
            U = E.s;
        e: if ({}.toString.call(K) == "[object Array]") {
            if ((U === 1 || U === -1) && te >= -Fs && te <= Fs && te === nc(te)) {
                if (K[0] === 0) {
                    if (te === 0 && K.length === 1) return !0;
                    break e
                }
                if ($ = (te + 1) % xn, $ < 1 && ($ += xn), String(K[0]).length == $) {
                    for ($ = 0; $ < K.length; $++)
                        if (H = K[$], H < 0 || H >= Yc || H !== nc(H)) break e;
                    if (H !== 0) return !0
                }
            }
        } else
        if (K === null && te === null && (U === null || U === 1 || U === -1)) return !0;
        throw Error(Oa + "Invalid BigNumber: " + E)
    }, w.maximum = w.max = function() {
        return I(arguments, -1)
    }, w.minimum = w.min = function() {
        return I(arguments, 1)
    }, w.random = function() {
        var E = 9007199254740992,
            $ = Math.random() * E & 2097151 ? function() {
                return nc(Math.random() * E)
            } : function() {
                return (Math.random() * 1073741824 | 0) * 8388608 + (Math.random() * 8388608 | 0)
            };
        return function(H) {
            var K, te, U, m, v, T = 0,
                N = [],
                O = new w(s);
            if (H == null ? H = o : xi(H, 0, Fs), m = rP(H / xn), h)
                if (crypto.getRandomValues) {
                    for (K = crypto.getRandomValues(new Uint32Array(m *= 2)); T < m;) v = K[T] * 131072 + (K[T + 1] >>> 11), v >= 9e15 ? (te = crypto.getRandomValues(new Uint32Array(2)), K[T] = te[0], K[T + 1] = te[1]) : (N.push(v % 1e14), T += 2);
                    T = m / 2
                } else if (crypto.randomBytes) {
                for (K = crypto.randomBytes(m *= 7); T < m;) v = (K[T] & 31) * 281474976710656 + K[T + 1] * 1099511627776 + K[T + 2] * 4294967296 + K[T + 3] * 16777216 + (K[T + 4] << 16) + (K[T + 5] << 8) + K[T + 6], v >= 9e15 ? crypto.randomBytes(7).copy(K, T) : (N.push(v % 1e14), T += 7);
                T = m / 7
            } else throw h = !1, Error(Oa + "crypto unavailable");
            if (!h)
                for (; T < m;) v = $(), v < 9e15 && (N[T++] = v % 1e14);
            for (m = N[--T], H %= xn, m && H && (v = sP[xn - H], N[T] = nc(m / v) * v); N[T] === 0; N.pop(), T--);
            if (T < 0) N = [U = 0];
            else {
                for (U = -1; N[0] === 0; N.splice(0, 1), U -= xn);
                for (T = 1, v = N[0]; v >= 10; v /= 10, T++);
                T < xn && (U -= xn - T)
            }
            return O.e = U, O.c = N, O
        }
    }(), w.sum = function() {
        for (var E = 1, $ = arguments, H = new w($[0]); E < $.length;) H = H.plus($[E++]);
        return H
    }, n = function() {
        var E = "0123456789";

        function $(H, K, te, U) {
            for (var m, v = [0], T, N = 0, O = H.length; N < O;) {
                for (T = v.length; T--; v[T] *= K);
                for (v[0] += U.indexOf(H.charAt(N++)), m = 0; m < v.length; m++) v[m] > te - 1 && (v[m + 1] == null && (v[m + 1] = 0), v[m + 1] += v[m] / te | 0, v[m] %= te)
            }
            return v.reverse()
        }
        return function(H, K, te, U, m) {
            var v, T, N, O, L, G, j, R, Y = H.indexOf("."),
                ve = o,
                V = a;
            for (Y >= 0 && (O = y, y = 0, H = H.replace(".", ""), R = new w(K), G = R.pow(H.length - Y), y = O, R.c = $(kd(ec(G.c), G.e, "0"), 10, te, E), R.e = R.c.length), j = $(H, K, te, m ? (v = C, E) : (v = E, C)), N = O = j.length; j[--O] == 0; j.pop());
            if (!j[0]) return v.charAt(0);
            if (Y < 0 ? --N : (G.c = j, G.e = N, G.s = U, G = e(G, R, ve, V, te), j = G.c, L = G.r, N = G.e), T = N + ve + 1, Y = j[T], O = te / 2, L = L || T < 0 || j[T + 1] != null, L = V < 4 ? (Y != null || L) && (V == 0 || V == (G.s < 0 ? 3 : 2)) : Y > O || Y == O && (V == 4 || L || V == 6 && j[T - 1] & 1 || V == (G.s < 0 ? 8 : 7)), T < 1 || !j[0]) H = L ? kd(v.charAt(1), -ve, v.charAt(0)) : v.charAt(0);
            else {
                if (j.length = T, L)
                    for (--te; ++j[--T] > te;) j[T] = 0, T || (++N, j = [1].concat(j));
                for (O = j.length; !j[--O];);
                for (Y = 0, H = ""; Y <= O; H += v.charAt(j[Y++]));
                H = kd(H, N, v.charAt(0))
            }
            return H
        }
    }(), e = function() {
        function E(K, te, U) {
            var m, v, T, N, O = 0,
                L = K.length,
                G = te % m0,
                j = te / m0 | 0;
            for (K = K.slice(); L--;) T = K[L] % m0, N = K[L] / m0 | 0, m = j * T + N * G, v = G * T + m % m0 * m0 + O, O = (v / U | 0) + (m / m0 | 0) + j * N, K[L] = v % U;
            return O && (K = [O].concat(K)), K
        }

        function $(K, te, U, m) {
            var v, T;
            if (U != m) T = U > m ? 1 : -1;
            else
                for (v = T = 0; v < U; v++)
                    if (K[v] != te[v]) {
                        T = K[v] > te[v] ? 1 : -1;
                        break
                    } return T
        }

        function H(K, te, U, m) {
            for (var v = 0; U--;) K[U] -= v, v = K[U] < te[U] ? 1 : 0, K[U] = v * m + K[U] - te[U];
            for (; !K[0] && K.length > 1; K.splice(0, 1));
        }
        return function(K, te, U, m, v) {
            var T, N, O, L, G, j, R, Y, ve, V, X, q, ne, ie, k, z, Z, ge = K.s == te.s ? 1 : -1,
                me = K.c,
                Re = te.c;
            if (!me || !me[0] || !Re || !Re[0]) return new w(!K.s || !te.s || (me ? Re && me[0] == Re[0] : !Re) ? NaN : me && me[0] == 0 || !Re ? ge * 0 : ge / 0);
            for (Y = new w(ge), ve = Y.c = [], N = K.e - te.e, ge = U + N + 1, v || (v = Yc, N = rc(K.e / xn) - rc(te.e / xn), ge = ge / xn | 0), O = 0; Re[O] == (me[O] || 0); O++);
            if (Re[O] > (me[O] || 0) && N--, ge < 0) ve.push(1), L = !0;
            else {
                for (ie = me.length, z = Re.length, O = 0, ge += 2, G = nc(v / (Re[0] + 1)), G > 1 && (Re = E(Re, G, v), me = E(me, G, v), z = Re.length, ie = me.length), ne = z, V = me.slice(0, z), X = V.length; X < z; V[X++] = 0);
                Z = Re.slice(), Z = [0].concat(Z), k = Re[0], Re[1] >= v / 2 && k++;
                do {
                    if (G = 0, T = $(Re, V, z, X), T < 0) {
                        if (q = V[0], z != X && (q = q * v + (V[1] || 0)), G = nc(q / k), G > 1)
                            for (G >= v && (G = v - 1), j = E(Re, G, v), R = j.length, X = V.length; $(j, V, R, X) == 1;) G--, H(j, z < R ? Z : Re, R, v), R = j.length, T = 1;
                        else G == 0 && (T = G = 1), j = Re.slice(), R = j.length;
                        if (R < X && (j = [0].concat(j)), H(V, j, X, v), X = V.length, T == -1)
                            for (; $(Re, V, z, X) < 1;) G++, H(V, z < X ? Z : Re, X, v), X = V.length
                    } else T === 0 && (G++, V = [0]);
                    ve[O++] = G, V[0] ? V[X++] = me[ne] || 0 : (V = [me[ne]], X = 1)
                } while ((ne++ < ie || V[0] != null) && ge--);
                L = V[0] != null, ve[0] || ve.splice(0, 1)
            }
            if (v == Yc) {
                for (O = 1, ge = ve[0]; ge >= 10; ge /= 10, O++);
                M(Y, U + (Y.e = O + N * xn - 1) + 1, m, L)
            } else Y.e = N, Y.r = +L;
            return Y
        }
    }();

    function S(E, $, H, K) {
        var te, U, m, v, T;
        if (H == null ? H = a : xi(H, 0, 8), !E.c) return E.toString();
        if (te = E.c[0], m = E.e, $ == null) T = ec(E.c), T = K == 1 || K == 2 && (m <= l || m >= c) ? $S(T, m) : kd(T, m, "0");
        else if (E = M(new w(E), $, H), U = E.e, T = ec(E.c), v = T.length, K == 1 || K == 2 && ($ <= U || U <= l)) {
            for (; v < $; T += "0", v++);
            T = $S(T, U)
        } else if ($ -= m, T = kd(T, U, "0"), U + 1 > v) {
            if (--$ > 0)
                for (T += "."; $--; T += "0");
        } else if ($ += U - v, $ > 0)
            for (U + 1 == v && (T += "."); $--; T += "0");
        return E.s < 0 && te ? "-" + T : T
    }

    function I(E, $) {
        for (var H, K, te = 1, U = new w(E[0]); te < E.length; te++) K = new w(E[te]), (!K.s || (H = jg(U, K)) === $ || H === 0 && U.s === $) && (U = K);
        return U
    }

    function P(E, $, H) {
        for (var K = 1, te = $.length; !$[--te]; $.pop());
        for (te = $[0]; te >= 10; te /= 10, K++);
        return (H = K + H * xn - 1) > f ? E.c = E.e = null : H < u ? E.c = [E.e = 0] : (E.e = H, E.c = $), E
    }
    r = function() {
        var E = /^(-?)0([xbo])(?=\w[\w.]*$)/i,
            $ = /^([^.]+)\.$/,
            H = /^\.([^.]+)$/,
            K = /^-?(Infinity|NaN)$/,
            te = /^\s*\+(?=[\w.])|^\s+|\s+$/g;
        return function(U, m, v, T) {
            var N, O = v ? m : m.replace(te, "");
            if (K.test(O)) U.s = isNaN(O) ? null : O < 0 ? -1 : 1;
            else {
                if (!v && (O = O.replace(E, function(L, G, j) {
                        return N = (j = j.toLowerCase()) == "x" ? 16 : j == "b" ? 2 : 8, !T || T == N ? G : L
                    }), T && (N = T, O = O.replace($, "$1").replace(H, "0.$1")), m != O)) return new w(O, N);
                if (w.DEBUG) throw Error(Oa + "Not a" + (T ? " base " + T : "") + " number: " + m);
                U.s = null
            }
            U.c = U.e = null
        }
    }();

    function M(E, $, H, K) {
        var te, U, m, v, T, N, O, L = E.c,
            G = sP;
        if (L) {
            e: {
                for (te = 1, v = L[0]; v >= 10; v /= 10, te++);
                if (U = $ - te, U < 0) U += xn,
                m = $,
                T = L[N = 0],
                O = nc(T / G[te - m - 1] % 10);
                else if (N = rP((U + 1) / xn), N >= L.length)
                    if (K) {
                        for (; L.length <= N; L.push(0));
                        T = O = 0, te = 1, U %= xn, m = U - xn + 1
                    } else break e;
                else {
                    for (T = v = L[N], te = 1; v >= 10; v /= 10, te++);
                    U %= xn, m = U - xn + te, O = m < 0 ? 0 : nc(T / G[te - m - 1] % 10)
                }
                if (K = K || $ < 0 || L[N + 1] != null || (m < 0 ? T : T % G[te - m - 1]), K = H < 4 ? (O || K) && (H == 0 || H == (E.s < 0 ? 3 : 2)) : O > 5 || O == 5 && (H == 4 || K || H == 6 && (U > 0 ? m > 0 ? T / G[te - m] : 0 : L[N - 1]) % 10 & 1 || H == (E.s < 0 ? 8 : 7)), $ < 1 || !L[0]) return L.length = 0, K ? ($ -= E.e + 1, L[0] = G[(xn - $ % xn) % xn], E.e = -$ || 0) : L[0] = E.e = 0, E;
                if (U == 0 ? (L.length = N, v = 1, N--) : (L.length = N + 1, v = G[xn - U], L[N] = m > 0 ? nc(T / G[te - m] % G[m]) * v : 0), K)
                    for (;;)
                        if (N == 0) {
                            for (U = 1, m = L[0]; m >= 10; m /= 10, U++);
                            for (m = L[0] += v, v = 1; m >= 10; m /= 10, v++);
                            U != v && (E.e++, L[0] == Yc && (L[0] = 1));
                            break
                        } else {
                            if (L[N] += v, L[N] != Yc) break;
                            L[N--] = 0, v = 1
                        }
                for (U = L.length; L[--U] === 0; L.pop());
            }
            E.e > f ? E.c = E.e = null : E.e < u && (E.c = [E.e = 0])
        }
        return E
    }

    function A(E) {
        var $, H = E.e;
        return H === null ? E.toString() : ($ = ec(E.c), $ = H <= l || H >= c ? $S($, H) : kd($, H, "0"), E.s < 0 ? "-" + $ : $)
    }
    return i.absoluteValue = i.abs = function() {
        var E = new w(this);
        return E.s < 0 && (E.s = 1), E
    }, i.comparedTo = function(E, $) {
        return jg(this, new w(E, $))
    }, i.decimalPlaces = i.dp = function(E, $) {
        var H, K, te, U = this;
        if (E != null) return xi(E, 0, Fs), $ == null ? $ = a : xi($, 0, 8), M(new w(U), E + U.e + 1, $);
        if (!(H = U.c)) return null;
        if (K = ((te = H.length - 1) - rc(this.e / xn)) * xn, te = H[te])
            for (; te % 10 == 0; te /= 10, K--);
        return K < 0 && (K = 0), K
    }, i.dividedBy = i.div = function(E, $) {
        return e(this, new w(E, $), o, a)
    }, i.dividedToIntegerBy = i.idiv = function(E, $) {
        return e(this, new w(E, $), 0, 1)
    }, i.exponentiatedBy = i.pow = function(E, $) {
        var H, K, te, U, m, v, T, N, O, L = this;
        if (E = new w(E), E.c && !E.isInteger()) throw Error(Oa + "Exponent not an integer: " + A(E));
        if ($ != null && ($ = new w($)), v = E.e > 14, !L.c || !L.c[0] || L.c[0] == 1 && !L.e && L.c.length == 1 || !E.c || !E.c[0]) return O = new w(Math.pow(+A(L), v ? E.s * (2 - DS(E)) : +A(E))), $ ? O.mod($) : O;
        if (T = E.s < 0, $) {
            if ($.c ? !$.c[0] : !$.s) return new w(NaN);
            K = !T && L.isInteger() && $.isInteger(), K && (L = L.mod($))
        } else {
            if (E.e > 9 && (L.e > 0 || L.e < -1 || (L.e == 0 ? L.c[0] > 1 || v && L.c[1] >= 24e7 : L.c[0] < 8e13 || v && L.c[0] <= 9999975e7))) return U = L.s < 0 && DS(E) ? -0 : 0, L.e > -1 && (U = 1 / U), new w(T ? 1 / U : U);
            y && (U = rP(y / xn + 2))
        }
        for (v ? (H = new w(.5), T && (E.s = 1), N = DS(E)) : (te = Math.abs(+A(E)), N = te % 2), O = new w(s);;) {
            if (N) {
                if (O = O.times(L), !O.c) break;
                U ? O.c.length > U && (O.c.length = U) : K && (O = O.mod($))
            }
            if (te) {
                if (te = nc(te / 2), te === 0) break;
                N = te % 2
            } else if (E = E.times(H), M(E, E.e + 1, 1), E.e > 14) N = DS(E);
            else {
                if (te = +A(E), te === 0) break;
                N = te % 2
            }
            L = L.times(L), U ? L.c && L.c.length > U && (L.c.length = U) : K && (L = L.mod($))
        }
        return K ? O : (T && (O = s.div(O)), $ ? O.mod($) : U ? M(O, y, a, m) : O)
    }, i.integerValue = function(E) {
        var $ = new w(this);
        return E == null ? E = a : xi(E, 0, 8), M($, $.e + 1, E)
    }, i.isEqualTo = i.eq = function(E, $) {
        return jg(this, new w(E, $)) === 0
    }, i.isFinite = function() {
        return !!this.c
    }, i.isGreaterThan = i.gt = function(E, $) {
        return jg(this, new w(E, $)) > 0
    }, i.isGreaterThanOrEqualTo = i.gte = function(E, $) {
        return ($ = jg(this, new w(E, $))) === 1 || $ === 0
    }, i.isInteger = function() {
        return !!this.c && rc(this.e / xn) > this.c.length - 2
    }, i.isLessThan = i.lt = function(E, $) {
        return jg(this, new w(E, $)) < 0
    }, i.isLessThanOrEqualTo = i.lte = function(E, $) {
        return ($ = jg(this, new w(E, $))) === -1 || $ === 0
    }, i.isNaN = function() {
        return !this.s
    }, i.isNegative = function() {
        return this.s < 0
    }, i.isPositive = function() {
        return this.s > 0
    }, i.isZero = function() {
        return !!this.c && this.c[0] == 0
    }, i.minus = function(E, $) {
        var H, K, te, U, m = this,
            v = m.s;
        if (E = new w(E, $), $ = E.s, !v || !$) return new w(NaN);
        if (v != $) return E.s = -$, m.plus(E);
        var T = m.e / xn,
            N = E.e / xn,
            O = m.c,
            L = E.c;
        if (!T || !N) {
            if (!O || !L) return O ? (E.s = -$, E) : new w(L ? m : NaN);
            if (!O[0] || !L[0]) return L[0] ? (E.s = -$, E) : new w(O[0] ? m : a == 3 ? -0 : 0)
        }
        if (T = rc(T), N = rc(N), O = O.slice(), v = T - N) {
            for ((U = v < 0) ? (v = -v, te = O) : (N = T, te = L), te.reverse(), $ = v; $--; te.push(0));
            te.reverse()
        } else
            for (K = (U = (v = O.length) < ($ = L.length)) ? v : $, v = $ = 0; $ < K; $++)
                if (O[$] != L[$]) {
                    U = O[$] < L[$];
                    break
                } if (U && (te = O, O = L, L = te, E.s = -E.s), $ = (K = L.length) - (H = O.length), $ > 0)
            for (; $--; O[H++] = 0);
        for ($ = Yc - 1; K > v;) {
            if (O[--K] < L[K]) {
                for (H = K; H && !O[--H]; O[H] = $);
                --O[H], O[K] += Yc
            }
            O[K] -= L[K]
        }
        for (; O[0] == 0; O.splice(0, 1), --N);
        return O[0] ? P(E, O, N) : (E.s = a == 3 ? -1 : 1, E.c = [E.e = 0], E)
    }, i.modulo = i.mod = function(E, $) {
        var H, K, te = this;
        return E = new w(E, $), !te.c || !E.s || E.c && !E.c[0] ? new w(NaN) : !E.c || te.c && !te.c[0] ? new w(te) : (g == 9 ? (K = E.s, E.s = 1, H = e(te, E, 0, 3), E.s = K, H.s *= K) : H = e(te, E, 0, g), E = te.minus(H.times(E)), !E.c[0] && g == 1 && (E.s = te.s), E)
    }, i.multipliedBy = i.times = function(E, $) {
        var H, K, te, U, m, v, T, N, O, L, G, j, R, Y, ve, V = this,
            X = V.c,
            q = (E = new w(E, $)).c;
        if (!X || !q || !X[0] || !q[0]) return !V.s || !E.s || X && !X[0] && !q || q && !q[0] && !X ? E.c = E.e = E.s = null : (E.s *= V.s, !X || !q ? E.c = E.e = null : (E.c = [0], E.e = 0)), E;
        for (K = rc(V.e / xn) + rc(E.e / xn), E.s *= V.s, T = X.length, L = q.length, T < L && (R = X, X = q, q = R, te = T, T = L, L = te), te = T + L, R = []; te--; R.push(0));
        for (Y = Yc, ve = m0, te = L; --te >= 0;) {
            for (H = 0, G = q[te] % ve, j = q[te] / ve | 0, m = T, U = te + m; U > te;) N = X[--m] % ve, O = X[m] / ve | 0, v = j * N + O * G, N = G * N + v % ve * ve + R[U] + H, H = (N / Y | 0) + (v / ve | 0) + j * O, R[U--] = N % Y;
            R[U] = H
        }
        return H ? ++K : R.splice(0, 1), P(E, R, K)
    }, i.negated = function() {
        var E = new w(this);
        return E.s = -E.s || null, E
    }, i.plus = function(E, $) {
        var H, K = this,
            te = K.s;
        if (E = new w(E, $), $ = E.s, !te || !$) return new w(NaN);
        if (te != $) return E.s = -$, K.minus(E);
        var U = K.e / xn,
            m = E.e / xn,
            v = K.c,
            T = E.c;
        if (!U || !m) {
            if (!v || !T) return new w(te / 0);
            if (!v[0] || !T[0]) return T[0] ? E : new w(v[0] ? K : te * 0)
        }
        if (U = rc(U), m = rc(m), v = v.slice(), te = U - m) {
            for (te > 0 ? (m = U, H = T) : (te = -te, H = v), H.reverse(); te--; H.push(0));
            H.reverse()
        }
        for (te = v.length, $ = T.length, te - $ < 0 && (H = T, T = v, v = H, $ = te), te = 0; $;) te = (v[--$] = v[$] + T[$] + te) / Yc | 0, v[$] = Yc === v[$] ? 0 : v[$] % Yc;
        return te && (v = [te].concat(v), ++m), P(E, v, m)
    }, i.precision = i.sd = function(E, $) {
        var H, K, te, U = this;
        if (E != null && E !== !!E) return xi(E, 1, Fs), $ == null ? $ = a : xi($, 0, 8), M(new w(U), E, $);
        if (!(H = U.c)) return null;
        if (te = H.length - 1, K = te * xn + 1, te = H[te]) {
            for (; te % 10 == 0; te /= 10, K--);
            for (te = H[0]; te >= 10; te /= 10, K++);
        }
        return E && U.e + 1 > K && (K = U.e + 1), K
    }, i.shiftedBy = function(E) {
        return xi(E, -iP, iP), this.times("1e" + E)
    }, i.squareRoot = i.sqrt = function() {
        var E, $, H, K, te, U = this,
            m = U.c,
            v = U.s,
            T = U.e,
            N = o + 4,
            O = new w("0.5");
        if (v !== 1 || !m || !m[0]) return new w(!v || v < 0 && (!m || m[0]) ? NaN : m ? U : 1 / 0);
        if (v = Math.sqrt(+A(U)), v == 0 || v == 1 / 0 ? ($ = ec(m), ($.length + T) % 2 == 0 && ($ += "0"), v = Math.sqrt(+$), T = rc((T + 1) / 2) - (T < 0 || T % 2), v == 1 / 0 ? $ = "5e" + T : ($ = v.toExponential(), $ = $.slice(0, $.indexOf("e") + 1) + T), H = new w($)) : H = new w(v + ""), H.c[0]) {
            for (T = H.e, v = T + N, v < 3 && (v = 0);;)
                if (te = H, H = O.times(te.plus(e(U, te, N, 1))), ec(te.c).slice(0, v) === ($ = ec(H.c)).slice(0, v))
                    if (H.e < T && --v, $ = $.slice(v - 3, v + 1), $ == "9999" || !K && $ == "4999") {
                        if (!K && (M(te, te.e + o + 2, 0), te.times(te).eq(U))) {
                            H = te;
                            break
                        }
                        N += 4, v += 4, K = 1
                    } else {
                        (!+$ || !+$.slice(1) && $.charAt(0) == "5") && (M(H, H.e + o + 2, 1), E = !H.times(H).eq(U));
                        break
                    }
        }
        return M(H, H.e + o + 1, a, E)
    }, i.toExponential = function(E, $) {
        return E != null && (xi(E, 0, Fs), E++), S(this, E, $, 1)
    }, i.toFixed = function(E, $) {
        return E != null && (xi(E, 0, Fs), E = E + this.e + 1), S(this, E, $)
    }, i.toFormat = function(E, $, H) {
        var K, te = this;
        if (H == null) E != null && $ && typeof $ == "object" ? (H = $, $ = null) : E && typeof E == "object" ? (H = E, E = $ = null) : H = _;
        else if (typeof H != "object") throw Error(Oa + "Argument not an object: " + H);
        if (K = te.toFixed(E, $), te.c) {
            var U, m = K.split("."),
                v = +H.groupSize,
                T = +H.secondaryGroupSize,
                N = H.groupSeparator || "",
                O = m[0],
                L = m[1],
                G = te.s < 0,
                j = G ? O.slice(1) : O,
                R = j.length;
            if (T && (U = v, v = T, T = U, R -= U), v > 0 && R > 0) {
                for (U = R % v || v, O = j.substr(0, U); U < R; U += v) O += N + j.substr(U, v);
                T > 0 && (O += N + j.slice(U)), G && (O = "-" + O)
            }
            K = L ? O + (H.decimalSeparator || "") + ((T = +H.fractionGroupSize) ? L.replace(new RegExp("\\d{" + T + "}\\B", "g"), "$&" + (H.fractionGroupSeparator || "")) : L) : O
        }
        return (H.prefix || "") + K + (H.suffix || "")
    }, i.toFraction = function(E) {
        var $, H, K, te, U, m, v, T, N, O, L, G, j = this,
            R = j.c;
        if (E != null && (v = new w(E), !v.isInteger() && (v.c || v.s !== 1) || v.lt(s))) throw Error(Oa + "Argument " + (v.isInteger() ? "out of range: " : "not an integer: ") + A(v));
        if (!R) return new w(j);
        for ($ = new w(s), N = H = new w(s), K = T = new w(s), G = ec(R), U = $.e = G.length - j.e - 1, $.c[0] = sP[(m = U % xn) < 0 ? xn + m : m], E = !E || v.comparedTo($) > 0 ? U > 0 ? $ : N : v, m = f, f = 1 / 0, v = new w(G), T.c[0] = 0; O = e(v, $, 0, 1), te = H.plus(O.times(K)), te.comparedTo(E) != 1;) H = K, K = te, N = T.plus(O.times(te = N)), T = te, $ = v.minus(O.times(te = $)), v = te;
        return te = e(E.minus(H), K, 0, 1), T = T.plus(te.times(N)), H = H.plus(te.times(K)), T.s = N.s = j.s, U = U * 2, L = e(N, K, U, a).minus(j).abs().comparedTo(e(T, H, U, a).minus(j).abs()) < 1 ? [N, K] : [T, H], f = m, L
    }, i.toNumber = function() {
        return +A(this)
    }, i.toPrecision = function(E, $) {
        return E != null && xi(E, 1, Fs), S(this, E, $, 2)
    }, i.toString = function(E) {
        var $, H = this,
            K = H.s,
            te = H.e;
        return te === null ? K ? ($ = "Infinity", K < 0 && ($ = "-" + $)) : $ = "NaN" : (E == null ? $ = te <= l || te >= c ? $S(ec(H.c), te) : kd(ec(H.c), te, "0") : E === 10 && b ? (H = M(new w(H), o + te + 1, a), $ = kd(ec(H.c), H.e, "0")) : (xi(E, 2, C.length, "Base"), $ = n(kd(ec(H.c), te, "0"), 10, E, K, !0)), K < 0 && H.c[0] && ($ = "-" + $)), $
    }, i.valueOf = i.toJSON = function() {
        return A(this)
    }, i._isBigNumber = !0, i[Symbol.toStringTag] = "BigNumber", i[Symbol.for("nodejs.util.inspect.custom")] = i.valueOf, t != null && w.set(t), w
}

function rc(t) {
    var e = t | 0;
    return t > 0 || t === e ? e : e - 1
}

function ec(t) {
    for (var e, n, r = 1, i = t.length, s = t[0] + ""; r < i;) {
        for (e = t[r++] + "", n = xn - e.length; n--; e = "0" + e);
        s += e
    }
    for (i = s.length; s.charCodeAt(--i) === 48;);
    return s.slice(0, i + 1 || 1)
}

function jg(t, e) {
    var n, r, i = t.c,
        s = e.c,
        o = t.s,
        a = e.s,
        l = t.e,
        c = e.e;
    if (!o || !a) return null;
    if (n = i && !i[0], r = s && !s[0], n || r) return n ? r ? 0 : -a : o;
    if (o != a) return o;
    if (n = o < 0, r = l == c, !i || !s) return r ? 0 : !i ^ n ? 1 : -1;
    if (!r) return l > c ^ n ? 1 : -1;
    for (a = (l = i.length) < (c = s.length) ? l : c, o = 0; o < a; o++)
        if (i[o] != s[o]) return i[o] > s[o] ^ n ? 1 : -1;
    return l == c ? 0 : l > c ^ n ? 1 : -1
}

function xi(t, e, n, r) {
    if (t < e || t > n || t !== nc(t)) throw Error(Oa + (r || "Argument") + (typeof t == "number" ? t < e || t > n ? " out of range: " : " not an integer: " : " not a primitive number: ") + String(t))
}

function DS(t) {
    var e = t.c.length - 1;
    return rc(t.e / xn) == e && t.c[e] % 2 != 0
}

function $S(t, e) {
    return (t.length > 1 ? t.charAt(0) + "." + t.slice(1) : t) + (e < 0 ? "e" : "e+") + e
}

function kd(t, e, n) {
    var r, i;
    if (e < 0) {
        for (i = n + "."; ++e; i += n);
        t = i + t
    } else if (r = t.length, ++e > r) {
        for (i = n, e -= r; --e; i += n);
        t += i
    } else e < r && (t = t.slice(0, e) + "." + t.slice(e));
    return t
}
var FA = qfe();
FA.config({
    ROUNDING_MODE: FA.ROUND_DOWN,
    EXPONENTIAL_AT: 1e9,
    DECIMAL_PLACES: 18
});
const ur = t => new FA(t);

function Os(t, {
    decimals: e = 18,
    round: n = 4,
    cut: r = !0
} = {}) {
    const i = ur(t).div(ur(10).pow(e));
    if (i.eq(0)) return "0";
    const s = i.toFixed(e);
    return r ? i.lt(1e-4) ? lot(s) : cot(s, n) : s
}

function Is(t, e = 18) {
    return ur(t).times(ur(10).pow(e)).toFixed(0)
}

function _3t(t, e = 2) {
    const i = ur(t);
    return i.gte(1e6) ? `${i.div(1e6).toFixed(e)}M` : i.gte(1e3) ? `${i.div(1e3).toFixed(e)}K` : i.eq(0) ? "0" : i.lt(.001) ? "< 0.001" : i.toFixed(e)
}

function jQ(t) {
    const e = t.toString().split(".");
    return e[0] = e[0].replace(/\B(?=(\d{3})+(?!\d))/g, " "), e.join(".")
}
const lot = t => {
        const e = t.match(/0*([1-9]\d?)/);
        return e ? `0.${e[0]}` : "0"
    },
    cot = (t, e) => {
        const [n, r] = t.split(".");
        if (!r) return n;
        const i = r.slice(0, e);
        return `${n}${ur(i).gt(0)?`.${i}`:""}`
    },
    Kfe = t => t.replace(/[^0-9.,]/g, "").replace(/,/g, ".").replace(/(\..*?)\..*/g, "$1").replace(/(,.*?),.*/g, "$1").replace(/^0+/g, "0").replace(/^0(?=\d)/, "").replace(/^\./, "0."),
    HQ = 100,
    uot = Ml("components:LaunchpadParticipateModal"),
    fot = ({
        onSuccess: t,
        walletStakesSum: e
    }) => {
        const [n, r] = ae.useState("0"), [i, s] = ae.useState({
            raw: "0",
            formatted: "0",
            fullPrecision: "0"
        }), [o, a] = ae.useState({
            raw: "0",
            formatted: "0",
            fullPrecision: "0"
        }), [l, c] = ae.useState("0"), {
            walletProvider: u
        } = fg(), {
            address: f,
            isConnected: h
        } = xs(), [{
            chainConfig: g,
            appRpcProvider: y
        }] = Uo(), {
            trackTx: _,
            trackError: C
        } = Ny(), b = va(), w = ae.useMemo(() => Object.values(e).reduce((A, E) => ur(A).plus(E).toString(), "0"), [e]), S = ur(w).plus(i.raw).div(1e18).gt(HQ);
        ae.useEffect(() => {
            if (!y || !f) return;
            const A = new Qr(g.contracts.privateSale, FQ, y),
                E = new Qr(g.contracts.AIX, Xm, y);
            Promise.all([y.getBalance(f), A.accountPower(f), E.balanceOf(f)]).then(([$, H, K]) => {
                const te = $.toString(),
                    U = Os(te),
                    m = Os(te, {
                        cut: !1
                    }),
                    v = K.toString(),
                    T = Os(v),
                    N = Os(v, {
                        cut: !1
                    });
                uot("power from contract", H.toString()), c(Os(H.toString())), a({
                    raw: te,
                    formatted: U,
                    fullPrecision: m
                }), s({
                    raw: v,
                    formatted: T,
                    fullPrecision: N
                })
            })
        }, [y, f]);
        const I = () => {
                r(o.fullPrecision)
            },
            P = A => {
                let E = Kfe(A.target.value);
                ur(E).gt(o.fullPrecision) && (E = o.fullPrecision), r(E)
            },
            M = async () => {
                if (!u) return null;
                const A = new vh(new Kf(u), f),
                    E = new Qr(g.contracts.privateSale, FQ, A);
                let $;
                try {
                    b({
                        modalKey: "loader",
                        title: "Confirm your transaction in the wallet"
                    }), $ = await E.buy({
                        value: Is(n)
                    }), b({
                        modalKey: "loader",
                        title: "Depositing ETH",
                        txHash: $.hash
                    }), _($), await $.wait(), t(), b({
                        modalKey: "success",
                        title: `Thank you for your contribution! 
You will be able to claim your $ECL at TGE. Stay tuned for more updates.`
                    })
                } catch (H) {
                    throw C(H, $), b(null), console.error("Deposit failed", H), H
                }
            };
        return J.jsxs(ba, {
            size: "sm",
            children: [J.jsx("div", {
                className: "modal-title",
                children: "Participate in Eclipse"
            }), h && J.jsxs(J.Fragment, {
                children: [J.jsxs("div", {
                    children: ["Your balance: ", i.formatted, " $AIX"]
                }), J.jsxs("div", {
                    className: "mb-4",
                    children: ["Your stake sum: ", Os(w), " $AIX"]
                }), !S && J.jsxs("div", {
                    className: "bg-[#ED1522] bg-opacity-10 border border-[#ED1522] p-4 rounded-lg my-4",
                    children: ["Your stake and balance of $AIX is less than the minimum required to participate in the Eclipse project (minimum of ", HQ, " $AIX)"]
                })]
            }), J.jsx("div", {
                className: "w-full my-8",
                children: J.jsx($7, {
                    labelEnd: J.jsx("div", {
                        className: "cursor-pointer",
                        onClick: I,
                        children: "Max"
                    }),
                    label: "ETH deposit amount",
                    name: "eth-value",
                    value: n,
                    onChange: P
                })
            }), J.jsxs("div", {
                className: "flex flex-col space-y-1 mb-4",
                children: [J.jsx("p", {
                    children: "Hold or Stake 100+ $AIX to be eligible."
                }), J.jsx("p", {
                    children: "Stake 10.000-99.999 $AIX for a 10% boost"
                }), J.jsx("p", {
                    children: "Stake 100.000+ $AIX for a 20% boost"
                })]
            }), J.jsx(W7, {
                className: "w-full",
                onClick: M,
                label: "Deposit",
                disabled: !S
            })]
        })
    },
    dot = ({
        title: t,
        txHash: e
    }) => {
        const [{
            chainConfig: n
        }] = Uo();
        return J.jsxs(ba, {
            size: "lg",
            children: [J.jsxs("div", {
                className: "flex flex-col justify-center items-center mb-8",
                children: [J.jsx("div", {
                    className: "w-32 h-32 mt-8 mb-4",
                    children: J.jsx(D7, {
                        spinnerSize: "full"
                    })
                }), J.jsx("span", {
                    children: "Loading..."
                })]
            }), J.jsx("div", {
                className: "text-xl text-center mb-7",
                children: t
            }), e && J.jsxs("div", {
                className: "flex items-center justify-center text-purple-600",
                children: [J.jsx("a", {
                    className: "underline",
                    href: `${n.explorer}/tx/${e}`,
                    target: "_blank",
                    children: "Show transaction status"
                }), J.jsx(Xr, {
                    className: "ml-3 -mt-0.5",
                    icon: "fa6-solid:arrow-up-right-from-square"
                })]
            })]
        })
    },
    $8 = {
        options: [{
            type: "singleImage",
            model: "default",
            chain: "ethereum"
        }, () => {}],
        prompt: ["", () => {}],
        settings: [{
            symbol: "AIX_NFT",
            name: "",
            description: "",
            id: ""
        }, () => {}],
        images: [{
            generating: !1,
            urls: null,
            selectedImage: null,
            error: !1,
            errorMessage: null
        }, () => {}]
    },
    y4 = ae.createContext($8),
    hot = ({
        children: t
    }) => {
        const e = ae.useState($8.options[0]),
            n = ae.useState(""),
            r = ae.useState($8.settings[0]),
            i = ae.useState($8.images[0]);
        return J.jsx(y4.Provider, {
            value: {
                options: e,
                prompt: n,
                settings: r,
                images: i
            },
            children: t || J.jsx(tU, {})
        })
    },
    E3t = () => {
        const {
            options: t
        } = ae.useContext(y4);
        return t
    },
    x3t = () => {
        const {
            prompt: t
        } = ae.useContext(y4);
        return t
    },
    pot = () => {
        const {
            settings: t
        } = ae.useContext(y4);
        return t
    },
    Yfe = () => {
        const {
            images: t
        } = ae.useContext(y4);
        return t
    },
    zQ = Ml("hooks:useNftsApi"),
    got = () => {
        const {
            address: t
        } = xs(), {
            loggedIn: e,
            signOut: n
        } = e5(), [{
            selectedImage: r
        }, i] = Yfe(), [{
            name: s,
            description: o,
            id: a
        }, l] = pot(), [c, u] = ae.useState(!1), f = ae.useMemo(() => !t || !e ? null : H7(`${Np}/api`, t, n), [t, e]);
        async function h(y) {
            if (!f) return null;
            i({
                generating: !0,
                urls: null,
                selectedImage: null,
                error: !1,
                errorMessage: null
            });
            try {
                const _ = await f.post("/generate_images", {
                    prompt: y
                });
                if ("error" in _.data) {
                    i({
                        generating: !1,
                        urls: null,
                        selectedImage: null,
                        error: !0,
                        errorMessage: _.data.error
                    });
                    return
                }
                i({
                    generating: !1,
                    urls: _.data.urls,
                    selectedImage: null,
                    error: !1,
                    errorMessage: null
                })
            } catch {
                i({
                    generating: !1,
                    urls: null,
                    selectedImage: null,
                    error: !0,
                    errorMessage: ""
                })
            }
        }
        async function g() {
            if (!f) return null;
            u(!0);
            const y = {
                name: s,
                description: o,
                image_url: r
            };
            zQ("NFT Metadata", y);
            try {
                const _ = await f.post("/nft_metadata", y),
                    C = String(_.data.token_id);
                return l(b => ({ ...b,
                    id: C
                })), zQ("NFT id", C), C
            } catch (_) {
                throw console.error(_), Error("Failed to send NFT Metadata.")
            } finally {
                u(!1)
            }
        }
        return {
            generateImages: h,
            sendNFTMetadata: g,
            sendingData: c
        }
    },
    mot = [{
        id: "metadata",
        name: "Upload metadata",
        status: "waiting"
    }, {
        id: "mint",
        name: "Mint",
        status: "waiting"
    }],
    LS = Ml("components:NftMintModal"),
    yot = () => {
        const t = va(),
            [{
                selectedImage: e
            }] = Yfe(),
            [{
                chainConfig: n
            }] = Uo(),
            {
                address: r,
                isConnected: i
            } = xs(),
            {
                walletProvider: s
            } = fg(),
            {
                trackTx: o,
                trackError: a
            } = Ny(),
            {
                sendNFTMetadata: l
            } = got(),
            [c, u] = ae.useState(mot);

        function f(y, _) {
            u(C => {
                const b = C.map(S => ({ ...S
                    })),
                    w = b.findIndex(S => S.id === y);
                return b[w].status = _, b
            })
        }
        async function h() {
            f("metadata", "processing");
            try {
                const y = await l();
                if (f("metadata", "done"), f("mint", "processing"), !y) return;
                await g(y), f("mint", "done")
            } catch (y) {
                console.error(y);
                return
            }
        }
        async function g(y) {
            if (!s || !i || !r) return;
            LS("Minting NFT", y);
            let _;
            try {
                const C = new vh(new Kf(s), r),
                    b = new Qr(n.contracts.AIX_NFT, Xst, C);
                t({
                    modalKey: "loader",
                    title: "Confirm your transaction in the wallet"
                }), _ = await b.mintNFT(y, r), LS("Set loader"), t({
                    modalKey: "loader",
                    title: "Minting NFT...",
                    txHash: _.txHash
                }), o(_), LS("tx", _), await _.wait(), t({
                    modalKey: "success",
                    title: "NFT Minted",
                    txHash: _.hash
                }), LS("NFT successfully generated.")
            } catch (C) {
                throw a(C, _), t({
                    modalKey: "mint-nft"
                }), C
            }
        }
        return J.jsxs(ba, {
            size: "md",
            children: [J.jsx("div", {
                className: "modal-title",
                children: "Mint NFT"
            }), J.jsxs("div", {
                className: "flex flex-col",
                children: [J.jsx("div", {
                    className: "max-w-64 mx-auto w-full mb-10",
                    children: J.jsx("div", {
                        className: "rounded-2xl col-span-1 relative pt-[110%] overflow-hidden ",
                        children: J.jsx("div", {
                            className: "absolute left-0 top-0 h-full w-full z-10 p-4",
                            style: {
                                background: `url('${e}') center / cover no-repeat`
                            }
                        })
                    })
                }), c.map(y => J.jsxs("div", {
                    className: "p-3 bg-[#17191B] bg-opacity-5 rounded-xl flex items-center mb-4 gap-4",
                    children: [J.jsx(Xr, {
                        className: `${y.status==="done"?"text-purple-600":"text-[#17191B] text-opacity-20"} text-xl`,
                        icon: y.status === "waiting" ? "fa6-solid:circle-arrow-down" : y.status === "processing" ? "fa6-solid:circle-notch" : "fa6-solid:circle-check"
                    }), y.name]
                }, y.id)), J.jsx(W7, {
                    className: "w-full mt-6",
                    label: "Mint",
                    onClick: h
                })]
            })]
        })
    },
    wot = ({
        botId: t
    }) => {
        const [e, n] = ae.useState(""), r = va(), {
            fetchTelegramGroupToken: i
        } = z7(), s = [J.jsxs("p", {
            children: ["Add", " ", J.jsx("a", {
                className: "font-semibold cursor-pointer underline inline text-[#FB1FFF]",
                href: "https://t.me/AIgentXBot",
                target: "_blank",
                rel: "noreferrer",
                children: "@AIgentXBot"
            }), " ", "to your group"]
        }), J.jsx("p", {
            children: "Set the Bot as an admin of the group"
        }), J.jsxs("div", {
            children: [J.jsx("div", {
                className: "mb-2",
                children: "Execute command inside of the group"
            }), J.jsxs("div", {
                className: "bg-black bg-opacity-5 border border-gray-200 rounded-2xl text-black relative px-4 py-8 mb-8",
                children: [J.jsx("div", {
                    children: J.jsx(Xr, {
                        icon: "fa6-solid:clone",
                        className: "absolute right-2 top-2 text-black opacity-20 cursor-pointer break-all",
                        onClick: () => o(e)
                    })
                }), J.jsx("div", {
                    className: "break-words",
                    children: e
                })]
            })]
        })];
        ae.useEffect(() => {
            t && i(t).then(a => {
                a && n(a.command)
            })
        }, [t]);

        function o(a) {
            navigator.clipboard.writeText(a), xc.success("Command coped")
        }
        return J.jsxs(ba, {
            size: "lg",
            children: [J.jsx("div", {
                className: "modal-title",
                children: "To setup the bot to telegram"
            }), J.jsx("div", {
                className: "max-w-md mx-auto p-6 bg-black bg-opacity-5 rounded-2xl",
                children: J.jsx("ul", {
                    className: "list-decimal list-inside",
                    children: s.map((a, l) => J.jsxs("li", {
                        className: "relative step flex items-start [&:not(:last-child)]:pb-4 after:bottom-0 after:h-full",
                        children: [J.jsx("div", {
                            className: "relative z-10 w-6 h-6 flex items-center justify-center rounded-full bg-gray-300 text-gray-700 mr-3 flex-shrink-0",
                            children: J.jsx("span", {
                                className: "-ml-[1px]",
                                children: l + 1
                            })
                        }), J.jsx("div", {
                            className: "mt-[2px]",
                            children: a
                        })]
                    }))
                })
            }), J.jsxs("p", {
                className: "text-center mt-6",
                children: ["Watch", " ", J.jsx("a", {
                    className: "font-semibold cursor-pointer underline inline text-[#FB1FFF]",
                    href: "https://youtube.com",
                    target: "_blank",
                    rel: "noreferrer",
                    children: "video"
                }), " ", "with detailed instructions."]
            }), J.jsx(Bo, {
                className: "mt-8 w-full",
                onClick: () => r(null),
                children: "Done"
            })]
        })
    },
    WQ = {
        webchat_link: "",
        webchat_js: ""
    },
    vot = ({
        botId: t
    }) => {
        const e = va(),
            {
                fetchBotWebchatLink: n
            } = z7(),
            [r, i] = ae.useState(WQ);
        ae.useEffect(() => {
            t && n(t).then(o => i(o || WQ))
        }, []);

        function s(o) {
            navigator.clipboard.writeText(o), xc.success("Link coped")
        }
        return J.jsxs(ba, {
            children: [J.jsx("div", {
                className: "modal-title",
                children: "To setup the bot to webchat"
            }), J.jsxs("div", {
                className: "bg-black bg-opacity-5 border border-gray-200 rounded-2xl text-black relative p-8 mb-8",
                children: [J.jsxs("div", {
                    children: [J.jsx(Xr, {
                        icon: "fa6-solid:clone",
                        className: "absolute right-2 top-2 text-black opacity-20 cursor-pointer break-all",
                        onClick: () => s(r.webchat_link)
                    }), J.jsx("span", {
                        className: "text-lg",
                        children: "Web chat link:"
                    })]
                }), J.jsx("div", {
                    className: "break-words",
                    children: r.webchat_link
                })]
            }), J.jsxs("div", {
                className: "bg-black bg-opacity-5 border border-gray-200 rounded-2xl text-black relative p-8",
                children: [J.jsxs("div", {
                    children: [J.jsx(Xr, {
                        icon: "fa6-solid:clone",
                        className: "absolute right-2 top-2 text-black opacity-20 cursor-pointer break-all",
                        onClick: () => s(r.webchat_js)
                    }), J.jsx("span", {
                        className: "text-lg",
                        children: "JS code:"
                    })]
                }), J.jsx("div", {
                    className: "break-words",
                    children: `${r.webchat_js}`
                })]
            }), J.jsx(Bo, {
                className: "mt-8 w-full",
                onClick: () => e(null),
                children: "Done"
            })]
        })
    },
    V7 = ({
        children: t,
        className: e,
        ...n
    }) => {
        const r = {
                "rounded-3xl": !(e != null && e.includes("rounded-")),
                "bg-white": !0,
                "bg-opacity-5": !(e != null && e.includes("bg-opacity-")),
                "p-6": !e || (e == null ? void 0 : e.split(" ").findIndex(s => s.indexOf("p-") === 0)) === -1
            },
            i = $A(r, e);
        return J.jsx("div", {
            className: i,
            ...n,
            children: t
        })
    },
    G7 = ur(2).pow(256).minus(1).toString(),
    yU = `0x${"0".repeat(40)}`,
    ey = (t, e) => t.toLowerCase() === e.toLowerCase(),
    zf = t => ey(t, yU),
    oP = Ml("hooks:useAllowance"),
    Zfe = (t, e, n) => {
        const [r, i] = ae.useState("0"), [{
            appRpcProvider: s,
            appWsProvider: o
        }] = Uo(), a = ae.useMemo(() => t ? new Qr(t, Xm, s) : null, [t, s]), l = Qm(async () => {
            if (oP("fetchAllowanceImmutable for address", t), t && zf(t)) {
                i(G7);
                return
            }
            if (a) return a.allowance(e, n).then(c => (oP("allowance reloaded:", String(c)), i(String(c) || "0"), c)).catch(c => {
                console.error("fetchAllowanceImmutable error", c)
            })
        });
        return ae.useEffect(() => {
            if (!e || !t) return i("0");
            const c = new Qr(t, Xm, o),
                u = (f, h, g) => {
                    ey(f, e) && ey(h, n) && (oP("approvalEventHandler: ", g.toString()), i(g.toString()))
                };
            return l(), c == null || c.on("Approval", u), () => {
                c == null || c.removeListener("Approval", u)
            }
        }, [o, t, e, n]), [r, l]
    },
    Qfe = (t, e, n) => {
        const {
            walletProvider: r
        } = fg(), {
            address: i
        } = xs(), s = va(), {
            trackTx: o,
            trackError: a
        } = Ny();
        return async (l = G7) => {
            if (!t || !r) return;
            const c = new vh(new Kf(r), i),
                u = new Qr(t, Xm, c);
            let f;
            try {
                s({
                    modalKey: "loader",
                    title: "Confirm your transaction in the wallet"
                }), f = await u.approve(e, l), s({
                    modalKey: "loader",
                    title: n ? String(n) : "loading",
                    txHash: f.hash
                }), o(f), await f.wait(), s(null)
            } catch (h) {
                throw a(h, f), s(null), console.error("useApprove failed", h), h
            }
        }
    },
    VQ = {
        raw: "0",
        formatted: "0",
        fullPrecision: "0"
    },
    GQ = Ml("components:StakesModal"),
    bot = ({
        stakes: t,
        selectedIndex: e = 0,
        walletStakesSum: n,
        fetchWalletStakes: r,
        fetchStakes: i,
        stakeValue: s = "0"
    }) => {
        const o = va(),
            [{
                chainConfig: a,
                appRpcProvider: l
            }] = Uo(),
            {
                address: c,
                chainId: u,
                isConnected: f
            } = xs(),
            {
                walletProvider: h
            } = fg(),
            {
                trackTx: g,
                trackError: y
            } = Ny(),
            [_, C] = Zfe(a.contracts.AIX, c, a.contracts.AIXRevenueSharing),
            b = Qfe(a.contracts.AIX, a.contracts.AIXRevenueSharing, "Approving"),
            [w, S] = ae.useState(t[e]),
            [I, P] = ae.useState(VQ),
            [M, A] = ae.useState(s);
        ae.useEffect(() => {
            if (!c) {
                P(VQ);
                return
            }
            H()
        }, [c]);
        const E = ur(_).lt(Is(M, 18)),
            $ = f && u !== a.id;
        async function H() {
            new Qr(a.contracts.AIX, Xm, l).balanceOf(c).then(m => P({
                raw: m.toString(),
                formatted: Os(m.toString(), {
                    decimals: 18
                }),
                fullPrecision: Os(m.toString(), {
                    decimals: 18,
                    cut: !1
                })
            }))
        }

        function K(U) {
            let m = Kfe(U.target.value);
            ur(m).gt(I.formatted) && (m = I.formatted), A(m)
        }
        async function te() {
            if (!h) return;
            E && (await b(G7), await C());
            let U;
            try {
                const m = new vh(new Kf(h), c),
                    v = new Qr(a.contracts.AIXRevenueSharing, gU, m),
                    T = Is(M, 18);
                o({
                    modalKey: "loader",
                    title: "Confirm your transaction in the wallet"
                });
                const N = await v.stake.estimateGas(Is(M), w.sec);
                U = await v.stake(Is(M), w.sec, {
                    gasLimit: ur(N.toString()).times(1.2).toFixed(0)
                }), o({
                    modalKey: "loader",
                    title: `Staking ${M} AIX...`,
                    txHash: U.txHash
                }), g(U), GQ("tx", U), await U.wait(), o(null), r(), i(), GQ(`${T} AIX successfully supplied.`)
            } catch (m) {
                throw y(m, U), o(null), console.error("Stake action failed:", m), m
            }
        }
        return J.jsxs(ba, {
            children: [J.jsx("div", {
                className: "modal-title",
                children: "Select Staking Option"
            }), J.jsx("div", {
                className: "flex flex-col space-y-4 mb-8",
                children: t.map(U => J.jsxs("div", {
                    className: `flex items-center rounded-lg bg-black bg-opacity-5 border-2 justify-between px-4 py-2 pb-1.5 cursor-pointer ${U.sec===w.sec?"border-purple-600":"border-black border-opacity-5"}`,
                    onClick: () => S(U),
                    children: [J.jsxs("span", {
                        className: "text-xl",
                        children: [U.apr, "% APR"]
                    }), J.jsxs("span", {
                        className: "opacity-50",
                        children: [U.days.toString(), " days Lockup"]
                    })]
                }, U.sec))
            }), J.jsxs("div", {
                className: "flex flex-col space-y-2 mb-6",
                children: [J.jsxs("div", {
                    className: "text-sm font-semibold text-gray-600 cursor-pointer",
                    onClick: () => A(I.formatted.toString()),
                    children: ["Balance: ", J.jsxs("span", {
                        className: "text-purple-600",
                        children: [I.formatted.toString(), " AIX"]
                    })]
                }), J.jsxs("div", {
                    className: "relative",
                    children: [J.jsx("input", {
                        value: M,
                        type: "text",
                        placeholder: "0",
                        className: "ui-input",
                        onChange: K
                    }), J.jsx("span", {
                        className: "font-bold absolute right-4 top-1/2 transform -translate-y-1/2 text-purple-500 text-sm cursor-pointer hover:text-purple-600",
                        onClick: () => A(I.formatted.toString()),
                        children: "Max"
                    })]
                })]
            }), J.jsxs("p", {
                className: "text-lg text-center mb-6",
                children: ["You are staking: ", Os(n[w.sec.toString()] || 0), " AIX tokens"]
            }), E && J.jsx(V7, {
                className: "items-center text-lg bg-none border border-gray-400 mb-10",
                children: J.jsxs("ul", {
                    children: [J.jsx("span", {
                        children: "You will need to send two transactions:"
                    }), J.jsx("li", {
                        className: "pl-4",
                        children: "1. Approve AIX for Stake"
                    }), J.jsx("li", {
                        className: "pl-4",
                        children: "2. Stake AIX tokens"
                    })]
                })
            }), J.jsx(Bo, {
                className: "w-full",
                onClick: te,
                disabled: $,
                children: $ ? "Wrong network" : E ? "Approve AIX and Stake" : "Stake"
            })]
        })
    },
    _ot = ({
        title: t,
        txHash: e
    }) => {
        const [{
            chainConfig: n
        }] = Uo(), r = va();
        return J.jsxs(ba, {
            size: "lg",
            children: [J.jsx(Xr, {
                className: "text-9xl text-green-600 mx-auto my-6",
                icon: "fa6-solid:circle-check"
            }), J.jsx("div", {
                className: "modal-title",
                children: t
            }), e && J.jsxs("div", {
                className: "flex items-center justify-center text-purple-600 mb-4",
                children: [J.jsx("a", {
                    className: "underline",
                    href: `${n.explorer}/tx/${e}`,
                    target: "_blank",
                    children: "Show transaction"
                }), J.jsx(Xr, {
                    className: "ml-3 -mt-0.5",
                    icon: "fa6-solid:arrow-up-right-from-square"
                })]
            }), J.jsx("div", {
                className: "flex justify-center",
                children: J.jsx(Bo, {
                    className: "border-black text-black",
                    buttonType: "stroke",
                    onClick: () => r(null),
                    children: "Close"
                })
            })]
        })
    },
    Jfe = ({
        label: t,
        containerSize: e,
        className: n
    }) => {
        const i = $A(`flex flex-col ${e==="full"?"flex-1 h-full":""} items-center justify-center space-y-4`, n);
        return J.jsxs(V7, {
            className: i,
            children: [J.jsx(D7, {
                spinnerSize: "small"
            }), J.jsx("p", {
                children: t
            })]
        })
    },
    aP = {
        sm: "w-5 h-5 text-[8px]",
        default: "w-10 h-10"
    },
    Eot = ({
        token: t,
        size: e = "default"
    }) => {
        const [n, r] = ae.useState(!1), [i, s] = ae.useState(!1), o = `https://raw.githubusercontent.com/trustwallet/assets/master/blockchains/ethereum/assets/${Hn(t.address)}/logo.png`;
        return n ? !i && t.image ? J.jsx("img", {
            src: t.image,
            onError: () => s(!0),
            className: `${aP[e]} rounded-full mr-3`
        }) : J.jsx("div", {
            className: `${aP[e]} rounded-full mr-2 bg-gray-200 flex items-center justify-center text-black`,
            children: J.jsx("span", {
                className: "-mb-0.5",
                children: t.symbol
            })
        }) : J.jsx("img", {
            src: o,
            onError: () => r(!0),
            className: `${aP[e]} rounded-full mr-3`
        })
    },
    xot = "logger/5.7.0";
let qQ = !1,
    KQ = !1;
const L8 = {
    debug: 1,
    default: 2,
    info: 2,
    warning: 3,
    error: 4,
    off: 5
};
let YQ = L8.default,
    lP = null;

function Sot() {
    try {
        const t = [];
        if (["NFD", "NFC", "NFKD", "NFKC"].forEach(e => {
                try {
                    if ("test".normalize(e) !== "test") throw new Error("bad normalize")
                } catch {
                    t.push(e)
                }
            }), t.length) throw new Error("missing " + t.join(", "));
        if ("".normalize("NFD") !== "e") throw new Error("broken implementation")
    } catch (t) {
        return t.message
    }
    return null
}
const ZQ = Sot();
var KD;
(function(t) {
    t.DEBUG = "DEBUG", t.INFO = "INFO", t.WARNING = "WARNING", t.ERROR = "ERROR", t.OFF = "OFF"
})(KD || (KD = {}));
var su;
(function(t) {
    t.UNKNOWN_ERROR = "UNKNOWN_ERROR", t.NOT_IMPLEMENTED = "NOT_IMPLEMENTED", t.UNSUPPORTED_OPERATION = "UNSUPPORTED_OPERATION", t.NETWORK_ERROR = "NETWORK_ERROR", t.SERVER_ERROR = "SERVER_ERROR", t.TIMEOUT = "TIMEOUT", t.BUFFER_OVERRUN = "BUFFER_OVERRUN", t.NUMERIC_FAULT = "NUMERIC_FAULT", t.MISSING_NEW = "MISSING_NEW", t.INVALID_ARGUMENT = "INVALID_ARGUMENT", t.MISSING_ARGUMENT = "MISSING_ARGUMENT", t.UNEXPECTED_ARGUMENT = "UNEXPECTED_ARGUMENT", t.CALL_EXCEPTION = "CALL_EXCEPTION", t.INSUFFICIENT_FUNDS = "INSUFFICIENT_FUNDS", t.NONCE_EXPIRED = "NONCE_EXPIRED", t.REPLACEMENT_UNDERPRICED = "REPLACEMENT_UNDERPRICED", t.UNPREDICTABLE_GAS_LIMIT = "UNPREDICTABLE_GAS_LIMIT", t.TRANSACTION_REPLACED = "TRANSACTION_REPLACED", t.ACTION_REJECTED = "ACTION_REJECTED"
})(su || (su = {}));
const QQ = "0123456789abcdef";
class br {
    constructor(e) {
        Object.defineProperty(this, "version", {
            enumerable: !0,
            value: e,
            writable: !1
        })
    }
    _log(e, n) {
        const r = e.toLowerCase();
        L8[r] == null && this.throwArgumentError("invalid log level name", "logLevel", e), !(YQ > L8[r]) && console.log.apply(console, n)
    }
    debug(...e) {
        this._log(br.levels.DEBUG, e)
    }
    info(...e) {
        this._log(br.levels.INFO, e)
    }
    warn(...e) {
        this._log(br.levels.WARNING, e)
    }
    makeError(e, n, r) {
        if (KQ) return this.makeError("censored error", n, {});
        n || (n = br.errors.UNKNOWN_ERROR), r || (r = {});
        const i = [];
        Object.keys(r).forEach(l => {
            const c = r[l];
            try {
                if (c instanceof Uint8Array) {
                    let u = "";
                    for (let f = 0; f < c.length; f++) u += QQ[c[f] >> 4], u += QQ[c[f] & 15];
                    i.push(l + "=Uint8Array(0x" + u + ")")
                } else i.push(l + "=" + JSON.stringify(c))
            } catch {
                i.push(l + "=" + JSON.stringify(r[l].toString()))
            }
        }), i.push(`code=${n}`), i.push(`version=${this.version}`);
        const s = e;
        let o = "";
        switch (n) {
            case su.NUMERIC_FAULT:
                {
                    o = "NUMERIC_FAULT";
                    const l = e;
                    switch (l) {
                        case "overflow":
                        case "underflow":
                        case "division-by-zero":
                            o += "-" + l;
                            break;
                        case "negative-power":
                        case "negative-width":
                            o += "-unsupported";
                            break;
                        case "unbound-bitwise-result":
                            o += "-unbound-result";
                            break
                    }
                    break
                }
            case su.CALL_EXCEPTION:
            case su.INSUFFICIENT_FUNDS:
            case su.MISSING_NEW:
            case su.NONCE_EXPIRED:
            case su.REPLACEMENT_UNDERPRICED:
            case su.TRANSACTION_REPLACED:
            case su.UNPREDICTABLE_GAS_LIMIT:
                o = n;
                break
        }
        o && (e += " [ See: https://links.ethers.org/v5-errors-" + o + " ]"), i.length && (e += " (" + i.join(", ") + ")");
        const a = new Error(e);
        return a.reason = s, a.code = n, Object.keys(r).forEach(function(l) {
            a[l] = r[l]
        }), a
    }
    throwError(e, n, r) {
        throw this.makeError(e, n, r)
    }
    throwArgumentError(e, n, r) {
        return this.throwError(e, br.errors.INVALID_ARGUMENT, {
            argument: n,
            value: r
        })
    }
    assert(e, n, r, i) {
        e || this.throwError(n, r, i)
    }
    assertArgument(e, n, r, i) {
        e || this.throwArgumentError(n, r, i)
    }
    checkNormalize(e) {
        ZQ && this.throwError("platform missing String.prototype.normalize", br.errors.UNSUPPORTED_OPERATION, {
            operation: "String.prototype.normalize",
            form: ZQ
        })
    }
    checkSafeUint53(e, n) {
        typeof e == "number" && (n == null && (n = "value not safe"), (e < 0 || e >= 9007199254740991) && this.throwError(n, br.errors.NUMERIC_FAULT, {
            operation: "checkSafeInteger",
            fault: "out-of-safe-range",
            value: e
        }), e % 1 && this.throwError(n, br.errors.NUMERIC_FAULT, {
            operation: "checkSafeInteger",
            fault: "non-integer",
            value: e
        }))
    }
    checkArgumentCount(e, n, r) {
        r ? r = ": " + r : r = "", e < n && this.throwError("missing argument" + r, br.errors.MISSING_ARGUMENT, {
            count: e,
            expectedCount: n
        }), e > n && this.throwError("too many arguments" + r, br.errors.UNEXPECTED_ARGUMENT, {
            count: e,
            expectedCount: n
        })
    }
    checkNew(e, n) {
        (e === Object || e == null) && this.throwError("missing new", br.errors.MISSING_NEW, {
            name: n.name
        })
    }
    checkAbstract(e, n) {
        e === n ? this.throwError("cannot instantiate abstract class " + JSON.stringify(n.name) + " directly; use a sub-class", br.errors.UNSUPPORTED_OPERATION, {
            name: e.name,
            operation: "new"
        }) : (e === Object || e == null) && this.throwError("missing new", br.errors.MISSING_NEW, {
            name: n.name
        })
    }
    static globalLogger() {
        return lP || (lP = new br(xot)), lP
    }
    static setCensorship(e, n) {
        if (!e && n && this.globalLogger().throwError("cannot permanently disable censorship", br.errors.UNSUPPORTED_OPERATION, {
                operation: "setCensorship"
            }), qQ) {
            if (!e) return;
            this.globalLogger().throwError("error censorship permanent", br.errors.UNSUPPORTED_OPERATION, {
                operation: "setCensorship"
            })
        }
        KQ = !!e, qQ = !!n
    }
    static setLogLevel(e) {
        const n = L8[e.toLowerCase()];
        if (n == null) {
            br.globalLogger().warn("invalid log level - " + e);
            return
        }
        YQ = n
    }
    static from(e) {
        return new br(e)
    }
}
br.errors = su;
br.levels = KD;
const Cot = "bytes/5.7.0",
    Pp = new br(Cot);

function Xfe(t) {
    return !!t.toHexString
}

function vv(t) {
    return t.slice || (t.slice = function() {
        const e = Array.prototype.slice.call(arguments);
        return vv(new Uint8Array(Array.prototype.slice.apply(t, e)))
    }), t
}

function JQ(t) {
    return typeof t == "number" && t == t && t % 1 === 0
}

function wU(t) {
    if (t == null) return !1;
    if (t.constructor === Uint8Array) return !0;
    if (typeof t == "string" || !JQ(t.length) || t.length < 0) return !1;
    for (let e = 0; e < t.length; e++) {
        const n = t[e];
        if (!JQ(n) || n < 0 || n >= 256) return !1
    }
    return !0
}

function Lf(t, e) {
    if (e || (e = {}), typeof t == "number") {
        Pp.checkSafeUint53(t, "invalid arrayify value");
        const n = [];
        for (; t;) n.unshift(t & 255), t = parseInt(String(t / 256));
        return n.length === 0 && n.push(0), vv(new Uint8Array(n))
    }
    if (e.allowMissingPrefix && typeof t == "string" && t.substring(0, 2) !== "0x" && (t = "0x" + t), Xfe(t) && (t = t.toHexString()), ty(t)) {
        let n = t.substring(2);
        n.length % 2 && (e.hexPad === "left" ? n = "0" + n : e.hexPad === "right" ? n += "0" : Pp.throwArgumentError("hex data is odd-length", "value", t));
        const r = [];
        for (let i = 0; i < n.length; i += 2) r.push(parseInt(n.substring(i, i + 2), 16));
        return vv(new Uint8Array(r))
    }
    return wU(t) ? vv(new Uint8Array(t)) : Pp.throwArgumentError("invalid arrayify value", "value", t)
}

function vU(t) {
    const e = t.map(i => Lf(i)),
        n = e.reduce((i, s) => i + s.length, 0),
        r = new Uint8Array(n);
    return e.reduce((i, s) => (r.set(s, i), i + s.length), 0), vv(r)
}

function cP(t, e) {
    t = Lf(t), t.length > e && Pp.throwArgumentError("value out of range", "value", arguments[0]);
    const n = new Uint8Array(e);
    return n.set(t, e - t.length), vv(n)
}

function ty(t, e) {
    return !(typeof t != "string" || !t.match(/^0x[0-9A-Fa-f]*$/) || e && t.length !== 2 + 2 * e)
}
const uP = "0123456789abcdef";

function q7(t, e) {
    if (e || (e = {}), typeof t == "number") {
        Pp.checkSafeUint53(t, "invalid hexlify value");
        let n = "";
        for (; t;) n = uP[t & 15] + n, t = Math.floor(t / 16);
        return n.length ? (n.length % 2 && (n = "0" + n), "0x" + n) : "0x00"
    }
    if (typeof t == "bigint") return t = t.toString(16), t.length % 2 ? "0x0" + t : "0x" + t;
    if (e.allowMissingPrefix && typeof t == "string" && t.substring(0, 2) !== "0x" && (t = "0x" + t), Xfe(t)) return t.toHexString();
    if (ty(t)) return t.length % 2 && (e.hexPad === "left" ? t = "0x0" + t.substring(2) : e.hexPad === "right" ? t += "0" : Pp.throwArgumentError("hex data is odd-length", "value", t)), t.toLowerCase();
    if (wU(t)) {
        let n = "0x";
        for (let r = 0; r < t.length; r++) {
            let i = t[r];
            n += uP[(i & 240) >> 4] + uP[i & 15]
        }
        return n
    }
    return Pp.throwArgumentError("invalid hexlify value", "value", t)
}

function XQ(t) {
    if (typeof t != "string") t = q7(t);
    else if (!ty(t) || t.length % 2) return null;
    return (t.length - 2) / 2
}

function Aot(t, e, n) {
    return typeof t != "string" ? t = q7(t) : (!ty(t) || t.length % 2) && Pp.throwArgumentError("invalid hexData", "value", t), e = 2 + 2 * e, "0x" + t.substring(e)
}
const Tot = "bignumber/5.7.0";
var UA = Dke.BN;
const Hd = new br(Tot),
    fP = {},
    eJ = 9007199254740991;
let tJ = !1;
class Hi {
    constructor(e, n) {
        e !== fP && Hd.throwError("cannot call constructor directly; use BigNumber.from", br.errors.UNSUPPORTED_OPERATION, {
            operation: "new (BigNumber)"
        }), this._hex = n, this._isBigNumber = !0, Object.freeze(this)
    }
    fromTwos(e) {
        return Ia(Yn(this).fromTwos(e))
    }
    toTwos(e) {
        return Ia(Yn(this).toTwos(e))
    }
    abs() {
        return this._hex[0] === "-" ? Hi.from(this._hex.substring(1)) : this
    }
    add(e) {
        return Ia(Yn(this).add(Yn(e)))
    }
    sub(e) {
        return Ia(Yn(this).sub(Yn(e)))
    }
    div(e) {
        return Hi.from(e).isZero() && tc("division-by-zero", "div"), Ia(Yn(this).div(Yn(e)))
    }
    mul(e) {
        return Ia(Yn(this).mul(Yn(e)))
    }
    mod(e) {
        const n = Yn(e);
        return n.isNeg() && tc("division-by-zero", "mod"), Ia(Yn(this).umod(n))
    }
    pow(e) {
        const n = Yn(e);
        return n.isNeg() && tc("negative-power", "pow"), Ia(Yn(this).pow(n))
    }
    and(e) {
        const n = Yn(e);
        return (this.isNegative() || n.isNeg()) && tc("unbound-bitwise-result", "and"), Ia(Yn(this).and(n))
    }
    or(e) {
        const n = Yn(e);
        return (this.isNegative() || n.isNeg()) && tc("unbound-bitwise-result", "or"), Ia(Yn(this).or(n))
    }
    xor(e) {
        const n = Yn(e);
        return (this.isNegative() || n.isNeg()) && tc("unbound-bitwise-result", "xor"), Ia(Yn(this).xor(n))
    }
    mask(e) {
        return (this.isNegative() || e < 0) && tc("negative-width", "mask"), Ia(Yn(this).maskn(e))
    }
    shl(e) {
        return (this.isNegative() || e < 0) && tc("negative-width", "shl"), Ia(Yn(this).shln(e))
    }
    shr(e) {
        return (this.isNegative() || e < 0) && tc("negative-width", "shr"), Ia(Yn(this).shrn(e))
    }
    eq(e) {
        return Yn(this).eq(Yn(e))
    }
    lt(e) {
        return Yn(this).lt(Yn(e))
    }
    lte(e) {
        return Yn(this).lte(Yn(e))
    }
    gt(e) {
        return Yn(this).gt(Yn(e))
    }
    gte(e) {
        return Yn(this).gte(Yn(e))
    }
    isNegative() {
        return this._hex[0] === "-"
    }
    isZero() {
        return Yn(this).isZero()
    }
    toNumber() {
        try {
            return Yn(this).toNumber()
        } catch {
            tc("overflow", "toNumber", this.toString())
        }
        return null
    }
    toBigInt() {
        try {
            return BigInt(this.toString())
        } catch {}
        return Hd.throwError("this platform does not support BigInt", br.errors.UNSUPPORTED_OPERATION, {
            value: this.toString()
        })
    }
    toString() {
        return arguments.length > 0 && (arguments[0] === 10 ? tJ || (tJ = !0, Hd.warn("BigNumber.toString does not accept any parameters; base-10 is assumed")) : arguments[0] === 16 ? Hd.throwError("BigNumber.toString does not accept any parameters; use bigNumber.toHexString()", br.errors.UNEXPECTED_ARGUMENT, {}) : Hd.throwError("BigNumber.toString does not accept parameters", br.errors.UNEXPECTED_ARGUMENT, {})), Yn(this).toString(10)
    }
    toHexString() {
        return this._hex
    }
    toJSON(e) {
        return {
            type: "BigNumber",
            hex: this.toHexString()
        }
    }
    static from(e) {
        if (e instanceof Hi) return e;
        if (typeof e == "string") return e.match(/^-?0x[0-9a-f]+$/i) ? new Hi(fP, D6(e)) : e.match(/^-?[0-9]+$/) ? new Hi(fP, D6(new UA(e))) : Hd.throwArgumentError("invalid BigNumber string", "value", e);
        if (typeof e == "number") return e % 1 && tc("underflow", "BigNumber.from", e), (e >= eJ || e <= -eJ) && tc("overflow", "BigNumber.from", e), Hi.from(String(e));
        const n = e;
        if (typeof n == "bigint") return Hi.from(n.toString());
        if (wU(n)) return Hi.from(q7(n));
        if (n)
            if (n.toHexString) {
                const r = n.toHexString();
                if (typeof r == "string") return Hi.from(r)
            } else {
                let r = n._hex;
                if (r == null && n.type === "BigNumber" && (r = n.hex), typeof r == "string" && (ty(r) || r[0] === "-" && ty(r.substring(1)))) return Hi.from(r)
            }
        return Hd.throwArgumentError("invalid BigNumber value", "value", e)
    }
    static isBigNumber(e) {
        return !!(e && e._isBigNumber)
    }
}

function D6(t) {
    if (typeof t != "string") return D6(t.toString(16));
    if (t[0] === "-") return t = t.substring(1), t[0] === "-" && Hd.throwArgumentError("invalid hex", "value", t), t = D6(t), t === "0x00" ? t : "-" + t;
    if (t.substring(0, 2) !== "0x" && (t = "0x" + t), t === "0x") return "0x00";
    for (t.length % 2 && (t = "0x0" + t.substring(2)); t.length > 4 && t.substring(0, 4) === "0x00";) t = "0x" + t.substring(4);
    return t
}

function Ia(t) {
    return Hi.from(D6(t))
}

function Yn(t) {
    const e = Hi.from(t).toHexString();
    return e[0] === "-" ? new UA("-" + e.substring(3), 16) : new UA(e.substring(2), 16)
}

function tc(t, e, n) {
    const r = {
        fault: t,
        operation: e
    };
    return n != null && (r.value = n), Hd.throwError(t, br.errors.NUMERIC_FAULT, r)
}

function Iot(t) {
    return new UA(t, 36).toString(16)
}
const Rot = "strings/5.7.0",
    Oot = new br(Rot);
var jA;
(function(t) {
    t.current = "", t.NFC = "NFC", t.NFD = "NFD", t.NFKC = "NFKC", t.NFKD = "NFKD"
})(jA || (jA = {}));
var nJ;
(function(t) {
    t.UNEXPECTED_CONTINUE = "unexpected continuation byte", t.BAD_PREFIX = "bad codepoint prefix", t.OVERRUN = "string overrun", t.MISSING_CONTINUE = "missing continuation byte", t.OUT_OF_RANGE = "out of UTF-8 range", t.UTF16_SURROGATE = "UTF-16 surrogate", t.OVERLONG = "overlong representation"
})(nJ || (nJ = {}));

function Not(t, e = jA.current) {
    e != jA.current && (Oot.checkNormalize(), t = t.normalize(e));
    let n = [];
    for (let r = 0; r < t.length; r++) {
        const i = t.charCodeAt(r);
        if (i < 128) n.push(i);
        else if (i < 2048) n.push(i >> 6 | 192), n.push(i & 63 | 128);
        else if ((i & 64512) == 55296) {
            r++;
            const s = t.charCodeAt(r);
            if (r >= t.length || (s & 64512) !== 56320) throw new Error("invalid utf-8 string");
            const o = 65536 + ((i & 1023) << 10) + (s & 1023);
            n.push(o >> 18 | 240), n.push(o >> 12 & 63 | 128), n.push(o >> 6 & 63 | 128), n.push(o & 63 | 128)
        } else n.push(i >> 12 | 224), n.push(i >> 6 & 63 | 128), n.push(i & 63 | 128)
    }
    return Lf(n)
}
var sE, _b, aT, ede;
class K7 {
    constructor(e, n) {
        _e(this, aT);
        _e(this, sE);
        _e(this, _b);
        le(this, sE, e), le(this, _b, n.filter(i => i.type === "function"));
        const r = W(this, _b).filter(i => i.stateMutability === "pure" || i.stateMutability === "view");
        for (const i of r) {
            const s = i.name;
            if (!s) continue;
            const o = De(this, aT, ede).call(this, s);
            this[s] || Object.defineProperty(this, s, {
                enumerable: !0,
                value: o,
                writable: !1
            })
        }
    }
}
sE = new WeakMap, _b = new WeakMap, aT = new WeakSet, ede = function(e) {
    return (...n) => {
        const r = W(this, sE),
            i = W(this, _b).find(a => a.name === e),
            s = (i == null ? void 0 : i.inputs) || [],
            o = (i == null ? void 0 : i.outputs) || [];
        return {
            contract: {
                address: r
            },
            name: e,
            inputs: s,
            outputs: o,
            params: n
        }
    }
};
const Pot = [{
        inputs: [{
            components: [{
                internalType: "address",
                name: "target",
                type: "address"
            }, {
                internalType: "bytes",
                name: "callData",
                type: "bytes"
            }],
            internalType: "struct DeploylessMulticall.Call[]",
            name: "calls",
            type: "tuple[]"
        }],
        stateMutability: "nonpayable",
        type: "constructor"
    }],
    kot = [{
        inputs: [{
            internalType: "bool",
            name: "requireSuccess",
            type: "bool"
        }, {
            components: [{
                internalType: "address",
                name: "target",
                type: "address"
            }, {
                internalType: "bytes",
                name: "callData",
                type: "bytes"
            }],
            internalType: "struct DeploylessMulticall2.Call[]",
            name: "calls",
            type: "tuple[]"
        }],
        stateMutability: "nonpayable",
        type: "constructor"
    }],
    Mot = [{
        inputs: [{
            components: [{
                internalType: "address",
                name: "target",
                type: "address"
            }, {
                internalType: "bool",
                name: "allowFailure",
                type: "bool"
            }, {
                internalType: "bytes",
                name: "callData",
                type: "bytes"
            }],
            internalType: "struct DeploylessMulticall3.Call[]",
            name: "calls",
            type: "tuple[]"
        }],
        stateMutability: "nonpayable",
        type: "constructor"
    }],
    bU = [{
        constant: !0,
        inputs: [{
            components: [{
                internalType: "address",
                name: "target",
                type: "address"
            }, {
                internalType: "bytes",
                name: "callData",
                type: "bytes"
            }],
            internalType: "struct Multicall.Call[]",
            name: "calls",
            type: "tuple[]"
        }],
        name: "aggregate",
        outputs: [{
            internalType: "uint256",
            name: "blockNumber",
            type: "uint256"
        }, {
            internalType: "bytes[]",
            name: "returnData",
            type: "bytes[]"
        }],
        payable: !1,
        stateMutability: "view",
        type: "function"
    }, {
        constant: !0,
        inputs: [{
            internalType: "uint256",
            name: "blockNumber",
            type: "uint256"
        }],
        name: "getBlockHash",
        outputs: [{
            internalType: "bytes32",
            name: "blockHash",
            type: "bytes32"
        }],
        payable: !1,
        stateMutability: "view",
        type: "function"
    }, {
        constant: !0,
        inputs: [],
        name: "getCurrentBlockCoinbase",
        outputs: [{
            internalType: "address",
            name: "coinbase",
            type: "address"
        }],
        payable: !1,
        stateMutability: "view",
        type: "function"
    }, {
        constant: !0,
        inputs: [],
        name: "getCurrentBlockDifficulty",
        outputs: [{
            internalType: "uint256",
            name: "difficulty",
            type: "uint256"
        }],
        payable: !1,
        stateMutability: "view",
        type: "function"
    }, {
        constant: !0,
        inputs: [],
        name: "getCurrentBlockGasLimit",
        outputs: [{
            internalType: "uint256",
            name: "gaslimit",
            type: "uint256"
        }],
        payable: !1,
        stateMutability: "view",
        type: "function"
    }, {
        constant: !0,
        inputs: [],
        name: "getCurrentBlockTimestamp",
        outputs: [{
            internalType: "uint256",
            name: "timestamp",
            type: "uint256"
        }],
        payable: !1,
        stateMutability: "view",
        type: "function"
    }, {
        constant: !0,
        inputs: [{
            internalType: "address",
            name: "addr",
            type: "address"
        }],
        name: "getEthBalance",
        outputs: [{
            internalType: "uint256",
            name: "balance",
            type: "uint256"
        }],
        payable: !1,
        stateMutability: "view",
        type: "function"
    }, {
        constant: !0,
        inputs: [],
        name: "getLastBlockHash",
        outputs: [{
            internalType: "bytes32",
            name: "blockHash",
            type: "bytes32"
        }],
        payable: !1,
        stateMutability: "view",
        type: "function"
    }],
    tde = [{
        inputs: [{
            components: [{
                internalType: "address",
                name: "target",
                type: "address"
            }, {
                internalType: "bytes",
                name: "callData",
                type: "bytes"
            }],
            internalType: "struct Multicall2.Call[]",
            name: "calls",
            type: "tuple[]"
        }],
        name: "aggregate",
        outputs: [{
            internalType: "uint256",
            name: "blockNumber",
            type: "uint256"
        }, {
            internalType: "bytes[]",
            name: "returnData",
            type: "bytes[]"
        }],
        payable: !1,
        stateMutability: "view",
        type: "function"
    }, {
        inputs: [{
            components: [{
                internalType: "address",
                name: "target",
                type: "address"
            }, {
                internalType: "bytes",
                name: "callData",
                type: "bytes"
            }],
            internalType: "struct Multicall2.Call[]",
            name: "calls",
            type: "tuple[]"
        }],
        name: "blockAndAggregate",
        outputs: [{
            internalType: "uint256",
            name: "blockNumber",
            type: "uint256"
        }, {
            internalType: "bytes32",
            name: "blockHash",
            type: "bytes32"
        }, {
            components: [{
                internalType: "bool",
                name: "success",
                type: "bool"
            }, {
                internalType: "bytes",
                name: "returnData",
                type: "bytes"
            }],
            internalType: "struct Multicall2.Result[]",
            name: "returnData",
            type: "tuple[]"
        }],
        stateMutability: "nonpayable",
        type: "function"
    }, {
        inputs: [{
            internalType: "uint256",
            name: "blockNumber",
            type: "uint256"
        }],
        name: "getBlockHash",
        outputs: [{
            internalType: "bytes32",
            name: "blockHash",
            type: "bytes32"
        }],
        stateMutability: "view",
        type: "function"
    }, {
        inputs: [],
        name: "getBlockNumber",
        outputs: [{
            internalType: "uint256",
            name: "blockNumber",
            type: "uint256"
        }],
        stateMutability: "view",
        type: "function"
    }, {
        inputs: [],
        name: "getCurrentBlockCoinbase",
        outputs: [{
            internalType: "address",
            name: "coinbase",
            type: "address"
        }],
        stateMutability: "view",
        type: "function"
    }, {
        inputs: [],
        name: "getCurrentBlockDifficulty",
        outputs: [{
            internalType: "uint256",
            name: "difficulty",
            type: "uint256"
        }],
        stateMutability: "view",
        type: "function"
    }, {
        inputs: [],
        name: "getCurrentBlockGasLimit",
        outputs: [{
            internalType: "uint256",
            name: "gaslimit",
            type: "uint256"
        }],
        stateMutability: "view",
        type: "function"
    }, {
        inputs: [],
        name: "getCurrentBlockTimestamp",
        outputs: [{
            internalType: "uint256",
            name: "timestamp",
            type: "uint256"
        }],
        stateMutability: "view",
        type: "function"
    }, {
        inputs: [{
            internalType: "address",
            name: "addr",
            type: "address"
        }],
        name: "getEthBalance",
        outputs: [{
            internalType: "uint256",
            name: "balance",
            type: "uint256"
        }],
        stateMutability: "view",
        type: "function"
    }, {
        inputs: [],
        name: "getLastBlockHash",
        outputs: [{
            internalType: "bytes32",
            name: "blockHash",
            type: "bytes32"
        }],
        stateMutability: "view",
        type: "function"
    }, {
        inputs: [{
            internalType: "bool",
            name: "requireSuccess",
            type: "bool"
        }, {
            components: [{
                internalType: "address",
                name: "target",
                type: "address"
            }, {
                internalType: "bytes",
                name: "callData",
                type: "bytes"
            }],
            internalType: "struct Multicall2.Call[]",
            name: "calls",
            type: "tuple[]"
        }],
        name: "tryAggregate",
        outputs: [{
            components: [{
                internalType: "bool",
                name: "success",
                type: "bool"
            }, {
                internalType: "bytes",
                name: "returnData",
                type: "bytes"
            }],
            internalType: "struct Multicall2.Result[]",
            name: "returnData",
            type: "tuple[]"
        }],
        payable: !1,
        stateMutability: "view",
        type: "function"
    }, {
        inputs: [{
            internalType: "bool",
            name: "requireSuccess",
            type: "bool"
        }, {
            components: [{
                internalType: "address",
                name: "target",
                type: "address"
            }, {
                internalType: "bytes",
                name: "callData",
                type: "bytes"
            }],
            internalType: "struct Multicall2.Call[]",
            name: "calls",
            type: "tuple[]"
        }],
        name: "tryBlockAndAggregate",
        outputs: [{
            internalType: "uint256",
            name: "blockNumber",
            type: "uint256"
        }, {
            internalType: "bytes32",
            name: "blockHash",
            type: "bytes32"
        }, {
            components: [{
                internalType: "bool",
                name: "success",
                type: "bool"
            }, {
                internalType: "bytes",
                name: "returnData",
                type: "bytes"
            }],
            internalType: "struct Multicall2.Result[]",
            name: "returnData",
            type: "tuple[]"
        }],
        stateMutability: "nonpayable",
        type: "function"
    }],
    nde = [{
        inputs: [{
            components: [{
                internalType: "address",
                name: "target",
                type: "address"
            }, {
                internalType: "bytes",
                name: "callData",
                type: "bytes"
            }],
            internalType: "struct Multicall3.Call[]",
            name: "calls",
            type: "tuple[]"
        }],
        name: "aggregate",
        outputs: [{
            internalType: "uint256",
            name: "blockNumber",
            type: "uint256"
        }, {
            internalType: "bytes[]",
            name: "returnData",
            type: "bytes[]"
        }],
        stateMutability: "view",
        type: "function"
    }, {
        inputs: [{
            components: [{
                internalType: "address",
                name: "target",
                type: "address"
            }, {
                internalType: "bool",
                name: "allowFailure",
                type: "bool"
            }, {
                internalType: "bytes",
                name: "callData",
                type: "bytes"
            }],
            internalType: "struct Multicall3.Call3[]",
            name: "calls",
            type: "tuple[]"
        }],
        name: "aggregate3",
        outputs: [{
            components: [{
                internalType: "bool",
                name: "success",
                type: "bool"
            }, {
                internalType: "bytes",
                name: "returnData",
                type: "bytes"
            }],
            internalType: "struct Multicall3.Result[]",
            name: "returnData",
            type: "tuple[]"
        }],
        stateMutability: "view",
        type: "function"
    }, {
        inputs: [{
            components: [{
                internalType: "address",
                name: "target",
                type: "address"
            }, {
                internalType: "bool",
                name: "allowFailure",
                type: "bool"
            }, {
                internalType: "uint256",
                name: "value",
                type: "uint256"
            }, {
                internalType: "bytes",
                name: "callData",
                type: "bytes"
            }],
            internalType: "struct Multicall3.Call3Value[]",
            name: "calls",
            type: "tuple[]"
        }],
        name: "aggregate3Value",
        outputs: [{
            components: [{
                internalType: "bool",
                name: "success",
                type: "bool"
            }, {
                internalType: "bytes",
                name: "returnData",
                type: "bytes"
            }],
            internalType: "struct Multicall3.Result[]",
            name: "returnData",
            type: "tuple[]"
        }],
        stateMutability: "payable",
        type: "function"
    }, {
        inputs: [{
            components: [{
                internalType: "address",
                name: "target",
                type: "address"
            }, {
                internalType: "bytes",
                name: "callData",
                type: "bytes"
            }],
            internalType: "struct Multicall3.Call[]",
            name: "calls",
            type: "tuple[]"
        }],
        name: "blockAndAggregate",
        outputs: [{
            internalType: "uint256",
            name: "blockNumber",
            type: "uint256"
        }, {
            internalType: "bytes32",
            name: "blockHash",
            type: "bytes32"
        }, {
            components: [{
                internalType: "bool",
                name: "success",
                type: "bool"
            }, {
                internalType: "bytes",
                name: "returnData",
                type: "bytes"
            }],
            internalType: "struct Multicall3.Result[]",
            name: "returnData",
            type: "tuple[]"
        }],
        stateMutability: "view",
        type: "function"
    }, {
        inputs: [],
        name: "getBasefee",
        outputs: [{
            internalType: "uint256",
            name: "basefee",
            type: "uint256"
        }],
        stateMutability: "view",
        type: "function"
    }, {
        inputs: [{
            internalType: "uint256",
            name: "blockNumber",
            type: "uint256"
        }],
        name: "getBlockHash",
        outputs: [{
            internalType: "bytes32",
            name: "blockHash",
            type: "bytes32"
        }],
        stateMutability: "view",
        type: "function"
    }, {
        inputs: [],
        name: "getBlockNumber",
        outputs: [{
            internalType: "uint256",
            name: "blockNumber",
            type: "uint256"
        }],
        stateMutability: "view",
        type: "function"
    }, {
        inputs: [],
        name: "getChainId",
        outputs: [{
            internalType: "uint256",
            name: "chainid",
            type: "uint256"
        }],
        stateMutability: "view",
        type: "function"
    }, {
        inputs: [],
        name: "getCurrentBlockCoinbase",
        outputs: [{
            internalType: "address",
            name: "coinbase",
            type: "address"
        }],
        stateMutability: "view",
        type: "function"
    }, {
        inputs: [],
        name: "getCurrentBlockDifficulty",
        outputs: [{
            internalType: "uint256",
            name: "difficulty",
            type: "uint256"
        }],
        stateMutability: "view",
        type: "function"
    }, {
        inputs: [],
        name: "getCurrentBlockGasLimit",
        outputs: [{
            internalType: "uint256",
            name: "gaslimit",
            type: "uint256"
        }],
        stateMutability: "view",
        type: "function"
    }, {
        inputs: [],
        name: "getCurrentBlockTimestamp",
        outputs: [{
            internalType: "uint256",
            name: "timestamp",
            type: "uint256"
        }],
        stateMutability: "view",
        type: "function"
    }, {
        inputs: [{
            internalType: "address",
            name: "addr",
            type: "address"
        }],
        name: "getEthBalance",
        outputs: [{
            internalType: "uint256",
            name: "balance",
            type: "uint256"
        }],
        stateMutability: "view",
        type: "function"
    }, {
        inputs: [],
        name: "getLastBlockHash",
        outputs: [{
            internalType: "bytes32",
            name: "blockHash",
            type: "bytes32"
        }],
        stateMutability: "view",
        type: "function"
    }, {
        inputs: [{
            internalType: "bool",
            name: "requireSuccess",
            type: "bool"
        }, {
            components: [{
                internalType: "address",
                name: "target",
                type: "address"
            }, {
                internalType: "bytes",
                name: "callData",
                type: "bytes"
            }],
            internalType: "struct Multicall3.Call[]",
            name: "calls",
            type: "tuple[]"
        }],
        name: "tryAggregate",
        outputs: [{
            components: [{
                internalType: "bool",
                name: "success",
                type: "bool"
            }, {
                internalType: "bytes",
                name: "returnData",
                type: "bytes"
            }],
            internalType: "struct Multicall3.Result[]",
            name: "returnData",
            type: "tuple[]"
        }],
        stateMutability: "view",
        type: "function"
    }, {
        inputs: [{
            internalType: "bool",
            name: "requireSuccess",
            type: "bool"
        }, {
            components: [{
                internalType: "address",
                name: "target",
                type: "address"
            }, {
                internalType: "bytes",
                name: "callData",
                type: "bytes"
            }],
            internalType: "struct Multicall3.Call[]",
            name: "calls",
            type: "tuple[]"
        }],
        name: "tryBlockAndAggregate",
        outputs: [{
            internalType: "uint256",
            name: "blockNumber",
            type: "uint256"
        }, {
            internalType: "bytes32",
            name: "blockHash",
            type: "bytes32"
        }, {
            components: [{
                internalType: "bool",
                name: "success",
                type: "bool"
            }, {
                internalType: "bytes",
                name: "returnData",
                type: "bytes"
            }],
            internalType: "struct Multicall3.Result[]",
            name: "returnData",
            type: "tuple[]"
        }],
        stateMutability: "nonpayable",
        type: "function"
    }];
class Nf {
    constructor(e) {
        Object.defineProperty(this, "abi", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: void 0
        }), this.abi = e
    }
    getFunctionSelector(e) {
        const n = this.getFunctionByName(e),
            r = n == null ? void 0 : n.inputs;
        if (!r) throw Error;
        const i = r.map(a => Rr.from(a)),
            s = Nf.getSignature(e, i);
        return hw(s).substring(0, 10)
    }
    getEventTopic(e) {
        const n = this.getEventByName(e),
            r = n == null ? void 0 : n.inputs;
        if (!r) throw Error;
        const i = r.map(o => Rr.from(o, !0)),
            s = Nf.getSignature(e, i);
        return hw(s)
    }
    decodeConstructor(e) {
        const n = this.getConstructor(),
            r = n == null ? void 0 : n.inputs;
        if (!r) throw Error;
        const i = r.map(a => Rr.from(a)),
            s = Jo.defaultAbiCoder().decode(i, e),
            o = BS(s, i);
        return {
            inputs: i,
            values: o
        }
    }
    decodeEvent(e, n) {
        const r = this.getEventByTopic(e[0]),
            [, ...i] = e,
            s = r == null ? void 0 : r.inputs;
        if (!s) throw Error;
        const o = s.map(_ => Rr.from(_, !0)),
            l = o.filter(_ => _.indexed).map((_, C) => {
                const b = i[C],
                    w = Jo.defaultAbiCoder().decode([_], b),
                    [S] = w;
                return S
            }),
            c = o.filter(_ => !_.indexed),
            u = Jo.defaultAbiCoder().decode(c, n);
        if (!r.name) throw Error;
        let f = 0,
            h = 0;
        const g = new Wp;
        for (const _ of o) _.indexed ? (g.push(l[f]), f++) : (g.push(u[h]), h++);
        const y = BS(g, o);
        return {
            name: r.name,
            inputs: o,
            values: y
        }
    }
    decodeFunction(e) {
        const n = e.substring(0, 10),
            r = this.getFunctionBySelector(n),
            i = r == null ? void 0 : r.inputs;
        if (!i) throw Error;
        const s = i.map(c => Rr.from(c)),
            o = `0x${e.substring(10)}`,
            a = Jo.defaultAbiCoder().decode(s, o),
            l = BS(a, s);
        if (!r.name) throw Error;
        return {
            name: r.name,
            inputs: s,
            values: l
        }
    }
    decodeFunctionOutput(e, n) {
        const r = this.getFunctionByName(e),
            i = r == null ? void 0 : r.outputs;
        if (!i) throw Error;
        const s = i.map(l => Rr.from(l)),
            o = Jo.defaultAbiCoder().decode(s, n),
            a = BS(o, s);
        return {
            name: e,
            outputs: s,
            values: a
        }
    }
    encodeConstructor(e) {
        const n = this.getConstructor(),
            r = n == null ? void 0 : n.inputs;
        if (!r) throw Error;
        const i = r.map(o => Rr.from(o)),
            s = dP(e, i);
        return Jo.defaultAbiCoder().encode(i, s)
    }
    encodeEvent(e, n) {
        const r = this.getEventByName(e),
            i = r == null ? void 0 : r.inputs;
        if (!i) throw Error;
        const s = i.map(_ => Rr.from(_, !0)),
            o = Nf.getSignature(e, s),
            a = hw(o),
            l = new Wp,
            c = [];
        for (let _ = 0; _ < s.length; _++) {
            const C = s[_],
                b = n[C.name];
            C.indexed ? l.push(b) : c.push(b)
        }
        const f = s.filter(_ => _.indexed).map((_, C) => Jo.defaultAbiCoder().encode([_], [l[C]])),
            h = [a, ...f],
            g = s.filter(_ => !_.indexed),
            y = Jo.defaultAbiCoder().encode(g, c);
        return {
            topics: h,
            data: y
        }
    }
    encodeFunction(e, n) {
        const r = this.getFunctionByName(e),
            i = r == null ? void 0 : r.inputs;
        if (!i) throw Error;
        const s = i.map(h => Rr.from(h)),
            o = Nf.getSignature(e, s),
            a = hw(o).substring(2, 10),
            l = dP(n, s),
            u = Jo.defaultAbiCoder().encode(s, l).substring(2);
        return `0x${a}${u}`
    }
    encodeFunctionOutput(e, n) {
        const i = this.getFunctionByName(e).outputs;
        if (!i) throw Error;
        const s = i.map(a => Rr.from(a)),
            o = dP(n, s);
        return Jo.defaultAbiCoder().encode(s, o)
    }
    getConstructor() {
        const e = this.abi.find(n => n.type === "constructor");
        if (!e) throw Error;
        return e
    }
    getFunctionByName(e) {
        const n = this.abi.find(r => r.type === "function" && r.name === e);
        if (!n) throw Error;
        return n
    }
    getFunctionBySelector(e) {
        const r = this.abi.filter(i => i.type === "function" || i.type === "error").find(i => {
            const s = i.name,
                o = i.inputs;
            if (!s || !o) return !1;
            const a = o.map(f => Rr.from(f)),
                l = Nf.getSignature(s, a);
            return hw(l).substring(0, 10) === e
        });
        if (!r) throw Error;
        return r
    }
    getEventByName(e) {
        const n = this.abi.find(r => r.type === "event" && r.name === e);
        if (!n) throw Error;
        return n
    }
    getEventByTopic(e) {
        const r = this.abi.filter(i => i.type === "event").find(i => {
            const s = i.name,
                o = i.inputs;
            if (!s || !o) return !1;
            const a = o.map(u => Rr.from(u, !0)),
                l = Nf.getSignature(s, a);
            return hw(l) === e
        });
        if (!r) throw Error;
        return r
    }
    static getSignature(e, n) {
        const r = [];
        for (const o of n) {
            const a = this.getInputSignature(o);
            r.push(a)
        }
        const i = r.join(",");
        return `${e}(${i})`
    }
    static getInputSignature(e) {
        if (e.baseType === "array") {
            const n = e.arrayLength && e.arrayLength >= 0 ? `[${e.arrayLength}]` : "[]";
            if (!e.arrayChildren) throw Error;
            return `${this.getInputSignature(e.arrayChildren)}${n}`
        }
        if (e.baseType === "tuple") {
            if (!e.components) throw Error;
            return `(${e.components.map(n=>this.getInputSignature(n)).join(",")})`
        }
        return e.type
    }
}

function hw(t) {
    return fs(qf(t))
}

function BS(t, e) {
    return Object.fromEntries(t.toArray().map((n, r) => [e[r].name, n]))
}

function dP(t, e) {
    return e.map(n => t[n.name])
}
class kc {
    static encode(e, n, r) {
        const {
            params: i
        } = hP(n), s = [{
            type: "function",
            name: e,
            inputs: i
        }], o = new Nf(s), a = Object.fromEntries(i.map((l, c) => [l.name, r[c]]));
        return o.encodeFunction(e, a)
    }
    static encodeConstructor(e, n) {
        const {
            params: r
        } = hP(e), i = [{
            type: "constructor",
            inputs: r
        }], s = new Nf(i), o = Object.fromEntries(r.map((a, l) => [a.name, n[l]]));
        return s.encodeConstructor(o)
    }
    static decode(e, n, r) {
        const {
            params: i,
            generated: s
        } = hP(n), o = [{
            type: "function",
            name: e,
            outputs: i
        }], l = new Nf(o).decodeFunctionOutput(e, r), c = i.map(u => l.values[u.name || ""]);
        for (const [u, f] of Object.entries(l.values)) {
            const h = u;
            s.has(u) || c[h] || (c[h] = f)
        }
        return c
    }
}

function hP(t) {
    const e = new Set(...t.map(i => i.name)),
        n = new Set;
    return {
        params: t.map(i => {
            const {
                name: s,
                indexed: o,
                type: a,
                components: l
            } = i, c = s || Dot(e);
            return e.add(c), s || n.add(c), {
                name: c,
                indexed: o,
                type: a,
                components: l
            }
        }),
        generated: n
    }
}

function Dot(t) {
    let e = 0;
    for (; t.has(e.toString());) e++;
    return `param${Math.random().toString().substring(2)}`
}

function $ot(t) {
    const n = {
        1: {
            address: "0xeefba1e63905ef1d7acba5a8513c70307c1ce441",
            block: 7929876
        },
        3: {
            address: "0x53c43764255c17bd724f74c4ef150724ac50a3ed",
            block: 7980811
        },
        4: {
            address: "0x42ad527de7d4e9d9d011ac45b31d8551f8fe9821",
            block: 4534725
        },
        5: {
            address: "0x77dca2c955b15e9de4dbbcf1246b4b85b651e50e",
            block: 743550
        },
        10: {
            address: "0x266557A864680A1401A3506c0eb72934BD13Bf59",
            block: 0
        },
        25: {
            address: "0x5e954f5972EC6BFc7dECd75779F10d848230345F",
            block: 0
        },
        42: {
            address: "0x2cc8688c5f75e365aaeeb4ea8d6a480405a48d2a",
            block: 11482433
        },
        56: {
            address: "0xe21a5b299756ee452a6a871ff29852862fc99be9",
            block: 0
        },
        100: {
            address: "0xb5b692a88bdfc81ca69dcb1d924f59f0413a602a",
            block: 0
        },
        106: {
            address: "0x0747CFe82D3Bee998f634569FE2B0005dF9d8EDE",
            block: 0
        },
        108: {
            address: "0xfce4609743e17d349b7e5f478a7a9a6cfa3c808c",
            block: 0
        },
        128: {
            address: "0x56171094a15b8cac4314c0f8930100b939503bd9",
            block: 0
        },
        137: {
            address: "0x35e4aa226ce52e1e59e5e5ec24766007bcbe2e7d",
            block: 12608630
        },
        250: {
            address: "0xc04d660976c923ddba750341fe5923e47900cf24",
            block: 0
        },
        288: {
            address: "0x650129FB67354eF8C148a8CDb1a2d5E01B520CaD",
            block: 0
        },
        321: {
            address: "0x543528e13eac69206e87334cca971503a552438b",
            block: 0
        },
        324: {
            address: "0x52806DC8c5Cb95a560039409FE2e1C29d9eBb22f",
            block: 9531405
        },
        592: {
            address: "0x57F40bbBCc11BE5471a8f9bF1dE56816a1CF08f6",
            block: 0
        },
        820: {
            address: "0x8ba3d23241c7044be703afaf2a728fdbc16f5f6f",
            block: 0
        },
        1234: {
            address: "0x176CcFFbAB792Aaa0da7C430FE20a7106d969f66",
            block: 22
        },
        1284: {
            address: "0x83e3b61886770de2F64AAcaD2724ED4f08F7f36B",
            block: 0
        },
        1337: {
            address: "0x77dca2c955b15e9de4dbbcf1246b4b85b651e50e",
            block: 0
        },
        3999: {
            address: "0xFC8bd6469c65d58fBf969512Be1564579cEc4855",
            block: 859439
        },
        4689: {
            address: "0x0e14ded9e7965c6446df2e5c528dd1b4e3b4640f",
            block: 0
        },
        31337: {
            address: "0xeefba1e63905ef1d7acba5a8513c70307c1ce441",
            block: 0
        },
        42161: {
            address: "0x10126ceb60954bc35049f24e819a380c505f8a0f",
            block: 0
        },
        42262: {
            address: "0xAC84239C64D4E21c98C905Eca62af0b56017B8F6",
            block: 0
        },
        43114: {
            address: "0xE8eeDd99baC03871CF123E76cE90bA179Df94351",
            block: 0
        },
        80001: {
            address: "0x08411add0b5aa8ee47563b146743c13b3556c9cc",
            block: 12011090
        },
        1313161554: {
            address: "0xa48c67d1c60b8187ecb7c549e8a670419d356994",
            block: 0
        },
        16666e5: {
            address: "0xfe4980f62d708c2a84d3929859ea226340759320",
            block: 0
        },
        73927: {
            address: "0x9Fa7eAC783F772734337B99D1d5AAeAd75Cd9077",
            block: 14080409
        }
    }[t];
    return n || null
}

function Lot(t) {
    const n = {
        1: {
            address: "0x5ba1e12693dc8f9c48aad8770482f4739beed696",
            block: 12336033
        },
        4: {
            address: "0x5ba1e12693dc8f9c48aad8770482f4739beed696",
            block: 8283206
        },
        5: {
            address: "0x5ba1e12693dc8f9c48aad8770482f4739beed696",
            block: 4489716
        },
        10: {
            address: "0x054FfF7ee30953DdB739458e11EAAd51224343a1",
            block: 31946661
        },
        42: {
            address: "0x5ba1e12693dc8f9c48aad8770482f4739beed696",
            block: 24025820
        },
        56: {
            address: "0x4c6bb7c24b6f3dfdfb548e54b7c5ea4cb52a0069",
            block: 0
        },
        100: {
            address: "0x5ba1e12693dc8f9c48aad8770482f4739beed696",
            block: 0
        },
        137: {
            address: "0xf43a7be1b284aa908cdfed8b3e286961956b4d2c",
            block: 15695723
        },
        250: {
            address: "0x470ADB45f5a9ac3550bcFFaD9D990Bf7e2e941c9",
            block: 0
        },
        324: {
            address: "0xDED0Aa78681A5AbF85D830D4478cf4acF00Ec4a4",
            block: 9531409
        },
        420: {
            address: "0x9477d5bA4Ed7568eD73da6b2cbcd63D92Bb8eBB1",
            block: 3441852
        },
        1284: {
            address: "0x9256d856A13EB3732d90D88B57F33d0847Fa50bF",
            block: 0
        },
        1337: {
            address: "0x5ba1e12693dc8f9c48aad8770482f4739beed696",
            block: 0
        },
        3999: {
            address: "0xf03f60aC45EC5616516dC400C3f25Ec6Db566c9F",
            block: 859481
        },
        31337: {
            address: "0x5ba1e12693dc8f9c48aad8770482f4739beed696",
            block: 0
        },
        42161: {
            address: "0x842eC2c7D803033Edf55E478F461FC547Bc54EB2",
            block: 0
        },
        42220: {
            address: "0xE72f42c64EA3dc05D2D94F541C3a806fa161c49B",
            block: 9325322
        },
        44787: {
            address: "0xA3A2E17933C0865534Ac7839F7a860E40C95D340",
            block: 9082778
        },
        53935: {
            address: "0x5b24224dC16508DAD755756639E420817DD4c99E",
            block: 62
        },
        421611: {
            address: "0x96DB1F8055074aB62161B6Ad66Ab6B8679513DeF",
            block: 0
        },
        73927: {
            address: "0x5Ac86eC2e6332280Eff161c169aCcC345996c340",
            block: 14080778
        }
    }[t];
    return n || null
}

function Bot(t) {
    const e = "0xca11bde05977b3631167028862be2a173976ca11",
        r = {
            1: {
                address: e,
                block: 14353601
            },
            3: {
                address: e,
                block: 12063863
            },
            4: {
                address: e,
                block: 10299530
            },
            5: {
                address: e,
                block: 6507670
            },
            10: {
                address: e,
                block: 4286263
            },
            14: {
                address: e,
                block: 3002461
            },
            16: {
                address: e,
                block: 276388
            },
            19: {
                address: e,
                block: 13382504
            },
            42: {
                address: e,
                block: 30285908
            },
            56: {
                address: e,
                block: 15921452
            },
            69: {
                address: e,
                block: 1418387
            },
            97: {
                address: e,
                block: 17422483
            },
            100: {
                address: e,
                block: 21022491
            },
            114: {
                address: e,
                block: 508735
            },
            137: {
                address: e,
                block: 25770160
            },
            196: {
                address: e,
                block: 47416
            },
            250: {
                address: e,
                block: 33001987
            },
            252: {
                address: e,
                block: 0
            },
            324: {
                address: "0x413fEb613604D46586c22801949A5b88b224c260",
                block: 9531414
            },
            420: {
                address: e,
                block: 49461
            },
            1284: {
                address: e,
                block: 609002
            },
            1285: {
                address: e,
                block: 1597904
            },
            1287: {
                address: e,
                block: 1850686
            },
            2222: {
                address: "0x1578f6d2D3168acF41b506AA666A521994F6BAB6",
                block: 1176602
            },
            4002: {
                address: e,
                block: 8328688
            },
            8453: {
                address: "0xcA11bde05977b3631167028862bE2a173976CA11",
                block: 5022
            },
            42161: {
                address: e,
                block: 7654707
            },
            42220: {
                address: e,
                block: 13112599
            },
            43113: {
                address: e,
                block: 7096959
            },
            43114: {
                address: e,
                block: 11907934
            },
            80001: {
                address: e,
                block: 25444704
            },
            421611: {
                address: e,
                block: 10228837
            },
            5e3: {
                address: "0xd77b59d4cb13bea71f3cc093e401720867355d6e",
                block: 18877383
            },
            16666e5: {
                address: e,
                block: 24185753
            },
            73927: {
                address: "0x138A85647768815078DF1dD85C6121e611381A0b",
                block: 14080843
            },
            81457: {
                address: "0x23928c6f823e0d78eadc9d2f69ace652ff3cdcb1",
                block: 368182
            }
        }[t];
    return r || null
}
const Fot = "0x608060405234801561001057600080fd5b5060405161075138038061075183398181016040528101906100329190610466565b60004390506000825167ffffffffffffffff811115610054576100536106d6565b5b60405190808252806020026020018201604052801561008757816020015b60608152602001906001900390816100725790505b50905060005b83518110156102715760008073bd770416a3345f91e4b34576cb804a576fa48eb173ffffffffffffffffffffffffffffffffffffffff168684815181106100d7576100d66106a7565b5b60200260200101516000015173ffffffffffffffffffffffffffffffffffffffff16146101a757858381518110610111576101106106a7565b5b60200260200101516000015173ffffffffffffffffffffffffffffffffffffffff16868481518110610146576101456106a7565b5b60200260200101516020015160405161015f91906104e0565b6000604051808303816000865af19150503d806000811461019c576040519150601f19603f3d011682016040523d82523d6000602084013e6101a1565b606091505b5061022f565b600073ffffffffffffffffffffffffffffffffffffffff168684815181106101d2576101d16106a7565b5b6020026020010151602001516040516101eb91906104e0565b6000604051808303816000865af19150503d8060008114610228576040519150601f19603f3d011682016040523d82523d6000602084013e61022d565b606091505b505b915091508161023d57600080fd5b80848481518110610251576102506106a7565b5b6020026020010181905250505080806102699061062f565b91505061008d565b508160408203526040602082035260208101602082015b602060018451010283018110156102aa57818151038152602081019050610288565b50604082604051030160408303f35b60006102cc6102c78461051c565b6104f7565b905080838252602082019050828560208602820111156102ef576102ee610714565b5b60005b8581101561033d57815167ffffffffffffffff81111561031557610314610705565b5b80860161032289826103fa565b855260208501945060208401935050506001810190506102f2565b5050509392505050565b600061035a61035584610548565b6104f7565b90508281526020810184848401111561037657610375610719565b5b6103818482856105cb565b509392505050565b60008151905061039881610739565b92915050565b600082601f8301126103b3576103b2610705565b5b81516103c38482602086016102b9565b91505092915050565b600082601f8301126103e1576103e0610705565b5b81516103f1848260208601610347565b91505092915050565b6000604082840312156104105761040f61070a565b5b61041a60406104f7565b9050600061042a84828501610389565b600083015250602082015167ffffffffffffffff81111561044e5761044d61070f565b5b61045a848285016103cc565b60208301525092915050565b60006020828403121561047c5761047b610723565b5b600082015167ffffffffffffffff81111561049a5761049961071e565b5b6104a68482850161039e565b91505092915050565b60006104ba82610579565b6104c48185610584565b93506104d48185602086016105cb565b80840191505092915050565b60006104ec82846104af565b915081905092915050565b6000610501610512565b905061050d82826105fe565b919050565b6000604051905090565b600067ffffffffffffffff821115610537576105366106d6565b5b602082029050602081019050919050565b600067ffffffffffffffff821115610563576105626106d6565b5b61056c82610728565b9050602081019050919050565b600081519050919050565b600081905092915050565b600061059a826105a1565b9050919050565b600073ffffffffffffffffffffffffffffffffffffffff82169050919050565b6000819050919050565b60005b838110156105e95780820151818401526020810190506105ce565b838111156105f8576000848401525b50505050565b61060782610728565b810181811067ffffffffffffffff82111715610626576106256106d6565b5b80604052505050565b600061063a826105c1565b91507fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff82141561066d5761066c610678565b5b600182019050919050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b7f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b600080fd5b600080fd5b600080fd5b600080fd5b600080fd5b600080fd5b600080fd5b6000601f19601f8301169050919050565b6107428161058f565b811461074d57600080fd5b5056fe",
    Uot = "0x608060405234801561001057600080fd5b5060405161087538038061087583398181016040528101906100329190610666565b6000815167ffffffffffffffff81111561004f5761004e610358565b5b60405190808252806020026020018201604052801561008857816020015b6100756102da565b81526020019060019003908161006d5790505b50905060005b82518110156101d3576000808483815181106100ad576100ac6106c2565b5b60200260200101516000015173ffffffffffffffffffffffffffffffffffffffff168584815181106100e2576100e16106c2565b5b6020026020010151602001516040516100fb9190610738565b6000604051808303816000865af19150503d8060008114610138576040519150601f19603f3d011682016040523d82523d6000602084013e61013d565b606091505b509150915085156101895781610188576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161017f906107d2565b60405180910390fd5b5b60405180604001604052808315158152602001828152508484815181106101b3576101b26106c2565b5b6020026020010181905250505080806101cb9061082b565b91505061008e565b50602081516040028260405103030160408160405103036001835111156102535760005b8351811015610251578060200260208501018160200260400183018261021f57855160200281525b6000831115610244576020808303510151602083510151038060208303510180835250505b50506001810190506101f7565b505b60005b8351811015610281578060200260208501018051516040602083510151035250600181019050610256565b5060005b83518110156102ae57806020026020850101604060208083510151035250600181019050610285565b506001835114156102cb5760208301604082018451602002815250505b60208152825160208201528181f35b6040518060400160405280600015158152602001606081525090565b6000604051905090565b600080fd5b600080fd5b60008115159050919050565b61031f8161030a565b811461032a57600080fd5b50565b60008151905061033c81610316565b92915050565b600080fd5b6000601f19601f8301169050919050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b61039082610347565b810181811067ffffffffffffffff821117156103af576103ae610358565b5b80604052505050565b60006103c26102f6565b90506103ce8282610387565b919050565b600067ffffffffffffffff8211156103ee576103ed610358565b5b602082029050602081019050919050565b600080fd5b600080fd5b600080fd5b600073ffffffffffffffffffffffffffffffffffffffff82169050919050565b60006104398261040e565b9050919050565b6104498161042e565b811461045457600080fd5b50565b60008151905061046681610440565b92915050565b600080fd5b600067ffffffffffffffff82111561048c5761048b610358565b5b61049582610347565b9050602081019050919050565b60005b838110156104c05780820151818401526020810190506104a5565b838111156104cf576000848401525b50505050565b60006104e86104e384610471565b6103b8565b9050828152602081018484840111156105045761050361046c565b5b61050f8482856104a2565b509392505050565b600082601f83011261052c5761052b610342565b5b815161053c8482602086016104d5565b91505092915050565b60006040828403121561055b5761055a610404565b5b61056560406103b8565b9050600061057584828501610457565b600083015250602082015167ffffffffffffffff81111561059957610598610409565b5b6105a584828501610517565b60208301525092915050565b60006105c46105bf846103d3565b6103b8565b905080838252602082019050602084028301858111156105e7576105e66103ff565b5b835b8181101561062e57805167ffffffffffffffff81111561060c5761060b610342565b5b8086016106198982610545565b855260208501945050506020810190506105e9565b5050509392505050565b600082601f83011261064d5761064c610342565b5b815161065d8482602086016105b1565b91505092915050565b6000806040838503121561067d5761067c610300565b5b600061068b8582860161032d565b925050602083015167ffffffffffffffff8111156106ac576106ab610305565b5b6106b885828601610638565b9150509250929050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b600081519050919050565b600081905092915050565b6000610712826106f1565b61071c81856106fc565b935061072c8185602086016104a2565b80840191505092915050565b60006107448284610707565b915081905092915050565b600082825260208201905092915050565b7f4d756c746963616c6c32206167677265676174653a2063616c6c206661696c6560008201527f6400000000000000000000000000000000000000000000000000000000000000602082015250565b60006107bc60218361074f565b91506107c782610760565b604082019050919050565b600060208201905081810360008301526107eb816107af565b9050919050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b6000819050919050565b600061083682610821565b91507fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff821415610869576108686107f2565b5b60018201905091905056fe",
    jot = "0x608060405234801561001057600080fd5b5060405161089338038061089383398181016040528101906100329190610697565b6000815167ffffffffffffffff81111561004f5761004e61033d565b5b60405190808252806020026020018201604052801561008857816020015b6100756102f7565b81526020019060019003908161006d5790505b50905060005b82518110156101f0576000808483815181106100ad576100ac6106e0565b5b60200260200101516000015173ffffffffffffffffffffffffffffffffffffffff168584815181106100e2576100e16106e0565b5b6020026020010151604001516040516100fb9190610756565b6000604051808303816000865af19150503d8060008114610138576040519150601f19603f3d011682016040523d82523d6000602084013e61013d565b606091505b5091509150848381518110610155576101546106e0565b5b6020026020010151602001516101a657816101a5576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161019c906107f0565b60405180910390fd5b5b60405180604001604052808315158152602001828152508484815181106101d0576101cf6106e0565b5b6020026020010181905250505080806101e890610849565b91505061008e565b50602081516040028260405103030160408160405103036001835111156102705760005b835181101561026e578060200260208501018160200260400183018261023c57855160200281525b6000831115610261576020808303510151602083510151038060208303510180835250505b5050600181019050610214565b505b60005b835181101561029e578060200260208501018051516040602083510151035250600181019050610273565b5060005b83518110156102cb578060200260208501016040602080835101510352506001810190506102a2565b506001835114156102e85760208301604082018451602002815250505b60208152825160208201528181f35b6040518060400160405280600015158152602001606081525090565b6000604051905090565b600080fd5b600080fd5b600080fd5b6000601f19601f8301169050919050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b6103758261032c565b810181811067ffffffffffffffff821117156103945761039361033d565b5b80604052505050565b60006103a7610313565b90506103b3828261036c565b919050565b600067ffffffffffffffff8211156103d3576103d261033d565b5b602082029050602081019050919050565b600080fd5b600080fd5b600080fd5b600073ffffffffffffffffffffffffffffffffffffffff82169050919050565b600061041e826103f3565b9050919050565b61042e81610413565b811461043957600080fd5b50565b60008151905061044b81610425565b92915050565b60008115159050919050565b61046681610451565b811461047157600080fd5b50565b6000815190506104838161045d565b92915050565b600080fd5b600067ffffffffffffffff8211156104a9576104a861033d565b5b6104b28261032c565b9050602081019050919050565b60005b838110156104dd5780820151818401526020810190506104c2565b838111156104ec576000848401525b50505050565b60006105056105008461048e565b61039d565b90508281526020810184848401111561052157610520610489565b5b61052c8482856104bf565b509392505050565b600082601f83011261054957610548610327565b5b81516105598482602086016104f2565b91505092915050565b600060608284031215610578576105776103e9565b5b610582606061039d565b905060006105928482850161043c565b60008301525060206105a684828501610474565b602083015250604082015167ffffffffffffffff8111156105ca576105c96103ee565b5b6105d684828501610534565b60408301525092915050565b60006105f56105f0846103b8565b61039d565b90508083825260208201905060208402830185811115610618576106176103e4565b5b835b8181101561065f57805167ffffffffffffffff81111561063d5761063c610327565b5b80860161064a8982610562565b8552602085019450505060208101905061061a565b5050509392505050565b600082601f83011261067e5761067d610327565b5b815161068e8482602086016105e2565b91505092915050565b6000602082840312156106ad576106ac61031d565b5b600082015167ffffffffffffffff8111156106cb576106ca610322565b5b6106d784828501610669565b91505092915050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b600081519050919050565b600081905092915050565b60006107308261070f565b61073a818561071a565b935061074a8185602086016104bf565b80840191505092915050565b60006107628284610725565b915081905092915050565b600082825260208201905092915050565b7f4d756c746963616c6c33206167677265676174653a2063616c6c206661696c6560008201527f6400000000000000000000000000000000000000000000000000000000000000602082015250565b60006107da60218361076d565b91506107e58261077e565b604082019050919050565b60006020820190508181036000830152610809816107cd565b9050919050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b6000819050919050565b60006108548261083f565b91507fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff82141561088757610886610810565b5b60018201905091905056fe";
async function Hot(t, e, n, r) {
    const i = e ? new Qr(e.address, bU, t) : null,
        s = n.map(c => {
            const u = kc.encode(c.name, c.inputs, c.params);
            return {
                target: c.contract.address,
                callData: u
            }
        }),
        o = i && i.aggregate ? await i.aggregate(s, r || {}) : await Vot(t, s, r == null ? void 0 : r.blockTag),
        a = n.length,
        l = [];
    for (let c = 0; c < a; c++) {
        const u = n[c];
        if (!u) throw new Error("Unable to access the call");
        const f = u.name,
            h = u.outputs,
            g = o.returnData[c],
            y = kc.decode(f, h, g),
            _ = h.length === 1 ? y[0] : y;
        l.push(_)
    }
    return l
}
async function zot(t, e, n, r) {
    const i = e ? new Qr(e.address, tde, t) : null,
        s = n.map(c => {
            const u = kc.encode(c.name, c.inputs, c.params);
            return {
                target: c.contract.address,
                callData: u
            }
        }),
        o = i && i.tryAggregate ? await i.tryAggregate(!1, s, r || {}) : await Got(t, s, r == null ? void 0 : r.blockTag),
        a = n.length,
        l = [];
    for (let c = 0; c < a; c++) {
        const u = n[c];
        if (!u) throw new Error("Unable to access the call");
        const f = u.name,
            h = u.outputs,
            g = o[c];
        if (!g) throw new Error("Unable to access the result");
        if (!g.success) l.push(null);
        else try {
            const y = kc.decode(f, h, g.returnData),
                _ = h.length === 1 ? y[0] : y;
            l.push(_)
        } catch {
            l.push(null)
        }
    }
    return l
}
async function Wot(t, e, n, r) {
    const i = e ? new Qr(e.address, nde, t) : null,
        s = n.map(c => {
            const u = kc.encode(c.name, c.inputs, c.params);
            return {
                target: c.contract.address,
                allowFailure: c.canFail,
                callData: u
            }
        }),
        o = i && i.aggregate3 ? await i.aggregate3(s, r || {}) : await qot(t, s, r == null ? void 0 : r.blockTag),
        a = n.length,
        l = [];
    for (let c = 0; c < a; c++) {
        const u = n[c];
        if (!u) throw new Error("Unable to access the call");
        const f = u.name,
            h = u.outputs,
            g = o[c];
        if (!g) throw new Error("Unable to access the result");
        if (!g.success) l.push(null);
        else try {
            const y = kc.decode(f, h, g.returnData),
                _ = h.length === 1 ? y[0] : y;
            l.push(_)
        } catch {
            l.push(null)
        }
    }
    return l
}
async function Vot(t, e, n) {
    const i = Pot.find(y => y.type === "constructor"),
        s = (i == null ? void 0 : i.inputs) || [],
        o = kc.encodeConstructor(s, [e]),
        a = vi([Fot, o]),
        l = await t.call({
            data: a,
            blockTag: n
        }),
        u = bU.find(y => y.type === "function" && y.name === "aggregate"),
        f = (u == null ? void 0 : u.name) || "",
        h = (u == null ? void 0 : u.outputs) || [];
    return kc.decode(f, h, l)
}
async function Got(t, e, n) {
    const i = kot.find(y => y.type === "constructor"),
        s = (i == null ? void 0 : i.inputs) || [],
        o = kc.encodeConstructor(s, [!1, e]),
        a = vi([Uot, o]),
        l = await t.call({
            data: a,
            blockTag: n
        }),
        u = tde.find(y => y.type === "function" && y.name === "tryAggregate"),
        f = (u == null ? void 0 : u.name) || "",
        h = (u == null ? void 0 : u.outputs) || [];
    return kc.decode(f, h, l)[0]
}
async function qot(t, e, n) {
    const i = Mot.find(y => y.type === "constructor"),
        s = (i == null ? void 0 : i.inputs) || [],
        o = kc.encodeConstructor(s, [e]),
        a = vi([jot, o]),
        l = await t.call({
            data: a,
            blockTag: n
        }),
        u = nde.find(y => y.type === "function" && y.name === "aggregate3"),
        f = (u == null ? void 0 : u.name) || "",
        h = (u == null ? void 0 : u.outputs) || [];
    return kc.decode(f, h, l)[0]
}

function Kot(t, e) {
    return new K7(e, bU).getEthBalance(t)
}
var Rf, oE, Z1, Q1, J1, qa, B8, F8, U8;
class _U {
    constructor(e, n, r) {
        _e(this, qa);
        _e(this, Rf);
        _e(this, oE);
        _e(this, Z1);
        _e(this, Q1);
        _e(this, J1);
        le(this, Rf, n), le(this, oE, r || {}), le(this, Z1, De(this, qa, U8).call(this, e, 1)), le(this, Q1, De(this, qa, U8).call(this, e, 2)), le(this, J1, De(this, qa, U8).call(this, e, 3))
    }
    getEthBalance(e) {
        const n = W(this, J1) || W(this, Q1) || W(this, Z1);
        if (!n) throw Error("Multicall contract is not available on this network.");
        return Kot(e, n.address)
    }
    async all(e, n) {
        if (!W(this, Rf)) throw Error("Provider should be initialized before use.");
        const r = De(this, qa, B8).call(this, "BASIC", n == null ? void 0 : n.blockTag),
            i = W(this, Rf);
        return await Hot(i, r, e, n)
    }
    async tryAll(e, n) {
        if (!W(this, Rf)) throw Error("Provider should be initialized before use.");
        const r = De(this, qa, B8).call(this, "TRY_ALL", n == null ? void 0 : n.blockTag),
            i = W(this, Rf);
        return await zot(i, r, e, n)
    }
    async tryEach(e, n, r) {
        if (!W(this, Rf)) throw Error("Provider should be initialized before use.");
        const i = De(this, qa, B8).call(this, "TRY_EACH", r == null ? void 0 : r.blockTag),
            s = W(this, Rf),
            o = e.map((a, l) => {
                const c = n[l];
                if (c === void 0) throw new Error("Unable to access the canFail value");
                return { ...a,
                    canFail: c
                }
            });
        return await Wot(s, i, o, r)
    }
}
Rf = new WeakMap, oE = new WeakMap, Z1 = new WeakMap, Q1 = new WeakMap, J1 = new WeakMap, qa = new WeakSet, B8 = function(e, n) {
    const r = De(this, qa, F8).call(this, W(this, Z1), n) ? W(this, Z1) : null,
        i = De(this, qa, F8).call(this, W(this, Q1), n) ? W(this, Q1) : null,
        s = De(this, qa, F8).call(this, W(this, J1), n) ? W(this, J1) : null;
    switch (e) {
        case "BASIC":
            return s || i || r;
        case "TRY_ALL":
            return s || i;
        case "TRY_EACH":
            return s
    }
}, F8 = function(e, n) {
    return e ? !n || n === "latest" || n === "pending" ? !0 : e.block < n : !1
}, U8 = function(e, n) {
    var o;

    function r(a, l) {
        switch (l) {
            case 1:
                return $ot(a);
            case 2:
                return Lot(a);
            case 3:
                return Bot(a)
        }
    }
    const i = (o = W(this, oE)) == null ? void 0 : o.multicall;
    if (!i) return r(e, n);
    const s = i.address;
    return s ? {
        address: s,
        block: i.block || 0
    } : r(e, n)
};
const Yot = (t, e) => {
        const n = [];
        for (let r = 0; r < t.length; r += e) {
            const i = t.slice(r, r + e);
            n.push(i)
        }
        return n
    },
    FS = Ml("utils:token");
async function HA(t, e, n, r) {
    let i = -1;
    const s = [...n].filter((l, c) => zf(l) ? (i = c, !1) : !0),
        o = new _U(t.id, e),
        a = [];
    s.forEach(l => {
        const c = new K7(l, Xm);
        a.push(c.name(), c.symbol(), c.decimals()), r && a.push(c.balanceOf(r))
    });
    try {
        const l = await o.tryAll(a),
            u = Yot(l, r ? 4 : 3).map((f, h) => {
                const g = {
                    name: f[0],
                    symbol: f[1],
                    decimals: Number(f[2]),
                    address: s[h].toLowerCase(),
                    balance: {
                        raw: "0",
                        formatted: "0",
                        fullPrecision: "0"
                    }
                };
                return r && (g.balance = {
                    raw: f[3].toString(),
                    formatted: Os(f[3].toString(), {
                        decimals: g.decimals
                    }),
                    fullPrecision: Os(f[3].toString(), {
                        decimals: g.decimals,
                        cut: !1
                    })
                }), g
            });
        if (FS("ethIndex", i), i !== -1) {
            const f = r ? (await e.getBalance(r)).toString() : "0";
            FS("ethBalance", f), FS("userAddress", r), u.splice(i, 0, {
                name: "Ethereum",
                symbol: "ETH",
                decimals: 18,
                address: yU,
                isEth: !0,
                balance: {
                    raw: f,
                    formatted: Os(f),
                    fullPrecision: Os(f, {
                        cut: !1
                    })
                }
            })
        }
        return FS("fetchTokensInfo tokensInfo", u), u
    } catch (l) {
        return console.error(l), []
    }
}
const Zot = ({
        tokens: t,
        setTokens: e,
        fetchingTokens: n,
        onTokenSelect: r
    }) => {
        const [{
            chainConfig: i,
            appRpcProvider: s
        }] = Uo(), {
            address: o
        } = xs(), a = va(), [l, c] = ae.useState(""), [u, f] = ae.useState(!1), [h, g] = ae.useState(t), y = C => {
            c(C.target.value)
        };
        ae.useEffect(() => {
            if (f(!1), !l) return g([...t]);
            if (kOe(l)) {
                const C = t.find(b => ey(b.address, l));
                if (!C) {
                    _();
                    return
                }
                g([C]);
                return
            }
            g([...t].filter(C => C.symbol.toLowerCase().includes(l.toLowerCase()) || C.name.toLowerCase().includes(l.toLowerCase())))
        }, [l, t]);
        const _ = async () => {
            try {
                const C = (await HA(i, s, [l], o))[0];
                if (!C) {
                    f(!0);
                    return
                }
                e(b => [...b, C])
            } catch (C) {
                console.error(C), f(!0)
            }
        };
        return J.jsxs(ba, {
            size: "sm",
            children: [J.jsx("div", {
                className: "modal-title",
                children: "Select token"
            }), J.jsx($7, {
                name: "search",
                value: l,
                onChange: y,
                inputContainerClasses: "!border-gray-300",
                startAdornment: J.jsx("div", {
                    className: "flex items-center justify-center self-stretch px-2 space-x-2 opacity-40 -mr-4",
                    children: J.jsx(Xr, {
                        icon: "fa6-solid:magnifying-glass"
                    })
                }),
                placeholder: "Search by name/symbol/address"
            }), n ? J.jsx(Jfe, {
                label: "Loading tokens"
            }) : u ? J.jsx("div", {
                children: "Can't find token"
            }) : J.jsx("div", {
                className: "mt-4 -mb-6 -mx-6 h-[40vh] overflow-auto",
                children: h.map(C => J.jsxs("div", {
                    className: "flex items-center py-2 px-6 hover:bg-gray-300 cursor-pointer",
                    onClick: () => {
                        r(C), a(null)
                    },
                    children: [J.jsx(Eot, {
                        token: C
                    }), J.jsxs("div", {
                        className: "flex flex-col",
                        children: [J.jsx("span", {
                            className: "",
                            children: C.symbol
                        }), J.jsx("span", {
                            className: "text-xs opacity-40",
                            children: C.name
                        })]
                    }), J.jsx("span", {
                        className: "text-lg ml-auto",
                        children: C.balance.formatted
                    })]
                }, C.address))
            })]
        })
    },
    rJ = t => ae.createElement("svg", {
        width: 24,
        height: 14,
        viewBox: "0 0 24 14",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg",
        ...t
    }, ae.createElement("path", {
        d: "M11.6928 0.175789L7.28844 2.52081C7.0546 2.64532 7.05832 2.98172 7.29485 3.10103L10.2042 4.56853C10.2498 4.59155 10.3002 4.60354 10.3514 4.60354H15.6909C15.7445 4.60354 15.7972 4.59038 15.8445 4.5652L23.0051 0.752688C23.3055 0.592748 23.1918 0.137451 22.8515 0.137451H11.8464C11.7928 0.137451 11.7401 0.150617 11.6928 0.175789Z",
        fill: "url(#paint0_linear_926_5026)"
    }), ae.createElement("path", {
        d: "M11.6928 13.3884L7.28844 11.0434C7.0546 10.9189 7.05832 10.5825 7.29485 10.4632L10.2042 8.99568C10.2498 8.97266 10.3002 8.96067 10.3514 8.96067H15.6909C15.7445 8.96067 15.7972 8.97383 15.8445 8.999L23.0051 12.8115C23.3055 12.9715 23.1918 13.4268 22.8515 13.4268H11.8464C11.7928 13.4268 11.7401 13.4136 11.6928 13.3884Z",
        fill: "url(#paint1_linear_926_5026)"
    }), ae.createElement("path", {
        d: "M7.30483 13.917H1.15746C0.865103 13.917 0.719861 13.5625 0.928186 13.3574L7.09574 7.28468C7.22505 7.15736 7.22586 6.94907 7.09754 6.82075L0.917658 0.640868C0.711794 0.435004 0.857595 0.0830078 1.14873 0.0830078H7.68608C7.77275 0.0830078 7.85587 0.117437 7.91715 0.178722L12.2463 4.50785C12.3076 4.56913 12.3907 4.60356 12.4774 4.60356H17.0804C17.2609 4.60356 17.4072 4.74987 17.4072 4.93035V8.6884C17.4072 8.86888 17.2609 9.01519 17.0804 9.01519H12.4774C12.3907 9.01519 12.3076 9.04962 12.2463 9.1109L7.5359 13.8213C7.47461 13.8826 7.3915 13.917 7.30483 13.917Z",
        fill: "url(#paint2_linear_926_5026)"
    }), ae.createElement("defs", null, ae.createElement("linearGradient", {
        id: "paint0_linear_926_5026",
        x1: 21.2714,
        y1: .385567,
        x2: 13.1112,
        y2: 8.49943,
        gradientUnits: "userSpaceOnUse"
    }, ae.createElement("stop", {
        stopColor: "#6015FF"
    }), ae.createElement("stop", {
        offset: 1,
        stopColor: "#6232CA",
        stopOpacity: 0
    })), ae.createElement("linearGradient", {
        id: "paint1_linear_926_5026",
        x1: 21.2714,
        y1: 13.1786,
        x2: 13.1112,
        y2: 5.06478,
        gradientUnits: "userSpaceOnUse"
    }, ae.createElement("stop", {
        stopColor: "#6015FF"
    }), ae.createElement("stop", {
        offset: 1,
        stopColor: "#6232CA",
        stopOpacity: 0
    })), ae.createElement("linearGradient", {
        id: "paint2_linear_926_5026",
        x1: 4.33571,
        y1: 7.54465,
        x2: 16.6992,
        y2: 7.70804,
        gradientUnits: "userSpaceOnUse"
    }, ae.createElement("stop", {
        stopColor: "#6015FF"
    }), ae.createElement("stop", {
        offset: .619792,
        stopColor: "#FB1FFF",
        stopOpacity: .46
    }), ae.createElement("stop", {
        offset: 1,
        stopColor: "#FB1FFF",
        stopOpacity: 0
    })))); //! moment.js
//! version : 2.30.1
//! authors : Tim Wood, Iskren Chernev, Moment.js contributors
//! license : MIT
//! momentjs.com
var rde;

function gt() {
    return rde.apply(null, arguments)
}

function Qot(t) {
    rde = t
}

function Lu(t) {
    return t instanceof Array || Object.prototype.toString.call(t) === "[object Array]"
}

function lm(t) {
    return t != null && Object.prototype.toString.call(t) === "[object Object]"
}

function mr(t, e) {
    return Object.prototype.hasOwnProperty.call(t, e)
}

function EU(t) {
    if (Object.getOwnPropertyNames) return Object.getOwnPropertyNames(t).length === 0;
    var e;
    for (e in t)
        if (mr(t, e)) return !1;
    return !0
}

function ka(t) {
    return t === void 0
}

function $h(t) {
    return typeof t == "number" || Object.prototype.toString.call(t) === "[object Number]"
}

function w4(t) {
    return t instanceof Date || Object.prototype.toString.call(t) === "[object Date]"
}

function ide(t, e) {
    var n = [],
        r, i = t.length;
    for (r = 0; r < i; ++r) n.push(e(t[r], r));
    return n
}

function mp(t, e) {
    for (var n in e) mr(e, n) && (t[n] = e[n]);
    return mr(e, "toString") && (t.toString = e.toString), mr(e, "valueOf") && (t.valueOf = e.valueOf), t
}

function hd(t, e, n, r) {
    return Tde(t, e, n, r, !0).utc()
}

function Jot() {
    return {
        empty: !1,
        unusedTokens: [],
        unusedInput: [],
        overflow: -2,
        charsLeftOver: 0,
        nullInput: !1,
        invalidEra: null,
        invalidMonth: null,
        invalidFormat: !1,
        userInvalidated: !1,
        iso: !1,
        parsedDateParts: [],
        era: null,
        meridiem: null,
        rfc2822: !1,
        weekdayMismatch: !1
    }
}

function In(t) {
    return t._pf == null && (t._pf = Jot()), t._pf
}
var YD;
Array.prototype.some ? YD = Array.prototype.some : YD = function(t) {
    var e = Object(this),
        n = e.length >>> 0,
        r;
    for (r = 0; r < n; r++)
        if (r in e && t.call(this, e[r], r, e)) return !0;
    return !1
};

function xU(t) {
    var e = null,
        n = !1,
        r = t._d && !isNaN(t._d.getTime());
    if (r && (e = In(t), n = YD.call(e.parsedDateParts, function(i) {
            return i != null
        }), r = e.overflow < 0 && !e.empty && !e.invalidEra && !e.invalidMonth && !e.invalidWeekday && !e.weekdayMismatch && !e.nullInput && !e.invalidFormat && !e.userInvalidated && (!e.meridiem || e.meridiem && n), t._strict && (r = r && e.charsLeftOver === 0 && e.unusedTokens.length === 0 && e.bigHour === void 0)), Object.isFrozen == null || !Object.isFrozen(t)) t._isValid = r;
    else return r;
    return t._isValid
}

function Y7(t) {
    var e = hd(NaN);
    return t != null ? mp(In(e), t) : In(e).userInvalidated = !0, e
}
var iJ = gt.momentProperties = [],
    pP = !1;

function SU(t, e) {
    var n, r, i, s = iJ.length;
    if (ka(e._isAMomentObject) || (t._isAMomentObject = e._isAMomentObject), ka(e._i) || (t._i = e._i), ka(e._f) || (t._f = e._f), ka(e._l) || (t._l = e._l), ka(e._strict) || (t._strict = e._strict), ka(e._tzm) || (t._tzm = e._tzm), ka(e._isUTC) || (t._isUTC = e._isUTC), ka(e._offset) || (t._offset = e._offset), ka(e._pf) || (t._pf = In(e)), ka(e._locale) || (t._locale = e._locale), s > 0)
        for (n = 0; n < s; n++) r = iJ[n], i = e[r], ka(i) || (t[r] = i);
    return t
}

function v4(t) {
    SU(this, t), this._d = new Date(t._d != null ? t._d.getTime() : NaN), this.isValid() || (this._d = new Date(NaN)), pP === !1 && (pP = !0, gt.updateOffset(this), pP = !1)
}

function Bu(t) {
    return t instanceof v4 || t != null && t._isAMomentObject != null
}

function sde(t) {
    gt.suppressDeprecationWarnings === !1 && typeof console < "u" && console.warn && console.warn("Deprecation warning: " + t)
}

function Fc(t, e) {
    var n = !0;
    return mp(function() {
        if (gt.deprecationHandler != null && gt.deprecationHandler(null, t), n) {
            var r = [],
                i, s, o, a = arguments.length;
            for (s = 0; s < a; s++) {
                if (i = "", typeof arguments[s] == "object") {
                    i += `
[` + s + "] ";
                    for (o in arguments[0]) mr(arguments[0], o) && (i += o + ": " + arguments[0][o] + ", ");
                    i = i.slice(0, -2)
                } else i = arguments[s];
                r.push(i)
            }
            sde(t + `
Arguments: ` + Array.prototype.slice.call(r).join("") + `
` + new Error().stack), n = !1
        }
        return e.apply(this, arguments)
    }, e)
}
var sJ = {};

function ode(t, e) {
    gt.deprecationHandler != null && gt.deprecationHandler(t, e), sJ[t] || (sde(e), sJ[t] = !0)
}
gt.suppressDeprecationWarnings = !1;
gt.deprecationHandler = null;

function pd(t) {
    return typeof Function < "u" && t instanceof Function || Object.prototype.toString.call(t) === "[object Function]"
}

function Xot(t) {
    var e, n;
    for (n in t) mr(t, n) && (e = t[n], pd(e) ? this[n] = e : this["_" + n] = e);
    this._config = t, this._dayOfMonthOrdinalParseLenient = new RegExp((this._dayOfMonthOrdinalParse.source || this._ordinalParse.source) + "|" + /\d{1,2}/.source)
}

function ZD(t, e) {
    var n = mp({}, t),
        r;
    for (r in e) mr(e, r) && (lm(t[r]) && lm(e[r]) ? (n[r] = {}, mp(n[r], t[r]), mp(n[r], e[r])) : e[r] != null ? n[r] = e[r] : delete n[r]);
    for (r in t) mr(t, r) && !mr(e, r) && lm(t[r]) && (n[r] = mp({}, n[r]));
    return n
}

function CU(t) {
    t != null && this.set(t)
}
var QD;
Object.keys ? QD = Object.keys : QD = function(t) {
    var e, n = [];
    for (e in t) mr(t, e) && n.push(e);
    return n
};
var eat = {
    sameDay: "[Today at] LT",
    nextDay: "[Tomorrow at] LT",
    nextWeek: "dddd [at] LT",
    lastDay: "[Yesterday at] LT",
    lastWeek: "[Last] dddd [at] LT",
    sameElse: "L"
};

function tat(t, e, n) {
    var r = this._calendar[t] || this._calendar.sameElse;
    return pd(r) ? r.call(e, n) : r
}

function ad(t, e, n) {
    var r = "" + Math.abs(t),
        i = e - r.length,
        s = t >= 0;
    return (s ? n ? "+" : "" : "-") + Math.pow(10, Math.max(0, i)).toString().substr(1) + r
}
var AU = /(\[[^\[]*\])|(\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|N{1,5}|YYYYYY|YYYYY|YYYY|YY|y{2,4}|yo?|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g,
    US = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g,
    gP = {},
    bv = {};

function qt(t, e, n, r) {
    var i = r;
    typeof r == "string" && (i = function() {
        return this[r]()
    }), t && (bv[t] = i), e && (bv[e[0]] = function() {
        return ad(i.apply(this, arguments), e[1], e[2])
    }), n && (bv[n] = function() {
        return this.localeData().ordinal(i.apply(this, arguments), t)
    })
}

function nat(t) {
    return t.match(/\[[\s\S]/) ? t.replace(/^\[|\]$/g, "") : t.replace(/\\/g, "")
}

function rat(t) {
    var e = t.match(AU),
        n, r;
    for (n = 0, r = e.length; n < r; n++) bv[e[n]] ? e[n] = bv[e[n]] : e[n] = nat(e[n]);
    return function(i) {
        var s = "",
            o;
        for (o = 0; o < r; o++) s += pd(e[o]) ? e[o].call(i, t) : e[o];
        return s
    }
}

function j8(t, e) {
    return t.isValid() ? (e = ade(e, t.localeData()), gP[e] = gP[e] || rat(e), gP[e](t)) : t.localeData().invalidDate()
}

function ade(t, e) {
    var n = 5;

    function r(i) {
        return e.longDateFormat(i) || i
    }
    for (US.lastIndex = 0; n >= 0 && US.test(t);) t = t.replace(US, r), US.lastIndex = 0, n -= 1;
    return t
}
var iat = {
    LTS: "h:mm:ss A",
    LT: "h:mm A",
    L: "MM/DD/YYYY",
    LL: "MMMM D, YYYY",
    LLL: "MMMM D, YYYY h:mm A",
    LLLL: "dddd, MMMM D, YYYY h:mm A"
};

function sat(t) {
    var e = this._longDateFormat[t],
        n = this._longDateFormat[t.toUpperCase()];
    return e || !n ? e : (this._longDateFormat[t] = n.match(AU).map(function(r) {
        return r === "MMMM" || r === "MM" || r === "DD" || r === "dddd" ? r.slice(1) : r
    }).join(""), this._longDateFormat[t])
}
var oat = "Invalid date";

function aat() {
    return this._invalidDate
}
var lat = "%d",
    cat = /\d{1,2}/;

function uat(t) {
    return this._ordinal.replace("%d", t)
}
var fat = {
    future: "in %s",
    past: "%s ago",
    s: "a few seconds",
    ss: "%d seconds",
    m: "a minute",
    mm: "%d minutes",
    h: "an hour",
    hh: "%d hours",
    d: "a day",
    dd: "%d days",
    w: "a week",
    ww: "%d weeks",
    M: "a month",
    MM: "%d months",
    y: "a year",
    yy: "%d years"
};

function dat(t, e, n, r) {
    var i = this._relativeTime[n];
    return pd(i) ? i(t, e, n, r) : i.replace(/%d/i, t)
}

function hat(t, e) {
    var n = this._relativeTime[t > 0 ? "future" : "past"];
    return pd(n) ? n(e) : n.replace(/%s/i, e)
}
var oJ = {
    D: "date",
    dates: "date",
    date: "date",
    d: "day",
    days: "day",
    day: "day",
    e: "weekday",
    weekdays: "weekday",
    weekday: "weekday",
    E: "isoWeekday",
    isoweekdays: "isoWeekday",
    isoweekday: "isoWeekday",
    DDD: "dayOfYear",
    dayofyears: "dayOfYear",
    dayofyear: "dayOfYear",
    h: "hour",
    hours: "hour",
    hour: "hour",
    ms: "millisecond",
    milliseconds: "millisecond",
    millisecond: "millisecond",
    m: "minute",
    minutes: "minute",
    minute: "minute",
    M: "month",
    months: "month",
    month: "month",
    Q: "quarter",
    quarters: "quarter",
    quarter: "quarter",
    s: "second",
    seconds: "second",
    second: "second",
    gg: "weekYear",
    weekyears: "weekYear",
    weekyear: "weekYear",
    GG: "isoWeekYear",
    isoweekyears: "isoWeekYear",
    isoweekyear: "isoWeekYear",
    w: "week",
    weeks: "week",
    week: "week",
    W: "isoWeek",
    isoweeks: "isoWeek",
    isoweek: "isoWeek",
    y: "year",
    years: "year",
    year: "year"
};

function Uc(t) {
    return typeof t == "string" ? oJ[t] || oJ[t.toLowerCase()] : void 0
}

function TU(t) {
    var e = {},
        n, r;
    for (r in t) mr(t, r) && (n = Uc(r), n && (e[n] = t[r]));
    return e
}
var pat = {
    date: 9,
    day: 11,
    weekday: 11,
    isoWeekday: 11,
    dayOfYear: 4,
    hour: 13,
    millisecond: 16,
    minute: 14,
    month: 8,
    quarter: 7,
    second: 15,
    weekYear: 1,
    isoWeekYear: 1,
    week: 5,
    isoWeek: 5,
    year: 1
};

function gat(t) {
    var e = [],
        n;
    for (n in t) mr(t, n) && e.push({
        unit: n,
        priority: pat[n]
    });
    return e.sort(function(r, i) {
        return r.priority - i.priority
    }), e
}
var lde = /\d/,
    Bl = /\d\d/,
    cde = /\d{3}/,
    IU = /\d{4}/,
    Z7 = /[+-]?\d{6}/,
    ci = /\d\d?/,
    ude = /\d\d\d\d?/,
    fde = /\d\d\d\d\d\d?/,
    Q7 = /\d{1,3}/,
    RU = /\d{1,4}/,
    J7 = /[+-]?\d{1,6}/,
    t5 = /\d+/,
    X7 = /[+-]?\d+/,
    mat = /Z|[+-]\d\d:?\d\d/gi,
    eI = /Z|[+-]\d\d(?::?\d\d)?/gi,
    yat = /[+-]?\d+(\.\d{1,3})?/,
    b4 = /[0-9]{0,256}['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFF07\uFF10-\uFFEF]{1,256}|[\u0600-\u06FF\/]{1,256}(\s*?[\u0600-\u06FF]{1,256}){1,2}/i,
    n5 = /^[1-9]\d?/,
    OU = /^([1-9]\d|\d)/,
    zA;
zA = {};

function At(t, e, n) {
    zA[t] = pd(e) ? e : function(r, i) {
        return r && n ? n : e
    }
}

function wat(t, e) {
    return mr(zA, t) ? zA[t](e._strict, e._locale) : new RegExp(vat(t))
}

function vat(t) {
    return bh(t.replace("\\", "").replace(/\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g, function(e, n, r, i, s) {
        return n || r || i || s
    }))
}

function bh(t) {
    return t.replace(/[-\/\\^$*+?.()|[\]{}]/g, "\\$&")
}

function vc(t) {
    return t < 0 ? Math.ceil(t) || 0 : Math.floor(t)
}

function Qn(t) {
    var e = +t,
        n = 0;
    return e !== 0 && isFinite(e) && (n = vc(e)), n
}
var JD = {};

function Lr(t, e) {
    var n, r = e,
        i;
    for (typeof t == "string" && (t = [t]), $h(e) && (r = function(s, o) {
            o[e] = Qn(s)
        }), i = t.length, n = 0; n < i; n++) JD[t[n]] = r
}

function _4(t, e) {
    Lr(t, function(n, r, i, s) {
        i._w = i._w || {}, e(n, i._w, i, s)
    })
}

function bat(t, e, n) {
    e != null && mr(JD, t) && JD[t](e, n._a, n, t)
}

function tI(t) {
    return t % 4 === 0 && t % 100 !== 0 || t % 400 === 0
}
var ko = 0,
    dh = 1,
    Bf = 2,
    Ps = 3,
    Eu = 4,
    hh = 5,
    _1 = 6,
    _at = 7,
    Eat = 8;
qt("Y", 0, 0, function() {
    var t = this.year();
    return t <= 9999 ? ad(t, 4) : "+" + t
});
qt(0, ["YY", 2], 0, function() {
    return this.year() % 100
});
qt(0, ["YYYY", 4], 0, "year");
qt(0, ["YYYYY", 5], 0, "year");
qt(0, ["YYYYYY", 6, !0], 0, "year");
At("Y", X7);
At("YY", ci, Bl);
At("YYYY", RU, IU);
At("YYYYY", J7, Z7);
At("YYYYYY", J7, Z7);
Lr(["YYYYY", "YYYYYY"], ko);
Lr("YYYY", function(t, e) {
    e[ko] = t.length === 2 ? gt.parseTwoDigitYear(t) : Qn(t)
});
Lr("YY", function(t, e) {
    e[ko] = gt.parseTwoDigitYear(t)
});
Lr("Y", function(t, e) {
    e[ko] = parseInt(t, 10)
});

function c_(t) {
    return tI(t) ? 366 : 365
}
gt.parseTwoDigitYear = function(t) {
    return Qn(t) + (Qn(t) > 68 ? 1900 : 2e3)
};
var dde = r5("FullYear", !0);

function xat() {
    return tI(this.year())
}

function r5(t, e) {
    return function(n) {
        return n != null ? (hde(this, t, n), gt.updateOffset(this, e), this) : $6(this, t)
    }
}

function $6(t, e) {
    if (!t.isValid()) return NaN;
    var n = t._d,
        r = t._isUTC;
    switch (e) {
        case "Milliseconds":
            return r ? n.getUTCMilliseconds() : n.getMilliseconds();
        case "Seconds":
            return r ? n.getUTCSeconds() : n.getSeconds();
        case "Minutes":
            return r ? n.getUTCMinutes() : n.getMinutes();
        case "Hours":
            return r ? n.getUTCHours() : n.getHours();
        case "Date":
            return r ? n.getUTCDate() : n.getDate();
        case "Day":
            return r ? n.getUTCDay() : n.getDay();
        case "Month":
            return r ? n.getUTCMonth() : n.getMonth();
        case "FullYear":
            return r ? n.getUTCFullYear() : n.getFullYear();
        default:
            return NaN
    }
}

function hde(t, e, n) {
    var r, i, s, o, a;
    if (!(!t.isValid() || isNaN(n))) {
        switch (r = t._d, i = t._isUTC, e) {
            case "Milliseconds":
                return void(i ? r.setUTCMilliseconds(n) : r.setMilliseconds(n));
            case "Seconds":
                return void(i ? r.setUTCSeconds(n) : r.setSeconds(n));
            case "Minutes":
                return void(i ? r.setUTCMinutes(n) : r.setMinutes(n));
            case "Hours":
                return void(i ? r.setUTCHours(n) : r.setHours(n));
            case "Date":
                return void(i ? r.setUTCDate(n) : r.setDate(n));
            case "FullYear":
                break;
            default:
                return
        }
        s = n, o = t.month(), a = t.date(), a = a === 29 && o === 1 && !tI(s) ? 28 : a, i ? r.setUTCFullYear(s, o, a) : r.setFullYear(s, o, a)
    }
}

function Sat(t) {
    return t = Uc(t), pd(this[t]) ? this[t]() : this
}

function Cat(t, e) {
    if (typeof t == "object") {
        t = TU(t);
        var n = gat(t),
            r, i = n.length;
        for (r = 0; r < i; r++) this[n[r].unit](t[n[r].unit])
    } else if (t = Uc(t), pd(this[t])) return this[t](e);
    return this
}

function Aat(t, e) {
    return (t % e + e) % e
}
var rs;
Array.prototype.indexOf ? rs = Array.prototype.indexOf : rs = function(t) {
    var e;
    for (e = 0; e < this.length; ++e)
        if (this[e] === t) return e;
    return -1
};

function NU(t, e) {
    if (isNaN(t) || isNaN(e)) return NaN;
    var n = Aat(e, 12);
    return t += (e - n) / 12, n === 1 ? tI(t) ? 29 : 28 : 31 - n % 7 % 2
}
qt("M", ["MM", 2], "Mo", function() {
    return this.month() + 1
});
qt("MMM", 0, 0, function(t) {
    return this.localeData().monthsShort(this, t)
});
qt("MMMM", 0, 0, function(t) {
    return this.localeData().months(this, t)
});
At("M", ci, n5);
At("MM", ci, Bl);
At("MMM", function(t, e) {
    return e.monthsShortRegex(t)
});
At("MMMM", function(t, e) {
    return e.monthsRegex(t)
});
Lr(["M", "MM"], function(t, e) {
    e[dh] = Qn(t) - 1
});
Lr(["MMM", "MMMM"], function(t, e, n, r) {
    var i = n._locale.monthsParse(t, r, n._strict);
    i != null ? e[dh] = i : In(n).invalidMonth = t
});
var Tat = "January_February_March_April_May_June_July_August_September_October_November_December".split("_"),
    pde = "Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_"),
    gde = /D[oD]?(\[[^\[\]]*\]|\s)+MMMM?/,
    Iat = b4,
    Rat = b4;

function Oat(t, e) {
    return t ? Lu(this._months) ? this._months[t.month()] : this._months[(this._months.isFormat || gde).test(e) ? "format" : "standalone"][t.month()] : Lu(this._months) ? this._months : this._months.standalone
}

function Nat(t, e) {
    return t ? Lu(this._monthsShort) ? this._monthsShort[t.month()] : this._monthsShort[gde.test(e) ? "format" : "standalone"][t.month()] : Lu(this._monthsShort) ? this._monthsShort : this._monthsShort.standalone
}

function Pat(t, e, n) {
    var r, i, s, o = t.toLocaleLowerCase();
    if (!this._monthsParse)
        for (this._monthsParse = [], this._longMonthsParse = [], this._shortMonthsParse = [], r = 0; r < 12; ++r) s = hd([2e3, r]), this._shortMonthsParse[r] = this.monthsShort(s, "").toLocaleLowerCase(), this._longMonthsParse[r] = this.months(s, "").toLocaleLowerCase();
    return n ? e === "MMM" ? (i = rs.call(this._shortMonthsParse, o), i !== -1 ? i : null) : (i = rs.call(this._longMonthsParse, o), i !== -1 ? i : null) : e === "MMM" ? (i = rs.call(this._shortMonthsParse, o), i !== -1 ? i : (i = rs.call(this._longMonthsParse, o), i !== -1 ? i : null)) : (i = rs.call(this._longMonthsParse, o), i !== -1 ? i : (i = rs.call(this._shortMonthsParse, o), i !== -1 ? i : null))
}

function kat(t, e, n) {
    var r, i, s;
    if (this._monthsParseExact) return Pat.call(this, t, e, n);
    for (this._monthsParse || (this._monthsParse = [], this._longMonthsParse = [], this._shortMonthsParse = []), r = 0; r < 12; r++) {
        if (i = hd([2e3, r]), n && !this._longMonthsParse[r] && (this._longMonthsParse[r] = new RegExp("^" + this.months(i, "").replace(".", "") + "$", "i"), this._shortMonthsParse[r] = new RegExp("^" + this.monthsShort(i, "").replace(".", "") + "$", "i")), !n && !this._monthsParse[r] && (s = "^" + this.months(i, "") + "|^" + this.monthsShort(i, ""), this._monthsParse[r] = new RegExp(s.replace(".", ""), "i")), n && e === "MMMM" && this._longMonthsParse[r].test(t)) return r;
        if (n && e === "MMM" && this._shortMonthsParse[r].test(t)) return r;
        if (!n && this._monthsParse[r].test(t)) return r
    }
}

function mde(t, e) {
    if (!t.isValid()) return t;
    if (typeof e == "string") {
        if (/^\d+$/.test(e)) e = Qn(e);
        else if (e = t.localeData().monthsParse(e), !$h(e)) return t
    }
    var n = e,
        r = t.date();
    return r = r < 29 ? r : Math.min(r, NU(t.year(), n)), t._isUTC ? t._d.setUTCMonth(n, r) : t._d.setMonth(n, r), t
}

function yde(t) {
    return t != null ? (mde(this, t), gt.updateOffset(this, !0), this) : $6(this, "Month")
}

function Mat() {
    return NU(this.year(), this.month())
}

function Dat(t) {
    return this._monthsParseExact ? (mr(this, "_monthsRegex") || wde.call(this), t ? this._monthsShortStrictRegex : this._monthsShortRegex) : (mr(this, "_monthsShortRegex") || (this._monthsShortRegex = Iat), this._monthsShortStrictRegex && t ? this._monthsShortStrictRegex : this._monthsShortRegex)
}

function $at(t) {
    return this._monthsParseExact ? (mr(this, "_monthsRegex") || wde.call(this), t ? this._monthsStrictRegex : this._monthsRegex) : (mr(this, "_monthsRegex") || (this._monthsRegex = Rat), this._monthsStrictRegex && t ? this._monthsStrictRegex : this._monthsRegex)
}

function wde() {
    function t(l, c) {
        return c.length - l.length
    }
    var e = [],
        n = [],
        r = [],
        i, s, o, a;
    for (i = 0; i < 12; i++) s = hd([2e3, i]), o = bh(this.monthsShort(s, "")), a = bh(this.months(s, "")), e.push(o), n.push(a), r.push(a), r.push(o);
    e.sort(t), n.sort(t), r.sort(t), this._monthsRegex = new RegExp("^(" + r.join("|") + ")", "i"), this._monthsShortRegex = this._monthsRegex, this._monthsStrictRegex = new RegExp("^(" + n.join("|") + ")", "i"), this._monthsShortStrictRegex = new RegExp("^(" + e.join("|") + ")", "i")
}

function Lat(t, e, n, r, i, s, o) {
    var a;
    return t < 100 && t >= 0 ? (a = new Date(t + 400, e, n, r, i, s, o), isFinite(a.getFullYear()) && a.setFullYear(t)) : a = new Date(t, e, n, r, i, s, o), a
}

function L6(t) {
    var e, n;
    return t < 100 && t >= 0 ? (n = Array.prototype.slice.call(arguments), n[0] = t + 400, e = new Date(Date.UTC.apply(null, n)), isFinite(e.getUTCFullYear()) && e.setUTCFullYear(t)) : e = new Date(Date.UTC.apply(null, arguments)), e
}

function WA(t, e, n) {
    var r = 7 + e - n,
        i = (7 + L6(t, 0, r).getUTCDay() - e) % 7;
    return -i + r - 1
}

function vde(t, e, n, r, i) {
    var s = (7 + n - r) % 7,
        o = WA(t, r, i),
        a = 1 + 7 * (e - 1) + s + o,
        l, c;
    return a <= 0 ? (l = t - 1, c = c_(l) + a) : a > c_(t) ? (l = t + 1, c = a - c_(t)) : (l = t, c = a), {
        year: l,
        dayOfYear: c
    }
}

function B6(t, e, n) {
    var r = WA(t.year(), e, n),
        i = Math.floor((t.dayOfYear() - r - 1) / 7) + 1,
        s, o;
    return i < 1 ? (o = t.year() - 1, s = i + _h(o, e, n)) : i > _h(t.year(), e, n) ? (s = i - _h(t.year(), e, n), o = t.year() + 1) : (o = t.year(), s = i), {
        week: s,
        year: o
    }
}

function _h(t, e, n) {
    var r = WA(t, e, n),
        i = WA(t + 1, e, n);
    return (c_(t) - r + i) / 7
}
qt("w", ["ww", 2], "wo", "week");
qt("W", ["WW", 2], "Wo", "isoWeek");
At("w", ci, n5);
At("ww", ci, Bl);
At("W", ci, n5);
At("WW", ci, Bl);
_4(["w", "ww", "W", "WW"], function(t, e, n, r) {
    e[r.substr(0, 1)] = Qn(t)
});

function Bat(t) {
    return B6(t, this._week.dow, this._week.doy).week
}
var Fat = {
    dow: 0,
    doy: 6
};

function Uat() {
    return this._week.dow
}

function jat() {
    return this._week.doy
}

function Hat(t) {
    var e = this.localeData().week(this);
    return t == null ? e : this.add((t - e) * 7, "d")
}

function zat(t) {
    var e = B6(this, 1, 4).week;
    return t == null ? e : this.add((t - e) * 7, "d")
}
qt("d", 0, "do", "day");
qt("dd", 0, 0, function(t) {
    return this.localeData().weekdaysMin(this, t)
});
qt("ddd", 0, 0, function(t) {
    return this.localeData().weekdaysShort(this, t)
});
qt("dddd", 0, 0, function(t) {
    return this.localeData().weekdays(this, t)
});
qt("e", 0, 0, "weekday");
qt("E", 0, 0, "isoWeekday");
At("d", ci);
At("e", ci);
At("E", ci);
At("dd", function(t, e) {
    return e.weekdaysMinRegex(t)
});
At("ddd", function(t, e) {
    return e.weekdaysShortRegex(t)
});
At("dddd", function(t, e) {
    return e.weekdaysRegex(t)
});
_4(["dd", "ddd", "dddd"], function(t, e, n, r) {
    var i = n._locale.weekdaysParse(t, r, n._strict);
    i != null ? e.d = i : In(n).invalidWeekday = t
});
_4(["d", "e", "E"], function(t, e, n, r) {
    e[r] = Qn(t)
});

function Wat(t, e) {
    return typeof t != "string" ? t : isNaN(t) ? (t = e.weekdaysParse(t), typeof t == "number" ? t : null) : parseInt(t, 10)
}

function Vat(t, e) {
    return typeof t == "string" ? e.weekdaysParse(t) % 7 || 7 : isNaN(t) ? null : t
}

function PU(t, e) {
    return t.slice(e, 7).concat(t.slice(0, e))
}
var Gat = "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"),
    bde = "Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_"),
    qat = "Su_Mo_Tu_We_Th_Fr_Sa".split("_"),
    Kat = b4,
    Yat = b4,
    Zat = b4;

function Qat(t, e) {
    var n = Lu(this._weekdays) ? this._weekdays : this._weekdays[t && t !== !0 && this._weekdays.isFormat.test(e) ? "format" : "standalone"];
    return t === !0 ? PU(n, this._week.dow) : t ? n[t.day()] : n
}

function Jat(t) {
    return t === !0 ? PU(this._weekdaysShort, this._week.dow) : t ? this._weekdaysShort[t.day()] : this._weekdaysShort
}

function Xat(t) {
    return t === !0 ? PU(this._weekdaysMin, this._week.dow) : t ? this._weekdaysMin[t.day()] : this._weekdaysMin
}

function elt(t, e, n) {
    var r, i, s, o = t.toLocaleLowerCase();
    if (!this._weekdaysParse)
        for (this._weekdaysParse = [], this._shortWeekdaysParse = [], this._minWeekdaysParse = [], r = 0; r < 7; ++r) s = hd([2e3, 1]).day(r), this._minWeekdaysParse[r] = this.weekdaysMin(s, "").toLocaleLowerCase(), this._shortWeekdaysParse[r] = this.weekdaysShort(s, "").toLocaleLowerCase(), this._weekdaysParse[r] = this.weekdays(s, "").toLocaleLowerCase();
    return n ? e === "dddd" ? (i = rs.call(this._weekdaysParse, o), i !== -1 ? i : null) : e === "ddd" ? (i = rs.call(this._shortWeekdaysParse, o), i !== -1 ? i : null) : (i = rs.call(this._minWeekdaysParse, o), i !== -1 ? i : null) : e === "dddd" ? (i = rs.call(this._weekdaysParse, o), i !== -1 || (i = rs.call(this._shortWeekdaysParse, o), i !== -1) ? i : (i = rs.call(this._minWeekdaysParse, o), i !== -1 ? i : null)) : e === "ddd" ? (i = rs.call(this._shortWeekdaysParse, o), i !== -1 || (i = rs.call(this._weekdaysParse, o), i !== -1) ? i : (i = rs.call(this._minWeekdaysParse, o), i !== -1 ? i : null)) : (i = rs.call(this._minWeekdaysParse, o), i !== -1 || (i = rs.call(this._weekdaysParse, o), i !== -1) ? i : (i = rs.call(this._shortWeekdaysParse, o), i !== -1 ? i : null))
}

function tlt(t, e, n) {
    var r, i, s;
    if (this._weekdaysParseExact) return elt.call(this, t, e, n);
    for (this._weekdaysParse || (this._weekdaysParse = [], this._minWeekdaysParse = [], this._shortWeekdaysParse = [], this._fullWeekdaysParse = []), r = 0; r < 7; r++) {
        if (i = hd([2e3, 1]).day(r), n && !this._fullWeekdaysParse[r] && (this._fullWeekdaysParse[r] = new RegExp("^" + this.weekdays(i, "").replace(".", "\\.?") + "$", "i"), this._shortWeekdaysParse[r] = new RegExp("^" + this.weekdaysShort(i, "").replace(".", "\\.?") + "$", "i"), this._minWeekdaysParse[r] = new RegExp("^" + this.weekdaysMin(i, "").replace(".", "\\.?") + "$", "i")), this._weekdaysParse[r] || (s = "^" + this.weekdays(i, "") + "|^" + this.weekdaysShort(i, "") + "|^" + this.weekdaysMin(i, ""), this._weekdaysParse[r] = new RegExp(s.replace(".", ""), "i")), n && e === "dddd" && this._fullWeekdaysParse[r].test(t)) return r;
        if (n && e === "ddd" && this._shortWeekdaysParse[r].test(t)) return r;
        if (n && e === "dd" && this._minWeekdaysParse[r].test(t)) return r;
        if (!n && this._weekdaysParse[r].test(t)) return r
    }
}

function nlt(t) {
    if (!this.isValid()) return t != null ? this : NaN;
    var e = $6(this, "Day");
    return t != null ? (t = Wat(t, this.localeData()), this.add(t - e, "d")) : e
}

function rlt(t) {
    if (!this.isValid()) return t != null ? this : NaN;
    var e = (this.day() + 7 - this.localeData()._week.dow) % 7;
    return t == null ? e : this.add(t - e, "d")
}

function ilt(t) {
    if (!this.isValid()) return t != null ? this : NaN;
    if (t != null) {
        var e = Vat(t, this.localeData());
        return this.day(this.day() % 7 ? e : e - 7)
    } else return this.day() || 7
}

function slt(t) {
    return this._weekdaysParseExact ? (mr(this, "_weekdaysRegex") || kU.call(this), t ? this._weekdaysStrictRegex : this._weekdaysRegex) : (mr(this, "_weekdaysRegex") || (this._weekdaysRegex = Kat), this._weekdaysStrictRegex && t ? this._weekdaysStrictRegex : this._weekdaysRegex)
}

function olt(t) {
    return this._weekdaysParseExact ? (mr(this, "_weekdaysRegex") || kU.call(this), t ? this._weekdaysShortStrictRegex : this._weekdaysShortRegex) : (mr(this, "_weekdaysShortRegex") || (this._weekdaysShortRegex = Yat), this._weekdaysShortStrictRegex && t ? this._weekdaysShortStrictRegex : this._weekdaysShortRegex)
}

function alt(t) {
    return this._weekdaysParseExact ? (mr(this, "_weekdaysRegex") || kU.call(this), t ? this._weekdaysMinStrictRegex : this._weekdaysMinRegex) : (mr(this, "_weekdaysMinRegex") || (this._weekdaysMinRegex = Zat), this._weekdaysMinStrictRegex && t ? this._weekdaysMinStrictRegex : this._weekdaysMinRegex)
}

function kU() {
    function t(u, f) {
        return f.length - u.length
    }
    var e = [],
        n = [],
        r = [],
        i = [],
        s, o, a, l, c;
    for (s = 0; s < 7; s++) o = hd([2e3, 1]).day(s), a = bh(this.weekdaysMin(o, "")), l = bh(this.weekdaysShort(o, "")), c = bh(this.weekdays(o, "")), e.push(a), n.push(l), r.push(c), i.push(a), i.push(l), i.push(c);
    e.sort(t), n.sort(t), r.sort(t), i.sort(t), this._weekdaysRegex = new RegExp("^(" + i.join("|") + ")", "i"), this._weekdaysShortRegex = this._weekdaysRegex, this._weekdaysMinRegex = this._weekdaysRegex, this._weekdaysStrictRegex = new RegExp("^(" + r.join("|") + ")", "i"), this._weekdaysShortStrictRegex = new RegExp("^(" + n.join("|") + ")", "i"), this._weekdaysMinStrictRegex = new RegExp("^(" + e.join("|") + ")", "i")
}

function MU() {
    return this.hours() % 12 || 12
}

function llt() {
    return this.hours() || 24
}
qt("H", ["HH", 2], 0, "hour");
qt("h", ["hh", 2], 0, MU);
qt("k", ["kk", 2], 0, llt);
qt("hmm", 0, 0, function() {
    return "" + MU.apply(this) + ad(this.minutes(), 2)
});
qt("hmmss", 0, 0, function() {
    return "" + MU.apply(this) + ad(this.minutes(), 2) + ad(this.seconds(), 2)
});
qt("Hmm", 0, 0, function() {
    return "" + this.hours() + ad(this.minutes(), 2)
});
qt("Hmmss", 0, 0, function() {
    return "" + this.hours() + ad(this.minutes(), 2) + ad(this.seconds(), 2)
});

function _de(t, e) {
    qt(t, 0, 0, function() {
        return this.localeData().meridiem(this.hours(), this.minutes(), e)
    })
}
_de("a", !0);
_de("A", !1);

function Ede(t, e) {
    return e._meridiemParse
}
At("a", Ede);
At("A", Ede);
At("H", ci, OU);
At("h", ci, n5);
At("k", ci, n5);
At("HH", ci, Bl);
At("hh", ci, Bl);
At("kk", ci, Bl);
At("hmm", ude);
At("hmmss", fde);
At("Hmm", ude);
At("Hmmss", fde);
Lr(["H", "HH"], Ps);
Lr(["k", "kk"], function(t, e, n) {
    var r = Qn(t);
    e[Ps] = r === 24 ? 0 : r
});
Lr(["a", "A"], function(t, e, n) {
    n._isPm = n._locale.isPM(t), n._meridiem = t
});
Lr(["h", "hh"], function(t, e, n) {
    e[Ps] = Qn(t), In(n).bigHour = !0
});
Lr("hmm", function(t, e, n) {
    var r = t.length - 2;
    e[Ps] = Qn(t.substr(0, r)), e[Eu] = Qn(t.substr(r)), In(n).bigHour = !0
});
Lr("hmmss", function(t, e, n) {
    var r = t.length - 4,
        i = t.length - 2;
    e[Ps] = Qn(t.substr(0, r)), e[Eu] = Qn(t.substr(r, 2)), e[hh] = Qn(t.substr(i)), In(n).bigHour = !0
});
Lr("Hmm", function(t, e, n) {
    var r = t.length - 2;
    e[Ps] = Qn(t.substr(0, r)), e[Eu] = Qn(t.substr(r))
});
Lr("Hmmss", function(t, e, n) {
    var r = t.length - 4,
        i = t.length - 2;
    e[Ps] = Qn(t.substr(0, r)), e[Eu] = Qn(t.substr(r, 2)), e[hh] = Qn(t.substr(i))
});

function clt(t) {
    return (t + "").toLowerCase().charAt(0) === "p"
}
var ult = /[ap]\.?m?\.?/i,
    flt = r5("Hours", !0);

function dlt(t, e, n) {
    return t > 11 ? n ? "pm" : "PM" : n ? "am" : "AM"
}
var xde = {
        calendar: eat,
        longDateFormat: iat,
        invalidDate: oat,
        ordinal: lat,
        dayOfMonthOrdinalParse: cat,
        relativeTime: fat,
        months: Tat,
        monthsShort: pde,
        week: Fat,
        weekdays: Gat,
        weekdaysMin: qat,
        weekdaysShort: bde,
        meridiemParse: ult
    },
    gi = {},
    d3 = {},
    F6;

function hlt(t, e) {
    var n, r = Math.min(t.length, e.length);
    for (n = 0; n < r; n += 1)
        if (t[n] !== e[n]) return n;
    return r
}

function aJ(t) {
    return t && t.toLowerCase().replace("_", "-")
}

function plt(t) {
    for (var e = 0, n, r, i, s; e < t.length;) {
        for (s = aJ(t[e]).split("-"), n = s.length, r = aJ(t[e + 1]), r = r ? r.split("-") : null; n > 0;) {
            if (i = nI(s.slice(0, n).join("-")), i) return i;
            if (r && r.length >= n && hlt(s, r) >= n - 1) break;
            n--
        }
        e++
    }
    return F6
}

function glt(t) {
    return !!(t && t.match("^[^/\\\\]*$"))
}

function nI(t) {
    var e = null,
        n;
    if (gi[t] === void 0 && typeof module < "u" && module && module.exports && glt(t)) try {
        e = F6._abbr, n = require, n("./locale/" + t), kp(e)
    } catch {
        gi[t] = null
    }
    return gi[t]
}

function kp(t, e) {
    var n;
    return t && (ka(e) ? n = Gh(t) : n = DU(t, e), n ? F6 = n : typeof console < "u" && console.warn && console.warn("Locale " + t + " not found. Did you forget to load it?")), F6._abbr
}

function DU(t, e) {
    if (e !== null) {
        var n, r = xde;
        if (e.abbr = t, gi[t] != null) ode("defineLocaleOverride", "use moment.updateLocale(localeName, config) to change an existing locale. moment.defineLocale(localeName, config) should only be used for creating a new locale See http://momentjs.com/guides/#/warnings/define-locale/ for more info."), r = gi[t]._config;
        else if (e.parentLocale != null)
            if (gi[e.parentLocale] != null) r = gi[e.parentLocale]._config;
            else if (n = nI(e.parentLocale), n != null) r = n._config;
        else return d3[e.parentLocale] || (d3[e.parentLocale] = []), d3[e.parentLocale].push({
            name: t,
            config: e
        }), null;
        return gi[t] = new CU(ZD(r, e)), d3[t] && d3[t].forEach(function(i) {
            DU(i.name, i.config)
        }), kp(t), gi[t]
    } else return delete gi[t], null
}

function mlt(t, e) {
    if (e != null) {
        var n, r, i = xde;
        gi[t] != null && gi[t].parentLocale != null ? gi[t].set(ZD(gi[t]._config, e)) : (r = nI(t), r != null && (i = r._config), e = ZD(i, e), r == null && (e.abbr = t), n = new CU(e), n.parentLocale = gi[t], gi[t] = n), kp(t)
    } else gi[t] != null && (gi[t].parentLocale != null ? (gi[t] = gi[t].parentLocale, t === kp() && kp(t)) : gi[t] != null && delete gi[t]);
    return gi[t]
}

function Gh(t) {
    var e;
    if (t && t._locale && t._locale._abbr && (t = t._locale._abbr), !t) return F6;
    if (!Lu(t)) {
        if (e = nI(t), e) return e;
        t = [t]
    }
    return plt(t)
}

function ylt() {
    return QD(gi)
}

function $U(t) {
    var e, n = t._a;
    return n && In(t).overflow === -2 && (e = n[dh] < 0 || n[dh] > 11 ? dh : n[Bf] < 1 || n[Bf] > NU(n[ko], n[dh]) ? Bf : n[Ps] < 0 || n[Ps] > 24 || n[Ps] === 24 && (n[Eu] !== 0 || n[hh] !== 0 || n[_1] !== 0) ? Ps : n[Eu] < 0 || n[Eu] > 59 ? Eu : n[hh] < 0 || n[hh] > 59 ? hh : n[_1] < 0 || n[_1] > 999 ? _1 : -1, In(t)._overflowDayOfYear && (e < ko || e > Bf) && (e = Bf), In(t)._overflowWeeks && e === -1 && (e = _at), In(t)._overflowWeekday && e === -1 && (e = Eat), In(t).overflow = e), t
}
var wlt = /^\s*((?:[+-]\d{6}|\d{4})-(?:\d\d-\d\d|W\d\d-\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?::\d\d(?::\d\d(?:[.,]\d+)?)?)?)([+-]\d\d(?::?\d\d)?|\s*Z)?)?$/,
    vlt = /^\s*((?:[+-]\d{6}|\d{4})(?:\d\d\d\d|W\d\d\d|W\d\d|\d\d\d|\d\d|))(?:(T| )(\d\d(?:\d\d(?:\d\d(?:[.,]\d+)?)?)?)([+-]\d\d(?::?\d\d)?|\s*Z)?)?$/,
    blt = /Z|[+-]\d\d(?::?\d\d)?/,
    jS = [
        ["YYYYYY-MM-DD", /[+-]\d{6}-\d\d-\d\d/],
        ["YYYY-MM-DD", /\d{4}-\d\d-\d\d/],
        ["GGGG-[W]WW-E", /\d{4}-W\d\d-\d/],
        ["GGGG-[W]WW", /\d{4}-W\d\d/, !1],
        ["YYYY-DDD", /\d{4}-\d{3}/],
        ["YYYY-MM", /\d{4}-\d\d/, !1],
        ["YYYYYYMMDD", /[+-]\d{10}/],
        ["YYYYMMDD", /\d{8}/],
        ["GGGG[W]WWE", /\d{4}W\d{3}/],
        ["GGGG[W]WW", /\d{4}W\d{2}/, !1],
        ["YYYYDDD", /\d{7}/],
        ["YYYYMM", /\d{6}/, !1],
        ["YYYY", /\d{4}/, !1]
    ],
    mP = [
        ["HH:mm:ss.SSSS", /\d\d:\d\d:\d\d\.\d+/],
        ["HH:mm:ss,SSSS", /\d\d:\d\d:\d\d,\d+/],
        ["HH:mm:ss", /\d\d:\d\d:\d\d/],
        ["HH:mm", /\d\d:\d\d/],
        ["HHmmss.SSSS", /\d\d\d\d\d\d\.\d+/],
        ["HHmmss,SSSS", /\d\d\d\d\d\d,\d+/],
        ["HHmmss", /\d\d\d\d\d\d/],
        ["HHmm", /\d\d\d\d/],
        ["HH", /\d\d/]
    ],
    _lt = /^\/?Date\((-?\d+)/i,
    Elt = /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),?\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|([+-]\d{4}))$/,
    xlt = {
        UT: 0,
        GMT: 0,
        EDT: -4 * 60,
        EST: -5 * 60,
        CDT: -5 * 60,
        CST: -6 * 60,
        MDT: -6 * 60,
        MST: -7 * 60,
        PDT: -7 * 60,
        PST: -8 * 60
    };

function Sde(t) {
    var e, n, r = t._i,
        i = wlt.exec(r) || vlt.exec(r),
        s, o, a, l, c = jS.length,
        u = mP.length;
    if (i) {
        for (In(t).iso = !0, e = 0, n = c; e < n; e++)
            if (jS[e][1].exec(i[1])) {
                o = jS[e][0], s = jS[e][2] !== !1;
                break
            }
        if (o == null) {
            t._isValid = !1;
            return
        }
        if (i[3]) {
            for (e = 0, n = u; e < n; e++)
                if (mP[e][1].exec(i[3])) {
                    a = (i[2] || " ") + mP[e][0];
                    break
                }
            if (a == null) {
                t._isValid = !1;
                return
            }
        }
        if (!s && a != null) {
            t._isValid = !1;
            return
        }
        if (i[4])
            if (blt.exec(i[4])) l = "Z";
            else {
                t._isValid = !1;
                return
            }
        t._f = o + (a || "") + (l || ""), BU(t)
    } else t._isValid = !1
}

function Slt(t, e, n, r, i, s) {
    var o = [Clt(t), pde.indexOf(e), parseInt(n, 10), parseInt(r, 10), parseInt(i, 10)];
    return s && o.push(parseInt(s, 10)), o
}

function Clt(t) {
    var e = parseInt(t, 10);
    return e <= 49 ? 2e3 + e : e <= 999 ? 1900 + e : e
}

function Alt(t) {
    return t.replace(/\([^()]*\)|[\n\t]/g, " ").replace(/(\s\s+)/g, " ").replace(/^\s\s*/, "").replace(/\s\s*$/, "")
}

function Tlt(t, e, n) {
    if (t) {
        var r = bde.indexOf(t),
            i = new Date(e[0], e[1], e[2]).getDay();
        if (r !== i) return In(n).weekdayMismatch = !0, n._isValid = !1, !1
    }
    return !0
}

function Ilt(t, e, n) {
    if (t) return xlt[t];
    if (e) return 0;
    var r = parseInt(n, 10),
        i = r % 100,
        s = (r - i) / 100;
    return s * 60 + i
}

function Cde(t) {
    var e = Elt.exec(Alt(t._i)),
        n;
    if (e) {
        if (n = Slt(e[4], e[3], e[2], e[5], e[6], e[7]), !Tlt(e[1], n, t)) return;
        t._a = n, t._tzm = Ilt(e[8], e[9], e[10]), t._d = L6.apply(null, t._a), t._d.setUTCMinutes(t._d.getUTCMinutes() - t._tzm), In(t).rfc2822 = !0
    } else t._isValid = !1
}

function Rlt(t) {
    var e = _lt.exec(t._i);
    if (e !== null) {
        t._d = new Date(+e[1]);
        return
    }
    if (Sde(t), t._isValid === !1) delete t._isValid;
    else return;
    if (Cde(t), t._isValid === !1) delete t._isValid;
    else return;
    t._strict ? t._isValid = !1 : gt.createFromInputFallback(t)
}
gt.createFromInputFallback = Fc("value provided is not in a recognized RFC2822 or ISO format. moment construction falls back to js Date(), which is not reliable across all browsers and versions. Non RFC2822/ISO date formats are discouraged. Please refer to http://momentjs.com/guides/#/warnings/js-date/ for more info.", function(t) {
    t._d = new Date(t._i + (t._useUTC ? " UTC" : ""))
});

function Aw(t, e, n) {
    return t ? ? e ? ? n
}

function Olt(t) {
    var e = new Date(gt.now());
    return t._useUTC ? [e.getUTCFullYear(), e.getUTCMonth(), e.getUTCDate()] : [e.getFullYear(), e.getMonth(), e.getDate()]
}

function LU(t) {
    var e, n, r = [],
        i, s, o;
    if (!t._d) {
        for (i = Olt(t), t._w && t._a[Bf] == null && t._a[dh] == null && Nlt(t), t._dayOfYear != null && (o = Aw(t._a[ko], i[ko]), (t._dayOfYear > c_(o) || t._dayOfYear === 0) && (In(t)._overflowDayOfYear = !0), n = L6(o, 0, t._dayOfYear), t._a[dh] = n.getUTCMonth(), t._a[Bf] = n.getUTCDate()), e = 0; e < 3 && t._a[e] == null; ++e) t._a[e] = r[e] = i[e];
        for (; e < 7; e++) t._a[e] = r[e] = t._a[e] == null ? e === 2 ? 1 : 0 : t._a[e];
        t._a[Ps] === 24 && t._a[Eu] === 0 && t._a[hh] === 0 && t._a[_1] === 0 && (t._nextDay = !0, t._a[Ps] = 0), t._d = (t._useUTC ? L6 : Lat).apply(null, r), s = t._useUTC ? t._d.getUTCDay() : t._d.getDay(), t._tzm != null && t._d.setUTCMinutes(t._d.getUTCMinutes() - t._tzm), t._nextDay && (t._a[Ps] = 24), t._w && typeof t._w.d < "u" && t._w.d !== s && (In(t).weekdayMismatch = !0)
    }
}

function Nlt(t) {
    var e, n, r, i, s, o, a, l, c;
    e = t._w, e.GG != null || e.W != null || e.E != null ? (s = 1, o = 4, n = Aw(e.GG, t._a[ko], B6(ai(), 1, 4).year), r = Aw(e.W, 1), i = Aw(e.E, 1), (i < 1 || i > 7) && (l = !0)) : (s = t._locale._week.dow, o = t._locale._week.doy, c = B6(ai(), s, o), n = Aw(e.gg, t._a[ko], c.year), r = Aw(e.w, c.week), e.d != null ? (i = e.d, (i < 0 || i > 6) && (l = !0)) : e.e != null ? (i = e.e + s, (e.e < 0 || e.e > 6) && (l = !0)) : i = s), r < 1 || r > _h(n, s, o) ? In(t)._overflowWeeks = !0 : l != null ? In(t)._overflowWeekday = !0 : (a = vde(n, r, i, s, o), t._a[ko] = a.year, t._dayOfYear = a.dayOfYear)
}
gt.ISO_8601 = function() {};
gt.RFC_2822 = function() {};

function BU(t) {
    if (t._f === gt.ISO_8601) {
        Sde(t);
        return
    }
    if (t._f === gt.RFC_2822) {
        Cde(t);
        return
    }
    t._a = [], In(t).empty = !0;
    var e = "" + t._i,
        n, r, i, s, o, a = e.length,
        l = 0,
        c, u;
    for (i = ade(t._f, t._locale).match(AU) || [], u = i.length, n = 0; n < u; n++) s = i[n], r = (e.match(wat(s, t)) || [])[0], r && (o = e.substr(0, e.indexOf(r)), o.length > 0 && In(t).unusedInput.push(o), e = e.slice(e.indexOf(r) + r.length), l += r.length), bv[s] ? (r ? In(t).empty = !1 : In(t).unusedTokens.push(s), bat(s, r, t)) : t._strict && !r && In(t).unusedTokens.push(s);
    In(t).charsLeftOver = a - l, e.length > 0 && In(t).unusedInput.push(e), t._a[Ps] <= 12 && In(t).bigHour === !0 && t._a[Ps] > 0 && (In(t).bigHour = void 0), In(t).parsedDateParts = t._a.slice(0), In(t).meridiem = t._meridiem, t._a[Ps] = Plt(t._locale, t._a[Ps], t._meridiem), c = In(t).era, c !== null && (t._a[ko] = t._locale.erasConvertYear(c, t._a[ko])), LU(t), $U(t)
}

function Plt(t, e, n) {
    var r;
    return n == null ? e : t.meridiemHour != null ? t.meridiemHour(e, n) : (t.isPM != null && (r = t.isPM(n), r && e < 12 && (e += 12), !r && e === 12 && (e = 0)), e)
}

function klt(t) {
    var e, n, r, i, s, o, a = !1,
        l = t._f.length;
    if (l === 0) {
        In(t).invalidFormat = !0, t._d = new Date(NaN);
        return
    }
    for (i = 0; i < l; i++) s = 0, o = !1, e = SU({}, t), t._useUTC != null && (e._useUTC = t._useUTC), e._f = t._f[i], BU(e), xU(e) && (o = !0), s += In(e).charsLeftOver, s += In(e).unusedTokens.length * 10, In(e).score = s, a ? s < r && (r = s, n = e) : (r == null || s < r || o) && (r = s, n = e, o && (a = !0));
    mp(t, n || e)
}

function Mlt(t) {
    if (!t._d) {
        var e = TU(t._i),
            n = e.day === void 0 ? e.date : e.day;
        t._a = ide([e.year, e.month, n, e.hour, e.minute, e.second, e.millisecond], function(r) {
            return r && parseInt(r, 10)
        }), LU(t)
    }
}

function Dlt(t) {
    var e = new v4($U(Ade(t)));
    return e._nextDay && (e.add(1, "d"), e._nextDay = void 0), e
}

function Ade(t) {
    var e = t._i,
        n = t._f;
    return t._locale = t._locale || Gh(t._l), e === null || n === void 0 && e === "" ? Y7({
        nullInput: !0
    }) : (typeof e == "string" && (t._i = e = t._locale.preparse(e)), Bu(e) ? new v4($U(e)) : (w4(e) ? t._d = e : Lu(n) ? klt(t) : n ? BU(t) : $lt(t), xU(t) || (t._d = null), t))
}

function $lt(t) {
    var e = t._i;
    ka(e) ? t._d = new Date(gt.now()) : w4(e) ? t._d = new Date(e.valueOf()) : typeof e == "string" ? Rlt(t) : Lu(e) ? (t._a = ide(e.slice(0), function(n) {
        return parseInt(n, 10)
    }), LU(t)) : lm(e) ? Mlt(t) : $h(e) ? t._d = new Date(e) : gt.createFromInputFallback(t)
}

function Tde(t, e, n, r, i) {
    var s = {};
    return (e === !0 || e === !1) && (r = e, e = void 0), (n === !0 || n === !1) && (r = n, n = void 0), (lm(t) && EU(t) || Lu(t) && t.length === 0) && (t = void 0), s._isAMomentObject = !0, s._useUTC = s._isUTC = i, s._l = n, s._i = t, s._f = e, s._strict = r, Dlt(s)
}

function ai(t, e, n, r) {
    return Tde(t, e, n, r, !1)
}
var Llt = Fc("moment().min is deprecated, use moment.max instead. http://momentjs.com/guides/#/warnings/min-max/", function() {
        var t = ai.apply(null, arguments);
        return this.isValid() && t.isValid() ? t < this ? this : t : Y7()
    }),
    Blt = Fc("moment().max is deprecated, use moment.min instead. http://momentjs.com/guides/#/warnings/min-max/", function() {
        var t = ai.apply(null, arguments);
        return this.isValid() && t.isValid() ? t > this ? this : t : Y7()
    });

function Ide(t, e) {
    var n, r;
    if (e.length === 1 && Lu(e[0]) && (e = e[0]), !e.length) return ai();
    for (n = e[0], r = 1; r < e.length; ++r)(!e[r].isValid() || e[r][t](n)) && (n = e[r]);
    return n
}

function Flt() {
    var t = [].slice.call(arguments, 0);
    return Ide("isBefore", t)
}

function Ult() {
    var t = [].slice.call(arguments, 0);
    return Ide("isAfter", t)
}
var jlt = function() {
        return Date.now ? Date.now() : +new Date
    },
    h3 = ["year", "quarter", "month", "week", "day", "hour", "minute", "second", "millisecond"];

function Hlt(t) {
    var e, n = !1,
        r, i = h3.length;
    for (e in t)
        if (mr(t, e) && !(rs.call(h3, e) !== -1 && (t[e] == null || !isNaN(t[e])))) return !1;
    for (r = 0; r < i; ++r)
        if (t[h3[r]]) {
            if (n) return !1;
            parseFloat(t[h3[r]]) !== Qn(t[h3[r]]) && (n = !0)
        }
    return !0
}

function zlt() {
    return this._isValid
}

function Wlt() {
    return Ku(NaN)
}

function rI(t) {
    var e = TU(t),
        n = e.year || 0,
        r = e.quarter || 0,
        i = e.month || 0,
        s = e.week || e.isoWeek || 0,
        o = e.day || 0,
        a = e.hour || 0,
        l = e.minute || 0,
        c = e.second || 0,
        u = e.millisecond || 0;
    this._isValid = Hlt(e), this._milliseconds = +u + c * 1e3 + l * 6e4 + a * 1e3 * 60 * 60, this._days = +o + s * 7, this._months = +i + r * 3 + n * 12, this._data = {}, this._locale = Gh(), this._bubble()
}

function H8(t) {
    return t instanceof rI
}

function XD(t) {
    return t < 0 ? Math.round(-1 * t) * -1 : Math.round(t)
}

function Vlt(t, e, n) {
    var r = Math.min(t.length, e.length),
        i = Math.abs(t.length - e.length),
        s = 0,
        o;
    for (o = 0; o < r; o++) Qn(t[o]) !== Qn(e[o]) && s++;
    return s + i
}

function Rde(t, e) {
    qt(t, 0, 0, function() {
        var n = this.utcOffset(),
            r = "+";
        return n < 0 && (n = -n, r = "-"), r + ad(~~(n / 60), 2) + e + ad(~~n % 60, 2)
    })
}
Rde("Z", ":");
Rde("ZZ", "");
At("Z", eI);
At("ZZ", eI);
Lr(["Z", "ZZ"], function(t, e, n) {
    n._useUTC = !0, n._tzm = FU(eI, t)
});
var Glt = /([\+\-]|\d\d)/gi;

function FU(t, e) {
    var n = (e || "").match(t),
        r, i, s;
    return n === null ? null : (r = n[n.length - 1] || [], i = (r + "").match(Glt) || ["-", 0, 0], s = +(i[1] * 60) + Qn(i[2]), s === 0 ? 0 : i[0] === "+" ? s : -s)
}

function UU(t, e) {
    var n, r;
    return e._isUTC ? (n = e.clone(), r = (Bu(t) || w4(t) ? t.valueOf() : ai(t).valueOf()) - n.valueOf(), n._d.setTime(n._d.valueOf() + r), gt.updateOffset(n, !1), n) : ai(t).local()
}

function e$(t) {
    return -Math.round(t._d.getTimezoneOffset())
}
gt.updateOffset = function() {};

function qlt(t, e, n) {
    var r = this._offset || 0,
        i;
    if (!this.isValid()) return t != null ? this : NaN;
    if (t != null) {
        if (typeof t == "string") {
            if (t = FU(eI, t), t === null) return this
        } else Math.abs(t) < 16 && !n && (t = t * 60);
        return !this._isUTC && e && (i = e$(this)), this._offset = t, this._isUTC = !0, i != null && this.add(i, "m"), r !== t && (!e || this._changeInProgress ? Pde(this, Ku(t - r, "m"), 1, !1) : this._changeInProgress || (this._changeInProgress = !0, gt.updateOffset(this, !0), this._changeInProgress = null)), this
    } else return this._isUTC ? r : e$(this)
}

function Klt(t, e) {
    return t != null ? (typeof t != "string" && (t = -t), this.utcOffset(t, e), this) : -this.utcOffset()
}

function Ylt(t) {
    return this.utcOffset(0, t)
}

function Zlt(t) {
    return this._isUTC && (this.utcOffset(0, t), this._isUTC = !1, t && this.subtract(e$(this), "m")), this
}

function Qlt() {
    if (this._tzm != null) this.utcOffset(this._tzm, !1, !0);
    else if (typeof this._i == "string") {
        var t = FU(mat, this._i);
        t != null ? this.utcOffset(t) : this.utcOffset(0, !0)
    }
    return this
}

function Jlt(t) {
    return this.isValid() ? (t = t ? ai(t).utcOffset() : 0, (this.utcOffset() - t) % 60 === 0) : !1
}

function Xlt() {
    return this.utcOffset() > this.clone().month(0).utcOffset() || this.utcOffset() > this.clone().month(5).utcOffset()
}

function ect() {
    if (!ka(this._isDSTShifted)) return this._isDSTShifted;
    var t = {},
        e;
    return SU(t, this), t = Ade(t), t._a ? (e = t._isUTC ? hd(t._a) : ai(t._a), this._isDSTShifted = this.isValid() && Vlt(t._a, e.toArray()) > 0) : this._isDSTShifted = !1, this._isDSTShifted
}

function tct() {
    return this.isValid() ? !this._isUTC : !1
}

function nct() {
    return this.isValid() ? this._isUTC : !1
}

function Ode() {
    return this.isValid() ? this._isUTC && this._offset === 0 : !1
}
var rct = /^(-|\+)?(?:(\d*)[. ])?(\d+):(\d+)(?::(\d+)(\.\d*)?)?$/,
    ict = /^(-|\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/;

function Ku(t, e) {
    var n = t,
        r = null,
        i, s, o;
    return H8(t) ? n = {
        ms: t._milliseconds,
        d: t._days,
        M: t._months
    } : $h(t) || !isNaN(+t) ? (n = {}, e ? n[e] = +t : n.milliseconds = +t) : (r = rct.exec(t)) ? (i = r[1] === "-" ? -1 : 1, n = {
        y: 0,
        d: Qn(r[Bf]) * i,
        h: Qn(r[Ps]) * i,
        m: Qn(r[Eu]) * i,
        s: Qn(r[hh]) * i,
        ms: Qn(XD(r[_1] * 1e3)) * i
    }) : (r = ict.exec(t)) ? (i = r[1] === "-" ? -1 : 1, n = {
        y: Hg(r[2], i),
        M: Hg(r[3], i),
        w: Hg(r[4], i),
        d: Hg(r[5], i),
        h: Hg(r[6], i),
        m: Hg(r[7], i),
        s: Hg(r[8], i)
    }) : n == null ? n = {} : typeof n == "object" && ("from" in n || "to" in n) && (o = sct(ai(n.from), ai(n.to)), n = {}, n.ms = o.milliseconds, n.M = o.months), s = new rI(n), H8(t) && mr(t, "_locale") && (s._locale = t._locale), H8(t) && mr(t, "_isValid") && (s._isValid = t._isValid), s
}
Ku.fn = rI.prototype;
Ku.invalid = Wlt;

function Hg(t, e) {
    var n = t && parseFloat(t.replace(",", "."));
    return (isNaN(n) ? 0 : n) * e
}

function lJ(t, e) {
    var n = {};
    return n.months = e.month() - t.month() + (e.year() - t.year()) * 12, t.clone().add(n.months, "M").isAfter(e) && --n.months, n.milliseconds = +e - +t.clone().add(n.months, "M"), n
}

function sct(t, e) {
    var n;
    return t.isValid() && e.isValid() ? (e = UU(e, t), t.isBefore(e) ? n = lJ(t, e) : (n = lJ(e, t), n.milliseconds = -n.milliseconds, n.months = -n.months), n) : {
        milliseconds: 0,
        months: 0
    }
}

function Nde(t, e) {
    return function(n, r) {
        var i, s;
        return r !== null && !isNaN(+r) && (ode(e, "moment()." + e + "(period, number) is deprecated. Please use moment()." + e + "(number, period). See http://momentjs.com/guides/#/warnings/add-inverted-param/ for more info."), s = n, n = r, r = s), i = Ku(n, r), Pde(this, i, t), this
    }
}

function Pde(t, e, n, r) {
    var i = e._milliseconds,
        s = XD(e._days),
        o = XD(e._months);
    t.isValid() && (r = r ? ? !0, o && mde(t, $6(t, "Month") + o * n), s && hde(t, "Date", $6(t, "Date") + s * n), i && t._d.setTime(t._d.valueOf() + i * n), r && gt.updateOffset(t, s || o))
}
var oct = Nde(1, "add"),
    act = Nde(-1, "subtract");

function kde(t) {
    return typeof t == "string" || t instanceof String
}

function lct(t) {
    return Bu(t) || w4(t) || kde(t) || $h(t) || uct(t) || cct(t) || t === null || t === void 0
}

function cct(t) {
    var e = lm(t) && !EU(t),
        n = !1,
        r = ["years", "year", "y", "months", "month", "M", "days", "day", "d", "dates", "date", "D", "hours", "hour", "h", "minutes", "minute", "m", "seconds", "second", "s", "milliseconds", "millisecond", "ms"],
        i, s, o = r.length;
    for (i = 0; i < o; i += 1) s = r[i], n = n || mr(t, s);
    return e && n
}

function uct(t) {
    var e = Lu(t),
        n = !1;
    return e && (n = t.filter(function(r) {
        return !$h(r) && kde(t)
    }).length === 0), e && n
}

function fct(t) {
    var e = lm(t) && !EU(t),
        n = !1,
        r = ["sameDay", "nextDay", "lastDay", "nextWeek", "lastWeek", "sameElse"],
        i, s;
    for (i = 0; i < r.length; i += 1) s = r[i], n = n || mr(t, s);
    return e && n
}

function dct(t, e) {
    var n = t.diff(e, "days", !0);
    return n < -6 ? "sameElse" : n < -1 ? "lastWeek" : n < 0 ? "lastDay" : n < 1 ? "sameDay" : n < 2 ? "nextDay" : n < 7 ? "nextWeek" : "sameElse"
}

function hct(t, e) {
    arguments.length === 1 && (arguments[0] ? lct(arguments[0]) ? (t = arguments[0], e = void 0) : fct(arguments[0]) && (e = arguments[0], t = void 0) : (t = void 0, e = void 0));
    var n = t || ai(),
        r = UU(n, this).startOf("day"),
        i = gt.calendarFormat(this, r) || "sameElse",
        s = e && (pd(e[i]) ? e[i].call(this, n) : e[i]);
    return this.format(s || this.localeData().calendar(i, this, ai(n)))
}

function pct() {
    return new v4(this)
}

function gct(t, e) {
    var n = Bu(t) ? t : ai(t);
    return this.isValid() && n.isValid() ? (e = Uc(e) || "millisecond", e === "millisecond" ? this.valueOf() > n.valueOf() : n.valueOf() < this.clone().startOf(e).valueOf()) : !1
}

function mct(t, e) {
    var n = Bu(t) ? t : ai(t);
    return this.isValid() && n.isValid() ? (e = Uc(e) || "millisecond", e === "millisecond" ? this.valueOf() < n.valueOf() : this.clone().endOf(e).valueOf() < n.valueOf()) : !1
}

function yct(t, e, n, r) {
    var i = Bu(t) ? t : ai(t),
        s = Bu(e) ? e : ai(e);
    return this.isValid() && i.isValid() && s.isValid() ? (r = r || "()", (r[0] === "(" ? this.isAfter(i, n) : !this.isBefore(i, n)) && (r[1] === ")" ? this.isBefore(s, n) : !this.isAfter(s, n))) : !1
}

function wct(t, e) {
    var n = Bu(t) ? t : ai(t),
        r;
    return this.isValid() && n.isValid() ? (e = Uc(e) || "millisecond", e === "millisecond" ? this.valueOf() === n.valueOf() : (r = n.valueOf(), this.clone().startOf(e).valueOf() <= r && r <= this.clone().endOf(e).valueOf())) : !1
}

function vct(t, e) {
    return this.isSame(t, e) || this.isAfter(t, e)
}

function bct(t, e) {
    return this.isSame(t, e) || this.isBefore(t, e)
}

function _ct(t, e, n) {
    var r, i, s;
    if (!this.isValid()) return NaN;
    if (r = UU(t, this), !r.isValid()) return NaN;
    switch (i = (r.utcOffset() - this.utcOffset()) * 6e4, e = Uc(e), e) {
        case "year":
            s = z8(this, r) / 12;
            break;
        case "month":
            s = z8(this, r);
            break;
        case "quarter":
            s = z8(this, r) / 3;
            break;
        case "second":
            s = (this - r) / 1e3;
            break;
        case "minute":
            s = (this - r) / 6e4;
            break;
        case "hour":
            s = (this - r) / 36e5;
            break;
        case "day":
            s = (this - r - i) / 864e5;
            break;
        case "week":
            s = (this - r - i) / 6048e5;
            break;
        default:
            s = this - r
    }
    return n ? s : vc(s)
}

function z8(t, e) {
    if (t.date() < e.date()) return -z8(e, t);
    var n = (e.year() - t.year()) * 12 + (e.month() - t.month()),
        r = t.clone().add(n, "months"),
        i, s;
    return e - r < 0 ? (i = t.clone().add(n - 1, "months"), s = (e - r) / (r - i)) : (i = t.clone().add(n + 1, "months"), s = (e - r) / (i - r)), -(n + s) || 0
}
gt.defaultFormat = "YYYY-MM-DDTHH:mm:ssZ";
gt.defaultFormatUtc = "YYYY-MM-DDTHH:mm:ss[Z]";

function Ect() {
    return this.clone().locale("en").format("ddd MMM DD YYYY HH:mm:ss [GMT]ZZ")
}

function xct(t) {
    if (!this.isValid()) return null;
    var e = t !== !0,
        n = e ? this.clone().utc() : this;
    return n.year() < 0 || n.year() > 9999 ? j8(n, e ? "YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]" : "YYYYYY-MM-DD[T]HH:mm:ss.SSSZ") : pd(Date.prototype.toISOString) ? e ? this.toDate().toISOString() : new Date(this.valueOf() + this.utcOffset() * 60 * 1e3).toISOString().replace("Z", j8(n, "Z")) : j8(n, e ? "YYYY-MM-DD[T]HH:mm:ss.SSS[Z]" : "YYYY-MM-DD[T]HH:mm:ss.SSSZ")
}

function Sct() {
    if (!this.isValid()) return "moment.invalid(/* " + this._i + " */)";
    var t = "moment",
        e = "",
        n, r, i, s;
    return this.isLocal() || (t = this.utcOffset() === 0 ? "moment.utc" : "moment.parseZone", e = "Z"), n = "[" + t + '("]', r = 0 <= this.year() && this.year() <= 9999 ? "YYYY" : "YYYYYY", i = "-MM-DD[T]HH:mm:ss.SSS", s = e + '[")]', this.format(n + r + i + s)
}

function Cct(t) {
    t || (t = this.isUtc() ? gt.defaultFormatUtc : gt.defaultFormat);
    var e = j8(this, t);
    return this.localeData().postformat(e)
}

function Act(t, e) {
    return this.isValid() && (Bu(t) && t.isValid() || ai(t).isValid()) ? Ku({
        to: this,
        from: t
    }).locale(this.locale()).humanize(!e) : this.localeData().invalidDate()
}

function Tct(t) {
    return this.from(ai(), t)
}

function Ict(t, e) {
    return this.isValid() && (Bu(t) && t.isValid() || ai(t).isValid()) ? Ku({
        from: this,
        to: t
    }).locale(this.locale()).humanize(!e) : this.localeData().invalidDate()
}

function Rct(t) {
    return this.to(ai(), t)
}

function Mde(t) {
    var e;
    return t === void 0 ? this._locale._abbr : (e = Gh(t), e != null && (this._locale = e), this)
}
var Dde = Fc("moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.", function(t) {
    return t === void 0 ? this.localeData() : this.locale(t)
});

function $de() {
    return this._locale
}
var VA = 1e3,
    _v = 60 * VA,
    GA = 60 * _v,
    Lde = (365 * 400 + 97) * 24 * GA;

function Ev(t, e) {
    return (t % e + e) % e
}

function Bde(t, e, n) {
    return t < 100 && t >= 0 ? new Date(t + 400, e, n) - Lde : new Date(t, e, n).valueOf()
}

function Fde(t, e, n) {
    return t < 100 && t >= 0 ? Date.UTC(t + 400, e, n) - Lde : Date.UTC(t, e, n)
}

function Oct(t) {
    var e, n;
    if (t = Uc(t), t === void 0 || t === "millisecond" || !this.isValid()) return this;
    switch (n = this._isUTC ? Fde : Bde, t) {
        case "year":
            e = n(this.year(), 0, 1);
            break;
        case "quarter":
            e = n(this.year(), this.month() - this.month() % 3, 1);
            break;
        case "month":
            e = n(this.year(), this.month(), 1);
            break;
        case "week":
            e = n(this.year(), this.month(), this.date() - this.weekday());
            break;
        case "isoWeek":
            e = n(this.year(), this.month(), this.date() - (this.isoWeekday() - 1));
            break;
        case "day":
        case "date":
            e = n(this.year(), this.month(), this.date());
            break;
        case "hour":
            e = this._d.valueOf(), e -= Ev(e + (this._isUTC ? 0 : this.utcOffset() * _v), GA);
            break;
        case "minute":
            e = this._d.valueOf(), e -= Ev(e, _v);
            break;
        case "second":
            e = this._d.valueOf(), e -= Ev(e, VA);
            break
    }
    return this._d.setTime(e), gt.updateOffset(this, !0), this
}

function Nct(t) {
    var e, n;
    if (t = Uc(t), t === void 0 || t === "millisecond" || !this.isValid()) return this;
    switch (n = this._isUTC ? Fde : Bde, t) {
        case "year":
            e = n(this.year() + 1, 0, 1) - 1;
            break;
        case "quarter":
            e = n(this.year(), this.month() - this.month() % 3 + 3, 1) - 1;
            break;
        case "month":
            e = n(this.year(), this.month() + 1, 1) - 1;
            break;
        case "week":
            e = n(this.year(), this.month(), this.date() - this.weekday() + 7) - 1;
            break;
        case "isoWeek":
            e = n(this.year(), this.month(), this.date() - (this.isoWeekday() - 1) + 7) - 1;
            break;
        case "day":
        case "date":
            e = n(this.year(), this.month(), this.date() + 1) - 1;
            break;
        case "hour":
            e = this._d.valueOf(), e += GA - Ev(e + (this._isUTC ? 0 : this.utcOffset() * _v), GA) - 1;
            break;
        case "minute":
            e = this._d.valueOf(), e += _v - Ev(e, _v) - 1;
            break;
        case "second":
            e = this._d.valueOf(), e += VA - Ev(e, VA) - 1;
            break
    }
    return this._d.setTime(e), gt.updateOffset(this, !0), this
}

function Pct() {
    return this._d.valueOf() - (this._offset || 0) * 6e4
}

function kct() {
    return Math.floor(this.valueOf() / 1e3)
}

function Mct() {
    return new Date(this.valueOf())
}

function Dct() {
    var t = this;
    return [t.year(), t.month(), t.date(), t.hour(), t.minute(), t.second(), t.millisecond()]
}

function $ct() {
    var t = this;
    return {
        years: t.year(),
        months: t.month(),
        date: t.date(),
        hours: t.hours(),
        minutes: t.minutes(),
        seconds: t.seconds(),
        milliseconds: t.milliseconds()
    }
}

function Lct() {
    return this.isValid() ? this.toISOString() : null
}

function Bct() {
    return xU(this)
}

function Fct() {
    return mp({}, In(this))
}

function Uct() {
    return In(this).overflow
}

function jct() {
    return {
        input: this._i,
        format: this._f,
        locale: this._locale,
        isUTC: this._isUTC,
        strict: this._strict
    }
}
qt("N", 0, 0, "eraAbbr");
qt("NN", 0, 0, "eraAbbr");
qt("NNN", 0, 0, "eraAbbr");
qt("NNNN", 0, 0, "eraName");
qt("NNNNN", 0, 0, "eraNarrow");
qt("y", ["y", 1], "yo", "eraYear");
qt("y", ["yy", 2], 0, "eraYear");
qt("y", ["yyy", 3], 0, "eraYear");
qt("y", ["yyyy", 4], 0, "eraYear");
At("N", jU);
At("NN", jU);
At("NNN", jU);
At("NNNN", Jct);
At("NNNNN", Xct);
Lr(["N", "NN", "NNN", "NNNN", "NNNNN"], function(t, e, n, r) {
    var i = n._locale.erasParse(t, r, n._strict);
    i ? In(n).era = i : In(n).invalidEra = t
});
At("y", t5);
At("yy", t5);
At("yyy", t5);
At("yyyy", t5);
At("yo", eut);
Lr(["y", "yy", "yyy", "yyyy"], ko);
Lr(["yo"], function(t, e, n, r) {
    var i;
    n._locale._eraYearOrdinalRegex && (i = t.match(n._locale._eraYearOrdinalRegex)), n._locale.eraYearOrdinalParse ? e[ko] = n._locale.eraYearOrdinalParse(t, i) : e[ko] = parseInt(t, 10)
});

function Hct(t, e) {
    var n, r, i, s = this._eras || Gh("en")._eras;
    for (n = 0, r = s.length; n < r; ++n) {
        switch (typeof s[n].since) {
            case "string":
                i = gt(s[n].since).startOf("day"), s[n].since = i.valueOf();
                break
        }
        switch (typeof s[n].until) {
            case "undefined":
                s[n].until = 1 / 0;
                break;
            case "string":
                i = gt(s[n].until).startOf("day").valueOf(), s[n].until = i.valueOf();
                break
        }
    }
    return s
}

function zct(t, e, n) {
    var r, i, s = this.eras(),
        o, a, l;
    for (t = t.toUpperCase(), r = 0, i = s.length; r < i; ++r)
        if (o = s[r].name.toUpperCase(), a = s[r].abbr.toUpperCase(), l = s[r].narrow.toUpperCase(), n) switch (e) {
            case "N":
            case "NN":
            case "NNN":
                if (a === t) return s[r];
                break;
            case "NNNN":
                if (o === t) return s[r];
                break;
            case "NNNNN":
                if (l === t) return s[r];
                break
        } else if ([o, a, l].indexOf(t) >= 0) return s[r]
}

function Wct(t, e) {
    var n = t.since <= t.until ? 1 : -1;
    return e === void 0 ? gt(t.since).year() : gt(t.since).year() + (e - t.offset) * n
}

function Vct() {
    var t, e, n, r = this.localeData().eras();
    for (t = 0, e = r.length; t < e; ++t)
        if (n = this.clone().startOf("day").valueOf(), r[t].since <= n && n <= r[t].until || r[t].until <= n && n <= r[t].since) return r[t].name;
    return ""
}

function Gct() {
    var t, e, n, r = this.localeData().eras();
    for (t = 0, e = r.length; t < e; ++t)
        if (n = this.clone().startOf("day").valueOf(), r[t].since <= n && n <= r[t].until || r[t].until <= n && n <= r[t].since) return r[t].narrow;
    return ""
}

function qct() {
    var t, e, n, r = this.localeData().eras();
    for (t = 0, e = r.length; t < e; ++t)
        if (n = this.clone().startOf("day").valueOf(), r[t].since <= n && n <= r[t].until || r[t].until <= n && n <= r[t].since) return r[t].abbr;
    return ""
}

function Kct() {
    var t, e, n, r, i = this.localeData().eras();
    for (t = 0, e = i.length; t < e; ++t)
        if (n = i[t].since <= i[t].until ? 1 : -1, r = this.clone().startOf("day").valueOf(), i[t].since <= r && r <= i[t].until || i[t].until <= r && r <= i[t].since) return (this.year() - gt(i[t].since).year()) * n + i[t].offset;
    return this.year()
}

function Yct(t) {
    return mr(this, "_erasNameRegex") || HU.call(this), t ? this._erasNameRegex : this._erasRegex
}

function Zct(t) {
    return mr(this, "_erasAbbrRegex") || HU.call(this), t ? this._erasAbbrRegex : this._erasRegex
}

function Qct(t) {
    return mr(this, "_erasNarrowRegex") || HU.call(this), t ? this._erasNarrowRegex : this._erasRegex
}

function jU(t, e) {
    return e.erasAbbrRegex(t)
}

function Jct(t, e) {
    return e.erasNameRegex(t)
}

function Xct(t, e) {
    return e.erasNarrowRegex(t)
}

function eut(t, e) {
    return e._eraYearOrdinalRegex || t5
}

function HU() {
    var t = [],
        e = [],
        n = [],
        r = [],
        i, s, o, a, l, c = this.eras();
    for (i = 0, s = c.length; i < s; ++i) o = bh(c[i].name), a = bh(c[i].abbr), l = bh(c[i].narrow), e.push(o), t.push(a), n.push(l), r.push(o), r.push(a), r.push(l);
    this._erasRegex = new RegExp("^(" + r.join("|") + ")", "i"), this._erasNameRegex = new RegExp("^(" + e.join("|") + ")", "i"), this._erasAbbrRegex = new RegExp("^(" + t.join("|") + ")", "i"), this._erasNarrowRegex = new RegExp("^(" + n.join("|") + ")", "i")
}
qt(0, ["gg", 2], 0, function() {
    return this.weekYear() % 100
});
qt(0, ["GG", 2], 0, function() {
    return this.isoWeekYear() % 100
});

function iI(t, e) {
    qt(0, [t, t.length], 0, e)
}
iI("gggg", "weekYear");
iI("ggggg", "weekYear");
iI("GGGG", "isoWeekYear");
iI("GGGGG", "isoWeekYear");
At("G", X7);
At("g", X7);
At("GG", ci, Bl);
At("gg", ci, Bl);
At("GGGG", RU, IU);
At("gggg", RU, IU);
At("GGGGG", J7, Z7);
At("ggggg", J7, Z7);
_4(["gggg", "ggggg", "GGGG", "GGGGG"], function(t, e, n, r) {
    e[r.substr(0, 2)] = Qn(t)
});
_4(["gg", "GG"], function(t, e, n, r) {
    e[r] = gt.parseTwoDigitYear(t)
});

function tut(t) {
    return Ude.call(this, t, this.week(), this.weekday() + this.localeData()._week.dow, this.localeData()._week.dow, this.localeData()._week.doy)
}

function nut(t) {
    return Ude.call(this, t, this.isoWeek(), this.isoWeekday(), 1, 4)
}

function rut() {
    return _h(this.year(), 1, 4)
}

function iut() {
    return _h(this.isoWeekYear(), 1, 4)
}

function sut() {
    var t = this.localeData()._week;
    return _h(this.year(), t.dow, t.doy)
}

function out() {
    var t = this.localeData()._week;
    return _h(this.weekYear(), t.dow, t.doy)
}

function Ude(t, e, n, r, i) {
    var s;
    return t == null ? B6(this, r, i).year : (s = _h(t, r, i), e > s && (e = s), aut.call(this, t, e, n, r, i))
}

function aut(t, e, n, r, i) {
    var s = vde(t, e, n, r, i),
        o = L6(s.year, 0, s.dayOfYear);
    return this.year(o.getUTCFullYear()), this.month(o.getUTCMonth()), this.date(o.getUTCDate()), this
}
qt("Q", 0, "Qo", "quarter");
At("Q", lde);
Lr("Q", function(t, e) {
    e[dh] = (Qn(t) - 1) * 3
});

function lut(t) {
    return t == null ? Math.ceil((this.month() + 1) / 3) : this.month((t - 1) * 3 + this.month() % 3)
}
qt("D", ["DD", 2], "Do", "date");
At("D", ci, n5);
At("DD", ci, Bl);
At("Do", function(t, e) {
    return t ? e._dayOfMonthOrdinalParse || e._ordinalParse : e._dayOfMonthOrdinalParseLenient
});
Lr(["D", "DD"], Bf);
Lr("Do", function(t, e) {
    e[Bf] = Qn(t.match(ci)[0])
});
var jde = r5("Date", !0);
qt("DDD", ["DDDD", 3], "DDDo", "dayOfYear");
At("DDD", Q7);
At("DDDD", cde);
Lr(["DDD", "DDDD"], function(t, e, n) {
    n._dayOfYear = Qn(t)
});

function cut(t) {
    var e = Math.round((this.clone().startOf("day") - this.clone().startOf("year")) / 864e5) + 1;
    return t == null ? e : this.add(t - e, "d")
}
qt("m", ["mm", 2], 0, "minute");
At("m", ci, OU);
At("mm", ci, Bl);
Lr(["m", "mm"], Eu);
var uut = r5("Minutes", !1);
qt("s", ["ss", 2], 0, "second");
At("s", ci, OU);
At("ss", ci, Bl);
Lr(["s", "ss"], hh);
var fut = r5("Seconds", !1);
qt("S", 0, 0, function() {
    return ~~(this.millisecond() / 100)
});
qt(0, ["SS", 2], 0, function() {
    return ~~(this.millisecond() / 10)
});
qt(0, ["SSS", 3], 0, "millisecond");
qt(0, ["SSSS", 4], 0, function() {
    return this.millisecond() * 10
});
qt(0, ["SSSSS", 5], 0, function() {
    return this.millisecond() * 100
});
qt(0, ["SSSSSS", 6], 0, function() {
    return this.millisecond() * 1e3
});
qt(0, ["SSSSSSS", 7], 0, function() {
    return this.millisecond() * 1e4
});
qt(0, ["SSSSSSSS", 8], 0, function() {
    return this.millisecond() * 1e5
});
qt(0, ["SSSSSSSSS", 9], 0, function() {
    return this.millisecond() * 1e6
});
At("S", Q7, lde);
At("SS", Q7, Bl);
At("SSS", Q7, cde);
var yp, Hde;
for (yp = "SSSS"; yp.length <= 9; yp += "S") At(yp, t5);

function dut(t, e) {
    e[_1] = Qn(("0." + t) * 1e3)
}
for (yp = "S"; yp.length <= 9; yp += "S") Lr(yp, dut);
Hde = r5("Milliseconds", !1);
qt("z", 0, 0, "zoneAbbr");
qt("zz", 0, 0, "zoneName");

function hut() {
    return this._isUTC ? "UTC" : ""
}

function put() {
    return this._isUTC ? "Coordinated Universal Time" : ""
}
var Ze = v4.prototype;
Ze.add = oct;
Ze.calendar = hct;
Ze.clone = pct;
Ze.diff = _ct;
Ze.endOf = Nct;
Ze.format = Cct;
Ze.from = Act;
Ze.fromNow = Tct;
Ze.to = Ict;
Ze.toNow = Rct;
Ze.get = Sat;
Ze.invalidAt = Uct;
Ze.isAfter = gct;
Ze.isBefore = mct;
Ze.isBetween = yct;
Ze.isSame = wct;
Ze.isSameOrAfter = vct;
Ze.isSameOrBefore = bct;
Ze.isValid = Bct;
Ze.lang = Dde;
Ze.locale = Mde;
Ze.localeData = $de;
Ze.max = Blt;
Ze.min = Llt;
Ze.parsingFlags = Fct;
Ze.set = Cat;
Ze.startOf = Oct;
Ze.subtract = act;
Ze.toArray = Dct;
Ze.toObject = $ct;
Ze.toDate = Mct;
Ze.toISOString = xct;
Ze.inspect = Sct;
typeof Symbol < "u" && Symbol.for != null && (Ze[Symbol.for("nodejs.util.inspect.custom")] = function() {
    return "Moment<" + this.format() + ">"
});
Ze.toJSON = Lct;
Ze.toString = Ect;
Ze.unix = kct;
Ze.valueOf = Pct;
Ze.creationData = jct;
Ze.eraName = Vct;
Ze.eraNarrow = Gct;
Ze.eraAbbr = qct;
Ze.eraYear = Kct;
Ze.year = dde;
Ze.isLeapYear = xat;
Ze.weekYear = tut;
Ze.isoWeekYear = nut;
Ze.quarter = Ze.quarters = lut;
Ze.month = yde;
Ze.daysInMonth = Mat;
Ze.week = Ze.weeks = Hat;
Ze.isoWeek = Ze.isoWeeks = zat;
Ze.weeksInYear = sut;
Ze.weeksInWeekYear = out;
Ze.isoWeeksInYear = rut;
Ze.isoWeeksInISOWeekYear = iut;
Ze.date = jde;
Ze.day = Ze.days = nlt;
Ze.weekday = rlt;
Ze.isoWeekday = ilt;
Ze.dayOfYear = cut;
Ze.hour = Ze.hours = flt;
Ze.minute = Ze.minutes = uut;
Ze.second = Ze.seconds = fut;
Ze.millisecond = Ze.milliseconds = Hde;
Ze.utcOffset = qlt;
Ze.utc = Ylt;
Ze.local = Zlt;
Ze.parseZone = Qlt;
Ze.hasAlignedHourOffset = Jlt;
Ze.isDST = Xlt;
Ze.isLocal = tct;
Ze.isUtcOffset = nct;
Ze.isUtc = Ode;
Ze.isUTC = Ode;
Ze.zoneAbbr = hut;
Ze.zoneName = put;
Ze.dates = Fc("dates accessor is deprecated. Use date instead.", jde);
Ze.months = Fc("months accessor is deprecated. Use month instead", yde);
Ze.years = Fc("years accessor is deprecated. Use year instead", dde);
Ze.zone = Fc("moment().zone is deprecated, use moment().utcOffset instead. http://momentjs.com/guides/#/warnings/zone/", Klt);
Ze.isDSTShifted = Fc("isDSTShifted is deprecated. See http://momentjs.com/guides/#/warnings/dst-shifted/ for more information", ect);

function gut(t) {
    return ai(t * 1e3)
}

function mut() {
    return ai.apply(null, arguments).parseZone()
}

function zde(t) {
    return t
}
var yr = CU.prototype;
yr.calendar = tat;
yr.longDateFormat = sat;
yr.invalidDate = aat;
yr.ordinal = uat;
yr.preparse = zde;
yr.postformat = zde;
yr.relativeTime = dat;
yr.pastFuture = hat;
yr.set = Xot;
yr.eras = Hct;
yr.erasParse = zct;
yr.erasConvertYear = Wct;
yr.erasAbbrRegex = Zct;
yr.erasNameRegex = Yct;
yr.erasNarrowRegex = Qct;
yr.months = Oat;
yr.monthsShort = Nat;
yr.monthsParse = kat;
yr.monthsRegex = $at;
yr.monthsShortRegex = Dat;
yr.week = Bat;
yr.firstDayOfYear = jat;
yr.firstDayOfWeek = Uat;
yr.weekdays = Qat;
yr.weekdaysMin = Xat;
yr.weekdaysShort = Jat;
yr.weekdaysParse = tlt;
yr.weekdaysRegex = slt;
yr.weekdaysShortRegex = olt;
yr.weekdaysMinRegex = alt;
yr.isPM = clt;
yr.meridiem = dlt;

function qA(t, e, n, r) {
    var i = Gh(),
        s = hd().set(r, e);
    return i[n](s, t)
}

function Wde(t, e, n) {
    if ($h(t) && (e = t, t = void 0), t = t || "", e != null) return qA(t, e, n, "month");
    var r, i = [];
    for (r = 0; r < 12; r++) i[r] = qA(t, r, n, "month");
    return i
}

function zU(t, e, n, r) {
    typeof t == "boolean" ? ($h(e) && (n = e, e = void 0), e = e || "") : (e = t, n = e, t = !1, $h(e) && (n = e, e = void 0), e = e || "");
    var i = Gh(),
        s = t ? i._week.dow : 0,
        o, a = [];
    if (n != null) return qA(e, (n + s) % 7, r, "day");
    for (o = 0; o < 7; o++) a[o] = qA(e, (o + s) % 7, r, "day");
    return a
}

function yut(t, e) {
    return Wde(t, e, "months")
}

function wut(t, e) {
    return Wde(t, e, "monthsShort")
}

function vut(t, e, n) {
    return zU(t, e, n, "weekdays")
}

function but(t, e, n) {
    return zU(t, e, n, "weekdaysShort")
}

function _ut(t, e, n) {
    return zU(t, e, n, "weekdaysMin")
}
kp("en", {
    eras: [{
        since: "0001-01-01",
        until: 1 / 0,
        offset: 1,
        name: "Anno Domini",
        narrow: "AD",
        abbr: "AD"
    }, {
        since: "0000-12-31",
        until: -1 / 0,
        offset: 1,
        name: "Before Christ",
        narrow: "BC",
        abbr: "BC"
    }],
    dayOfMonthOrdinalParse: /\d{1,2}(th|st|nd|rd)/,
    ordinal: function(t) {
        var e = t % 10,
            n = Qn(t % 100 / 10) === 1 ? "th" : e === 1 ? "st" : e === 2 ? "nd" : e === 3 ? "rd" : "th";
        return t + n
    }
});
gt.lang = Fc("moment.lang is deprecated. Use moment.locale instead.", kp);
gt.langData = Fc("moment.langData is deprecated. Use moment.localeData instead.", Gh);
var Md = Math.abs;

function Eut() {
    var t = this._data;
    return this._milliseconds = Md(this._milliseconds), this._days = Md(this._days), this._months = Md(this._months), t.milliseconds = Md(t.milliseconds), t.seconds = Md(t.seconds), t.minutes = Md(t.minutes), t.hours = Md(t.hours), t.months = Md(t.months), t.years = Md(t.years), this
}

function Vde(t, e, n, r) {
    var i = Ku(e, n);
    return t._milliseconds += r * i._milliseconds, t._days += r * i._days, t._months += r * i._months, t._bubble()
}

function xut(t, e) {
    return Vde(this, t, e, 1)
}

function Sut(t, e) {
    return Vde(this, t, e, -1)
}

function cJ(t) {
    return t < 0 ? Math.floor(t) : Math.ceil(t)
}

function Cut() {
    var t = this._milliseconds,
        e = this._days,
        n = this._months,
        r = this._data,
        i, s, o, a, l;
    return t >= 0 && e >= 0 && n >= 0 || t <= 0 && e <= 0 && n <= 0 || (t += cJ(t$(n) + e) * 864e5, e = 0, n = 0), r.milliseconds = t % 1e3, i = vc(t / 1e3), r.seconds = i % 60, s = vc(i / 60), r.minutes = s % 60, o = vc(s / 60), r.hours = o % 24, e += vc(o / 24), l = vc(Gde(e)), n += l, e -= cJ(t$(l)), a = vc(n / 12), n %= 12, r.days = e, r.months = n, r.years = a, this
}

function Gde(t) {
    return t * 4800 / 146097
}

function t$(t) {
    return t * 146097 / 4800
}

function Aut(t) {
    if (!this.isValid()) return NaN;
    var e, n, r = this._milliseconds;
    if (t = Uc(t), t === "month" || t === "quarter" || t === "year") switch (e = this._days + r / 864e5, n = this._months + Gde(e), t) {
        case "month":
            return n;
        case "quarter":
            return n / 3;
        case "year":
            return n / 12
    } else switch (e = this._days + Math.round(t$(this._months)), t) {
        case "week":
            return e / 7 + r / 6048e5;
        case "day":
            return e + r / 864e5;
        case "hour":
            return e * 24 + r / 36e5;
        case "minute":
            return e * 1440 + r / 6e4;
        case "second":
            return e * 86400 + r / 1e3;
        case "millisecond":
            return Math.floor(e * 864e5) + r;
        default:
            throw new Error("Unknown unit " + t)
    }
}

function qh(t) {
    return function() {
        return this.as(t)
    }
}
var qde = qh("ms"),
    Tut = qh("s"),
    Iut = qh("m"),
    Rut = qh("h"),
    Out = qh("d"),
    Nut = qh("w"),
    Put = qh("M"),
    kut = qh("Q"),
    Mut = qh("y"),
    Dut = qde;

function $ut() {
    return Ku(this)
}

function Lut(t) {
    return t = Uc(t), this.isValid() ? this[t + "s"]() : NaN
}

function Py(t) {
    return function() {
        return this.isValid() ? this._data[t] : NaN
    }
}
var But = Py("milliseconds"),
    Fut = Py("seconds"),
    Uut = Py("minutes"),
    jut = Py("hours"),
    Hut = Py("days"),
    zut = Py("months"),
    Wut = Py("years");

function Vut() {
    return vc(this.days() / 7)
}
var zd = Math.round,
    qw = {
        ss: 44,
        s: 45,
        m: 45,
        h: 22,
        d: 26,
        w: null,
        M: 11
    };

function Gut(t, e, n, r, i) {
    return i.relativeTime(e || 1, !!n, t, r)
}

function qut(t, e, n, r) {
    var i = Ku(t).abs(),
        s = zd(i.as("s")),
        o = zd(i.as("m")),
        a = zd(i.as("h")),
        l = zd(i.as("d")),
        c = zd(i.as("M")),
        u = zd(i.as("w")),
        f = zd(i.as("y")),
        h = s <= n.ss && ["s", s] || s < n.s && ["ss", s] || o <= 1 && ["m"] || o < n.m && ["mm", o] || a <= 1 && ["h"] || a < n.h && ["hh", a] || l <= 1 && ["d"] || l < n.d && ["dd", l];
    return n.w != null && (h = h || u <= 1 && ["w"] || u < n.w && ["ww", u]), h = h || c <= 1 && ["M"] || c < n.M && ["MM", c] || f <= 1 && ["y"] || ["yy", f], h[2] = e, h[3] = +t > 0, h[4] = r, Gut.apply(null, h)
}

function Kut(t) {
    return t === void 0 ? zd : typeof t == "function" ? (zd = t, !0) : !1
}

function Yut(t, e) {
    return qw[t] === void 0 ? !1 : e === void 0 ? qw[t] : (qw[t] = e, t === "s" && (qw.ss = e - 1), !0)
}

function Zut(t, e) {
    if (!this.isValid()) return this.localeData().invalidDate();
    var n = !1,
        r = qw,
        i, s;
    return typeof t == "object" && (e = t, t = !1), typeof t == "boolean" && (n = t), typeof e == "object" && (r = Object.assign({}, qw, e), e.s != null && e.ss == null && (r.ss = e.s - 1)), i = this.localeData(), s = qut(this, !n, r, i), n && (s = i.pastFuture(+this, s)), i.postformat(s)
}
var yP = Math.abs;

function pw(t) {
    return (t > 0) - (t < 0) || +t
}

function sI() {
    if (!this.isValid()) return this.localeData().invalidDate();
    var t = yP(this._milliseconds) / 1e3,
        e = yP(this._days),
        n = yP(this._months),
        r, i, s, o, a = this.asSeconds(),
        l, c, u, f;
    return a ? (r = vc(t / 60), i = vc(r / 60), t %= 60, r %= 60, s = vc(n / 12), n %= 12, o = t ? t.toFixed(3).replace(/\.?0+$/, "") : "", l = a < 0 ? "-" : "", c = pw(this._months) !== pw(a) ? "-" : "", u = pw(this._days) !== pw(a) ? "-" : "", f = pw(this._milliseconds) !== pw(a) ? "-" : "", l + "P" + (s ? c + s + "Y" : "") + (n ? c + n + "M" : "") + (e ? u + e + "D" : "") + (i || r || t ? "T" : "") + (i ? f + i + "H" : "") + (r ? f + r + "M" : "") + (t ? f + o + "S" : "")) : "P0D"
}
var ar = rI.prototype;
ar.isValid = zlt;
ar.abs = Eut;
ar.add = xut;
ar.subtract = Sut;
ar.as = Aut;
ar.asMilliseconds = qde;
ar.asSeconds = Tut;
ar.asMinutes = Iut;
ar.asHours = Rut;
ar.asDays = Out;
ar.asWeeks = Nut;
ar.asMonths = Put;
ar.asQuarters = kut;
ar.asYears = Mut;
ar.valueOf = Dut;
ar._bubble = Cut;
ar.clone = $ut;
ar.get = Lut;
ar.milliseconds = But;
ar.seconds = Fut;
ar.minutes = Uut;
ar.hours = jut;
ar.days = Hut;
ar.weeks = Vut;
ar.months = zut;
ar.years = Wut;
ar.humanize = Zut;
ar.toISOString = sI;
ar.toString = sI;
ar.toJSON = sI;
ar.locale = Mde;
ar.localeData = $de;
ar.toIsoString = Fc("toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)", sI);
ar.lang = Dde;
qt("X", 0, 0, "unix");
qt("x", 0, 0, "valueOf");
At("x", X7);
At("X", yat);
Lr("X", function(t, e, n) {
    n._d = new Date(parseFloat(t) * 1e3)
});
Lr("x", function(t, e, n) {
    n._d = new Date(Qn(t))
}); //! moment.js
gt.version = "2.30.1";
Qot(ai);
gt.fn = Ze;
gt.min = Flt;
gt.max = Ult;
gt.now = jlt;
gt.utc = hd;
gt.unix = gut;
gt.months = yut;
gt.isDate = w4;
gt.locale = kp;
gt.invalid = Y7;
gt.duration = Ku;
gt.isMoment = Bu;
gt.weekdays = vut;
gt.parseZone = mut;
gt.localeData = Gh;
gt.isDuration = H8;
gt.monthsShort = wut;
gt.weekdaysMin = _ut;
gt.defineLocale = DU;
gt.updateLocale = mlt;
gt.locales = ylt;
gt.weekdaysShort = but;
gt.normalizeUnits = Uc;
gt.relativeTimeRounding = Kut;
gt.relativeTimeThreshold = Yut;
gt.calendarFormat = dct;
gt.prototype = Ze;
gt.HTML5_FMT = {
    DATETIME_LOCAL: "YYYY-MM-DDTHH:mm",
    DATETIME_LOCAL_SECONDS: "YYYY-MM-DDTHH:mm:ss",
    DATETIME_LOCAL_MS: "YYYY-MM-DDTHH:mm:ss.SSS",
    DATE: "YYYY-MM-DD",
    TIME: "HH:mm",
    TIME_SECONDS: "HH:mm:ss",
    TIME_MS: "HH:mm:ss.SSS",
    WEEK: "GGGG-[W]WW",
    MONTH: "YYYY-MM"
};
const Qut = t => {
        const [e, n] = ae.useState("0"), r = ae.useRef();
        ae.useEffect(() => {
            if (t === 0 || t === "0" || !t) {
                n("0");
                return
            }
            return i(), r.current = setInterval(() => {
                i()
            }, 1e3), () => clearInterval(r.current)
        }, [t]);

        function i() {
            const s = gt(Number(t) * 1e3),
                o = gt().utc(),
                a = gt.duration(s.diff(o));
            if (a.asSeconds() < 0) {
                n("0"), clearInterval(r.current);
                return
            }
            const l = a.months(),
                c = a.days(),
                u = a.hours(),
                f = a.minutes(),
                h = a.seconds();
            n(`${l?`${l} month${l>1?"s":""} `:""}${c?`${c} day${c>1?"s":""} `:""}${u?`${u} hour${u>1?"s":""} `:""}${f||!l&&!c&&!u?`${f} min`:""}${!l&&!c&&!u&&!f?`${h} sec`:""}`)
        }
        return e
    },
    Jut = [{
        id: 1,
        type: "Essential",
        info: "Includes AigentX branding.",
        icon: J.jsx(rJ, {}),
        priority: 1
    }, {
        id: 2,
        type: "Pro",
        info: "No AigentX branding.",
        icon: J.jsx(Xr, {
            icon: "fa6-solid:circle-check"
        }),
        priority: 2
    }, {
        id: 3,
        type: "Exclusive",
        info: "Fully customized solution.",
        icon: J.jsx(Xr, {
            icon: "fa6-solid:circle-check"
        }),
        priority: 3
    }, {
        id: 1001,
        type: "Essential",
        info: "Includes AigentX branding.",
        icon: J.jsx(rJ, {}),
        priority: 1
    }, {
        id: 1002,
        type: "Pro",
        info: "No AigentX branding.",
        icon: J.jsx(Xr, {
            icon: "fa6-solid:circle-check"
        }),
        priority: 2
    }, {
        id: 1003,
        type: "Exclusive",
        info: "Fully customized solution.",
        icon: J.jsx(Xr, {
            icon: "fa6-solid:circle-check"
        }),
        priority: 3
    }],
    Dd = Ml("components:XCTariffsModal"),
    Xut = () => {
        const [{
            chainConfig: t,
            appRpcProvider: e
        }] = Uo(), {
            walletProvider: n
        } = fg(), {
            address: r
        } = xs(), i = va(), {
            trackTx: s,
            trackError: o
        } = Ny(), {
            fetchUserRefs: a
        } = z7(), [l, c] = ae.useState(null), [u, f] = ae.useState(null), [h, g] = ae.useState([]), y = u == null ? void 0 : u.reduce((M, A) => !M && A.expiresAt !== 0 || M && A.expiresAt !== 0 && A.priority > M.priority ? A : M, null);
        ae.useEffect(() => {
            b(), _()
        }, []), ae.useEffect(() => {
            C()
        }, [r, l]);
        async function _() {
            try {
                const M = await a();
                Dd("getUserRefs refs", M), g(M || [])
            } catch (M) {
                console.error("filed to fetch user refs", M)
            }
        }
        async function C() {
            if (!r || !l) {
                f([]);
                return
            }
            const E = (await new Qr(t.contracts.payments, f3, e).getUserSubscriptions(r, l.map($ => $.id))).map(($, H) => {
                var K;
                return {
                    id: l[H].id,
                    priority: ((K = l[H].ui) == null ? void 0 : K.priority) || -1,
                    startedAt: Number($[0]),
                    expiresAt: Number($[1]),
                    periodsPayment: Number($[2])
                }
            });
            Dd("newUserSubs", E), f(E)
        }
        async function b() {
            const M = new _U(t.id, e),
                A = new K7(t.contracts.payments, f3);
            let E = [];
            try {
                const $ = [...Array.from(Array(10).keys()), 1001, 1002, 1003];
                E = (await Promise.all((await M.all($.map(H => A.subscriptions(H)))).map(async (H, K) => {
                    if (!H[1] && !H[2]) return null;
                    const te = await HA(t, e, [H[0]]),
                        U = $[K];
                    return {
                        id: U,
                        paymentPeriod: H[1].toString(),
                        payableToken: te[0],
                        isPaused: H[2],
                        extendable: H[3],
                        setupPrice: H[4].toString(),
                        paymentPeriodPrice: H[5].toString(),
                        ui: Jut.find(m => m.id === U)
                    }
                }))).filter(Boolean)
            } catch ($) {
                console.error($)
            }
            c(E), Dd("subscriptions", E)
        }

        function w(M, A) {
            if (A && l) {
                if (y && y.id !== M.id) {
                    const E = l.find($ => $.id === (y == null ? void 0 : y.id));
                    P(M, y, E);
                    return
                }
                if (A.expiresAt === 0) {
                    S(M);
                    return
                }
                I(M)
            }
        }
        async function S(M) {
            if (!n) return;
            const A = new vh(new Kf(n), r),
                E = new Qr(t.contracts.payments, f3, A),
                $ = "1",
                H = [M.id, $, h, (Date.now() / 1e3).toFixed(0), new Uint8Array];
            let K;
            try {
                i({
                    modalKey: "loader",
                    title: "Confirm your transaction in the wallet"
                });
                const te = ur(M.setupPrice).plus(ur($).times(M.paymentPeriodPrice)).toString();
                Dd("pay transaction call data", {
                    params: H,
                    value: te
                }), K = await E.pay(...H, {
                    value: te
                }), i({
                    modalKey: "loader",
                    title: "Payment in process...",
                    txHash: K.hash
                }), s(K), await K.wait(), await C(), i({
                    modalKey: "xc-tariffs"
                })
            } catch (te) {
                throw o(te, K), i({
                    modalKey: "xc-tariffs"
                }), console.error("payment failed", te), te
            }
        }
        async function I(M) {
            if (!n) return;
            const A = new vh(new Kf(n), r),
                E = new Qr(t.contracts.payments, f3, A),
                $ = "1",
                H = [M.id, 1, h, (Date.now() / 1e3).toFixed(0), new Uint8Array];
            let K;
            try {
                i({
                    modalKey: "loader",
                    title: "Confirm your transaction in the wallet"
                });
                const te = ur($).times(M.paymentPeriodPrice).toString();
                Dd("extend transaction call data", {
                    params: H,
                    value: te
                }), K = await E.extend(...H, {
                    value: te
                }), i({
                    modalKey: "loader",
                    title: "Payment in process...",
                    txHash: K.hash
                }), s(K), await K.wait(), await C(), i({
                    modalKey: "xc-tariffs"
                })
            } catch (te) {
                throw o(te, K), i({
                    modalKey: "xc-tariffs"
                }), console.error("payment failed", te), te
            }
        }
        async function P(M, A, E) {
            if (!n || !E || !A) return;
            Dd("upgrade", {
                fromSub: E,
                toSub: M,
                currentUserSub: A
            });
            const $ = new vh(new Kf(n), r),
                H = new Qr(t.contracts.payments, f3, $),
                K = "1",
                te = [E.id, M.id, K, h, (Date.now() / 1e3).toFixed(0), new Uint8Array],
                U = await e.getBlock("latest");
            if (!U) return;
            Dd("latest block", U);
            let m;
            try {
                i({
                    modalKey: "loader",
                    title: "Confirm your transaction in the wallet"
                });
                let v = E.setupPrice;
                A.expiresAt > U.timestamp && E.extendable && (v = ur(A.periodsPayment).times(ur(A.expiresAt).minus(U.timestamp)).div(ur(A.expiresAt).minus(A.startedAt)).toString()), Dd("compensation", v);
                const T = ur(M.paymentPeriodPrice).times(K).plus(M.setupPrice).toString();
                let N = "0";
                ur(v).lt(T) && (N = ur(T).minus(v).toString()), Dd("upgrade transaction call data", {
                    params: te,
                    value: N
                }), m = await H.upgrade(...te, {
                    value: N
                }), i({
                    modalKey: "loader",
                    title: "Upgrade in process...",
                    txHash: m.hash
                }), s(m), await m.wait(), await C(), i({
                    modalKey: "xc-tariffs"
                })
            } catch (v) {
                throw o(v, m), i({
                    modalKey: "xc-tariffs"
                }), console.error("payment failed", v), v
            }
        }
        return J.jsx(ba, {
            size: "5xl",
            children: !l || !u ? J.jsx(Jfe, {
                label: "Loading subscriptions..."
            }) : J.jsxs(J.Fragment, {
                children: [J.jsx("div", {
                    className: "modal-title",
                    children: "Select a plan"
                }), J.jsx("div", {
                    className: "flex space-x-2 mb-4",
                    children: l.filter(M => M.ui).map((M, A) => J.jsx(eft, {
                        index: A,
                        sub: M,
                        subs: l,
                        userSub: u.find(E => E.id === M.id),
                        currentUserSub: y,
                        onPay: () => w(M, u.find(E => E.id === M.id))
                    }, M.id))
                })]
            })
        })
    },
    eft = ae.memo(({
        index: t,
        sub: e,
        subs: n,
        userSub: r,
        currentUserSub: i,
        onPay: s
    }) => {
        const o = !!(r != null && r.expiresAt),
            a = Qut((r == null ? void 0 : r.expiresAt) || 0),
            l = a === "0",
            c = n.find(f => f.id === (i == null ? void 0 : i.id));
        if (!e.ui) return null;
        const u = e.id !== (c == null ? void 0 : c.id) ? e.ui.priority > ((c == null ? void 0 : c.ui) && c.ui.priority || 0) : !0;
        return J.jsx("div", {
            className: "relative pt-[36%] z-10 flex-1",
            children: J.jsxs(V7, {
                className: "flex flex-col absolute overflow-hidden left-0 top-0 w-full h-full",
                children: [J.jsx("div", {
                    className: `absolute w-[140%] h-[140%] -right-[50%] -bottom-[50%] -z-10 ${t===0?"bg-circle-purple":t===1?"bg-circle-orange":"bg-circle-blue"}`
                }), J.jsx("div", {
                    className: "flex items-center justify-between mb-7",
                    children: J.jsx("div", {
                        className: "py-1.5 px-3.5 rounded-xl bg-white text-base",
                        children: J.jsx("div", {
                            className: "-mb-[2px]",
                            children: e.ui.type
                        })
                    })
                }), J.jsxs("div", {
                    className: "text-3xl",
                    children: [Os(e.setupPrice, {
                        decimals: e.payableToken.decimals,
                        round: 1
                    }), " ", e.payableToken.symbol]
                }), J.jsx("div", {
                    className: "text-lg text-gray-500 mb-4",
                    children: e.extendable ? `+${Os(e.paymentPeriodPrice,{decimals:e.payableToken.decimals,round:1})} eth/month` : "one-time payment"
                }), J.jsxs("div", {
                    className: "flex mb-5 items-center",
                    children: [J.jsx("div", {
                        className: "flex-shrink-0 mr-2 bg-white rounded-xl w-9 h-9 relative",
                        children: J.jsx("span", {
                            className: "absolute left-1/2 top-1/2 -translate-x-1/2 -translate-y-1/2",
                            children: e.ui.icon
                        })
                    }), J.jsx("span", {
                        children: e.ui.info
                    })]
                }), J.jsx("div", {
                    className: "mb-auto",
                    children: o && e.extendable && (i == null ? void 0 : i.id) === e.id ? l ? "Your subscription expired" : J.jsxs(J.Fragment, {
                        children: [J.jsx("span", {
                            children: "Expires in:"
                        }), J.jsx("br", {}), J.jsx("span", {
                            children: a
                        })]
                    }) : ""
                }), u && J.jsx(W7, {
                    className: "w-full mt-auto",
                    onClick: s,
                    buttonColor: t === 0 ? "default" : t === 1 ? "orange" : "blue",
                    label: e.isPaused ? "Tariff paused" : o && l ? "Renew" : o && e.extendable ? "Extend" : o && !e.extendable ? "Active" : i ? "Upgrade" : "Try AigentXC",
                    disabled: o && !e.extendable || e.isPaused
                })]
            })
        })
    }),
    tft = () => {
        const [t, e] = ae.useState(""), [n, r] = ae.useState(""), [i, s] = ae.useState("");
        return J.jsxs(ba, {
            size: "xl",
            children: [J.jsx("div", {
                className: "modal-title",
                children: "Custom Solution Request"
            }), J.jsxs("div", {
                className: "mb-4",
                children: [J.jsx("span", {
                    className: "block mb-1",
                    children: "Company name"
                }), J.jsx("input", {
                    value: t,
                    placeholder: "Answer",
                    className: "ui-input",
                    onChange: o => e(o.target.value)
                })]
            }), J.jsxs("div", {
                className: "mb-4",
                children: [J.jsx("span", {
                    className: "block mb-1",
                    children: "The number of employees"
                }), J.jsx("input", {
                    value: n,
                    placeholder: "Answer",
                    className: "ui-input",
                    onChange: o => r(o.target.value)
                })]
            }), J.jsxs("div", {
                className: "mb-8",
                children: [J.jsx("span", {
                    className: "block mb-1",
                    children: "Your Request"
                }), J.jsx("input", {
                    value: i,
                    placeholder: "Answer",
                    className: "ui-input",
                    onChange: o => s(o.target.value)
                })]
            }), J.jsx(Bo, {
                className: "w-full",
                children: "Send"
            })]
        })
    },
    nft = () => {
        const [t, e] = ae.useState("tg");
        return J.jsxs(ba, {
            size: "xl",
            children: [J.jsx("div", {
                className: "modal-title",
                children: "Which channels would you like to use it:"
            }), J.jsxs("div", {
                className: "flex space-x-2 mb-6",
                children: [J.jsx("div", {
                    className: "flex-1 pt-[25%] relative",
                    onClick: () => e("tg"),
                    children: J.jsxs("div", {
                        className: `cursor-pointer text-xl absolute flex flex-col align-middle justify-center left-0 top-0 w-full h-full text-center py-3 rounded-2xl border-2 bg-black bg-opacity-5 ${t==="tg"?"border-purple-600":""}`,
                        children: [J.jsx("img", {
                            className: "mb-2 w-11 mx-auto",
                            src: "/images/telegram-icon.svg",
                            alt: "telegram"
                        }), J.jsx("span", {
                            children: "Telegram"
                        })]
                    })
                }), J.jsx("div", {
                    className: "flex-1 pt-[20%] relative",
                    onClick: () => e("dis"),
                    children: J.jsxs("div", {
                        className: `cursor-pointer text-xl absolute flex flex-col align-middle justify-center left-0 top-0 w-full h-full text-center py-3 rounded-2xl border-2 bg-black bg-opacity-5 ${t==="dis"?"border-purple-600":""}`,
                        children: [J.jsx("img", {
                            className: "mb-2 w-11 mx-auto",
                            src: "/images/discord-icon.svg",
                            alt: "discord"
                        }), J.jsx("span", {
                            children: "Discord"
                        })]
                    })
                }), J.jsx("div", {
                    className: "flex-1 pt-[20%] relative",
                    onClick: () => e("whats"),
                    children: J.jsxs("div", {
                        className: `cursor-pointer text-xl absolute flex flex-col align-middle justify-center left-0 top-0 w-full h-full text-center py-3 rounded-2xl border-2 bg-black bg-opacity-5 ${t==="whats"?"border-purple-600":""}`,
                        children: [J.jsx("img", {
                            className: "mb-2 w-11 mx-auto",
                            src: "/images/whats-app-icon.svg",
                            alt: "whats-app"
                        }), J.jsx("span", {
                            children: "WhatsApp"
                        })]
                    })
                })]
            }), J.jsx(Bo, {
                className: "w-full",
                children: "Next"
            })]
        })
    },
    rft = t => {
        switch (t.modalKey) {
            case "stakes":
                return J.jsx(bot, { ...t
                });
            case "loader":
                return J.jsx(dot, { ...t
                });
            case "confirm":
                return J.jsx(qst, { ...t
                });
            case "success":
                return J.jsx(_ot, { ...t
                });
            case "join-affiliate":
                return J.jsx(Yst, { ...t
                });
            case "xc-tariffs":
                return J.jsx(Xut, { ...t
                });
            case "xo-tariffs":
                return J.jsx(tft, { ...t
                });
            case "xt-tariffs":
                return J.jsx(nft, { ...t
                });
            case "add-knowledge":
                return J.jsx(Wst, { ...t
                });
            case "web-integration":
                return J.jsx(vot, { ...t
                });
            case "telegram-integration":
                return J.jsx(wot, { ...t
                });
            case "connect-tg":
                return J.jsx(Kst, { ...t
                });
            case "swap-select-token":
                return J.jsx(Zot, { ...t
                });
            case "launch-participate":
                return J.jsx(fot, { ...t
                });
            case "mint-nft":
                return J.jsx(yot, { ...t
                });
            default:
                return null
        }
    },
    ift = () => {
        const t = sit();
        return t ? rft(t) : null
    },
    sft = ({
        t
    }) => {
        var n, r;
        const e = (n = t.id) == null ? void 0 : n.includes("/");
        return J.jsxs("div", {
            className: "flex items-center ",
            children: [J.jsx("div", {
                className: "absolute right-1.5 top-1.5 cursor-pointer",
                onClick: () => xc.dismiss(t.id),
                children: J.jsx(Xr, {
                    icon: "fa6-solid:xmark",
                    width: 12
                })
            }), t.icon, J.jsxs("div", {
                className: "flex flex-col items-start ml-2 mr-4",
                children: [(r = t.message) == null ? void 0 : r.toString(), e && J.jsxs("a", {
                    className: "underline flex items-center",
                    href: t.id,
                    target: "_blank",
                    rel: "noopener noreferrer",
                    children: ["View on explorer", J.jsx(Xr, {
                        className: "ml-3 -mt-0.5",
                        icon: "fa6-solid:arrow-up-right-from-square"
                    })]
                })]
            })]
        })
    },
    oft = () => J.jsx(ert, {
        position: "top-right",
        containerStyle: {
            top: "5rem"
        },
        toastOptions: {
            duration: 5e3,
            className: "bg-transparent",
            style: {
                maxWidth: "unset"
            },
            success: {
                className: "bg-[#52C41A] bg-opacity-20 text-white px-6 py-4 border border-[#52C41A]",
                icon: J.jsx(Xr, {
                    icon: "fa6-solid:circle-check",
                    className: "text-[#52C41A]",
                    width: 20
                })
            },
            error: {
                className: "bg-[#ED1522] bg-opacity-20 text-white px-6 py-4 border border-[#ED1522]",
                icon: J.jsx(Xr, {
                    icon: "fa6-solid:circle-xmark",
                    className: "text-[#ED1522]",
                    width: 20
                })
            }
        },
        children: t => J.jsx(Que, {
            toast: t,
            children: () => J.jsx(sft, {
                t
            })
        })
    }),
    uJ = () => {
        const {
            chainId: t,
            isConnected: e
        } = xs(), [{
            chainConfig: n
        }] = Uo(), r = Vfe();
        return !n || !e ? null : t !== n.id ? J.jsxs("div", {
            className: "cursor-pointer fixed z-20 bottom-8 left-1/2 -translate-x-1/2 bg-[#FFE662] bg-opacity-20 flex items-center font-bold text-lg px-6 py-4 pb-3 rounded-xl",
            onClick: r,
            children: [J.jsx(Xr, {
                className: "mr-4",
                color: "#FFA940",
                icon: "fa6-solid:circle-exclamation"
            }), J.jsxs("span", {
                children: ["Click to switch network to ", n.name]
            })]
        }) : null
    },
    aft = (t, e = 5, n = 4) => `${t.slice(0,e)}...${t.slice(-n)}`,
    Kde = () => {
        const {
            open: t
        } = WL(), {
            isConnected: e,
            address: n
        } = xs(), r = () => e && n ? J.jsxs(J.Fragment, {
            children: [J.jsx(Xr, {
                className: "mr-4",
                icon: "fa6-solid:user"
            }), aft(n)]
        }) : J.jsxs(J.Fragment, {
            children: [J.jsx(Xr, {
                className: "mr-4",
                icon: "fa6-solid:plus"
            }), "Connect wallet"]
        });
        return J.jsx(Bo, {
            onClick: () => t(),
            children: r()
        })
    },
    lft = ({
        children: t,
        className: e,
        ...n
    }) => J.jsx("h1", {
        className: `text-4xl mb-6 ${e}`,
        ...n,
        children: t
    }),
    gw = ({
        children: t
    }) => {
        const {
            address: e
        } = xs(), {
            loggedIn: n,
            signIn: r,
            demoSignIn: i
        } = e5();
        return n ? t || J.jsx(tU, {}) : J.jsxs(J.Fragment, {
            children: [J.jsx(lft, {
                children: "My Aigents"
            }), J.jsxs("div", {
                className: "flex flex-col flex-1 items-center justify-start",
                children: [J.jsx("div", {
                    className: "relative after:content-[''] after:absolute after:left-0 after:top-0 after:w-2/12 after:h-full after:z-20 after:bg-gradient-to-r after:from-[#17191B] before:content-[''] before:absolute before:right-0 before:top-0 before:w-2/12 before:h-full before:z-20 before:bg-gradient-to-l before:from-[#17191B]",
                    children: J.jsx("img", {
                        className: "w-full my-16",
                        src: "/images/welcome-bots.png"
                    })
                }), J.jsx("h1", {
                    className: "text-6xl",
                    children: "Welcome"
                }), J.jsxs("span", {
                    className: "text-2xl my-6",
                    children: [e ? "Sign auth message" : "Connect your wallet", " to create, launch, and manage bots."]
                }), e ? J.jsxs(J.Fragment, {
                    children: [J.jsx(W7, {
                        label: "Sign in",
                        className: "mt-8 w-48",
                        onClick: r
                    }), J.jsx(Bo, {
                        className: "mt-8 w-48",
                        onClick: i,
                        children: "Demo Access"
                    })]
                }) : J.jsx(Kde, {})]
            })]
        })
    },
    cft = () => {
        const [t] = unt(), {
            loggedIn: e
        } = e5(), {
            submitRefCode: n
        } = Hfe();
        return ae.useEffect(() => {
            const r = t.get("ref-type") || localStorage.getItem("ref-type"),
                i = t.get("ref-code") || localStorage.getItem("ref-code");
            r && i && !e && (localStorage.setItem("ref-type", r), localStorage.setItem("ref-code", i)), r && i && e && n(i).then(() => {
                localStorage.removeItem("ref-type"), localStorage.removeItem("ref-code")
            })
        }, [e, t]), null
    },
    n$ = {
        value: "",
        name: ""
    };
let HS;
const uft = () => {
    const {
        address: t
    } = xs(), {
        loggedIn: e,
        signOut: n
    } = e5(), r = ae.useMemo(() => !t || !e ? null : H7(`${Np}/affiliate/crm`, t, n), [t, e]);
    async function i() {
        if (!r) return null;
        try {
            return (await r.get("/bot/list")).data
        } catch (y) {
            return console.error(y), null
        }
    }
    async function s(y) {
        if (!r) return null;
        try {
            return (await r.get(`/bot/last-messages/${y}`)).data
        } catch (_) {
            return console.error(_), null
        }
    }
    async function o(y) {
        if (!r) return null;
        try {
            return (await r.get(`/chat/history/${y}`)).data
        } catch (_) {
            return console.error(_), null
        }
    }
    async function a(y) {
        if (!r) return null;
        try {
            return (await r.get(`/chat/summarize/${y}`)).data
        } catch (_) {
            return console.error(_), null
        }
    }
    async function l(y, _, C) {
        if (!r) return null;
        try {
            return (await r.post(`/bot/${y}/send`, {
                chat_id: y,
                text: _,
                channel: C
            })).data
        } catch (b) {
            return console.error(b), null
        }
    }
    async function c(y, _, C, b, w) {
        if (r) try {
            await r.post("/user/metadata/set", {
                chat_id: y,
                notes: _,
                tags: C
            }), b && b()
        } catch (S) {
            console.error(S), w && w()
        }
    }
    async function u(y, _ = !1, C = [], b, w) {
        if (r) try {
            await r.post("/user/metadata/delete", {
                chat_id: y,
                notes: _,
                tags: C
            }), b && b()
        } catch (S) {
            console.error(S), w && w()
        }
    }
    async function f(y, _, C) {
        if (r) {
            HS && HS.abort(), HS = new AbortController;
            try {
                const b = await r.get(`/chat/unread/${y}`, {
                    signal: HS.signal
                }).catch();
                _(b.data)
            } catch (b) {
                console.error(b), C && C(b)
            }
        }
    }
    async function h(y, _) {
        if (!r) return null;
        const C = `/bot/${_}/release/${y}`;
        try {
            return (await r.get(C)).data
        } catch (b) {
            return console.error(b), null
        }
    }
    async function g(y, _, C) {
        if (!r) return null;
        const b = `/bot/${_}/pause/${y}/${C?`?expiry=${C}`:""}`;
        try {
            return (await r.get(b)).data
        } catch (w) {
            return console.error(w), null
        }
    }
    return {
        botsInst: r,
        fetchBotsList: i,
        fetchBotConversations: s,
        fetchBotChatHistory: o,
        sendMessageToUser: l,
        setUserMetadata: c,
        deleteUserMetadata: u,
        checkNewMessage: f,
        pauseChat: g,
        releaseChat: h,
        generateChatSummary: a
    }
};
Ml("providers:ConversationsProvider");
const r$ = {
        bots: null,
        fetching: !0
    },
    i$ = {
        conversations: null,
        fetching: !0
    },
    s$ = {
        history: null,
        fetching: !0
    },
    fft = {
        botsState: r$,
        selectedBot: n$,
        setSelectedBot: () => {},
        conversationsState: i$,
        selectedConversation: null,
        setSelectedConversation: () => {},
        conversationHistoryState: s$,
        setConversationSettings: () => {},
        conversationSettings: null,
        setConversationHistoryState: () => {},
        pauseConversation: () => Promise.resolve(),
        releaseConversation: () => Promise.resolve(),
        visitor: null
    },
    Yde = ae.createContext(fft),
    dft = ({
        children: t
    }) => {
        const {
            fetchBotsList: e,
            fetchBotConversations: n,
            fetchBotChatHistory: r,
            checkNewMessage: i,
            pauseChat: s,
            releaseChat: o
        } = uft(), {
            address: a
        } = xs(), [l, c] = ae.useState(r$), [u, f] = ae.useState(n$), [h, g] = ae.useState(i$), [y, _] = ae.useState(null), [C, b] = ae.useState(s$), [w, S] = ae.useState(null), [I, P] = ae.useState(null), M = ae.useRef();
        ae.useEffect(() => {
            A()
        }, [a]), ae.useEffect(() => {
            if (!l.fetching) {
                if (l.bots.length === 0) {
                    f(n$);
                    return
                }
                f(U => U.value === l.bots[0].bot_name ? U : {
                    value: l.bots[0].bot_name,
                    name: l.bots[0].bot_name
                })
            }
        }, [l]), ae.useEffect(() => (E(), M.current = setInterval(() => E(!0), 5e3), () => clearInterval(M.current)), [u]), ae.useEffect(() => {
            $()
        }, [y]), ae.useEffect(() => {
            if (C.fetching) return;
            const U = document.querySelector("#chat .rcs-inner-container");
            U && (U.scrollTop = U.scrollHeight)
        }, [C.fetching]);
        async function A(U = !1) {
            U || c(r$);
            const m = await e();
            if (!m) {
                c({
                    bots: [],
                    fetching: !1
                });
                return
            }
            c({
                bots: m.bots_list,
                fetching: !1
            })
        }
        const E = Qm(async (U = !1) => {
            if (!u.value) return;
            U || g(i$);
            const m = await n(u.value);
            if (!m) {
                g(v => ({
                    conversations: v.conversations || [],
                    fetching: !1
                }));
                return
            }
            if (y) {
                const v = m.last_messages.findIndex(T => T.chat_id === y.chat_id);
                m.last_messages[v] = { ...m.last_messages[v],
                    unread_msg_count: 0
                }
            }
            g({
                conversations: m.last_messages.sort((v, T) => v.last_message.timestamp > T.last_message.timestamp ? -1 : v.last_message.timestamp < T.last_message.timestamp ? 1 : 0),
                fetching: !1
            })
        });
        async function $() {
            if (!y) return;
            b(s$);
            const U = await r(y.chat_id);
            if (!U) b({
                history: [],
                fetching: !1
            }), P(null), S(null);
            else {
                const {
                    visitor: m,
                    messages: v,
                    status: T,
                    bot: N,
                    expiry_at: O,
                    is_paused: L
                } = U;
                P(m), S({
                    status: T,
                    bot: N,
                    expiry_at: O,
                    is_paused: L
                }), b({
                    history: v,
                    fetching: !1
                }), H(), g(G => {
                    if (!G.conversations) return G;
                    const j = [...G.conversations],
                        R = j.findIndex(Y => Y.chat_id === y.chat_id);
                    return R === -1 ? G : (j[R] = { ...j[R],
                        unread_msg_count: 0
                    }, { ...G,
                        conversations: j
                    })
                })
            }
        }
        const H = async () => {
                y && await i(y.chat_id, U => {
                    U.status === "success" && b(m => m.history ? { ...m,
                        history: [...m.history.filter(v => v.user_id !== "typing"), ...U.messages]
                    } : m), H()
                }, U => {
                    Dr.isCancel(U) || setTimeout(() => H(), 2e3)
                })
            },
            K = async U => {
                const m = await s(y.chat_id, u.name, U);
                m && S(v => v && { ...v,
                    is_paused: !0,
                    expiry_at: m.expiry_at
                })
            },
            te = async () => {
                await o(y.chat_id, u.name) && S(m => m && { ...m,
                    is_paused: !1,
                    expiry_at: null
                })
            };
        return J.jsx(Yde.Provider, {
            value: {
                botsState: l,
                selectedBot: u,
                setSelectedBot: f,
                conversationsState: h,
                selectedConversation: y,
                setSelectedConversation: _,
                conversationHistoryState: C,
                conversationSettings: w,
                setConversationSettings: S,
                setConversationHistoryState: b,
                visitor: I,
                pauseConversation: K,
                releaseConversation: te
            },
            children: t
        })
    },
    S3t = () => ae.useContext(Yde),
    mw = Ml("providers:StakesProviderCtx"),
    hft = {
        stakes: [],
        fetching: !0,
        walletStakes: [],
        walletStakesSum: {},
        fetchStakes: () => {},
        fetchWalletStakes: () => {}
    },
    Zde = ae.createContext(hft),
    fJ = ({
        children: t
    }) => {
        const [{
            chainConfig: e,
            appRpcProvider: n
        }] = Uo(), {
            address: r
        } = xs(), [i, s] = ae.useState([]), [o, a] = ae.useState([]), [l, c] = ae.useState({}), [u, f] = ae.useState(!0), h = ae.useMemo(() => new Qr(e.contracts.AIXRevenueSharing, gU, n), []);
        ae.useEffect(() => {
            !h || !n || (mw("getAllStakesPeriodBoostAPR fired"), y())
        }, [n, h]), ae.useEffect(() => {
            if (h) {
                if (!r) {
                    a([]);
                    return
                }
                _()
            }
        }, [h, r]);

        function g(C) {
            const b = ur(C).div(1e4);
            return ur(1).plus(b.div(365)).pow(365).minus(1).times(100).toFixed(2)
        }
        const y = Qm(async () => {
                const [C, b] = await Promise.allSettled([Dr.get("https://clay-maiden-ai.cloud:2053/average_apr"), h.getAllStakesPeriodBoostAPR()]);
                if (mw("fetchStakes contract resp", b), mw("fetchStakes api resp", C), b.status === "fulfilled") {
                    const w = b.value.map(S => {
                        const I = S[0] / 60 n / 60 n / 24 n;
                        let P = ur(S[2].toString()).div(100).toString(),
                            M = g(S[2].toString());
                        if (C.status === "fulfilled") {
                            const A = C.value.data.find(E => E.period === Number(S[0]));
                            if (A) {
                                const E = FA.max(S[2].toString(), A.week_avg_apr_numerator, A.day_avg_apr_numerator).toString();
                                P = ur(E).div(100).toFixed(2), M = g(E)
                            }
                        }
                        return mw("result apy/apr", {
                            apr: P,
                            apy: M
                        }), {
                            sec: S[0],
                            days: I,
                            apr: P,
                            apy: M
                        }
                    }).sort((S, I) => S.sec < I.sec ? -1 : S.sec > I.sec ? 1 : 0).slice(0, 3);
                    s(w)
                }
                f(!1)
            }),
            _ = Qm(() => {
                h.getUserStakes(r).then(C => {
                    mw("getUserStakes resp", C);
                    const b = {};
                    a(C.map(w => {
                        const S = w[4].toString(),
                            I = w[2].toString();
                        return b[S] ? b[S] = ur(b[S]).plus(I).toString() : b[S] = I, {
                            user: w[0].toString(),
                            stakeId: w[1].toString(),
                            stakedAmount: I,
                            boostedStakedAmount: w[3].toString(),
                            period: S,
                            unstakeTimestamp: w[5].toString(),
                            lastRewardPerToken: w[6].toString(),
                            totalPaidRewards: w[7].toString(),
                            apr: w[8].toString(),
                            apy: g(w[8].toString()),
                            availableReward: w[9].toString(),
                            poolShare: w[10].toString()
                        }
                    })), mw("setWalletStakesSum", b), c(b)
                })
            });
        return J.jsx(Zde.Provider, {
            value: {
                stakes: i,
                fetching: u,
                walletStakes: o,
                fetchStakes: y,
                fetchWalletStakes: _,
                walletStakesSum: l
            },
            children: t
        })
    },
    C3t = () => ae.useContext(Zde);
class re extends Array {
    constructor(e, n) {
        if (super(e), this.sign = n, e > re.__kMaxLength) throw new RangeError("Maximum BigInt size exceeded")
    }
    static BigInt(e) {
        var n = Math.floor,
            r = Number.isFinite;
        if (typeof e == "number") {
            if (e === 0) return re.__zero();
            if (re.__isOneDigitInt(e)) return 0 > e ? re.__oneDigit(-e, !0) : re.__oneDigit(e, !1);
            if (!r(e) || n(e) !== e) throw new RangeError("The number " + e + " cannot be converted to BigInt because it is not an integer");
            return re.__fromDouble(e)
        }
        if (typeof e == "string") {
            const i = re.__fromString(e);
            if (i === null) throw new SyntaxError("Cannot convert " + e + " to a BigInt");
            return i
        }
        if (typeof e == "boolean") return e === !0 ? re.__oneDigit(1, !1) : re.__zero();
        if (typeof e == "object") {
            if (e.constructor === re) return e;
            const i = re.__toPrimitive(e);
            return re.BigInt(i)
        }
        throw new TypeError("Cannot convert " + e + " to a BigInt")
    }
    toDebugString() {
        const e = ["BigInt["];
        for (const n of this) e.push((n && (n >>> 0).toString(16)) + ", ");
        return e.push("]"), e.join("")
    }
    toString(e = 10) {
        if (2 > e || 36 < e) throw new RangeError("toString() radix argument must be between 2 and 36");
        return this.length === 0 ? "0" : e & e - 1 ? re.__toStringGeneric(this, e, !1) : re.__toStringBasePowerOfTwo(this, e)
    }
    static toNumber(e) {
        const n = e.length;
        if (n === 0) return 0;
        if (n === 1) {
            const C = e.__unsignedDigit(0);
            return e.sign ? -C : C
        }
        const r = e.__digit(n - 1),
            i = re.__clz30(r),
            s = 30 * n - i;
        if (1024 < s) return e.sign ? -1 / 0 : 1 / 0;
        let o = s - 1,
            a = r,
            l = n - 1;
        const c = i + 3;
        let u = c === 32 ? 0 : a << c;
        u >>>= 12;
        const f = c - 12;
        let h = 12 <= c ? 0 : a << 20 + c,
            g = 20 + c;
        for (0 < f && 0 < l && (l--, a = e.__digit(l), u |= a >>> 30 - f, h = a << f + 2, g = f + 2); 0 < g && 0 < l;) l--, a = e.__digit(l), h |= 30 <= g ? a << g - 30 : a >>> 30 - g, g -= 30;
        const y = re.__decideRounding(e, g, l, a);
        if ((y === 1 || y === 0 && (1 & h) == 1) && (h = h + 1 >>> 0, h === 0 && (u++, u >>> 20 != 0 && (u = 0, o++, 1023 < o)))) return e.sign ? -1 / 0 : 1 / 0;
        const _ = e.sign ? -2147483648 : 0;
        return o = o + 1023 << 20, re.__kBitConversionInts[1] = _ | o | u, re.__kBitConversionInts[0] = h, re.__kBitConversionDouble[0]
    }
    static unaryMinus(e) {
        if (e.length === 0) return e;
        const n = e.__copy();
        return n.sign = !e.sign, n
    }
    static bitwiseNot(e) {
        return e.sign ? re.__absoluteSubOne(e).__trim() : re.__absoluteAddOne(e, !0)
    }
    static exponentiate(e, n) {
        if (n.sign) throw new RangeError("Exponent must be positive");
        if (n.length === 0) return re.__oneDigit(1, !1);
        if (e.length === 0) return e;
        if (e.length === 1 && e.__digit(0) === 1) return e.sign && !(1 & n.__digit(0)) ? re.unaryMinus(e) : e;
        if (1 < n.length) throw new RangeError("BigInt too big");
        let r = n.__unsignedDigit(0);
        if (r === 1) return e;
        if (r >= re.__kMaxLengthBits) throw new RangeError("BigInt too big");
        if (e.length === 1 && e.__digit(0) === 2) {
            const o = 1 + (0 | r / 30),
                a = e.sign && (1 & r) != 0,
                l = new re(o, a);
            l.__initializeDigits();
            const c = 1 << r % 30;
            return l.__setDigit(o - 1, c), l
        }
        let i = null,
            s = e;
        for (1 & r && (i = e), r >>= 1; r !== 0; r >>= 1) s = re.multiply(s, s), 1 & r && (i === null ? i = s : i = re.multiply(i, s));
        return i
    }
    static multiply(e, n) {
        if (e.length === 0) return e;
        if (n.length === 0) return n;
        let r = e.length + n.length;
        30 <= e.__clzmsd() + n.__clzmsd() && r--;
        const i = new re(r, e.sign !== n.sign);
        i.__initializeDigits();
        for (let s = 0; s < e.length; s++) re.__multiplyAccumulate(n, e.__digit(s), i, s);
        return i.__trim()
    }
    static divide(e, n) {
        if (n.length === 0) throw new RangeError("Division by zero");
        if (0 > re.__absoluteCompare(e, n)) return re.__zero();
        const r = e.sign !== n.sign,
            i = n.__unsignedDigit(0);
        let s;
        if (n.length === 1 && 32767 >= i) {
            if (i === 1) return r === e.sign ? e : re.unaryMinus(e);
            s = re.__absoluteDivSmall(e, i, null)
        } else s = re.__absoluteDivLarge(e, n, !0, !1);
        return s.sign = r, s.__trim()
    }
    static remainder(e, n) {
        if (n.length === 0) throw new RangeError("Division by zero");
        if (0 > re.__absoluteCompare(e, n)) return e;
        const r = n.__unsignedDigit(0);
        if (n.length === 1 && 32767 >= r) {
            if (r === 1) return re.__zero();
            const s = re.__absoluteModSmall(e, r);
            return s === 0 ? re.__zero() : re.__oneDigit(s, e.sign)
        }
        const i = re.__absoluteDivLarge(e, n, !1, !0);
        return i.sign = e.sign, i.__trim()
    }
    static add(e, n) {
        const r = e.sign;
        return r === n.sign ? re.__absoluteAdd(e, n, r) : 0 <= re.__absoluteCompare(e, n) ? re.__absoluteSub(e, n, r) : re.__absoluteSub(n, e, !r)
    }
    static subtract(e, n) {
        const r = e.sign;
        return r === n.sign ? 0 <= re.__absoluteCompare(e, n) ? re.__absoluteSub(e, n, r) : re.__absoluteSub(n, e, !r) : re.__absoluteAdd(e, n, r)
    }
    static leftShift(e, n) {
        return n.length === 0 || e.length === 0 ? e : n.sign ? re.__rightShiftByAbsolute(e, n) : re.__leftShiftByAbsolute(e, n)
    }
    static signedRightShift(e, n) {
        return n.length === 0 || e.length === 0 ? e : n.sign ? re.__leftShiftByAbsolute(e, n) : re.__rightShiftByAbsolute(e, n)
    }
    static unsignedRightShift() {
        throw new TypeError("BigInts have no unsigned right shift; use >> instead")
    }
    static lessThan(e, n) {
        return 0 > re.__compareToBigInt(e, n)
    }
    static lessThanOrEqual(e, n) {
        return 0 >= re.__compareToBigInt(e, n)
    }
    static greaterThan(e, n) {
        return 0 < re.__compareToBigInt(e, n)
    }
    static greaterThanOrEqual(e, n) {
        return 0 <= re.__compareToBigInt(e, n)
    }
    static equal(e, n) {
        if (e.sign !== n.sign || e.length !== n.length) return !1;
        for (let r = 0; r < e.length; r++)
            if (e.__digit(r) !== n.__digit(r)) return !1;
        return !0
    }
    static notEqual(e, n) {
        return !re.equal(e, n)
    }
    static bitwiseAnd(e, n) {
        var r = Math.max;
        if (!e.sign && !n.sign) return re.__absoluteAnd(e, n).__trim();
        if (e.sign && n.sign) {
            const i = r(e.length, n.length) + 1;
            let s = re.__absoluteSubOne(e, i);
            const o = re.__absoluteSubOne(n);
            return s = re.__absoluteOr(s, o, s), re.__absoluteAddOne(s, !0, s).__trim()
        }
        return e.sign && ([e, n] = [n, e]), re.__absoluteAndNot(e, re.__absoluteSubOne(n)).__trim()
    }
    static bitwiseXor(e, n) {
        var r = Math.max;
        if (!e.sign && !n.sign) return re.__absoluteXor(e, n).__trim();
        if (e.sign && n.sign) {
            const o = r(e.length, n.length),
                a = re.__absoluteSubOne(e, o),
                l = re.__absoluteSubOne(n);
            return re.__absoluteXor(a, l, a).__trim()
        }
        const i = r(e.length, n.length) + 1;
        e.sign && ([e, n] = [n, e]);
        let s = re.__absoluteSubOne(n, i);
        return s = re.__absoluteXor(s, e, s), re.__absoluteAddOne(s, !0, s).__trim()
    }
    static bitwiseOr(e, n) {
        var r = Math.max;
        const i = r(e.length, n.length);
        if (!e.sign && !n.sign) return re.__absoluteOr(e, n).__trim();
        if (e.sign && n.sign) {
            let o = re.__absoluteSubOne(e, i);
            const a = re.__absoluteSubOne(n);
            return o = re.__absoluteAnd(o, a, o), re.__absoluteAddOne(o, !0, o).__trim()
        }
        e.sign && ([e, n] = [n, e]);
        let s = re.__absoluteSubOne(n, i);
        return s = re.__absoluteAndNot(s, e, s), re.__absoluteAddOne(s, !0, s).__trim()
    }
    static asIntN(e, n) {
        var r = Math.floor;
        if (n.length === 0) return n;
        if (e = r(e), 0 > e) throw new RangeError("Invalid value: not (convertible to) a safe integer");
        if (e === 0) return re.__zero();
        if (e >= re.__kMaxLengthBits) return n;
        const i = 0 | (e + 29) / 30;
        if (n.length < i) return n;
        const s = n.__unsignedDigit(i - 1),
            o = 1 << (e - 1) % 30;
        if (n.length === i && s < o) return n;
        if ((s & o) !== o) return re.__truncateToNBits(e, n);
        if (!n.sign) return re.__truncateAndSubFromPowerOfTwo(e, n, !0);
        if (!(s & o - 1)) {
            for (let a = i - 2; 0 <= a; a--)
                if (n.__digit(a) !== 0) return re.__truncateAndSubFromPowerOfTwo(e, n, !1);
            return n.length === i && s === o ? n : re.__truncateToNBits(e, n)
        }
        return re.__truncateAndSubFromPowerOfTwo(e, n, !1)
    }
    static asUintN(e, n) {
        var r = Math.floor;
        if (n.length === 0) return n;
        if (e = r(e), 0 > e) throw new RangeError("Invalid value: not (convertible to) a safe integer");
        if (e === 0) return re.__zero();
        if (n.sign) {
            if (e > re.__kMaxLengthBits) throw new RangeError("BigInt too big");
            return re.__truncateAndSubFromPowerOfTwo(e, n, !1)
        }
        if (e >= re.__kMaxLengthBits) return n;
        const i = 0 | (e + 29) / 30;
        if (n.length < i) return n;
        const s = e % 30;
        return n.length == i && (s === 0 || !(n.__digit(i - 1) >>> s)) ? n : re.__truncateToNBits(e, n)
    }
    static ADD(e, n) {
        if (e = re.__toPrimitive(e), n = re.__toPrimitive(n), typeof e == "string") return typeof n != "string" && (n = n.toString()), e + n;
        if (typeof n == "string") return e.toString() + n;
        if (e = re.__toNumeric(e), n = re.__toNumeric(n), re.__isBigInt(e) && re.__isBigInt(n)) return re.add(e, n);
        if (typeof e == "number" && typeof n == "number") return e + n;
        throw new TypeError("Cannot mix BigInt and other types, use explicit conversions")
    }
    static LT(e, n) {
        return re.__compare(e, n, 0)
    }
    static LE(e, n) {
        return re.__compare(e, n, 1)
    }
    static GT(e, n) {
        return re.__compare(e, n, 2)
    }
    static GE(e, n) {
        return re.__compare(e, n, 3)
    }
    static EQ(e, n) {
        for (;;) {
            if (re.__isBigInt(e)) return re.__isBigInt(n) ? re.equal(e, n) : re.EQ(n, e);
            if (typeof e == "number") {
                if (re.__isBigInt(n)) return re.__equalToNumber(n, e);
                if (typeof n != "object") return e == n;
                n = re.__toPrimitive(n)
            } else if (typeof e == "string") {
                if (re.__isBigInt(n)) return e = re.__fromString(e), e !== null && re.equal(e, n);
                if (typeof n != "object") return e == n;
                n = re.__toPrimitive(n)
            } else if (typeof e == "boolean") {
                if (re.__isBigInt(n)) return re.__equalToNumber(n, +e);
                if (typeof n != "object") return e == n;
                n = re.__toPrimitive(n)
            } else if (typeof e == "symbol") {
                if (re.__isBigInt(n)) return !1;
                if (typeof n != "object") return e == n;
                n = re.__toPrimitive(n)
            } else if (typeof e == "object") {
                if (typeof n == "object" && n.constructor !== re) return e == n;
                e = re.__toPrimitive(e)
            } else return e == n
        }
    }
    static NE(e, n) {
        return !re.EQ(e, n)
    }
    static __zero() {
        return new re(0, !1)
    }
    static __oneDigit(e, n) {
        const r = new re(1, n);
        return r.__setDigit(0, e), r
    }
    __copy() {
        const e = new re(this.length, this.sign);
        for (let n = 0; n < this.length; n++) e[n] = this[n];
        return e
    }
    __trim() {
        let e = this.length,
            n = this[e - 1];
        for (; n === 0;) e--, n = this[e - 1], this.pop();
        return e === 0 && (this.sign = !1), this
    }
    __initializeDigits() {
        for (let e = 0; e < this.length; e++) this[e] = 0
    }
    static __decideRounding(e, n, r, i) {
        if (0 < n) return -1;
        let s;
        if (0 > n) s = -n - 1;
        else {
            if (r === 0) return -1;
            r--, i = e.__digit(r), s = 29
        }
        let o = 1 << s;
        if (!(i & o)) return -1;
        if (o -= 1, (i & o) != 0) return 1;
        for (; 0 < r;)
            if (r--, e.__digit(r) !== 0) return 1;
        return 0
    }
    static __fromDouble(e) {
        re.__kBitConversionDouble[0] = e;
        const n = 2047 & re.__kBitConversionInts[1] >>> 20,
            r = n - 1023,
            i = (0 | r / 30) + 1,
            s = new re(i, 0 > e);
        let o = 1048575 & re.__kBitConversionInts[1] | 1048576,
            a = re.__kBitConversionInts[0];
        const l = 20,
            c = r % 30;
        let u, f = 0;
        if (c < 20) {
            const h = l - c;
            f = h + 32, u = o >>> h, o = o << 32 - h | a >>> h, a <<= 32 - h
        } else if (c === 20) f = 32, u = o, o = a, a = 0;
        else {
            const h = c - l;
            f = 32 - h, u = o << h | a >>> 32 - h, o = a << h, a = 0
        }
        s.__setDigit(i - 1, u);
        for (let h = i - 2; 0 <= h; h--) 0 < f ? (f -= 30, u = o >>> 2, o = o << 30 | a >>> 2, a <<= 30) : u = 0, s.__setDigit(h, u);
        return s.__trim()
    }
    static __isWhitespace(e) {
        return 13 >= e && 9 <= e || (159 >= e ? e == 32 : 131071 >= e ? e == 160 || e == 5760 : 196607 >= e ? (e &= 131071, 10 >= e || e == 40 || e == 41 || e == 47 || e == 95 || e == 4096) : e == 65279)
    }
    static __fromString(e, n = 0) {
        let r = 0;
        const i = e.length;
        let s = 0;
        if (s === i) return re.__zero();
        let o = e.charCodeAt(s);
        for (; re.__isWhitespace(o);) {
            if (++s === i) return re.__zero();
            o = e.charCodeAt(s)
        }
        if (o === 43) {
            if (++s === i) return null;
            o = e.charCodeAt(s), r = 1
        } else if (o === 45) {
            if (++s === i) return null;
            o = e.charCodeAt(s), r = -1
        }
        if (n === 0) {
            if (n = 10, o === 48) {
                if (++s === i) return re.__zero();
                if (o = e.charCodeAt(s), o === 88 || o === 120) {
                    if (n = 16, ++s === i) return null;
                    o = e.charCodeAt(s)
                } else if (o === 79 || o === 111) {
                    if (n = 8, ++s === i) return null;
                    o = e.charCodeAt(s)
                } else if (o === 66 || o === 98) {
                    if (n = 2, ++s === i) return null;
                    o = e.charCodeAt(s)
                }
            }
        } else if (n === 16 && o === 48) {
            if (++s === i) return re.__zero();
            if (o = e.charCodeAt(s), o === 88 || o === 120) {
                if (++s === i) return null;
                o = e.charCodeAt(s)
            }
        }
        if (r != 0 && n !== 10) return null;
        for (; o === 48;) {
            if (++s === i) return re.__zero();
            o = e.charCodeAt(s)
        }
        const a = i - s;
        let l = re.__kMaxBitsPerChar[n],
            c = re.__kBitsPerCharTableMultiplier - 1;
        if (a > 1073741824 / l) return null;
        const u = l * a + c >>> re.__kBitsPerCharTableShift,
            f = new re(0 | (u + 29) / 30, !1),
            h = 10 > n ? n : 10,
            g = 10 < n ? n - 10 : 0;
        if (n & n - 1) {
            f.__initializeDigits();
            let y = !1,
                _ = 0;
            do {
                let C = 0,
                    b = 1;
                for (;;) {
                    let S;
                    if (o - 48 >>> 0 < h) S = o - 48;
                    else if ((32 | o) - 97 >>> 0 < g) S = (32 | o) - 87;
                    else {
                        y = !0;
                        break
                    }
                    const I = b * n;
                    if (1073741823 < I) break;
                    if (b = I, C = C * n + S, _++, ++s === i) {
                        y = !0;
                        break
                    }
                    o = e.charCodeAt(s)
                }
                c = 30 * re.__kBitsPerCharTableMultiplier - 1;
                const w = 0 | (l * _ + c >>> re.__kBitsPerCharTableShift) / 30;
                f.__inplaceMultiplyAdd(b, C, w)
            } while (!y)
        } else {
            l >>= re.__kBitsPerCharTableShift;
            const y = [],
                _ = [];
            let C = !1;
            do {
                let b = 0,
                    w = 0;
                for (;;) {
                    let S;
                    if (o - 48 >>> 0 < h) S = o - 48;
                    else if ((32 | o) - 97 >>> 0 < g) S = (32 | o) - 87;
                    else {
                        C = !0;
                        break
                    }
                    if (w += l, b = b << l | S, ++s === i) {
                        C = !0;
                        break
                    }
                    if (o = e.charCodeAt(s), 30 < w + l) break
                }
                y.push(b), _.push(w)
            } while (!C);
            re.__fillFromParts(f, y, _)
        }
        if (s !== i) {
            if (!re.__isWhitespace(o)) return null;
            for (s++; s < i; s++)
                if (o = e.charCodeAt(s), !re.__isWhitespace(o)) return null
        }
        return f.sign = r == -1, f.__trim()
    }
    static __fillFromParts(e, n, r) {
        let i = 0,
            s = 0,
            o = 0;
        for (let a = n.length - 1; 0 <= a; a--) {
            const l = n[a],
                c = r[a];
            s |= l << o, o += c, o === 30 ? (e.__setDigit(i++, s), o = 0, s = 0) : 30 < o && (e.__setDigit(i++, 1073741823 & s), o -= 30, s = l >>> c - o)
        }
        if (s !== 0) {
            if (i >= e.length) throw new Error("implementation bug");
            e.__setDigit(i++, s)
        }
        for (; i < e.length; i++) e.__setDigit(i, 0)
    }
    static __toStringBasePowerOfTwo(e, n) {
        const r = e.length;
        let i = n - 1;
        i = (85 & i >>> 1) + (85 & i), i = (51 & i >>> 2) + (51 & i), i = (15 & i >>> 4) + (15 & i);
        const s = i,
            o = n - 1,
            a = e.__digit(r - 1),
            l = re.__clz30(a);
        let c = 0 | (30 * r - l + s - 1) / s;
        if (e.sign && c++, 268435456 < c) throw new Error("string too long");
        const u = Array(c);
        let f = c - 1,
            h = 0,
            g = 0;
        for (let _ = 0; _ < r - 1; _++) {
            const C = e.__digit(_),
                b = (h | C << g) & o;
            u[f--] = re.__kConversionChars[b];
            const w = s - g;
            for (h = C >>> w, g = 30 - w; g >= s;) u[f--] = re.__kConversionChars[h & o], h >>>= s, g -= s
        }
        const y = (h | a << g) & o;
        for (u[f--] = re.__kConversionChars[y], h = a >>> s - g; h !== 0;) u[f--] = re.__kConversionChars[h & o], h >>>= s;
        if (e.sign && (u[f--] = "-"), f != -1) throw new Error("implementation bug");
        return u.join("")
    }
    static __toStringGeneric(e, n, r) {
        const i = e.length;
        if (i === 0) return "";
        if (i === 1) {
            let _ = e.__unsignedDigit(0).toString(n);
            return r === !1 && e.sign && (_ = "-" + _), _
        }
        const s = 30 * i - re.__clz30(e.__digit(i - 1)),
            o = re.__kMaxBitsPerChar[n],
            a = o - 1;
        let l = s * re.__kBitsPerCharTableMultiplier;
        l += a - 1, l = 0 | l / a;
        const c = l + 1 >> 1,
            u = re.exponentiate(re.__oneDigit(n, !1), re.__oneDigit(c, !1));
        let f, h;
        const g = u.__unsignedDigit(0);
        if (u.length === 1 && 32767 >= g) {
            f = new re(e.length, !1), f.__initializeDigits();
            let _ = 0;
            for (let C = 2 * e.length - 1; 0 <= C; C--) {
                const b = _ << 15 | e.__halfDigit(C);
                f.__setHalfDigit(C, 0 | b / g), _ = 0 | b % g
            }
            h = _.toString(n)
        } else {
            const _ = re.__absoluteDivLarge(e, u, !0, !0);
            f = _.quotient;
            const C = _.remainder.__trim();
            h = re.__toStringGeneric(C, n, !0)
        }
        f.__trim();
        let y = re.__toStringGeneric(f, n, !0);
        for (; h.length < c;) h = "0" + h;
        return r === !1 && e.sign && (y = "-" + y), y + h
    }
    static __unequalSign(e) {
        return e ? -1 : 1
    }
    static __absoluteGreater(e) {
        return e ? -1 : 1
    }
    static __absoluteLess(e) {
        return e ? 1 : -1
    }
    static __compareToBigInt(e, n) {
        const r = e.sign;
        if (r !== n.sign) return re.__unequalSign(r);
        const i = re.__absoluteCompare(e, n);
        return 0 < i ? re.__absoluteGreater(r) : 0 > i ? re.__absoluteLess(r) : 0
    }
    static __compareToNumber(e, n) {
        if (re.__isOneDigitInt(n)) {
            const r = e.sign,
                i = 0 > n;
            if (r !== i) return re.__unequalSign(r);
            if (e.length === 0) {
                if (i) throw new Error("implementation bug");
                return n === 0 ? 0 : -1
            }
            if (1 < e.length) return re.__absoluteGreater(r);
            const s = Math.abs(n),
                o = e.__unsignedDigit(0);
            return o > s ? re.__absoluteGreater(r) : o < s ? re.__absoluteLess(r) : 0
        }
        return re.__compareToDouble(e, n)
    }
    static __compareToDouble(e, n) {
        if (n !== n) return n;
        if (n === 1 / 0) return -1;
        if (n === -1 / 0) return 1;
        const r = e.sign;
        if (r !== 0 > n) return re.__unequalSign(r);
        if (n === 0) throw new Error("implementation bug: should be handled elsewhere");
        if (e.length === 0) return -1;
        re.__kBitConversionDouble[0] = n;
        const i = 2047 & re.__kBitConversionInts[1] >>> 20;
        if (i == 2047) throw new Error("implementation bug: handled elsewhere");
        const s = i - 1023;
        if (0 > s) return re.__absoluteGreater(r);
        const o = e.length;
        let a = e.__digit(o - 1);
        const l = re.__clz30(a),
            c = 30 * o - l,
            u = s + 1;
        if (c < u) return re.__absoluteLess(r);
        if (c > u) return re.__absoluteGreater(r);
        let f = 1048576 | 1048575 & re.__kBitConversionInts[1],
            h = re.__kBitConversionInts[0];
        const g = 20,
            y = 29 - l;
        if (y !== (0 | (c - 1) % 30)) throw new Error("implementation bug");
        let _, C = 0;
        if (20 > y) {
            const b = g - y;
            C = b + 32, _ = f >>> b, f = f << 32 - b | h >>> b, h <<= 32 - b
        } else if (y === 20) C = 32, _ = f, f = h, h = 0;
        else {
            const b = y - g;
            C = 32 - b, _ = f << b | h >>> 32 - b, f = h << b, h = 0
        }
        if (a >>>= 0, _ >>>= 0, a > _) return re.__absoluteGreater(r);
        if (a < _) return re.__absoluteLess(r);
        for (let b = o - 2; 0 <= b; b--) {
            0 < C ? (C -= 30, _ = f >>> 2, f = f << 30 | h >>> 2, h <<= 30) : _ = 0;
            const w = e.__unsignedDigit(b);
            if (w > _) return re.__absoluteGreater(r);
            if (w < _) return re.__absoluteLess(r)
        }
        if (f !== 0 || h !== 0) {
            if (C === 0) throw new Error("implementation bug");
            return re.__absoluteLess(r)
        }
        return 0
    }
    static __equalToNumber(e, n) {
        var r = Math.abs;
        return re.__isOneDigitInt(n) ? n === 0 ? e.length === 0 : e.length === 1 && e.sign === 0 > n && e.__unsignedDigit(0) === r(n) : re.__compareToDouble(e, n) === 0
    }
    static __comparisonResultToBool(e, n) {
        return n === 0 ? 0 > e : n === 1 ? 0 >= e : n === 2 ? 0 < e : n === 3 ? 0 <= e : void 0
    }
    static __compare(e, n, r) {
        if (e = re.__toPrimitive(e), n = re.__toPrimitive(n), typeof e == "string" && typeof n == "string") switch (r) {
            case 0:
                return e < n;
            case 1:
                return e <= n;
            case 2:
                return e > n;
            case 3:
                return e >= n
        }
        if (re.__isBigInt(e) && typeof n == "string") return n = re.__fromString(n), n !== null && re.__comparisonResultToBool(re.__compareToBigInt(e, n), r);
        if (typeof e == "string" && re.__isBigInt(n)) return e = re.__fromString(e), e !== null && re.__comparisonResultToBool(re.__compareToBigInt(e, n), r);
        if (e = re.__toNumeric(e), n = re.__toNumeric(n), re.__isBigInt(e)) {
            if (re.__isBigInt(n)) return re.__comparisonResultToBool(re.__compareToBigInt(e, n), r);
            if (typeof n != "number") throw new Error("implementation bug");
            return re.__comparisonResultToBool(re.__compareToNumber(e, n), r)
        }
        if (typeof e != "number") throw new Error("implementation bug");
        if (re.__isBigInt(n)) return re.__comparisonResultToBool(re.__compareToNumber(n, e), 2 ^ r);
        if (typeof n != "number") throw new Error("implementation bug");
        return r === 0 ? e < n : r === 1 ? e <= n : r === 2 ? e > n : r === 3 ? e >= n : void 0
    }
    __clzmsd() {
        return re.__clz30(this.__digit(this.length - 1))
    }
    static __absoluteAdd(e, n, r) {
        if (e.length < n.length) return re.__absoluteAdd(n, e, r);
        if (e.length === 0) return e;
        if (n.length === 0) return e.sign === r ? e : re.unaryMinus(e);
        let i = e.length;
        (e.__clzmsd() === 0 || n.length === e.length && n.__clzmsd() === 0) && i++;
        const s = new re(i, r);
        let o = 0,
            a = 0;
        for (; a < n.length; a++) {
            const l = e.__digit(a) + n.__digit(a) + o;
            o = l >>> 30, s.__setDigit(a, 1073741823 & l)
        }
        for (; a < e.length; a++) {
            const l = e.__digit(a) + o;
            o = l >>> 30, s.__setDigit(a, 1073741823 & l)
        }
        return a < s.length && s.__setDigit(a, o), s.__trim()
    }
    static __absoluteSub(e, n, r) {
        if (e.length === 0) return e;
        if (n.length === 0) return e.sign === r ? e : re.unaryMinus(e);
        const i = new re(e.length, r);
        let s = 0,
            o = 0;
        for (; o < n.length; o++) {
            const a = e.__digit(o) - n.__digit(o) - s;
            s = 1 & a >>> 30, i.__setDigit(o, 1073741823 & a)
        }
        for (; o < e.length; o++) {
            const a = e.__digit(o) - s;
            s = 1 & a >>> 30, i.__setDigit(o, 1073741823 & a)
        }
        return i.__trim()
    }
    static __absoluteAddOne(e, n, r = null) {
        const i = e.length;
        r === null ? r = new re(i, n) : r.sign = n;
        let s = 1;
        for (let o = 0; o < i; o++) {
            const a = e.__digit(o) + s;
            s = a >>> 30, r.__setDigit(o, 1073741823 & a)
        }
        return s != 0 && r.__setDigitGrow(i, 1), r
    }
    static __absoluteSubOne(e, n) {
        const r = e.length;
        n = n || r;
        const i = new re(n, !1);
        let s = 1;
        for (let o = 0; o < r; o++) {
            const a = e.__digit(o) - s;
            s = 1 & a >>> 30, i.__setDigit(o, 1073741823 & a)
        }
        if (s != 0) throw new Error("implementation bug");
        for (let o = r; o < n; o++) i.__setDigit(o, 0);
        return i
    }
    static __absoluteAnd(e, n, r = null) {
        let i = e.length,
            s = n.length,
            o = s;
        if (i < s) {
            o = i;
            const c = e,
                u = i;
            e = n, i = s, n = c, s = u
        }
        let a = o;
        r === null ? r = new re(a, !1) : a = r.length;
        let l = 0;
        for (; l < o; l++) r.__setDigit(l, e.__digit(l) & n.__digit(l));
        for (; l < a; l++) r.__setDigit(l, 0);
        return r
    }
    static __absoluteAndNot(e, n, r = null) {
        const i = e.length,
            s = n.length;
        let o = s;
        i < s && (o = i);
        let a = i;
        r === null ? r = new re(a, !1) : a = r.length;
        let l = 0;
        for (; l < o; l++) r.__setDigit(l, e.__digit(l) & ~n.__digit(l));
        for (; l < i; l++) r.__setDigit(l, e.__digit(l));
        for (; l < a; l++) r.__setDigit(l, 0);
        return r
    }
    static __absoluteOr(e, n, r = null) {
        let i = e.length,
            s = n.length,
            o = s;
        if (i < s) {
            o = i;
            const c = e,
                u = i;
            e = n, i = s, n = c, s = u
        }
        let a = i;
        r === null ? r = new re(a, !1) : a = r.length;
        let l = 0;
        for (; l < o; l++) r.__setDigit(l, e.__digit(l) | n.__digit(l));
        for (; l < i; l++) r.__setDigit(l, e.__digit(l));
        for (; l < a; l++) r.__setDigit(l, 0);
        return r
    }
    static __absoluteXor(e, n, r = null) {
        let i = e.length,
            s = n.length,
            o = s;
        if (i < s) {
            o = i;
            const c = e,
                u = i;
            e = n, i = s, n = c, s = u
        }
        let a = i;
        r === null ? r = new re(a, !1) : a = r.length;
        let l = 0;
        for (; l < o; l++) r.__setDigit(l, e.__digit(l) ^ n.__digit(l));
        for (; l < i; l++) r.__setDigit(l, e.__digit(l));
        for (; l < a; l++) r.__setDigit(l, 0);
        return r
    }
    static __absoluteCompare(e, n) {
        const r = e.length - n.length;
        if (r != 0) return r;
        let i = e.length - 1;
        for (; 0 <= i && e.__digit(i) === n.__digit(i);) i--;
        return 0 > i ? 0 : e.__unsignedDigit(i) > n.__unsignedDigit(i) ? 1 : -1
    }
    static __multiplyAccumulate(e, n, r, i) {
        if (n === 0) return;
        const s = 32767 & n,
            o = n >>> 15;
        let a = 0,
            l = 0;
        for (let c, u = 0; u < e.length; u++, i++) {
            c = r.__digit(i);
            const f = e.__digit(u),
                h = 32767 & f,
                g = f >>> 15,
                y = re.__imul(h, s),
                _ = re.__imul(h, o),
                C = re.__imul(g, s),
                b = re.__imul(g, o);
            c += l + y + a, a = c >>> 30, c &= 1073741823, c += ((32767 & _) << 15) + ((32767 & C) << 15), a += c >>> 30, l = b + (_ >>> 15) + (C >>> 15), r.__setDigit(i, 1073741823 & c)
        }
        for (; a != 0 || l !== 0; i++) {
            let c = r.__digit(i);
            c += a + l, l = 0, a = c >>> 30, r.__setDigit(i, 1073741823 & c)
        }
    }
    static __internalMultiplyAdd(e, n, r, i, s) {
        let o = r,
            a = 0;
        for (let l = 0; l < i; l++) {
            const c = e.__digit(l),
                u = re.__imul(32767 & c, n),
                f = re.__imul(c >>> 15, n),
                h = u + ((32767 & f) << 15) + a + o;
            o = h >>> 30, a = f >>> 15, s.__setDigit(l, 1073741823 & h)
        }
        if (s.length > i)
            for (s.__setDigit(i++, o + a); i < s.length;) s.__setDigit(i++, 0);
        else if (o + a !== 0) throw new Error("implementation bug")
    }
    __inplaceMultiplyAdd(e, n, r) {
        r > this.length && (r = this.length);
        const i = 32767 & e,
            s = e >>> 15;
        let o = 0,
            a = n;
        for (let l = 0; l < r; l++) {
            const c = this.__digit(l),
                u = 32767 & c,
                f = c >>> 15,
                h = re.__imul(u, i),
                g = re.__imul(u, s),
                y = re.__imul(f, i),
                _ = re.__imul(f, s);
            let C = a + h + o;
            o = C >>> 30, C &= 1073741823, C += ((32767 & g) << 15) + ((32767 & y) << 15), o += C >>> 30, a = _ + (g >>> 15) + (y >>> 15), this.__setDigit(l, 1073741823 & C)
        }
        if (o != 0 || a !== 0) throw new Error("implementation bug")
    }
    static __absoluteDivSmall(e, n, r = null) {
        r === null && (r = new re(e.length, !1));
        let i = 0;
        for (let s, o = 2 * e.length - 1; 0 <= o; o -= 2) {
            s = (i << 15 | e.__halfDigit(o)) >>> 0;
            const a = 0 | s / n;
            i = 0 | s % n, s = (i << 15 | e.__halfDigit(o - 1)) >>> 0;
            const l = 0 | s / n;
            i = 0 | s % n, r.__setDigit(o >>> 1, a << 15 | l)
        }
        return r
    }
    static __absoluteModSmall(e, n) {
        let r = 0;
        for (let i = 2 * e.length - 1; 0 <= i; i--) r = 0 | ((r << 15 | e.__halfDigit(i)) >>> 0) % n;
        return r
    }
    static __absoluteDivLarge(e, n, r, i) {
        const s = n.__halfDigitLength(),
            o = n.length,
            a = e.__halfDigitLength() - s;
        let l = null;
        r && (l = new re(a + 2 >>> 1, !1), l.__initializeDigits());
        const c = new re(s + 2 >>> 1, !1);
        c.__initializeDigits();
        const u = re.__clz15(n.__halfDigit(s - 1));
        0 < u && (n = re.__specialLeftShift(n, u, 0));
        const f = re.__specialLeftShift(e, u, 1),
            h = n.__halfDigit(s - 1);
        let g = 0;
        for (let y, _ = a; 0 <= _; _--) {
            y = 32767;
            const C = f.__halfDigit(_ + s);
            if (C !== h) {
                const w = (C << 15 | f.__halfDigit(_ + s - 1)) >>> 0;
                y = 0 | w / h;
                let S = 0 | w % h;
                const I = n.__halfDigit(s - 2),
                    P = f.__halfDigit(_ + s - 2);
                for (; re.__imul(y, I) >>> 0 > (S << 16 | P) >>> 0 && (y--, S += h, !(32767 < S)););
            }
            re.__internalMultiplyAdd(n, y, 0, o, c);
            let b = f.__inplaceSub(c, _, s + 1);
            b !== 0 && (b = f.__inplaceAdd(n, _, s), f.__setHalfDigit(_ + s, 32767 & f.__halfDigit(_ + s) + b), y--), r && (1 & _ ? g = y << 15 : l.__setDigit(_ >>> 1, g | y))
        }
        if (i) return f.__inplaceRightShift(u), r ? {
            quotient: l,
            remainder: f
        } : f;
        if (r) return l;
        throw new Error("unreachable")
    }
    static __clz15(e) {
        return re.__clz30(e) - 15
    }
    __inplaceAdd(e, n, r) {
        let i = 0;
        for (let s = 0; s < r; s++) {
            const o = this.__halfDigit(n + s) + e.__halfDigit(s) + i;
            i = o >>> 15, this.__setHalfDigit(n + s, 32767 & o)
        }
        return i
    }
    __inplaceSub(e, n, r) {
        let i = 0;
        if (1 & n) {
            n >>= 1;
            let s = this.__digit(n),
                o = 32767 & s,
                a = 0;
            for (; a < r - 1 >>> 1; a++) {
                const u = e.__digit(a),
                    f = (s >>> 15) - (32767 & u) - i;
                i = 1 & f >>> 15, this.__setDigit(n + a, (32767 & f) << 15 | 32767 & o), s = this.__digit(n + a + 1), o = (32767 & s) - (u >>> 15) - i, i = 1 & o >>> 15
            }
            const l = e.__digit(a),
                c = (s >>> 15) - (32767 & l) - i;
            if (i = 1 & c >>> 15, this.__setDigit(n + a, (32767 & c) << 15 | 32767 & o), n + a + 1 >= this.length) throw new RangeError("out of bounds");
            !(1 & r) && (s = this.__digit(n + a + 1), o = (32767 & s) - (l >>> 15) - i, i = 1 & o >>> 15, this.__setDigit(n + e.length, 1073709056 & s | 32767 & o))
        } else {
            n >>= 1;
            let s = 0;
            for (; s < e.length - 1; s++) {
                const u = this.__digit(n + s),
                    f = e.__digit(s),
                    h = (32767 & u) - (32767 & f) - i;
                i = 1 & h >>> 15;
                const g = (u >>> 15) - (f >>> 15) - i;
                i = 1 & g >>> 15, this.__setDigit(n + s, (32767 & g) << 15 | 32767 & h)
            }
            const o = this.__digit(n + s),
                a = e.__digit(s),
                l = (32767 & o) - (32767 & a) - i;
            i = 1 & l >>> 15;
            let c = 0;
            !(1 & r) && (c = (o >>> 15) - (a >>> 15) - i, i = 1 & c >>> 15), this.__setDigit(n + s, (32767 & c) << 15 | 32767 & l)
        }
        return i
    }
    __inplaceRightShift(e) {
        if (e === 0) return;
        let n = this.__digit(0) >>> e;
        const r = this.length - 1;
        for (let i = 0; i < r; i++) {
            const s = this.__digit(i + 1);
            this.__setDigit(i, 1073741823 & s << 30 - e | n), n = s >>> e
        }
        this.__setDigit(r, n)
    }
    static __specialLeftShift(e, n, r) {
        const i = e.length,
            s = new re(i + r, !1);
        if (n === 0) {
            for (let a = 0; a < i; a++) s.__setDigit(a, e.__digit(a));
            return 0 < r && s.__setDigit(i, 0), s
        }
        let o = 0;
        for (let a = 0; a < i; a++) {
            const l = e.__digit(a);
            s.__setDigit(a, 1073741823 & l << n | o), o = l >>> 30 - n
        }
        return 0 < r && s.__setDigit(i, o), s
    }
    static __leftShiftByAbsolute(e, n) {
        const r = re.__toShiftAmount(n);
        if (0 > r) throw new RangeError("BigInt too big");
        const i = 0 | r / 30,
            s = r % 30,
            o = e.length,
            a = s !== 0 && e.__digit(o - 1) >>> 30 - s != 0,
            l = o + i + (a ? 1 : 0),
            c = new re(l, e.sign);
        if (s === 0) {
            let u = 0;
            for (; u < i; u++) c.__setDigit(u, 0);
            for (; u < l; u++) c.__setDigit(u, e.__digit(u - i))
        } else {
            let u = 0;
            for (let f = 0; f < i; f++) c.__setDigit(f, 0);
            for (let f = 0; f < o; f++) {
                const h = e.__digit(f);
                c.__setDigit(f + i, 1073741823 & h << s | u), u = h >>> 30 - s
            }
            if (a) c.__setDigit(o + i, u);
            else if (u !== 0) throw new Error("implementation bug")
        }
        return c.__trim()
    }
    static __rightShiftByAbsolute(e, n) {
        const r = e.length,
            i = e.sign,
            s = re.__toShiftAmount(n);
        if (0 > s) return re.__rightShiftByMaximum(i);
        const o = 0 | s / 30,
            a = s % 30;
        let l = r - o;
        if (0 >= l) return re.__rightShiftByMaximum(i);
        let c = !1;
        if (i) {
            if (e.__digit(o) & (1 << a) - 1) c = !0;
            else
                for (let f = 0; f < o; f++)
                    if (e.__digit(f) !== 0) {
                        c = !0;
                        break
                    }
        }
        c && a === 0 && !~e.__digit(r - 1) && l++;
        let u = new re(l, i);
        if (a === 0) {
            u.__setDigit(l - 1, 0);
            for (let f = o; f < r; f++) u.__setDigit(f - o, e.__digit(f))
        } else {
            let f = e.__digit(o) >>> a;
            const h = r - o - 1;
            for (let g = 0; g < h; g++) {
                const y = e.__digit(g + o + 1);
                u.__setDigit(g, 1073741823 & y << 30 - a | f), f = y >>> a
            }
            u.__setDigit(h, f)
        }
        return c && (u = re.__absoluteAddOne(u, !0, u)), u.__trim()
    }
    static __rightShiftByMaximum(e) {
        return e ? re.__oneDigit(1, !0) : re.__zero()
    }
    static __toShiftAmount(e) {
        if (1 < e.length) return -1;
        const n = e.__unsignedDigit(0);
        return n > re.__kMaxLengthBits ? -1 : n
    }
    static __toPrimitive(e, n = "default") {
        if (typeof e != "object" || e.constructor === re) return e;
        if (typeof Symbol < "u" && typeof Symbol.toPrimitive == "symbol") {
            const s = e[Symbol.toPrimitive];
            if (s) {
                const o = s(n);
                if (typeof o != "object") return o;
                throw new TypeError("Cannot convert object to primitive value")
            }
        }
        const r = e.valueOf;
        if (r) {
            const s = r.call(e);
            if (typeof s != "object") return s
        }
        const i = e.toString;
        if (i) {
            const s = i.call(e);
            if (typeof s != "object") return s
        }
        throw new TypeError("Cannot convert object to primitive value")
    }
    static __toNumeric(e) {
        return re.__isBigInt(e) ? e : +e
    }
    static __isBigInt(e) {
        return typeof e == "object" && e !== null && e.constructor === re
    }
    static __truncateToNBits(e, n) {
        const r = 0 | (e + 29) / 30,
            i = new re(r, n.sign),
            s = r - 1;
        for (let a = 0; a < s; a++) i.__setDigit(a, n.__digit(a));
        let o = n.__digit(s);
        if (e % 30 != 0) {
            const a = 32 - e % 30;
            o = o << a >>> a
        }
        return i.__setDigit(s, o), i.__trim()
    }
    static __truncateAndSubFromPowerOfTwo(e, n, r) {
        var i = Math.min;
        const s = 0 | (e + 29) / 30,
            o = new re(s, r);
        let a = 0;
        const l = s - 1;
        let c = 0;
        for (const g = i(l, n.length); a < g; a++) {
            const y = 0 - n.__digit(a) - c;
            c = 1 & y >>> 30, o.__setDigit(a, 1073741823 & y)
        }
        for (; a < l; a++) o.__setDigit(a, 0 | 1073741823 & -c);
        let u = l < n.length ? n.__digit(l) : 0;
        const f = e % 30;
        let h;
        if (f == 0) h = 0 - u - c, h &= 1073741823;
        else {
            const g = 32 - f;
            u = u << g >>> g;
            const y = 1 << 32 - g;
            h = y - u - c, h &= y - 1
        }
        return o.__setDigit(l, h), o.__trim()
    }
    __digit(e) {
        return this[e]
    }
    __unsignedDigit(e) {
        return this[e] >>> 0
    }
    __setDigit(e, n) {
        this[e] = 0 | n
    }
    __setDigitGrow(e, n) {
        this[e] = 0 | n
    }
    __halfDigitLength() {
        const e = this.length;
        return 32767 >= this.__unsignedDigit(e - 1) ? 2 * e - 1 : 2 * e
    }
    __halfDigit(e) {
        return 32767 & this[e >>> 1] >>> 15 * (1 & e)
    }
    __setHalfDigit(e, n) {
        const r = e >>> 1,
            i = this.__digit(r),
            s = 1 & e ? 32767 & i | n << 15 : 1073709056 & i | 32767 & n;
        this.__setDigit(r, s)
    }
    static __digitPow(e, n) {
        let r = 1;
        for (; 0 < n;) 1 & n && (r *= e), n >>>= 1, e *= e;
        return r
    }
    static __isOneDigitInt(e) {
        return (1073741823 & e) === e
    }
}
re.__kMaxLength = 33554432, re.__kMaxLengthBits = re.__kMaxLength << 5, re.__kMaxBitsPerChar = [0, 0, 32, 51, 64, 75, 83, 90, 96, 102, 107, 111, 115, 119, 122, 126, 128, 131, 134, 136, 139, 141, 143, 145, 147, 149, 151, 153, 154, 156, 158, 159, 160, 162, 163, 165, 166], re.__kBitsPerCharTableShift = 5, re.__kBitsPerCharTableMultiplier = 1 << re.__kBitsPerCharTableShift, re.__kConversionChars = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z"], re.__kBitConversionBuffer = new ArrayBuffer(8), re.__kBitConversionDouble = new Float64Array(re.__kBitConversionBuffer), re.__kBitConversionInts = new Int32Array(re.__kBitConversionBuffer), re.__clz30 = Math.clz32 ? function(t) {
    return Math.clz32(t) - 2
} : function(t) {
    return t === 0 ? 30 : 0 | 29 - (0 | Math.log(t >>> 0) / Math.LN2)
}, re.__imul = Math.imul || function(t, e) {
    return 0 | t * e
};
var pft = "Invariant failed";

function fn(t, e) {
    throw new Error(pft)
}
var i5 = 1e9,
    gft = {
        precision: 20,
        rounding: 4,
        toExpNeg: -7,
        toExpPos: 21,
        LN10: "2.302585092994045684017991454684364207601101488628772976033327900967572609677352480235997205089598298341967784042286"
    },
    VU, yi = !0,
    Mc = "[DecimalError] ",
    cm = Mc + "Invalid argument: ",
    WU = Mc + "Exponent out of range: ",
    s5 = Math.floor,
    Kg = Math.pow,
    mft = /^(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?$/i,
    _l, Ws = 1e7,
    ii = 7,
    Qde = 9007199254740991,
    KA = s5(Qde / ii),
    Rt = {};
Rt.absoluteValue = Rt.abs = function() {
    var t = new this.constructor(this);
    return t.s && (t.s = 1), t
};
Rt.comparedTo = Rt.cmp = function(t) {
    var e, n, r, i, s = this;
    if (t = new s.constructor(t), s.s !== t.s) return s.s || -t.s;
    if (s.e !== t.e) return s.e > t.e ^ s.s < 0 ? 1 : -1;
    for (r = s.d.length, i = t.d.length, e = 0, n = r < i ? r : i; e < n; ++e)
        if (s.d[e] !== t.d[e]) return s.d[e] > t.d[e] ^ s.s < 0 ? 1 : -1;
    return r === i ? 0 : r > i ^ s.s < 0 ? 1 : -1
};
Rt.decimalPlaces = Rt.dp = function() {
    var t = this,
        e = t.d.length - 1,
        n = (e - t.e) * ii;
    if (e = t.d[e], e)
        for (; e % 10 == 0; e /= 10) n--;
    return n < 0 ? 0 : n
};
Rt.dividedBy = Rt.div = function(t) {
    return Eh(this, new this.constructor(t))
};
Rt.dividedToIntegerBy = Rt.idiv = function(t) {
    var e = this,
        n = e.constructor;
    return Gr(Eh(e, new n(t), 0, 1), n.precision)
};
Rt.equals = Rt.eq = function(t) {
    return !this.cmp(t)
};
Rt.exponent = function() {
    return Es(this)
};
Rt.greaterThan = Rt.gt = function(t) {
    return this.cmp(t) > 0
};
Rt.greaterThanOrEqualTo = Rt.gte = function(t) {
    return this.cmp(t) >= 0
};
Rt.isInteger = Rt.isint = function() {
    return this.e > this.d.length - 2
};
Rt.isNegative = Rt.isneg = function() {
    return this.s < 0
};
Rt.isPositive = Rt.ispos = function() {
    return this.s > 0
};
Rt.isZero = function() {
    return this.s === 0
};
Rt.lessThan = Rt.lt = function(t) {
    return this.cmp(t) < 0
};
Rt.lessThanOrEqualTo = Rt.lte = function(t) {
    return this.cmp(t) < 1
};
Rt.logarithm = Rt.log = function(t) {
    var e, n = this,
        r = n.constructor,
        i = r.precision,
        s = i + 5;
    if (t === void 0) t = new r(10);
    else if (t = new r(t), t.s < 1 || t.eq(_l)) throw Error(Mc + "NaN");
    if (n.s < 1) throw Error(Mc + (n.s ? "NaN" : "-Infinity"));
    return n.eq(_l) ? new r(0) : (yi = !1, e = Eh(U6(n, s), U6(t, s), s), yi = !0, Gr(e, i))
};
Rt.minus = Rt.sub = function(t) {
    var e = this;
    return t = new e.constructor(t), e.s == t.s ? ehe(e, t) : Jde(e, (t.s = -t.s, t))
};
Rt.modulo = Rt.mod = function(t) {
    var e, n = this,
        r = n.constructor,
        i = r.precision;
    if (t = new r(t), !t.s) throw Error(Mc + "NaN");
    return n.s ? (yi = !1, e = Eh(n, t, 0, 1).times(t), yi = !0, n.minus(e)) : Gr(new r(n), i)
};
Rt.naturalExponential = Rt.exp = function() {
    return Xde(this)
};
Rt.naturalLogarithm = Rt.ln = function() {
    return U6(this)
};
Rt.negated = Rt.neg = function() {
    var t = new this.constructor(this);
    return t.s = -t.s || 0, t
};
Rt.plus = Rt.add = function(t) {
    var e = this;
    return t = new e.constructor(t), e.s == t.s ? Jde(e, t) : ehe(e, (t.s = -t.s, t))
};
Rt.precision = Rt.sd = function(t) {
    var e, n, r, i = this;
    if (t !== void 0 && t !== !!t && t !== 1 && t !== 0) throw Error(cm + t);
    if (e = Es(i) + 1, r = i.d.length - 1, n = r * ii + 1, r = i.d[r], r) {
        for (; r % 10 == 0; r /= 10) n--;
        for (r = i.d[0]; r >= 10; r /= 10) n++
    }
    return t && e > n ? e : n
};
Rt.squareRoot = Rt.sqrt = function() {
    var t, e, n, r, i, s, o, a = this,
        l = a.constructor;
    if (a.s < 1) {
        if (!a.s) return new l(0);
        throw Error(Mc + "NaN")
    }
    for (t = Es(a), yi = !1, i = Math.sqrt(+a), i == 0 || i == 1 / 0 ? (e = Wf(a.d), (e.length + t) % 2 == 0 && (e += "0"), i = Math.sqrt(e), t = s5((t + 1) / 2) - (t < 0 || t % 2), i == 1 / 0 ? e = "5e" + t : (e = i.toExponential(), e = e.slice(0, e.indexOf("e") + 1) + t), r = new l(e)) : r = new l(i.toString()), n = l.precision, i = o = n + 3;;)
        if (s = r, r = s.plus(Eh(a, s, o + 2)).times(.5), Wf(s.d).slice(0, o) === (e = Wf(r.d)).slice(0, o)) {
            if (e = e.slice(o - 3, o + 1), i == o && e == "4999") {
                if (Gr(s, n + 1, 0), s.times(s).eq(a)) {
                    r = s;
                    break
                }
            } else if (e != "9999") break;
            o += 4
        }
    return yi = !0, Gr(r, n)
};
Rt.times = Rt.mul = function(t) {
    var e, n, r, i, s, o, a, l, c, u = this,
        f = u.constructor,
        h = u.d,
        g = (t = new f(t)).d;
    if (!u.s || !t.s) return new f(0);
    for (t.s *= u.s, n = u.e + t.e, l = h.length, c = g.length, l < c && (s = h, h = g, g = s, o = l, l = c, c = o), s = [], o = l + c, r = o; r--;) s.push(0);
    for (r = c; --r >= 0;) {
        for (e = 0, i = l + r; i > r;) a = s[i] + g[r] * h[i - r - 1] + e, s[i--] = a % Ws | 0, e = a / Ws | 0;
        s[i] = (s[i] + e) % Ws | 0
    }
    for (; !s[--o];) s.pop();
    return e ? ++n : s.shift(), t.d = s, t.e = n, yi ? Gr(t, f.precision) : t
};
Rt.toDecimalPlaces = Rt.todp = function(t, e) {
    var n = this,
        r = n.constructor;
    return n = new r(n), t === void 0 ? n : (ld(t, 0, i5), e === void 0 ? e = r.rounding : ld(e, 0, 8), Gr(n, t + Es(n) + 1, e))
};
Rt.toExponential = function(t, e) {
    var n, r = this,
        i = r.constructor;
    return t === void 0 ? n = ny(r, !0) : (ld(t, 0, i5), e === void 0 ? e = i.rounding : ld(e, 0, 8), r = Gr(new i(r), t + 1, e), n = ny(r, !0, t + 1)), n
};
Rt.toFixed = function(t, e) {
    var n, r, i = this,
        s = i.constructor;
    return t === void 0 ? ny(i) : (ld(t, 0, i5), e === void 0 ? e = s.rounding : ld(e, 0, 8), r = Gr(new s(i), t + Es(i) + 1, e), n = ny(r.abs(), !1, t + Es(r) + 1), i.isneg() && !i.isZero() ? "-" + n : n)
};
Rt.toInteger = Rt.toint = function() {
    var t = this,
        e = t.constructor;
    return Gr(new e(t), Es(t) + 1, e.rounding)
};
Rt.toNumber = function() {
    return +this
};
Rt.toPower = Rt.pow = function(t) {
    var e, n, r, i, s, o, a = this,
        l = a.constructor,
        c = 12,
        u = +(t = new l(t));
    if (!t.s) return new l(_l);
    if (a = new l(a), !a.s) {
        if (t.s < 1) throw Error(Mc + "Infinity");
        return a
    }
    if (a.eq(_l)) return a;
    if (r = l.precision, t.eq(_l)) return Gr(a, r);
    if (e = t.e, n = t.d.length - 1, o = e >= n, s = a.s, o) {
        if ((n = u < 0 ? -u : u) <= Qde) {
            for (i = new l(_l), e = Math.ceil(r / ii + 4), yi = !1; n % 2 && (i = i.times(a), hJ(i.d, e)), n = s5(n / 2), n !== 0;) a = a.times(a), hJ(a.d, e);
            return yi = !0, t.s < 0 ? new l(_l).div(i) : Gr(i, r)
        }
    } else if (s < 0) throw Error(Mc + "NaN");
    return s = s < 0 && t.d[Math.max(e, n)] & 1 ? -1 : 1, a.s = 1, yi = !1, i = t.times(U6(a, r + c)), yi = !0, i = Xde(i), i.s = s, i
};
Rt.toPrecision = function(t, e) {
    var n, r, i = this,
        s = i.constructor;
    return t === void 0 ? (n = Es(i), r = ny(i, n <= s.toExpNeg || n >= s.toExpPos)) : (ld(t, 1, i5), e === void 0 ? e = s.rounding : ld(e, 0, 8), i = Gr(new s(i), t, e), n = Es(i), r = ny(i, t <= n || n <= s.toExpNeg, t)), r
};
Rt.toSignificantDigits = Rt.tosd = function(t, e) {
    var n = this,
        r = n.constructor;
    return t === void 0 ? (t = r.precision, e = r.rounding) : (ld(t, 1, i5), e === void 0 ? e = r.rounding : ld(e, 0, 8)), Gr(new r(n), t, e)
};
Rt.toString = Rt.valueOf = Rt.val = Rt.toJSON = Rt[Symbol.for("nodejs.util.inspect.custom")] = function() {
    var t = this,
        e = Es(t),
        n = t.constructor;
    return ny(t, e <= n.toExpNeg || e >= n.toExpPos)
};

function Jde(t, e) {
    var n, r, i, s, o, a, l, c, u = t.constructor,
        f = u.precision;
    if (!t.s || !e.s) return e.s || (e = new u(t)), yi ? Gr(e, f) : e;
    if (l = t.d, c = e.d, o = t.e, i = e.e, l = l.slice(), s = o - i, s) {
        for (s < 0 ? (r = l, s = -s, a = c.length) : (r = c, i = o, a = l.length), o = Math.ceil(f / ii), a = o > a ? o + 1 : a + 1, s > a && (s = a, r.length = 1), r.reverse(); s--;) r.push(0);
        r.reverse()
    }
    for (a = l.length, s = c.length, a - s < 0 && (s = a, r = c, c = l, l = r), n = 0; s;) n = (l[--s] = l[s] + c[s] + n) / Ws | 0, l[s] %= Ws;
    for (n && (l.unshift(n), ++i), a = l.length; l[--a] == 0;) l.pop();
    return e.d = l, e.e = i, yi ? Gr(e, f) : e
}

function ld(t, e, n) {
    if (t !== ~~t || t < e || t > n) throw Error(cm + t)
}

function Wf(t) {
    var e, n, r, i = t.length - 1,
        s = "",
        o = t[0];
    if (i > 0) {
        for (s += o, e = 1; e < i; e++) r = t[e] + "", n = ii - r.length, n && (s += I0(n)), s += r;
        o = t[e], r = o + "", n = ii - r.length, n && (s += I0(n))
    } else if (o === 0) return "0";
    for (; o % 10 === 0;) o /= 10;
    return s + o
}
var Eh = function() {
    function t(r, i) {
        var s, o = 0,
            a = r.length;
        for (r = r.slice(); a--;) s = r[a] * i + o, r[a] = s % Ws | 0, o = s / Ws | 0;
        return o && r.unshift(o), r
    }

    function e(r, i, s, o) {
        var a, l;
        if (s != o) l = s > o ? 1 : -1;
        else
            for (a = l = 0; a < s; a++)
                if (r[a] != i[a]) {
                    l = r[a] > i[a] ? 1 : -1;
                    break
                } return l
    }

    function n(r, i, s) {
        for (var o = 0; s--;) r[s] -= o, o = r[s] < i[s] ? 1 : 0, r[s] = o * Ws + r[s] - i[s];
        for (; !r[0] && r.length > 1;) r.shift()
    }
    return function(r, i, s, o) {
        var a, l, c, u, f, h, g, y, _, C, b, w, S, I, P, M, A, E, $ = r.constructor,
            H = r.s == i.s ? 1 : -1,
            K = r.d,
            te = i.d;
        if (!r.s) return new $(r);
        if (!i.s) throw Error(Mc + "Division by zero");
        for (l = r.e - i.e, A = te.length, P = K.length, g = new $(H), y = g.d = [], c = 0; te[c] == (K[c] || 0);) ++c;
        if (te[c] > (K[c] || 0) && --l, s == null ? w = s = $.precision : o ? w = s + (Es(r) - Es(i)) + 1 : w = s, w < 0) return new $(0);
        if (w = w / ii + 2 | 0, c = 0, A == 1)
            for (u = 0, te = te[0], w++;
                (c < P || u) && w--; c++) S = u * Ws + (K[c] || 0), y[c] = S / te | 0, u = S % te | 0;
        else {
            for (u = Ws / (te[0] + 1) | 0, u > 1 && (te = t(te, u), K = t(K, u), A = te.length, P = K.length), I = A, _ = K.slice(0, A), C = _.length; C < A;) _[C++] = 0;
            E = te.slice(), E.unshift(0), M = te[0], te[1] >= Ws / 2 && ++M;
            do u = 0, a = e(te, _, A, C), a < 0 ? (b = _[0], A != C && (b = b * Ws + (_[1] || 0)), u = b / M | 0, u > 1 ? (u >= Ws && (u = Ws - 1), f = t(te, u), h = f.length, C = _.length, a = e(f, _, h, C), a == 1 && (u--, n(f, A < h ? E : te, h))) : (u == 0 && (a = u = 1), f = te.slice()), h = f.length, h < C && f.unshift(0), n(_, f, C), a == -1 && (C = _.length, a = e(te, _, A, C), a < 1 && (u++, n(_, A < C ? E : te, C))), C = _.length) : a === 0 && (u++, _ = [0]), y[c++] = u, a && _[0] ? _[C++] = K[I] || 0 : (_ = [K[I]], C = 1); while ((I++ < P || _[0] !== void 0) && w--)
        }
        return y[0] || y.shift(), g.e = l, Gr(g, o ? s + Es(g) + 1 : s)
    }
}();

function Xde(t, e) {
    var n, r, i, s, o, a, l = 0,
        c = 0,
        u = t.constructor,
        f = u.precision;
    if (Es(t) > 16) throw Error(WU + Es(t));
    if (!t.s) return new u(_l);
    for (e == null ? (yi = !1, a = f) : a = e, o = new u(.03125); t.abs().gte(.1);) t = t.times(o), c += 5;
    for (r = Math.log(Kg(2, c)) / Math.LN10 * 2 + 5 | 0, a += r, n = i = s = new u(_l), u.precision = a;;) {
        if (i = Gr(i.times(t), a), n = n.times(++l), o = s.plus(Eh(i, n, a)), Wf(o.d).slice(0, a) === Wf(s.d).slice(0, a)) {
            for (; c--;) s = Gr(s.times(s), a);
            return u.precision = f, e == null ? (yi = !0, Gr(s, f)) : s
        }
        s = o
    }
}

function Es(t) {
    for (var e = t.e * ii, n = t.d[0]; n >= 10; n /= 10) e++;
    return e
}

function wP(t, e, n) {
    if (e > t.LN10.sd()) throw yi = !0, n && (t.precision = n), Error(Mc + "LN10 precision limit exceeded");
    return Gr(new t(t.LN10), e)
}

function I0(t) {
    for (var e = ""; t--;) e += "0";
    return e
}

function U6(t, e) {
    var n, r, i, s, o, a, l, c, u, f = 1,
        h = 10,
        g = t,
        y = g.d,
        _ = g.constructor,
        C = _.precision;
    if (g.s < 1) throw Error(Mc + (g.s ? "NaN" : "-Infinity"));
    if (g.eq(_l)) return new _(0);
    if (e == null ? (yi = !1, c = C) : c = e, g.eq(10)) return e == null && (yi = !0), wP(_, c);
    if (c += h, _.precision = c, n = Wf(y), r = n.charAt(0), s = Es(g), Math.abs(s) < 15e14) {
        for (; r < 7 && r != 1 || r == 1 && n.charAt(1) > 3;) g = g.times(t), n = Wf(g.d), r = n.charAt(0), f++;
        s = Es(g), r > 1 ? (g = new _("0." + n), s++) : g = new _(r + "." + n.slice(1))
    } else return l = wP(_, c + 2, C).times(s + ""), g = U6(new _(r + "." + n.slice(1)), c - h).plus(l), _.precision = C, e == null ? (yi = !0, Gr(g, C)) : g;
    for (a = o = g = Eh(g.minus(_l), g.plus(_l), c), u = Gr(g.times(g), c), i = 3;;) {
        if (o = Gr(o.times(u), c), l = a.plus(Eh(o, new _(i), c)), Wf(l.d).slice(0, c) === Wf(a.d).slice(0, c)) return a = a.times(2), s !== 0 && (a = a.plus(wP(_, c + 2, C).times(s + ""))), a = Eh(a, new _(f), c), _.precision = C, e == null ? (yi = !0, Gr(a, C)) : a;
        a = l, i += 2
    }
}

function dJ(t, e) {
    var n, r, i;
    for ((n = e.indexOf(".")) > -1 && (e = e.replace(".", "")), (r = e.search(/e/i)) > 0 ? (n < 0 && (n = r), n += +e.slice(r + 1), e = e.substring(0, r)) : n < 0 && (n = e.length), r = 0; e.charCodeAt(r) === 48;) ++r;
    for (i = e.length; e.charCodeAt(i - 1) === 48;) --i;
    if (e = e.slice(r, i), e) {
        if (i -= r, n = n - r - 1, t.e = s5(n / ii), t.d = [], r = (n + 1) % ii, n < 0 && (r += ii), r < i) {
            for (r && t.d.push(+e.slice(0, r)), i -= ii; r < i;) t.d.push(+e.slice(r, r += ii));
            e = e.slice(r), r = ii - e.length
        } else r -= i;
        for (; r--;) e += "0";
        if (t.d.push(+e), yi && (t.e > KA || t.e < -KA)) throw Error(WU + n)
    } else t.s = 0, t.e = 0, t.d = [0];
    return t
}

function Gr(t, e, n) {
    var r, i, s, o, a, l, c, u, f = t.d;
    for (o = 1, s = f[0]; s >= 10; s /= 10) o++;
    if (r = e - o, r < 0) r += ii, i = e, c = f[u = 0];
    else {
        if (u = Math.ceil((r + 1) / ii), s = f.length, u >= s) return t;
        for (c = s = f[u], o = 1; s >= 10; s /= 10) o++;
        r %= ii, i = r - ii + o
    }
    if (n !== void 0 && (s = Kg(10, o - i - 1), a = c / s % 10 | 0, l = e < 0 || f[u + 1] !== void 0 || c % s, l = n < 4 ? (a || l) && (n == 0 || n == (t.s < 0 ? 3 : 2)) : a > 5 || a == 5 && (n == 4 || l || n == 6 && (r > 0 ? i > 0 ? c / Kg(10, o - i) : 0 : f[u - 1]) % 10 & 1 || n == (t.s < 0 ? 8 : 7))), e < 1 || !f[0]) return l ? (s = Es(t), f.length = 1, e = e - s - 1, f[0] = Kg(10, (ii - e % ii) % ii), t.e = s5(-e / ii) || 0) : (f.length = 1, f[0] = t.e = t.s = 0), t;
    if (r == 0 ? (f.length = u, s = 1, u--) : (f.length = u + 1, s = Kg(10, ii - r), f[u] = i > 0 ? (c / Kg(10, o - i) % Kg(10, i) | 0) * s : 0), l)
        for (;;)
            if (u == 0) {
                (f[0] += s) == Ws && (f[0] = 1, ++t.e);
                break
            } else {
                if (f[u] += s, f[u] != Ws) break;
                f[u--] = 0, s = 1
            }
    for (r = f.length; f[--r] === 0;) f.pop();
    if (yi && (t.e > KA || t.e < -KA)) throw Error(WU + Es(t));
    return t
}

function ehe(t, e) {
    var n, r, i, s, o, a, l, c, u, f, h = t.constructor,
        g = h.precision;
    if (!t.s || !e.s) return e.s ? e.s = -e.s : e = new h(t), yi ? Gr(e, g) : e;
    if (l = t.d, f = e.d, r = e.e, c = t.e, l = l.slice(), o = c - r, o) {
        for (u = o < 0, u ? (n = l, o = -o, a = f.length) : (n = f, r = c, a = l.length), i = Math.max(Math.ceil(g / ii), a) + 2, o > i && (o = i, n.length = 1), n.reverse(), i = o; i--;) n.push(0);
        n.reverse()
    } else {
        for (i = l.length, a = f.length, u = i < a, u && (a = i), i = 0; i < a; i++)
            if (l[i] != f[i]) {
                u = l[i] < f[i];
                break
            }
        o = 0
    }
    for (u && (n = l, l = f, f = n, e.s = -e.s), a = l.length, i = f.length - a; i > 0; --i) l[a++] = 0;
    for (i = f.length; i > o;) {
        if (l[--i] < f[i]) {
            for (s = i; s && l[--s] === 0;) l[s] = Ws - 1;
            --l[s], l[i] += Ws
        }
        l[i] -= f[i]
    }
    for (; l[--a] === 0;) l.pop();
    for (; l[0] === 0; l.shift()) --r;
    return l[0] ? (e.d = l, e.e = r, yi ? Gr(e, g) : e) : new h(0)
}

function ny(t, e, n) {
    var r, i = Es(t),
        s = Wf(t.d),
        o = s.length;
    return e ? (n && (r = n - o) > 0 ? s = s.charAt(0) + "." + s.slice(1) + I0(r) : o > 1 && (s = s.charAt(0) + "." + s.slice(1)), s = s + (i < 0 ? "e" : "e+") + i) : i < 0 ? (s = "0." + I0(-i - 1) + s, n && (r = n - o) > 0 && (s += I0(r))) : i >= o ? (s += I0(i + 1 - o), n && (r = n - i - 1) > 0 && (s = s + "." + I0(r))) : ((r = i + 1) < o && (s = s.slice(0, r) + "." + s.slice(r)), n && (r = n - o) > 0 && (i + 1 === o && (s += "."), s += I0(r))), t.s < 0 ? "-" + s : s
}

function hJ(t, e) {
    if (t.length > e) return t.length = e, !0
}

function the(t) {
    var e, n, r;

    function i(s) {
        var o = this;
        if (!(o instanceof i)) return new i(s);
        if (o.constructor = i, s instanceof i) {
            o.s = s.s, o.e = s.e, o.d = (s = s.d) ? s.slice() : s;
            return
        }
        if (typeof s == "number") {
            if (s * 0 !== 0) throw Error(cm + s);
            if (s > 0) o.s = 1;
            else if (s < 0) s = -s, o.s = -1;
            else {
                o.s = 0, o.e = 0, o.d = [0];
                return
            }
            if (s === ~~s && s < 1e7) {
                o.e = 0, o.d = [s];
                return
            }
            return dJ(o, s.toString())
        } else if (typeof s != "string") throw Error(cm + s);
        if (s.charCodeAt(0) === 45 ? (s = s.slice(1), o.s = -1) : o.s = 1, mft.test(s)) dJ(o, s);
        else throw Error(cm + s)
    }
    if (i.prototype = Rt, i.ROUND_UP = 0, i.ROUND_DOWN = 1, i.ROUND_CEIL = 2, i.ROUND_FLOOR = 3, i.ROUND_HALF_UP = 4, i.ROUND_HALF_DOWN = 5, i.ROUND_HALF_EVEN = 6, i.ROUND_HALF_CEIL = 7, i.ROUND_HALF_FLOOR = 8, i.clone = the, i.config = i.set = yft, t === void 0 && (t = {}), t)
        for (r = ["precision", "rounding", "toExpNeg", "toExpPos", "LN10"], e = 0; e < r.length;) t.hasOwnProperty(n = r[e++]) || (t[n] = this[n]);
    return i.config(t), i
}

function yft(t) {
    if (!t || typeof t != "object") throw Error(Mc + "Object expected");
    var e, n, r, i = ["precision", 1, i5, "rounding", 0, 8, "toExpNeg", -1 / 0, 0, "toExpPos", 0, 1 / 0];
    for (e = 0; e < i.length; e += 3)
        if ((r = t[n = i[e]]) !== void 0)
            if (s5(r) === r && r >= i[e + 1] && r <= i[e + 2]) this[n] = r;
            else throw Error(cm + n + ": " + r);
    if ((r = t[n = "LN10"]) !== void 0)
        if (r == Math.LN10) this[n] = new this(r);
        else throw Error(cm + n + ": " + r);
    return this
}
var VU = the(gft);
_l = new VU(1);
const wft = VU;
var vft = 20,
    bft = 1,
    YA = 1e6,
    pJ = 1e6,
    _ft = -7,
    Eft = 21,
    GU = "[big.js] ",
    E4 = GU + "Invalid ",
    qU = E4 + "decimal places",
    gJ = E4 + "rounding mode",
    nhe = GU + "Division by zero",
    li = {},
    ry = void 0,
    xft = /^-?(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?$/i;

function rhe() {
    function t(e) {
        var n = this;
        if (!(n instanceof t)) return e === ry ? rhe() : new t(e);
        e instanceof t ? (n.s = e.s, n.e = e.e, n.c = e.c.slice()) : Sft(n, e), n.constructor = t
    }
    return t.prototype = li, t.DP = vft, t.RM = bft, t.NE = _ft, t.PE = Eft, t.version = "5.2.2", t
}

function Sft(t, e) {
    var n, r, i;
    if (e === 0 && 1 / e < 0) e = "-0";
    else if (!xft.test(e += "")) throw Error(E4 + "number");
    for (t.s = e.charAt(0) == "-" ? (e = e.slice(1), -1) : 1, (n = e.indexOf(".")) > -1 && (e = e.replace(".", "")), (r = e.search(/e/i)) > 0 ? (n < 0 && (n = r), n += +e.slice(r + 1), e = e.substring(0, r)) : n < 0 && (n = e.length), i = e.length, r = 0; r < i && e.charAt(r) == "0";) ++r;
    if (r == i) t.c = [t.e = 0];
    else {
        for (; i > 0 && e.charAt(--i) == "0";);
        for (t.e = n - r - 1, t.c = [], n = 0; r <= i;) t.c[n++] = +e.charAt(r++)
    }
    return t
}

function oI(t, e, n, r) {
    var i = t.c,
        s = t.e + e + 1;
    if (s < i.length) {
        if (n === 1) r = i[s] >= 5;
        else if (n === 2) r = i[s] > 5 || i[s] == 5 && (r || s < 0 || i[s + 1] !== ry || i[s - 1] & 1);
        else if (n === 3) r = r || !!i[0];
        else if (r = !1, n !== 0) throw Error(gJ);
        if (s < 1) i.length = 1, r ? (t.e = -e, i[0] = 1) : i[0] = t.e = 0;
        else {
            if (i.length = s--, r)
                for (; ++i[s] > 9;) i[s] = 0, s-- || (++t.e, i.unshift(1));
            for (s = i.length; !i[--s];) i.pop()
        }
    } else if (n < 0 || n > 3 || n !== ~~n) throw Error(gJ);
    return t
}

function x4(t, e, n, r) {
    var i, s, o = t.constructor,
        a = !t.c[0];
    if (n !== ry) {
        if (n !== ~~n || n < (e == 3) || n > YA) throw Error(e == 3 ? E4 + "precision" : qU);
        for (t = new o(t), n = r - t.e, t.c.length > ++r && oI(t, n, o.RM), e == 2 && (r = t.e + n + 1); t.c.length < r;) t.c.push(0)
    }
    if (i = t.e, s = t.c.join(""), n = s.length, e != 2 && (e == 1 || e == 3 && r <= i || i <= o.NE || i >= o.PE)) s = s.charAt(0) + (n > 1 ? "." + s.slice(1) : "") + (i < 0 ? "e" : "e+") + i;
    else if (i < 0) {
        for (; ++i;) s = "0" + s;
        s = "0." + s
    } else if (i > 0)
        if (++i > n)
            for (i -= n; i--;) s += "0";
        else i < n && (s = s.slice(0, i) + "." + s.slice(i));
    else n > 1 && (s = s.charAt(0) + "." + s.slice(1));
    return t.s < 0 && (!a || e == 4) ? "-" + s : s
}
li.abs = function() {
    var t = new this.constructor(this);
    return t.s = 1, t
};
li.cmp = function(t) {
    var e, n = this,
        r = n.c,
        i = (t = new n.constructor(t)).c,
        s = n.s,
        o = t.s,
        a = n.e,
        l = t.e;
    if (!r[0] || !i[0]) return r[0] ? s : i[0] ? -o : 0;
    if (s != o) return s;
    if (e = s < 0, a != l) return a > l ^ e ? 1 : -1;
    for (o = (a = r.length) < (l = i.length) ? a : l, s = -1; ++s < o;)
        if (r[s] != i[s]) return r[s] > i[s] ^ e ? 1 : -1;
    return a == l ? 0 : a > l ^ e ? 1 : -1
};
li.div = function(t) {
    var e = this,
        n = e.constructor,
        r = e.c,
        i = (t = new n(t)).c,
        s = e.s == t.s ? 1 : -1,
        o = n.DP;
    if (o !== ~~o || o < 0 || o > YA) throw Error(qU);
    if (!i[0]) throw Error(nhe);
    if (!r[0]) return new n(s * 0);
    var a, l, c, u, f, h = i.slice(),
        g = a = i.length,
        y = r.length,
        _ = r.slice(0, a),
        C = _.length,
        b = t,
        w = b.c = [],
        S = 0,
        I = o + (b.e = e.e - t.e) + 1;
    for (b.s = s, s = I < 0 ? 0 : I, h.unshift(0); C++ < a;) _.push(0);
    do {
        for (c = 0; c < 10; c++) {
            if (a != (C = _.length)) u = a > C ? 1 : -1;
            else
                for (f = -1, u = 0; ++f < a;)
                    if (i[f] != _[f]) {
                        u = i[f] > _[f] ? 1 : -1;
                        break
                    } if (u < 0) {
                for (l = C == a ? i : h; C;) {
                    if (_[--C] < l[C]) {
                        for (f = C; f && !_[--f];) _[f] = 9;
                        --_[f], _[C] += 10
                    }
                    _[C] -= l[C]
                }
                for (; !_[0];) _.shift()
            } else break
        }
        w[S++] = u ? c : ++c, _[0] && u ? _[C] = r[g] || 0 : _ = [r[g]]
    } while ((g++ < y || _[0] !== ry) && s--);
    return !w[0] && S != 1 && (w.shift(), b.e--), S > I && oI(b, o, n.RM, _[0] !== ry), b
};
li.eq = function(t) {
    return !this.cmp(t)
};
li.gt = function(t) {
    return this.cmp(t) > 0
};
li.gte = function(t) {
    return this.cmp(t) > -1
};
li.lt = function(t) {
    return this.cmp(t) < 0
};
li.lte = function(t) {
    return this.cmp(t) < 1
};
li.minus = li.sub = function(t) {
    var e, n, r, i, s = this,
        o = s.constructor,
        a = s.s,
        l = (t = new o(t)).s;
    if (a != l) return t.s = -l, s.plus(t);
    var c = s.c.slice(),
        u = s.e,
        f = t.c,
        h = t.e;
    if (!c[0] || !f[0]) return f[0] ? (t.s = -l, t) : new o(c[0] ? s : 0);
    if (a = u - h) {
        for ((i = a < 0) ? (a = -a, r = c) : (h = u, r = f), r.reverse(), l = a; l--;) r.push(0);
        r.reverse()
    } else
        for (n = ((i = c.length < f.length) ? c : f).length, a = l = 0; l < n; l++)
            if (c[l] != f[l]) {
                i = c[l] < f[l];
                break
            } if (i && (r = c, c = f, f = r, t.s = -t.s), (l = (n = f.length) - (e = c.length)) > 0)
        for (; l--;) c[e++] = 0;
    for (l = e; n > a;) {
        if (c[--n] < f[n]) {
            for (e = n; e && !c[--e];) c[e] = 9;
            --c[e], c[n] += 10
        }
        c[n] -= f[n]
    }
    for (; c[--l] === 0;) c.pop();
    for (; c[0] === 0;) c.shift(), --h;
    return c[0] || (t.s = 1, c = [h = 0]), t.c = c, t.e = h, t
};
li.mod = function(t) {
    var e, n = this,
        r = n.constructor,
        i = n.s,
        s = (t = new r(t)).s;
    if (!t.c[0]) throw Error(nhe);
    return n.s = t.s = 1, e = t.cmp(n) == 1, n.s = i, t.s = s, e ? new r(n) : (i = r.DP, s = r.RM, r.DP = r.RM = 0, n = n.div(t), r.DP = i, r.RM = s, this.minus(n.times(t)))
};
li.plus = li.add = function(t) {
    var e, n = this,
        r = n.constructor,
        i = n.s,
        s = (t = new r(t)).s;
    if (i != s) return t.s = -s, n.minus(t);
    var o = n.e,
        a = n.c,
        l = t.e,
        c = t.c;
    if (!a[0] || !c[0]) return c[0] ? t : new r(a[0] ? n : i * 0);
    if (a = a.slice(), i = o - l) {
        for (i > 0 ? (l = o, e = c) : (i = -i, e = a), e.reverse(); i--;) e.push(0);
        e.reverse()
    }
    for (a.length - c.length < 0 && (e = c, c = a, a = e), i = c.length, s = 0; i; a[i] %= 10) s = (a[--i] = a[i] + c[i] + s) / 10 | 0;
    for (s && (a.unshift(s), ++l), i = a.length; a[--i] === 0;) a.pop();
    return t.c = a, t.e = l, t
};
li.pow = function(t) {
    var e = this,
        n = new e.constructor(1),
        r = n,
        i = t < 0;
    if (t !== ~~t || t < -pJ || t > pJ) throw Error(E4 + "exponent");
    for (i && (t = -t); t & 1 && (r = r.times(e)), t >>= 1, !!t;) e = e.times(e);
    return i ? n.div(r) : r
};
li.round = function(t, e) {
    var n = this.constructor;
    if (t === ry) t = 0;
    else if (t !== ~~t || t < -YA || t > YA) throw Error(qU);
    return oI(new n(this), t, e === ry ? n.RM : e)
};
li.sqrt = function() {
    var t, e, n, r = this,
        i = r.constructor,
        s = r.s,
        o = r.e,
        a = new i(.5);
    if (!r.c[0]) return new i(r);
    if (s < 0) throw Error(GU + "No square root");
    s = Math.sqrt(r + ""), s === 0 || s === 1 / 0 ? (e = r.c.join(""), e.length + o & 1 || (e += "0"), s = Math.sqrt(e), o = ((o + 1) / 2 | 0) - (o < 0 || o & 1), t = new i((s == 1 / 0 ? "1e" : (s = s.toExponential()).slice(0, s.indexOf("e") + 1)) + o)) : t = new i(s), o = t.e + (i.DP += 4);
    do n = t, t = a.times(n.plus(r.div(n))); while (n.c.slice(0, o).join("") !== t.c.slice(0, o).join(""));
    return oI(t, i.DP -= 4, i.RM)
};
li.times = li.mul = function(t) {
    var e, n = this,
        r = n.constructor,
        i = n.c,
        s = (t = new r(t)).c,
        o = i.length,
        a = s.length,
        l = n.e,
        c = t.e;
    if (t.s = n.s == t.s ? 1 : -1, !i[0] || !s[0]) return new r(t.s * 0);
    for (t.e = l + c, o < a && (e = i, i = s, s = e, c = o, o = a, a = c), e = new Array(c = o + a); c--;) e[c] = 0;
    for (l = a; l--;) {
        for (a = 0, c = o + l; c > l;) a = e[c] + s[l] * i[c - l - 1] + a, e[c--] = a % 10, a = a / 10 | 0;
        e[c] = (e[c] + a) % 10
    }
    for (a ? ++t.e : e.shift(), l = e.length; !e[--l];) e.pop();
    return t.c = e, t
};
li.toExponential = function(t) {
    return x4(this, 1, t, t)
};
li.toFixed = function(t) {
    return x4(this, 2, t, this.e + t)
};
li.toPrecision = function(t) {
    return x4(this, 3, t, t - 1)
};
li.toString = function() {
    return x4(this)
};
li.valueOf = li.toJSON = function() {
    return x4(this, 4)
};
var ihe = rhe(),
    she = {
        exports: {}
    };
(function(t) {
    function e(n) {
        return n.prototype.toFormat = function(i, s, o) {
            if (!this.e && this.e !== 0) return this.toString();
            var a, l, c, u, f, h, g, y, _, C, b, w, S, I, P, M = this.format || {},
                A = this.constructor.format || {};
            if (i != f ? typeof i == "object" ? (o = i, i = f) : s != f ? typeof s == "object" ? (o = s, s = f) : typeof o != "object" && (o = {}) : o = {} : o = {}, a = this.toFixed(i, s).split("."), y = a[0], _ = a[1], g = this.s < 0 ? y.slice(1) : y, h = g.length, C = o.decimalSeparator, C == f && (C = M.decimalSeparator, C == f && (C = A.decimalSeparator, C == f && (C = "."))), b = o.groupSeparator, b == f && (b = M.groupSeparator, b == f && (b = A.groupSeparator)), b && (w = o.groupSize, w == f && (w = M.groupSize, w == f && (w = A.groupSize, w == f && (w = 0))), S = o.secondaryGroupSize, S == f && (S = M.secondaryGroupSize, S == f && (S = A.secondaryGroupSize, S == f && (S = 0))), S ? (l = +S, c = +w, h -= c) : (l = +w, c = +S), l > 0 && h > 0)) {
                for (u = h % l || l, y = g.substr(0, u); u < h; u += l) y += b + g.substr(u, l);
                c > 0 && (y += b + g.slice(u)), this.s < 0 && (y = "-" + y)
            }
            return _ ? (I = o.fractionGroupSeparator, I == f && (I = M.fractionGroupSeparator, I == f && (I = A.fractionGroupSeparator)), I && (P = o.fractionGroupSize, P == f && (P = M.fractionGroupSize, P == f && (P = A.fractionGroupSize, P == f && (P = 0))), P = +P, P && (_ = _.replace(new RegExp("\\d{" + P + "}\\B", "g"), "$&" + I))), y + C + _) : y
        }, n.format = {
            decimalSeparator: ".",
            groupSeparator: ",",
            groupSize: 3,
            secondaryGroupSize: 0,
            fractionGroupSeparator: "",
            fractionGroupSize: 0
        }, n
    }
    t.exports && (t.exports = e)
})(she);
var Cft = she.exports;
const KU = co(Cft);
var ohe = {
    exports: {}
};
/**
 * [js-sha3]{@link https://github.com/emn178/js-sha3}
 *
 * @version 0.8.0
 * @author Chen, Yi-Cyuan [emn178@gmail.com]
 * @copyright Chen, Yi-Cyuan 2015-2018
 * @license MIT
 */
(function(t) {
    (function() {
        var e = "input is invalid type",
            n = "finalize already called",
            r = typeof window == "object",
            i = r ? window : {};
        i.JS_SHA3_NO_WINDOW && (r = !1);
        var s = !r && typeof self == "object",
            o = !i.JS_SHA3_NO_NODE_JS && typeof process == "object" && process.versions && process.versions.node;
        o ? i = st : s && (i = self);
        var a = !i.JS_SHA3_NO_COMMON_JS && !0 && t.exports,
            l = !i.JS_SHA3_NO_ARRAY_BUFFER && typeof ArrayBuffer < "u",
            c = "0123456789abcdef".split(""),
            u = [31, 7936, 2031616, 520093696],
            f = [4, 1024, 262144, 67108864],
            h = [1, 256, 65536, 16777216],
            g = [6, 1536, 393216, 100663296],
            y = [0, 8, 16, 24],
            _ = [1, 0, 32898, 0, 32906, 2147483648, 2147516416, 2147483648, 32907, 0, 2147483649, 0, 2147516545, 2147483648, 32777, 2147483648, 138, 0, 136, 0, 2147516425, 0, 2147483658, 0, 2147516555, 0, 139, 2147483648, 32905, 2147483648, 32771, 2147483648, 32770, 2147483648, 128, 2147483648, 32778, 0, 2147483658, 2147483648, 2147516545, 2147483648, 32896, 2147483648, 2147483649, 0, 2147516424, 2147483648],
            C = [224, 256, 384, 512],
            b = [128, 256],
            w = ["hex", "buffer", "arrayBuffer", "array", "digest"],
            S = {
                128: 168,
                256: 136
            };
        (i.JS_SHA3_NO_NODE_JS || !Array.isArray) && (Array.isArray = function(V) {
            return Object.prototype.toString.call(V) === "[object Array]"
        }), l && (i.JS_SHA3_NO_ARRAY_BUFFER_IS_VIEW || !ArrayBuffer.isView) && (ArrayBuffer.isView = function(V) {
            return typeof V == "object" && V.buffer && V.buffer.constructor === ArrayBuffer
        });
        for (var I = function(V, X, q) {
                return function(ne) {
                    return new R(V, X, V).update(ne)[q]()
                }
            }, P = function(V, X, q) {
                return function(ne, ie) {
                    return new R(V, X, ie).update(ne)[q]()
                }
            }, M = function(V, X, q) {
                return function(ne, ie, k, z) {
                    return m["cshake" + V].update(ne, ie, k, z)[q]()
                }
            }, A = function(V, X, q) {
                return function(ne, ie, k, z) {
                    return m["kmac" + V].update(ne, ie, k, z)[q]()
                }
            }, E = function(V, X, q, ne) {
                for (var ie = 0; ie < w.length; ++ie) {
                    var k = w[ie];
                    V[k] = X(q, ne, k)
                }
                return V
            }, $ = function(V, X) {
                var q = I(V, X, "hex");
                return q.create = function() {
                    return new R(V, X, V)
                }, q.update = function(ne) {
                    return q.create().update(ne)
                }, E(q, I, V, X)
            }, H = function(V, X) {
                var q = P(V, X, "hex");
                return q.create = function(ne) {
                    return new R(V, X, ne)
                }, q.update = function(ne, ie) {
                    return q.create(ie).update(ne)
                }, E(q, P, V, X)
            }, K = function(V, X) {
                var q = S[V],
                    ne = M(V, X, "hex");
                return ne.create = function(ie, k, z) {
                    return !k && !z ? m["shake" + V].create(ie) : new R(V, X, ie).bytepad([k, z], q)
                }, ne.update = function(ie, k, z, Z) {
                    return ne.create(k, z, Z).update(ie)
                }, E(ne, M, V, X)
            }, te = function(V, X) {
                var q = S[V],
                    ne = A(V, X, "hex");
                return ne.create = function(ie, k, z) {
                    return new Y(V, X, k).bytepad(["KMAC", z], q).bytepad([ie], q)
                }, ne.update = function(ie, k, z, Z) {
                    return ne.create(ie, z, Z).update(k)
                }, E(ne, A, V, X)
            }, U = [{
                name: "keccak",
                padding: h,
                bits: C,
                createMethod: $
            }, {
                name: "sha3",
                padding: g,
                bits: C,
                createMethod: $
            }, {
                name: "shake",
                padding: u,
                bits: b,
                createMethod: H
            }, {
                name: "cshake",
                padding: f,
                bits: b,
                createMethod: K
            }, {
                name: "kmac",
                padding: f,
                bits: b,
                createMethod: te
            }], m = {}, v = [], T = 0; T < U.length; ++T)
            for (var N = U[T], O = N.bits, L = 0; L < O.length; ++L) {
                var G = N.name + "_" + O[L];
                if (v.push(G), m[G] = N.createMethod(O[L], N.padding), N.name !== "sha3") {
                    var j = N.name + O[L];
                    v.push(j), m[j] = m[G]
                }
            }

        function R(V, X, q) {
            this.blocks = [], this.s = [], this.padding = X, this.outputBits = q, this.reset = !0, this.finalized = !1, this.block = 0, this.start = 0, this.blockCount = 1600 - (V << 1) >> 5, this.byteCount = this.blockCount << 2, this.outputBlocks = q >> 5, this.extraBytes = (q & 31) >> 3;
            for (var ne = 0; ne < 50; ++ne) this.s[ne] = 0
        }
        R.prototype.update = function(V) {
            if (this.finalized) throw new Error(n);
            var X, q = typeof V;
            if (q !== "string") {
                if (q === "object") {
                    if (V === null) throw new Error(e);
                    if (l && V.constructor === ArrayBuffer) V = new Uint8Array(V);
                    else if (!Array.isArray(V) && (!l || !ArrayBuffer.isView(V))) throw new Error(e)
                } else throw new Error(e);
                X = !0
            }
            for (var ne = this.blocks, ie = this.byteCount, k = V.length, z = this.blockCount, Z = 0, ge = this.s, me, Re; Z < k;) {
                if (this.reset)
                    for (this.reset = !1, ne[0] = this.block, me = 1; me < z + 1; ++me) ne[me] = 0;
                if (X)
                    for (me = this.start; Z < k && me < ie; ++Z) ne[me >> 2] |= V[Z] << y[me++ & 3];
                else
                    for (me = this.start; Z < k && me < ie; ++Z) Re = V.charCodeAt(Z), Re < 128 ? ne[me >> 2] |= Re << y[me++ & 3] : Re < 2048 ? (ne[me >> 2] |= (192 | Re >> 6) << y[me++ & 3], ne[me >> 2] |= (128 | Re & 63) << y[me++ & 3]) : Re < 55296 || Re >= 57344 ? (ne[me >> 2] |= (224 | Re >> 12) << y[me++ & 3], ne[me >> 2] |= (128 | Re >> 6 & 63) << y[me++ & 3], ne[me >> 2] |= (128 | Re & 63) << y[me++ & 3]) : (Re = 65536 + ((Re & 1023) << 10 | V.charCodeAt(++Z) & 1023), ne[me >> 2] |= (240 | Re >> 18) << y[me++ & 3], ne[me >> 2] |= (128 | Re >> 12 & 63) << y[me++ & 3], ne[me >> 2] |= (128 | Re >> 6 & 63) << y[me++ & 3], ne[me >> 2] |= (128 | Re & 63) << y[me++ & 3]);
                if (this.lastByteIndex = me, me >= ie) {
                    for (this.start = me - ie, this.block = ne[z], me = 0; me < z; ++me) ge[me] ^= ne[me];
                    ve(ge), this.reset = !0
                } else this.start = me
            }
            return this
        }, R.prototype.encode = function(V, X) {
            var q = V & 255,
                ne = 1,
                ie = [q];
            for (V = V >> 8, q = V & 255; q > 0;) ie.unshift(q), V = V >> 8, q = V & 255, ++ne;
            return X ? ie.push(ne) : ie.unshift(ne), this.update(ie), ie.length
        }, R.prototype.encodeString = function(V) {
            var X, q = typeof V;
            if (q !== "string") {
                if (q === "object") {
                    if (V === null) throw new Error(e);
                    if (l && V.constructor === ArrayBuffer) V = new Uint8Array(V);
                    else if (!Array.isArray(V) && (!l || !ArrayBuffer.isView(V))) throw new Error(e)
                } else throw new Error(e);
                X = !0
            }
            var ne = 0,
                ie = V.length;
            if (X) ne = ie;
            else
                for (var k = 0; k < V.length; ++k) {
                    var z = V.charCodeAt(k);
                    z < 128 ? ne += 1 : z < 2048 ? ne += 2 : z < 55296 || z >= 57344 ? ne += 3 : (z = 65536 + ((z & 1023) << 10 | V.charCodeAt(++k) & 1023), ne += 4)
                }
            return ne += this.encode(ne * 8), this.update(V), ne
        }, R.prototype.bytepad = function(V, X) {
            for (var q = this.encode(X), ne = 0; ne < V.length; ++ne) q += this.encodeString(V[ne]);
            var ie = X - q % X,
                k = [];
            return k.length = ie, this.update(k), this
        }, R.prototype.finalize = function() {
            if (!this.finalized) {
                this.finalized = !0;
                var V = this.blocks,
                    X = this.lastByteIndex,
                    q = this.blockCount,
                    ne = this.s;
                if (V[X >> 2] |= this.padding[X & 3], this.lastByteIndex === this.byteCount)
                    for (V[0] = V[q], X = 1; X < q + 1; ++X) V[X] = 0;
                for (V[q - 1] |= 2147483648, X = 0; X < q; ++X) ne[X] ^= V[X];
                ve(ne)
            }
        }, R.prototype.toString = R.prototype.hex = function() {
            this.finalize();
            for (var V = this.blockCount, X = this.s, q = this.outputBlocks, ne = this.extraBytes, ie = 0, k = 0, z = "", Z; k < q;) {
                for (ie = 0; ie < V && k < q; ++ie, ++k) Z = X[ie], z += c[Z >> 4 & 15] + c[Z & 15] + c[Z >> 12 & 15] + c[Z >> 8 & 15] + c[Z >> 20 & 15] + c[Z >> 16 & 15] + c[Z >> 28 & 15] + c[Z >> 24 & 15];
                k % V === 0 && (ve(X), ie = 0)
            }
            return ne && (Z = X[ie], z += c[Z >> 4 & 15] + c[Z & 15], ne > 1 && (z += c[Z >> 12 & 15] + c[Z >> 8 & 15]), ne > 2 && (z += c[Z >> 20 & 15] + c[Z >> 16 & 15])), z
        }, R.prototype.arrayBuffer = function() {
            this.finalize();
            var V = this.blockCount,
                X = this.s,
                q = this.outputBlocks,
                ne = this.extraBytes,
                ie = 0,
                k = 0,
                z = this.outputBits >> 3,
                Z;
            ne ? Z = new ArrayBuffer(q + 1 << 2) : Z = new ArrayBuffer(z);
            for (var ge = new Uint32Array(Z); k < q;) {
                for (ie = 0; ie < V && k < q; ++ie, ++k) ge[k] = X[ie];
                k % V === 0 && ve(X)
            }
            return ne && (ge[ie] = X[ie], Z = Z.slice(0, z)), Z
        }, R.prototype.buffer = R.prototype.arrayBuffer, R.prototype.digest = R.prototype.array = function() {
            this.finalize();
            for (var V = this.blockCount, X = this.s, q = this.outputBlocks, ne = this.extraBytes, ie = 0, k = 0, z = [], Z, ge; k < q;) {
                for (ie = 0; ie < V && k < q; ++ie, ++k) Z = k << 2, ge = X[ie], z[Z] = ge & 255, z[Z + 1] = ge >> 8 & 255, z[Z + 2] = ge >> 16 & 255, z[Z + 3] = ge >> 24 & 255;
                k % V === 0 && ve(X)
            }
            return ne && (Z = k << 2, ge = X[ie], z[Z] = ge & 255, ne > 1 && (z[Z + 1] = ge >> 8 & 255), ne > 2 && (z[Z + 2] = ge >> 16 & 255)), z
        };

        function Y(V, X, q) {
            R.call(this, V, X, q)
        }
        Y.prototype = new R, Y.prototype.finalize = function() {
            return this.encode(this.outputBits, !0), R.prototype.finalize.call(this)
        };
        var ve = function(V) {
            var X, q, ne, ie, k, z, Z, ge, me, Re, He, Be, bt, mn, at, tt, _t, ot, lt, wt, Xe, Q, D, B, se, de, ye, Se, nt, Ke, mt, en, vt, hn, ui, bn, On, Un, Lt, jt, qn, Ht, zt, Jn, Vt, Ft, Xn, Kt, Qt, fe, he, be, Pe, qe, Je, Mt, Le, rt, ct, ft, an, pn, ln;
            for (ne = 0; ne < 48; ne += 2) ie = V[0] ^ V[10] ^ V[20] ^ V[30] ^ V[40], k = V[1] ^ V[11] ^ V[21] ^ V[31] ^ V[41], z = V[2] ^ V[12] ^ V[22] ^ V[32] ^ V[42], Z = V[3] ^ V[13] ^ V[23] ^ V[33] ^ V[43], ge = V[4] ^ V[14] ^ V[24] ^ V[34] ^ V[44], me = V[5] ^ V[15] ^ V[25] ^ V[35] ^ V[45], Re = V[6] ^ V[16] ^ V[26] ^ V[36] ^ V[46], He = V[7] ^ V[17] ^ V[27] ^ V[37] ^ V[47], Be = V[8] ^ V[18] ^ V[28] ^ V[38] ^ V[48], bt = V[9] ^ V[19] ^ V[29] ^ V[39] ^ V[49], X = Be ^ (z << 1 | Z >>> 31), q = bt ^ (Z << 1 | z >>> 31), V[0] ^= X, V[1] ^= q, V[10] ^= X, V[11] ^= q, V[20] ^= X, V[21] ^= q, V[30] ^= X, V[31] ^= q, V[40] ^= X, V[41] ^= q, X = ie ^ (ge << 1 | me >>> 31), q = k ^ (me << 1 | ge >>> 31), V[2] ^= X, V[3] ^= q, V[12] ^= X, V[13] ^= q, V[22] ^= X, V[23] ^= q, V[32] ^= X, V[33] ^= q, V[42] ^= X, V[43] ^= q, X = z ^ (Re << 1 | He >>> 31), q = Z ^ (He << 1 | Re >>> 31), V[4] ^= X, V[5] ^= q, V[14] ^= X, V[15] ^= q, V[24] ^= X, V[25] ^= q, V[34] ^= X, V[35] ^= q, V[44] ^= X, V[45] ^= q, X = ge ^ (Be << 1 | bt >>> 31), q = me ^ (bt << 1 | Be >>> 31), V[6] ^= X, V[7] ^= q, V[16] ^= X, V[17] ^= q, V[26] ^= X, V[27] ^= q, V[36] ^= X, V[37] ^= q, V[46] ^= X, V[47] ^= q, X = Re ^ (ie << 1 | k >>> 31), q = He ^ (k << 1 | ie >>> 31), V[8] ^= X, V[9] ^= q, V[18] ^= X, V[19] ^= q, V[28] ^= X, V[29] ^= q, V[38] ^= X, V[39] ^= q, V[48] ^= X, V[49] ^= q, mn = V[0], at = V[1], Ft = V[11] << 4 | V[10] >>> 28, Xn = V[10] << 4 | V[11] >>> 28, Se = V[20] << 3 | V[21] >>> 29, nt = V[21] << 3 | V[20] >>> 29, ft = V[31] << 9 | V[30] >>> 23, an = V[30] << 9 | V[31] >>> 23, Ht = V[40] << 18 | V[41] >>> 14, zt = V[41] << 18 | V[40] >>> 14, hn = V[2] << 1 | V[3] >>> 31, ui = V[3] << 1 | V[2] >>> 31, tt = V[13] << 12 | V[12] >>> 20, _t = V[12] << 12 | V[13] >>> 20, Kt = V[22] << 10 | V[23] >>> 22, Qt = V[23] << 10 | V[22] >>> 22, Ke = V[33] << 13 | V[32] >>> 19, mt = V[32] << 13 | V[33] >>> 19, pn = V[42] << 2 | V[43] >>> 30, ln = V[43] << 2 | V[42] >>> 30, qe = V[5] << 30 | V[4] >>> 2, Je = V[4] << 30 | V[5] >>> 2, bn = V[14] << 6 | V[15] >>> 26, On = V[15] << 6 | V[14] >>> 26, ot = V[25] << 11 | V[24] >>> 21, lt = V[24] << 11 | V[25] >>> 21, fe = V[34] << 15 | V[35] >>> 17, he = V[35] << 15 | V[34] >>> 17, en = V[45] << 29 | V[44] >>> 3, vt = V[44] << 29 | V[45] >>> 3, B = V[6] << 28 | V[7] >>> 4, se = V[7] << 28 | V[6] >>> 4, Mt = V[17] << 23 | V[16] >>> 9, Le = V[16] << 23 | V[17] >>> 9, Un = V[26] << 25 | V[27] >>> 7, Lt = V[27] << 25 | V[26] >>> 7, wt = V[36] << 21 | V[37] >>> 11, Xe = V[37] << 21 | V[36] >>> 11, be = V[47] << 24 | V[46] >>> 8, Pe = V[46] << 24 | V[47] >>> 8, Jn = V[8] << 27 | V[9] >>> 5, Vt = V[9] << 27 | V[8] >>> 5, de = V[18] << 20 | V[19] >>> 12, ye = V[19] << 20 | V[18] >>> 12, rt = V[29] << 7 | V[28] >>> 25, ct = V[28] << 7 | V[29] >>> 25, jt = V[38] << 8 | V[39] >>> 24, qn = V[39] << 8 | V[38] >>> 24, Q = V[48] << 14 | V[49] >>> 18, D = V[49] << 14 | V[48] >>> 18, V[0] = mn ^ ~tt & ot, V[1] = at ^ ~_t & lt, V[10] = B ^ ~de & Se, V[11] = se ^ ~ye & nt, V[20] = hn ^ ~bn & Un, V[21] = ui ^ ~On & Lt, V[30] = Jn ^ ~Ft & Kt, V[31] = Vt ^ ~Xn & Qt, V[40] = qe ^ ~Mt & rt, V[41] = Je ^ ~Le & ct, V[2] = tt ^ ~ot & wt, V[3] = _t ^ ~lt & Xe, V[12] = de ^ ~Se & Ke, V[13] = ye ^ ~nt & mt, V[22] = bn ^ ~Un & jt, V[23] = On ^ ~Lt & qn, V[32] = Ft ^ ~Kt & fe, V[33] = Xn ^ ~Qt & he, V[42] = Mt ^ ~rt & ft, V[43] = Le ^ ~ct & an, V[4] = ot ^ ~wt & Q, V[5] = lt ^ ~Xe & D, V[14] = Se ^ ~Ke & en, V[15] = nt ^ ~mt & vt, V[24] = Un ^ ~jt & Ht, V[25] = Lt ^ ~qn & zt, V[34] = Kt ^ ~fe & be, V[35] = Qt ^ ~he & Pe, V[44] = rt ^ ~ft & pn, V[45] = ct ^ ~an & ln, V[6] = wt ^ ~Q & mn, V[7] = Xe ^ ~D & at, V[16] = Ke ^ ~en & B, V[17] = mt ^ ~vt & se, V[26] = jt ^ ~Ht & hn, V[27] = qn ^ ~zt & ui, V[36] = fe ^ ~be & Jn, V[37] = he ^ ~Pe & Vt, V[46] = ft ^ ~pn & qe, V[47] = an ^ ~ln & Je, V[8] = Q ^ ~mn & tt, V[9] = D ^ ~at & _t, V[18] = en ^ ~B & de, V[19] = vt ^ ~se & ye, V[28] = Ht ^ ~hn & bn, V[29] = zt ^ ~ui & On, V[38] = be ^ ~Jn & Ft, V[39] = Pe ^ ~Vt & Xn, V[48] = pn ^ ~qe & Mt, V[49] = ln ^ ~Je & Le, V[0] ^= _[ne], V[1] ^= _[ne + 1]
        };
        if (a) t.exports = m;
        else
            for (T = 0; T < v.length; ++T) i[v[T]] = m[v[T]]
    })()
})(ohe);
var Aft = ohe.exports;
const Tft = co(Aft);

function YU(t) {
    return "0x" + Tft.keccak_256(Lf(t))
}
const Ift = "address/5.7.0",
    E1 = new br(Ift);

function mJ(t) {
    ty(t, 20) || E1.throwArgumentError("invalid address", "address", t), t = t.toLowerCase();
    const e = t.substring(2).split(""),
        n = new Uint8Array(40);
    for (let i = 0; i < 40; i++) n[i] = e[i].charCodeAt(0);
    const r = Lf(YU(n));
    for (let i = 0; i < 40; i += 2) r[i >> 1] >> 4 >= 8 && (e[i] = e[i].toUpperCase()), (r[i >> 1] & 15) >= 8 && (e[i + 1] = e[i + 1].toUpperCase());
    return "0x" + e.join("")
}
const Rft = 9007199254740991;

function Oft(t) {
    return Math.log10 ? Math.log10(t) : Math.log(t) / Math.LN10
}
const ZU = {};
for (let t = 0; t < 10; t++) ZU[String(t)] = String(t);
for (let t = 0; t < 26; t++) ZU[String.fromCharCode(65 + t)] = String(10 + t);
const yJ = Math.floor(Oft(Rft));

function Nft(t) {
    t = t.toUpperCase(), t = t.substring(4) + t.substring(0, 2) + "00";
    let e = t.split("").map(r => ZU[r]).join("");
    for (; e.length >= yJ;) {
        let r = e.substring(0, yJ);
        e = parseInt(r, 10) % 97 + e.substring(r.length)
    }
    let n = String(98 - parseInt(e, 10) % 97);
    for (; n.length < 2;) n = "0" + n;
    return n
}

function o$(t) {
    let e = null;
    if (typeof t != "string" && E1.throwArgumentError("invalid address", "address", t), t.match(/^(0x)?[0-9a-fA-F]{40}$/)) t.substring(0, 2) !== "0x" && (t = "0x" + t), e = mJ(t), t.match(/([A-F].*[a-f])|([a-f].*[A-F])/) && e !== t && E1.throwArgumentError("bad address checksum", "address", t);
    else if (t.match(/^XE[0-9]{2}[0-9A-Za-z]{30,31}$/)) {
        for (t.substring(2, 4) !== Nft(t) && E1.throwArgumentError("bad icap checksum", "address", t), e = Iot(t.substring(4)); e.length < 40;) e = "0" + e;
        e = mJ("0x" + e)
    } else E1.throwArgumentError("invalid address", "address", t);
    return e
}

function Pft(t, e, n) {
    return XQ(e) !== 32 && E1.throwArgumentError("salt must be 32 bytes", "salt", e), XQ(n) !== 32 && E1.throwArgumentError("initCodeHash must be 32 bytes", "initCodeHash", n), o$(Aot(YU(vU(["0xff", o$(t), e, n])), 12))
}

function kft(t, e) {
    if (typeof t != "object" || !t) return t;
    var n = t[Symbol.toPrimitive];
    if (n !== void 0) {
        var r = n.call(t, e);
        if (typeof r != "object") return r;
        throw new TypeError("@@toPrimitive must return a primitive value.")
    }
    return String(t)
}

function Mft(t) {
    var e = kft(t, "string");
    return typeof e == "symbol" ? e : String(e)
}

function Dft(t, e) {
    for (var n = 0; n < e.length; n++) {
        var r = e[n];
        r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(t, Mft(r.key), r)
    }
}

function S4(t, e, n) {
    return e && Dft(t.prototype, e), Object.defineProperty(t, "prototype", {
        writable: !1
    }), t
}

function j6() {
    return j6 = Object.assign ? Object.assign.bind() : function(t) {
        for (var e = 1; e < arguments.length; e++) {
            var n = arguments[e];
            for (var r in n) Object.prototype.hasOwnProperty.call(n, r) && (t[r] = n[r])
        }
        return t
    }, j6.apply(this, arguments)
}

function o5(t, e) {
    t.prototype = Object.create(e.prototype), t.prototype.constructor = t, a$(t, e)
}

function a$(t, e) {
    return a$ = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(r, i) {
        return r.__proto__ = i, r
    }, a$(t, e)
}
var it;
(function(t) {
    t[t.MAINNET = 1] = "MAINNET", t[t.GOERLI = 5] = "GOERLI", t[t.SEPOLIA = 11155111] = "SEPOLIA", t[t.OPTIMISM = 10] = "OPTIMISM", t[t.OPTIMISM_GOERLI = 420] = "OPTIMISM_GOERLI", t[t.OPTIMISM_SEPOLIA = 11155420] = "OPTIMISM_SEPOLIA", t[t.ARBITRUM_ONE = 42161] = "ARBITRUM_ONE", t[t.ARBITRUM_GOERLI = 421613] = "ARBITRUM_GOERLI", t[t.ARBITRUM_SEPOLIA = 421614] = "ARBITRUM_SEPOLIA", t[t.POLYGON = 137] = "POLYGON", t[t.POLYGON_MUMBAI = 80001] = "POLYGON_MUMBAI", t[t.CELO = 42220] = "CELO", t[t.CELO_ALFAJORES = 44787] = "CELO_ALFAJORES", t[t.GNOSIS = 100] = "GNOSIS", t[t.MOONBEAM = 1284] = "MOONBEAM", t[t.BNB = 56] = "BNB", t[t.AVALANCHE = 43114] = "AVALANCHE", t[t.BASE_GOERLI = 84531] = "BASE_GOERLI", t[t.BASE = 8453] = "BASE", t[t.ZORA = 7777777] = "ZORA", t[t.ZORA_SEPOLIA = 999999999] = "ZORA_SEPOLIA", t[t.ROOTSTOCK = 30] = "ROOTSTOCK", t[t.BLAST = 81457] = "BLAST", t[t.ZKSYNC = 324] = "ZKSYNC"
})(it || (it = {}));
it.MAINNET, it.OPTIMISM, it.OPTIMISM_GOERLI, it.OPTIMISM_SEPOLIA, it.ARBITRUM_ONE, it.ARBITRUM_GOERLI, it.ARBITRUM_SEPOLIA, it.POLYGON, it.POLYGON_MUMBAI, it.GOERLI, it.SEPOLIA, it.CELO_ALFAJORES, it.CELO, it.BNB, it.AVALANCHE, it.BASE, it.BASE_GOERLI, it.ZORA, it.ZORA_SEPOLIA, it.ROOTSTOCK, it.BLAST, it.ZKSYNC;
var wJ;
(function(t) {
    t.ETHER = "ETH", t.MATIC = "MATIC", t.CELO = "CELO", t.GNOSIS = "XDAI", t.MOONBEAM = "GLMR", t.BNB = "BNB", t.AVAX = "AVAX", t.ROOTSTOCK = "RBTC"
})(wJ || (wJ = {}));
var cl, Zc, hi, vP, bP, _P, EP, xP, $ft = [it.MAINNET, it.GOERLI, it.SEPOLIA];

function Lft(t, e) {
    return e === void 0 && (e = []), $ft.concat(e).reduce(function(n, r) {
        return n[r] = t, n
    }, {})
}
it.OPTIMISM, it.ARBITRUM_ONE, it.POLYGON, it.POLYGON_MUMBAI, it.SEPOLIA;
var Bft = (cl = {}, cl[it.MAINNET] = "0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f", cl[it.GOERLI] = "0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f", cl[it.SEPOLIA] = "0xB7f907f7A9eBC822a80BD25E224be42Ce0A698A0", cl[it.OPTIMISM] = "0x0c3c1c532F1e39EdF36BE9Fe0bE1410313E074Bf", cl[it.ARBITRUM_ONE] = "0xf1D7CC64Fb4452F05c498126312eBE29f30Fbcf9", cl[it.AVALANCHE] = "0x9e5A52f57b3038F1B8EeE45F28b3C1967e22799C", cl[it.BASE] = "0x8909dc15e40173ff4699343b6eb8132c65e18ec6", cl[it.BNB] = "0x8909Dc15e40173Ff4699343b6eB8132c65e18eC6", cl[it.POLYGON] = "0x9e5A52f57b3038F1B8EeE45F28b3C1967e22799C", cl[it.CELO] = "0x79a530c8e2fA8748B7B40dd3629C0520c2cCf03f", cl[it.BLAST] = "0x5C346464d33F90bABaf70dB6388507CC889C1070", cl);
Zc = {}, Zc[it.MAINNET] = "0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D", Zc[it.GOERLI] = "0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D", Zc[it.ARBITRUM_ONE] = "0x4752ba5dbc23f44d87826276bf6fd6b1c372ad24", Zc[it.OPTIMISM] = "0x4a7b5da61326a6379179b40d00f57e5bbdc962c2", Zc[it.BASE] = "0x4752ba5dbc23f44d87826276bf6fd6b1c372ad24", Zc[it.AVALANCHE] = "0x4752ba5dbc23f44d87826276bf6fd6b1c372ad24", Zc[it.BNB] = "0x4752ba5dbc23f44d87826276bf6fd6b1c372ad24", Zc[it.POLYGON] = "0xedf6066a2b290c185783862c7f4776a2c8077ad1", Zc[it.BLAST] = "0xBB66Eb1c5e875933D44DAe661dbD80e5D9B03035";
var C4 = {
        v3CoreFactoryAddress: "0x1F98431c8aD98523631AE4a59f267346ea31F984",
        multicallAddress: "0x1F98415757620B543A52E61c46B32eB19261F984",
        quoterAddress: "0xb27308f9F90D607463bb33eA1BeBb41C27CE5AB6",
        v3MigratorAddress: "0xA5644E29708357803b5A882D272c41cC0dF92B34",
        nonfungiblePositionManagerAddress: "0xC36442b4a4522E871399CD717aBDD847Ab11FE88"
    },
    Fft = j6({}, C4, {
        mixedRouteQuoterV1Address: "0x84E44095eeBfEC7793Cd7d5b57B7e401D7f1cA2E"
    }),
    Uft = j6({}, C4, {
        mixedRouteQuoterV1Address: "0xBa60b6e6fF25488308789E6e0A65D838be34194e"
    }),
    jft = C4,
    Hft = j6({}, C4, {
        multicallAddress: "0xadF885960B47eA2CD9B55E6DAc6B42b7Cb2806dB",
        tickLensAddress: "0xbfd8137f7d1516D3ea5cA83523914859ec47F573"
    }),
    vJ = C4,
    bJ = {
        v3CoreFactoryAddress: "0xAfE208a311B21f13EF87E33A90049fC17A7acDEc",
        multicallAddress: "0x633987602DE5C4F337e3DbF265303A1080324204",
        quoterAddress: "0x82825d0554fA07f7FC52Ab63c961F330fdEFa8E8",
        v3MigratorAddress: "0x3cFd4d48EDfDCC53D3f173F596f621064614C582",
        nonfungiblePositionManagerAddress: "0x3d79EdAaBC0EaB6F08ED885C05Fc0B014290D95A",
        tickLensAddress: "0x5f115D9113F88e0a0Db1b5033D90D4a9690AcD3D"
    },
    zft = {
        v3CoreFactoryAddress: "0xdB1d10011AD0Ff90774D0C6Bb92e5C5c8b4461F7",
        multicallAddress: "0x963Df249eD09c358A4819E39d9Cd5736c3087184",
        quoterAddress: "0x78D78E420Da98ad378D7799bE8f4AF69033EB077",
        v3MigratorAddress: "0x32681814957e0C13117ddc0c2aba232b5c9e760f",
        nonfungiblePositionManagerAddress: "0x7b8A01B39D58278b5DE7e48c8449c9f4F5170613",
        tickLensAddress: "0xD9270014D396281579760619CCf4c3af0501A47C",
        swapRouter02Address: "0xB971eF87ede563556b2ED4b1C0b0019111Dd85d2"
    },
    Wft = {
        v3CoreFactoryAddress: "0xB656dA17129e7EB733A557f4EBc57B76CFbB5d10",
        multicallAddress: "0x07F2D8a2a02251B62af965f22fC4744A5f96BCCd",
        quoterAddress: "0x9569CbA925c8ca2248772A9A4976A516743A246F",
        v3MigratorAddress: "0xf6c55fBe84B1C8c3283533c53F51bC32F5C7Aba8",
        nonfungiblePositionManagerAddress: "0x39Ca85Af2F383190cBf7d7c41ED9202D27426EF6",
        tickLensAddress: "0xe6140Bd164b63E8BfCfc40D5dF952f83e171758e"
    },
    Vft = {
        v3CoreFactoryAddress: "0x8CE191193D15ea94e11d327b4c7ad8bbE520f6aF",
        multicallAddress: "0x80e4e06841bb76AA9735E0448cB8d003C0EF009a",
        quoterAddress: "0x0FBEa6cf957d95ee9313490050F6A0DA68039404",
        v3MigratorAddress: "0xE7EcbAAaA54D007A00dbb6c1d2f150066D69dA07",
        nonfungiblePositionManagerAddress: "0xdA75cEf1C93078e8b736FCA5D5a30adb97C8957d",
        tickLensAddress: "0xCb7f54747F58F8944973cea5b8f4ac2209BadDC5",
        swapRouter02Address: "0x94cC0AaC535CCDB3C01d6787D6413C739ae12bc4"
    },
    Gft = {
        v3CoreFactoryAddress: "0x4893376342d5D7b3e31d4184c08b265e5aB2A3f6",
        multicallAddress: "0x8260CB40247290317a4c062F3542622367F206Ee",
        quoterAddress: "0x1dd92b83591781D0C6d98d07391eea4b9a6008FA",
        v3MigratorAddress: "0xA815919D2584Ac3F76ea9CB62E6Fd40a43BCe0C3",
        nonfungiblePositionManagerAddress: "0x622e4726a167799826d1E1D150b076A7725f5D81",
        tickLensAddress: "0xb52429333da969a0C79a60930a4Bf0020E5D1DE8"
    },
    qft = {
        v3CoreFactoryAddress: "0x248AB79Bbb9bC29bB72f7Cd42F17e054Fc40188e",
        multicallAddress: "0x2B718b475e385eD29F56775a66aAB1F5cC6B2A0A",
        quoterAddress: "0x2779a0CC1c3e0E44D2542EC3e79e3864Ae93Ef0B",
        v3MigratorAddress: "0x398f43ef2c67B941147157DA1c5a868E906E043D",
        nonfungiblePositionManagerAddress: "0x6b2937Bde17889EDCf8fbD8dE31C3C2a70Bc4d65",
        tickLensAddress: "0x0fd18587734e5C2dcE2dccDcC7DD1EC89ba557d9",
        swapRouter02Address: "0x101F443B4d1b059569D643917553c771E1b9663E"
    },
    Kft = {
        v3CoreFactoryAddress: "0x0227628f3F023bb0B980b67D528571c95c6DaC1c",
        multicallAddress: "0xD7F33bCdb21b359c8ee6F0251d30E94832baAd07",
        quoterAddress: "0xEd1f6473345F45b75F8179591dd5bA1888cf2FB3",
        v3MigratorAddress: "0x729004182cF005CEC8Bd85df140094b6aCbe8b15",
        nonfungiblePositionManagerAddress: "0x1238536071E1c677A632429e3655c799b22cDA52",
        tickLensAddress: "0xd7f33bcdb21b359c8ee6f0251d30e94832baad07",
        swapRouter02Address: "0x3bFA4769FB09eefC5a80d6E87c3B9C650f7Ae48E",
        mixedRouteQuoterV2Address: "0xa8b0be287acB850952DE4287b84B7222cc654C09"
    },
    Yft = {
        v3CoreFactoryAddress: "0x740b1c1de25031C31FF4fC9A62f554A55cdC1baD",
        multicallAddress: "0x0139141Cd4Ee88dF3Cdb65881D411bAE271Ef0C2",
        quoterAddress: "0xbe0F5544EC67e9B3b2D979aaA43f18Fd87E6257F",
        v3MigratorAddress: "0x44f5f1f5E452ea8d29C890E8F6e893fC0f1f0f97",
        nonfungiblePositionManagerAddress: "0x655C406EBFa14EE2006250925e54ec43AD184f8B",
        tickLensAddress: "0xEB9fFC8bf81b4fFd11fb6A63a6B0f098c6e21950",
        swapRouter02Address: "0xbb00FF08d01D300023C629E8fFfFcb65A5a578cE"
    },
    Zft = {
        v3CoreFactoryAddress: "0x33128a8fC17869897dcE68Ed026d694621f6FDfD",
        multicallAddress: "0x091e99cb1C49331a94dD62755D168E941AbD0693",
        quoterAddress: "0x3d4e44Eb1374240CE5F1B871ab261CD16335B76a",
        v3MigratorAddress: "0x23cF10b1ee3AdfCA73B0eF17C07F7577e7ACd2d7",
        nonfungiblePositionManagerAddress: "0x03a520b32C04BF3bEEf7BEb72E919cf822Ed34f1",
        tickLensAddress: "0x0CdeE061c75D43c82520eD998C23ac2991c9ac6d",
        swapRouter02Address: "0x2626664c2603336E57B271c5C0b26F421741e481",
        mixedRouteQuoterV1Address: "0xe544efae946f0008ae9a8d64493efa7886b73776"
    },
    Qft = {
        v3CoreFactoryAddress: "0x9323c1d6D800ed51Bd7C6B216cfBec678B7d0BC2",
        multicallAddress: "0xB206027a9E0E13F05eBEFa5D2402Bab3eA716439",
        quoterAddress: "0xedf539058e28E5937dAef3f69cEd0b25fbE66Ae9",
        v3MigratorAddress: "0x3efe5d02a04b7351D671Db7008ec6eBA9AD9e3aE",
        nonfungiblePositionManagerAddress: "0x3c61369ef0D1D2AFa70d8feC2F31C5D6Ce134F30",
        tickLensAddress: "0x1acB873Ee909D0c98adB18e4474943249F931b92",
        swapRouter02Address: "0x8357227D4eDc78991Db6FDB9bD6ADE250536dE1d"
    },
    Jft = {
        v3CoreFactoryAddress: "0x7145F8aeef1f6510E92164038E1B6F8cB2c42Cbb",
        multicallAddress: "0xA51c76bEE6746cB487a7e9312E43e2b8f4A37C15",
        quoterAddress: "0x11867e1b3348F3ce4FcC170BC5af3d23E07E64Df",
        v3MigratorAddress: "0x048352d8dCF13686982C799da63fA6426a9D0b60",
        nonfungiblePositionManagerAddress: "0xbC91e8DfA3fF18De43853372A3d7dfe585137D78",
        tickLensAddress: "0x209AAda09D74Ad3B8D0E92910Eaf85D2357e3044",
        swapRouter02Address: "0x7De04c96BE5159c3b5CeffC82aa176dc81281557"
    },
    Xft = {
        v3CoreFactoryAddress: "0x4324A677D74764f46f33ED447964252441aA8Db6",
        multicallAddress: "0xA1E7e3A69671C4494EC59Dbd442de930a93F911A",
        quoterAddress: "0xC195976fEF0985886E37036E2DF62bF371E12Df0",
        v3MigratorAddress: "0x65ef259b31bf1d977c37e9434658694267674897",
        nonfungiblePositionManagerAddress: "0xB8458EaAe43292e3c1F7994EFd016bd653d23c20",
        tickLensAddress: "0x23C0F71877a1Fc4e20A78018f9831365c85f3064"
    },
    edt = {
        v3CoreFactoryAddress: "0xaF37EC98A00FD63689CF3060BF3B6784E00caD82",
        multicallAddress: "0x996a9858cDfa45Ad68E47c9A30a7201E29c6a386",
        quoterAddress: "0xb51727c996C68E60F598A923a5006853cd2fEB31",
        v3MigratorAddress: "0x16678977CA4ec3DAD5efc7b15780295FE5f56162",
        nonfungiblePositionManagerAddress: "0x9d9386c042F194B460Ec424a1e57ACDE25f5C4b1",
        tickLensAddress: "0x55B9dF5bF68ADe972191a91980459f48ecA16afC",
        swapRouter02Address: "0x0B14ff67f0014046b4b99057Aec4509640b3947A"
    },
    tdt = {
        v3CoreFactoryAddress: "0x792edAdE80af5fC680d96a2eD80A44247D2Cf6Fd",
        multicallAddress: "0xdC7f370de7631cE9e2c2e1DCDA6B3B5744Cf4705",
        quoterAddress: "0x6Cdcd65e03c1CEc3730AeeCd45bc140D57A25C77",
        v3MigratorAddress: "0x15CA7043CD84C5D21Ae76Ba0A1A967d42c40ecE0",
        nonfungiblePositionManagerAddress: "0xB218e4f7cF0533d4696fDfC419A0023D33345F28",
        tickLensAddress: "0x2E95185bCdD928a3e984B7e2D6560Ab1b17d7274",
        swapRouter02Address: "0x549FEB8c9bd4c12Ad2AB27022dA12492aC452B66"
    },
    ndt = {
        v3CoreFactoryAddress: "0x8FdA5a7a8dCA67BBcDd10F02Fa0649A937215422",
        multicallAddress: "0x0c68a7C72f074d1c45C16d41fa74eEbC6D16a65C",
        quoterAddress: "0x8Cb537fc92E26d8EBBb760E632c95484b6Ea3e28",
        v3MigratorAddress: "0x611841b24E43C4ACfd290B427a3D6cf1A59dac8E",
        nonfungiblePositionManagerAddress: "0x0616e5762c1E7Dc3723c50663dF10a162D690a86",
        tickLensAddress: "0xe10FF11b809f8EE07b056B452c3B2caa7FE24f89",
        swapRouter02Address: "0x99c56385daBCE3E81d8499d0b8d0257aBC07E8A3"
    };
hi = {}, hi[it.MAINNET] = Fft, hi[it.OPTIMISM] = jft, hi[it.ARBITRUM_ONE] = Hft, hi[it.POLYGON] = vJ, hi[it.POLYGON_MUMBAI] = vJ, hi[it.GOERLI] = Uft, hi[it.CELO] = bJ, hi[it.CELO_ALFAJORES] = bJ, hi[it.BNB] = zft, hi[it.OPTIMISM_GOERLI] = Wft, hi[it.OPTIMISM_SEPOLIA] = Vft, hi[it.ARBITRUM_GOERLI] = Gft, hi[it.ARBITRUM_SEPOLIA] = qft, hi[it.SEPOLIA] = Kft, hi[it.AVALANCHE] = Yft, hi[it.BASE] = Zft, hi[it.BASE_GOERLI] = Qft, hi[it.ZORA] = Jft, hi[it.ZORA_SEPOLIA] = Xft, hi[it.ROOTSTOCK] = edt, hi[it.BLAST] = tdt, hi[it.ZKSYNC] = ndt;
vP = {}, vP[it.MAINNET] = "0xC4e172459f1E7939D522503B81AFAaC1014CE6F6";
bP = {}, bP[it.MAINNET] = "0x408ED6354d4973f66138C91495F2f2FCbd8724C3";
_P = {}, _P[it.MAINNET] = "0x090D4613473dEE047c3f2706764f49E0821D256e";
EP = {}, EP[it.MAINNET] = "0xeca4B0bDBf7c55E9b7925919d03CbF8Dc82537E8";
xP = {}, xP[it.MAINNET] = "0x65770b5283117639760beA3F867b69b3697a91dd";
var gc;
(function(t) {
    t[t.EXACT_INPUT = 0] = "EXACT_INPUT", t[t.EXACT_OUTPUT = 1] = "EXACT_OUTPUT"
})(gc || (gc = {}));
var Tc;
(function(t) {
    t[t.ROUND_DOWN = 0] = "ROUND_DOWN", t[t.ROUND_HALF_UP = 1] = "ROUND_HALF_UP", t[t.ROUND_UP = 2] = "ROUND_UP"
})(Tc || (Tc = {}));
var rdt = re.BigInt("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"),
    p3, g3, u_ = KU(wft),
    SP = KU(ihe),
    idt = (p3 = {}, p3[Tc.ROUND_DOWN] = u_.ROUND_DOWN, p3[Tc.ROUND_HALF_UP] = u_.ROUND_HALF_UP, p3[Tc.ROUND_UP] = u_.ROUND_UP, p3),
    sdt = (g3 = {}, g3[Tc.ROUND_DOWN] = 0, g3[Tc.ROUND_HALF_UP] = 1, g3[Tc.ROUND_UP] = 3, g3),
    iy = function() {
        function t(n, r) {
            r === void 0 && (r = re.BigInt(1)), this.numerator = re.BigInt(n), this.denominator = re.BigInt(r)
        }
        t.tryParseFraction = function(r) {
            if (r instanceof re || typeof r == "number" || typeof r == "string") return new t(r);
            if ("numerator" in r && "denominator" in r) return r;
            throw new Error("Could not parse fraction")
        };
        var e = t.prototype;
        return e.invert = function() {
            return new t(this.denominator, this.numerator)
        }, e.add = function(r) {
            var i = t.tryParseFraction(r);
            return re.equal(this.denominator, i.denominator) ? new t(re.add(this.numerator, i.numerator), this.denominator) : new t(re.add(re.multiply(this.numerator, i.denominator), re.multiply(i.numerator, this.denominator)), re.multiply(this.denominator, i.denominator))
        }, e.subtract = function(r) {
            var i = t.tryParseFraction(r);
            return re.equal(this.denominator, i.denominator) ? new t(re.subtract(this.numerator, i.numerator), this.denominator) : new t(re.subtract(re.multiply(this.numerator, i.denominator), re.multiply(i.numerator, this.denominator)), re.multiply(this.denominator, i.denominator))
        }, e.lessThan = function(r) {
            var i = t.tryParseFraction(r);
            return re.lessThan(re.multiply(this.numerator, i.denominator), re.multiply(i.numerator, this.denominator))
        }, e.equalTo = function(r) {
            var i = t.tryParseFraction(r);
            return re.equal(re.multiply(this.numerator, i.denominator), re.multiply(i.numerator, this.denominator))
        }, e.greaterThan = function(r) {
            var i = t.tryParseFraction(r);
            return re.greaterThan(re.multiply(this.numerator, i.denominator), re.multiply(i.numerator, this.denominator))
        }, e.multiply = function(r) {
            var i = t.tryParseFraction(r);
            return new t(re.multiply(this.numerator, i.numerator), re.multiply(this.denominator, i.denominator))
        }, e.divide = function(r) {
            var i = t.tryParseFraction(r);
            return new t(re.multiply(this.numerator, i.denominator), re.multiply(this.denominator, i.numerator))
        }, e.toSignificant = function(r, i, s) {
            i === void 0 && (i = {
                groupSeparator: ""
            }), s === void 0 && (s = Tc.ROUND_HALF_UP), Number.isInteger(r) || fn(), r > 0 || fn(), u_.set({
                precision: r + 1,
                rounding: idt[s]
            });
            var o = new u_(this.numerator.toString()).div(this.denominator.toString()).toSignificantDigits(r);
            return o.toFormat(o.decimalPlaces(), i)
        }, e.toFixed = function(r, i, s) {
            return i === void 0 && (i = {
                groupSeparator: ""
            }), s === void 0 && (s = Tc.ROUND_HALF_UP), Number.isInteger(r) || fn(), r >= 0 || fn(), SP.DP = r, SP.RM = sdt[s], new SP(this.numerator.toString()).div(this.denominator.toString()).toFormat(r, i)
        }, S4(t, [{
            key: "quotient",
            get: function() {
                return re.divide(this.numerator, this.denominator)
            }
        }, {
            key: "remainder",
            get: function() {
                return new t(re.remainder(this.numerator, this.denominator), this.denominator)
            }
        }, {
            key: "asFraction",
            get: function() {
                return new t(this.numerator, this.denominator)
            }
        }]), t
    }(),
    _J = KU(ihe),
    bs = function(t) {
        o5(e, t);

        function e(r, i, s) {
            var o;
            return o = t.call(this, i, s) || this, re.lessThanOrEqual(o.quotient, rdt) || fn(), o.currency = r, o.decimalScale = re.exponentiate(re.BigInt(10), re.BigInt(r.decimals)), o
        }
        e.fromRawAmount = function(i, s) {
            return new e(i, s)
        }, e.fromFractionalAmount = function(i, s, o) {
            return new e(i, s, o)
        };
        var n = e.prototype;
        return n.add = function(i) {
            this.currency.equals(i.currency) || fn();
            var s = t.prototype.add.call(this, i);
            return e.fromFractionalAmount(this.currency, s.numerator, s.denominator)
        }, n.subtract = function(i) {
            this.currency.equals(i.currency) || fn();
            var s = t.prototype.subtract.call(this, i);
            return e.fromFractionalAmount(this.currency, s.numerator, s.denominator)
        }, n.multiply = function(i) {
            var s = t.prototype.multiply.call(this, i);
            return e.fromFractionalAmount(this.currency, s.numerator, s.denominator)
        }, n.divide = function(i) {
            var s = t.prototype.divide.call(this, i);
            return e.fromFractionalAmount(this.currency, s.numerator, s.denominator)
        }, n.toSignificant = function(i, s, o) {
            return i === void 0 && (i = 6), o === void 0 && (o = Tc.ROUND_DOWN), t.prototype.divide.call(this, this.decimalScale).toSignificant(i, s, o)
        }, n.toFixed = function(i, s, o) {
            return i === void 0 && (i = this.currency.decimals), o === void 0 && (o = Tc.ROUND_DOWN), i <= this.currency.decimals || fn(), t.prototype.divide.call(this, this.decimalScale).toFixed(i, s, o)
        }, n.toExact = function(i) {
            return i === void 0 && (i = {
                groupSeparator: ""
            }), _J.DP = this.currency.decimals, new _J(this.quotient.toString()).div(this.decimalScale.toString()).toFormat(i)
        }, S4(e, [{
            key: "wrapped",
            get: function() {
                return this.currency.isToken ? this : e.fromFractionalAmount(this.currency.wrapped, this.numerator, this.denominator)
            }
        }]), e
    }(iy),
    EJ = new iy(re.BigInt(100));

function zS(t) {
    return new sy(t.numerator, t.denominator)
}
var sy = function(t) {
        o5(e, t);

        function e() {
            var r;
            return r = t.apply(this, arguments) || this, r.isPercent = !0, r
        }
        var n = e.prototype;
        return n.add = function(i) {
            return zS(t.prototype.add.call(this, i))
        }, n.subtract = function(i) {
            return zS(t.prototype.subtract.call(this, i))
        }, n.multiply = function(i) {
            return zS(t.prototype.multiply.call(this, i))
        }, n.divide = function(i) {
            return zS(t.prototype.divide.call(this, i))
        }, n.toSignificant = function(i, s, o) {
            return i === void 0 && (i = 5), t.prototype.multiply.call(this, EJ).toSignificant(i, s, o)
        }, n.toFixed = function(i, s, o) {
            return i === void 0 && (i = 2), t.prototype.multiply.call(this, EJ).toFixed(i, s, o)
        }, e
    }(iy),
    um = function(t) {
        o5(e, t);

        function e() {
            for (var r, i, s, o, a, l = arguments.length, c = new Array(l), u = 0; u < l; u++) c[u] = arguments[u];
            if (c.length === 4) i = c[0], s = c[1], o = c[2], a = c[3];
            else {
                var f = c[0].quoteAmount.divide(c[0].baseAmount),
                    h = [c[0].baseAmount.currency, c[0].quoteAmount.currency, f.denominator, f.numerator];
                i = h[0], s = h[1], o = h[2], a = h[3]
            }
            return r = t.call(this, a, o) || this, r.baseCurrency = i, r.quoteCurrency = s, r.scalar = new iy(re.exponentiate(re.BigInt(10), re.BigInt(i.decimals)), re.exponentiate(re.BigInt(10), re.BigInt(s.decimals))), r
        }
        var n = e.prototype;
        return n.invert = function() {
            return new e(this.quoteCurrency, this.baseCurrency, this.numerator, this.denominator)
        }, n.multiply = function(i) {
            this.quoteCurrency.equals(i.baseCurrency) || fn();
            var s = t.prototype.multiply.call(this, i);
            return new e(this.baseCurrency, i.quoteCurrency, s.denominator, s.numerator)
        }, n.quote = function(i) {
            i.currency.equals(this.baseCurrency) || fn();
            var s = t.prototype.multiply.call(this, i);
            return bs.fromFractionalAmount(this.quoteCurrency, s.numerator, s.denominator)
        }, n.toSignificant = function(i, s, o) {
            return i === void 0 && (i = 6), this.adjustedForDecimals.toSignificant(i, s, o)
        }, n.toFixed = function(i, s, o) {
            return i === void 0 && (i = 4), this.adjustedForDecimals.toFixed(i, s, o)
        }, S4(e, [{
            key: "adjustedForDecimals",
            get: function() {
                return t.prototype.multiply.call(this, this.scalar)
            }
        }]), e
    }(iy),
    ahe = function(e, n, r, i) {
        Number.isSafeInteger(e) || fn(), n >= 0 && n < 255 && Number.isInteger(n) || fn(), this.chainId = e, this.decimals = n, this.symbol = r, this.name = i
    },
    odt = function(t) {
        o5(e, t);

        function e() {
            var n;
            return n = t.apply(this, arguments) || this, n.isNative = !0, n.isToken = !1, n
        }
        return e
    }(ahe);

function adt(t) {
    try {
        return o$(t)
    } catch {
        throw new Error(t + " is not a valid address.")
    }
}
var ldt = /^0x[0-9a-fA-F]{40}$/;

function cdt(t) {
    if (ldt.test(t)) return t;
    throw new Error(t + " is not a valid address.")
}
var Ui = function(t) {
        o5(e, t);

        function e(r, i, s, o, a, l, c, u) {
            var f;
            return f = t.call(this, r, s, o, a) || this, f.isNative = !1, f.isToken = !0, l ? f.address = cdt(i) : f.address = adt(i), c && (c.gte(Hi.from(0)) || fn()), u && (u.gte(Hi.from(0)) || fn()), f.buyFeeBps = c, f.sellFeeBps = u, f
        }
        var n = e.prototype;
        return n.equals = function(i) {
            return i.isToken && this.chainId === i.chainId && this.address.toLowerCase() === i.address.toLowerCase()
        }, n.sortsBefore = function(i) {
            return this.chainId !== i.chainId && fn(), this.address.toLowerCase() === i.address.toLowerCase() && fn(), this.address.toLowerCase() < i.address.toLowerCase()
        }, S4(e, [{
            key: "wrapped",
            get: function() {
                return this
            }
        }]), e
    }(ahe),
    x2 = {
        1: new Ui(1, "0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2", 18, "WETH", "Wrapped Ether"),
        3: new Ui(3, "0xc778417E063141139Fce010982780140Aa0cD5Ab", 18, "WETH", "Wrapped Ether"),
        4: new Ui(4, "0xc778417E063141139Fce010982780140Aa0cD5Ab", 18, "WETH", "Wrapped Ether"),
        5: new Ui(5, "0xB4FBF271143F4FBf7B91A5ded31805e42b2208d6", 18, "WETH", "Wrapped Ether"),
        42: new Ui(42, "0xd0A1E359811322d97991E03f863a0C30C2cF029C", 18, "WETH", "Wrapped Ether"),
        10: new Ui(10, "0x4200000000000000000000000000000000000006", 18, "WETH", "Wrapped Ether"),
        69: new Ui(69, "0x4200000000000000000000000000000000000006", 18, "WETH", "Wrapped Ether"),
        11155420: new Ui(11155420, "0x4200000000000000000000000000000000000006", 18, "WETH", "Wrapped Ether"),
        42161: new Ui(42161, "0x82aF49447D8a07e3bd95BD0d56f35241523fBab1", 18, "WETH", "Wrapped Ether"),
        421611: new Ui(421611, "0xB47e6A5f8b33b3F17603C83a0535A9dcD7E32681", 18, "WETH", "Wrapped Ether"),
        421614: new Ui(421614, "0x980B62Da83eFf3D4576C647993b0c1D7faf17c73", 18, "WETH", "Wrapped Ether"),
        8453: new Ui(8453, "0x4200000000000000000000000000000000000006", 18, "WETH", "Wrapped Ether"),
        56: new Ui(56, "0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c", 18, "WBNB", "Wrapped BNB"),
        137: new Ui(137, "0x0d500B1d8E8eF31E21C99d1Db9A6444d3ADf1270", 18, "WMATIC", "Wrapped MATIC"),
        43114: new Ui(43114, "0xB31f66AA3C1e785363F0875A1B74E27b85FD66c7", 18, "WAVAX", "Wrapped AVAX"),
        324: new Ui(324, "0x5AEa5775959fBC2557Cc8789bC1bf90A239D9a91", 18, "WETH", "Wrapped Ether")
    },
    lhe = function(t) {
        o5(e, t);

        function e(r) {
            return t.call(this, r, 18, "ETH", "Ether") || this
        }
        e.onChain = function(i) {
            var s;
            return (s = this._etherCache[i]) != null ? s : this._etherCache[i] = new e(i)
        };
        var n = e.prototype;
        return n.equals = function(i) {
            return i.isNative && i.chainId === this.chainId
        }, S4(e, [{
            key: "wrapped",
            get: function() {
                var i = x2[this.chainId];
                return i || fn(), i
            }
        }]), e
    }(odt);
lhe._etherCache = {};

function udt(t, e, n) {
    var r = t.quote(e),
        i = r.subtract(n).divide(r);
    return new sy(i.numerator, i.denominator)
}

function xJ(t, e, n, r) {
    if (n > 0 || fn(), t.length <= n || fn(), t.length === 0) return t.push(e), null;
    var i = t.length === n;
    if (i && r(t[t.length - 1], e) <= 0) return e;
    for (var s = 0, o = t.length; s < o;) {
        var a = s + o >>> 1;
        r(t[a], e) <= 0 ? s = a + 1 : o = a
    }
    return t.splice(s, 0, e), i ? t.pop() : null
}
var fdt = re.BigInt(Number.MAX_SAFE_INTEGER),
    ddt = re.BigInt(0),
    hdt = re.BigInt(1),
    SJ = re.BigInt(2);

function CP(t) {
    if (re.greaterThanOrEqual(t, ddt) || fn(), re.lessThan(t, fdt)) return re.BigInt(Math.floor(Math.sqrt(re.toNumber(t))));
    var e, n;
    for (e = t, n = re.add(re.divide(t, SJ), hdt); re.lessThan(n, e);) e = n, n = re.divide(re.add(re.divide(t, n), n), SJ);
    return e
}
const pdt = {
        address: yU,
        decimals: 18,
        name: "Ethereum",
        symbol: "ETH"
    },
    gdt = "solidity/5.7.0",
    mdt = new RegExp("^bytes([0-9]+)$"),
    ydt = new RegExp("^(u?int)([0-9]*)$"),
    wdt = new RegExp("^(.*)\\[([0-9]*)\\]$"),
    vdt = "0000000000000000000000000000000000000000000000000000000000000000",
    Tw = new br(gdt);

function che(t, e, n) {
    switch (t) {
        case "address":
            return n ? cP(e, 32) : Lf(e);
        case "string":
            return Not(e);
        case "bytes":
            return Lf(e);
        case "bool":
            return e = e ? "0x01" : "0x00", n ? cP(e, 32) : Lf(e)
    }
    let r = t.match(ydt);
    if (r) {
        let i = parseInt(r[2] || "256");
        return (r[2] && String(i) !== r[2] || i % 8 !== 0 || i === 0 || i > 256) && Tw.throwArgumentError("invalid number type", "type", t), n && (i = 256), e = Hi.from(e).toTwos(i), cP(e, i / 8)
    }
    if (r = t.match(mdt), r) {
        const i = parseInt(r[1]);
        return (String(i) !== r[1] || i === 0 || i > 32) && Tw.throwArgumentError("invalid bytes type", "type", t), Lf(e).byteLength !== i && Tw.throwArgumentError(`invalid value for ${t}`, "value", e), n ? Lf((e + vdt).substring(0, 66)) : e
    }
    if (r = t.match(wdt), r && Array.isArray(e)) {
        const i = r[1];
        parseInt(r[2] || String(e.length)) != e.length && Tw.throwArgumentError(`invalid array length for ${t}`, "value", e);
        const o = [];
        return e.forEach(function(a) {
            o.push(che(i, a, !0))
        }), vU(o)
    }
    return Tw.throwArgumentError("invalid type", "type", t)
}

function uhe(t, e) {
    t.length != e.length && Tw.throwArgumentError("wrong number of values; expected ${ types.length }", "values", e);
    const n = [];
    return t.forEach(function(r, i) {
        n.push(che(r, e[i]))
    }), q7(vU(n))
}

function bdt(t, e) {
    return YU(uhe(t, e))
}
var _dt = "0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f",
    Edt = Bft,
    xdt = "0x96e8ac4277198ff8b6f785478aa9a39f403cb768dd02cbee326c3e7da348845f",
    Sdt = re.BigInt(1e3),
    Io = re.BigInt(0),
    xv = re.BigInt(1),
    Cdt = re.BigInt(5),
    CJ = re.BigInt(997),
    AJ = re.BigInt(1e3),
    TJ = re.BigInt(1e4),
    uf = new sy(Io),
    IJ = new sy(xv);

function Adt(t, e, n) {
    if (fhe()) return Reflect.construct.apply(null, arguments);
    var r = [null];
    r.push.apply(r, e);
    var i = new(t.bind.apply(t, r));
    return n && H6(i, n.prototype), i
}

function fhe() {
    try {
        var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}))
    } catch {}
    return (fhe = function() {
        return !!t
    })()
}

function Tdt(t, e) {
    if (typeof t != "object" || !t) return t;
    var n = t[Symbol.toPrimitive];
    if (n !== void 0) {
        var r = n.call(t, e);
        if (typeof r != "object") return r;
        throw new TypeError("@@toPrimitive must return a primitive value.")
    }
    return String(t)
}

function Idt(t) {
    var e = Tdt(t, "string");
    return typeof e == "symbol" ? e : String(e)
}

function Rdt(t, e) {
    for (var n = 0; n < e.length; n++) {
        var r = e[n];
        r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(t, Idt(r.key), r)
    }
}

function dhe(t, e, n) {
    return e && Rdt(t.prototype, e), Object.defineProperty(t, "prototype", {
        writable: !1
    }), t
}

function hhe(t, e) {
    t.prototype = Object.create(e.prototype), t.prototype.constructor = t, H6(t, e)
}

function l$(t) {
    return l$ = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(n) {
        return n.__proto__ || Object.getPrototypeOf(n)
    }, l$(t)
}

function H6(t, e) {
    return H6 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(r, i) {
        return r.__proto__ = i, r
    }, H6(t, e)
}

function Odt(t) {
    try {
        return Function.toString.call(t).indexOf("[native code]") !== -1
    } catch {
        return typeof t == "function"
    }
}

function ZA(t) {
    var e = typeof Map == "function" ? new Map : void 0;
    return ZA = function(r) {
        if (r === null || !Odt(r)) return r;
        if (typeof r != "function") throw new TypeError("Super expression must either be null or a function");
        if (typeof e < "u") {
            if (e.has(r)) return e.get(r);
            e.set(r, i)
        }

        function i() {
            return Adt(r, arguments, l$(this).constructor)
        }
        return i.prototype = Object.create(r.prototype, {
            constructor: {
                value: i,
                enumerable: !1,
                writable: !0,
                configurable: !0
            }
        }), H6(i, r)
    }, ZA(t)
}

function phe(t) {
    if (t === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return t
}

function Ndt(t, e) {
    if (t) {
        if (typeof t == "string") return RJ(t, e);
        var n = Object.prototype.toString.call(t).slice(8, -1);
        if (n === "Object" && t.constructor && (n = t.constructor.name), n === "Map" || n === "Set") return Array.from(t);
        if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return RJ(t, e)
    }
}

function RJ(t, e) {
    (e == null || e > t.length) && (e = t.length);
    for (var n = 0, r = new Array(e); n < e; n++) r[n] = t[n];
    return r
}

function OJ(t, e) {
    var n = typeof Symbol < "u" && t[Symbol.iterator] || t["@@iterator"];
    if (n) return (n = n.call(t)).next.bind(n);
    if (Array.isArray(t) || (n = Ndt(t)) || e) {
        n && (t = n);
        var r = 0;
        return function() {
            return r >= t.length ? {
                done: !0
            } : {
                done: !1,
                value: t[r++]
            }
        }
    }
    throw new TypeError(`Invalid attempt to iterate non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)
}
var ghe = "setPrototypeOf" in Object,
    NJ = function(t) {
        hhe(e, t);

        function e() {
            var n;
            return n = t.call(this) || this, n.isInsufficientReservesError = !0, n.name = n.constructor.name, ghe && Object.setPrototypeOf(phe(n), (this instanceof e ? this.constructor : void 0).prototype), n
        }
        return e
    }(ZA(Error)),
    AP = function(t) {
        hhe(e, t);

        function e() {
            var n;
            return n = t.call(this) || this, n.isInsufficientInputAmountError = !0, n.name = n.constructor.name, ghe && Object.setPrototypeOf(phe(n), (this instanceof e ? this.constructor : void 0).prototype), n
        }
        return e
    }(ZA(Error)),
    Pdt = function(e) {
        var n = e.factoryAddress,
            r = e.tokenA,
            i = e.tokenB,
            s = r.sortsBefore(i) ? [r, i] : [i, r],
            o = s[0],
            a = s[1];
        return Pft(n, bdt(["bytes"], [uhe(["address", "address"], [o.address, a.address])]), xdt)
    },
    PJ = function() {
        function t(n, r) {
            var i = n.currency.sortsBefore(r.currency) ? [n, r] : [r, n];
            this.liquidityToken = new Ui(i[0].currency.chainId, t.getAddress(i[0].currency, i[1].currency), 18, "UNI-V2", "Uniswap V2"), this.tokenAmounts = i
        }
        t.getAddress = function(r, i) {
            var s, o = (s = Edt[r.chainId]) != null ? s : _dt;
            return Pdt({
                factoryAddress: o,
                tokenA: r,
                tokenB: i
            })
        };
        var e = t.prototype;
        return e.involvesToken = function(r) {
            return r.equals(this.token0) || r.equals(this.token1)
        }, e.priceOf = function(r) {
            return this.involvesToken(r) || fn(), r.equals(this.token0) ? this.token0Price : this.token1Price
        }, e.reserveOf = function(r) {
            return this.involvesToken(r) || fn(), r.equals(this.token0) ? this.reserve0 : this.reserve1
        }, e.getOutputAmount = function(r, i) {
            if (i === void 0 && (i = !0), this.involvesToken(r.currency) || fn(), re.equal(this.reserve0.quotient, Io) || re.equal(this.reserve1.quotient, Io)) throw new NJ;
            var s = this.reserveOf(r.currency),
                o = this.reserveOf(r.currency.equals(this.token0) ? this.token1 : this.token0),
                a = i ? this.derivePercentAfterSellFees(r) : uf,
                l = a.greaterThan(uf) ? bs.fromRawAmount(r.currency, a.multiply(r).quotient) : r,
                c = re.multiply(l.quotient, CJ),
                u = re.multiply(c, o.quotient),
                f = re.add(re.multiply(s.quotient, AJ), c),
                h = bs.fromRawAmount(r.currency.equals(this.token0) ? this.token1 : this.token0, re.divide(u, f));
            if (re.equal(h.quotient, Io)) throw new AP;
            var g = i ? this.derivePercentAfterBuyFees(h) : uf,
                y = g.greaterThan(uf) ? bs.fromRawAmount(h.currency, h.multiply(g).quotient) : h;
            if (re.equal(y.quotient, Io)) throw new AP;
            return [y, new t(s.add(l), o.subtract(y))]
        }, e.getInputAmount = function(r, i) {
            i === void 0 && (i = !0), this.involvesToken(r.currency) || fn();
            var s = i ? this.derivePercentAfterBuyFees(r) : uf,
                o = s.greaterThan(uf) ? bs.fromRawAmount(r.currency, re.add(r.divide(s).quotient, xv)) : r;
            if (re.equal(this.reserve0.quotient, Io) || re.equal(this.reserve1.quotient, Io) || re.greaterThanOrEqual(r.quotient, this.reserveOf(r.currency).quotient) || re.greaterThanOrEqual(o.quotient, this.reserveOf(r.currency).quotient)) throw new NJ;
            var a = this.reserveOf(r.currency),
                l = this.reserveOf(r.currency.equals(this.token0) ? this.token1 : this.token0),
                c = re.multiply(re.multiply(l.quotient, o.quotient), AJ),
                u = re.multiply(re.subtract(a.quotient, o.quotient), CJ),
                f = bs.fromRawAmount(r.currency.equals(this.token0) ? this.token1 : this.token0, re.add(re.divide(c, u), xv)),
                h = i ? this.derivePercentAfterSellFees(f) : uf,
                g = h.greaterThan(uf) ? bs.fromRawAmount(f.currency, re.add(f.divide(h).quotient, xv)) : f;
            return [g, new t(l.add(f), a.subtract(r))]
        }, e.getLiquidityMinted = function(r, i, s) {
            r.currency.equals(this.liquidityToken) || fn();
            var o = i.currency.sortsBefore(s.currency) ? [i, s] : [s, i];
            o[0].currency.equals(this.token0) && o[1].currency.equals(this.token1) || fn();
            var a;
            if (re.equal(r.quotient, Io)) a = re.subtract(CP(re.multiply(o[0].quotient, o[1].quotient)), Sdt);
            else {
                var l = re.divide(re.multiply(o[0].quotient, r.quotient), this.reserve0.quotient),
                    c = re.divide(re.multiply(o[1].quotient, r.quotient), this.reserve1.quotient);
                a = re.lessThanOrEqual(l, c) ? l : c
            }
            if (!re.greaterThan(a, Io)) throw new AP;
            return bs.fromRawAmount(this.liquidityToken, a)
        }, e.getLiquidityValue = function(r, i, s, o, a) {
            o === void 0 && (o = !1), this.involvesToken(r) || fn(), i.currency.equals(this.liquidityToken) || fn(), s.currency.equals(this.liquidityToken) || fn(), re.lessThanOrEqual(s.quotient, i.quotient) || fn();
            var l;
            if (!o) l = i;
            else {
                a || fn();
                var c = re.BigInt(a);
                if (re.equal(c, Io)) l = i;
                else {
                    var u = CP(re.multiply(this.reserve0.quotient, this.reserve1.quotient)),
                        f = CP(c);
                    if (re.greaterThan(u, f)) {
                        var h = re.multiply(i.quotient, re.subtract(u, f)),
                            g = re.add(re.multiply(u, Cdt), f),
                            y = re.divide(h, g);
                        l = i.add(bs.fromRawAmount(this.liquidityToken, y))
                    } else l = i
                }
            }
            return bs.fromRawAmount(r, re.divide(re.multiply(s.quotient, this.reserveOf(r).quotient), l.quotient))
        }, e.derivePercentAfterSellFees = function(r) {
            var i = this.token0.wrapped.equals(r.wrapped.currency) ? this.token0.wrapped.sellFeeBps : this.token1.wrapped.sellFeeBps;
            return i != null && i.gt(Hi.from(0)) ? IJ.subtract(new sy(re.BigInt(i)).divide(TJ)) : uf
        }, e.derivePercentAfterBuyFees = function(r) {
            var i = this.token0.wrapped.equals(r.wrapped.currency) ? this.token0.wrapped.buyFeeBps : this.token1.wrapped.buyFeeBps;
            return i != null && i.gt(Hi.from(0)) ? IJ.subtract(new sy(re.BigInt(i)).divide(TJ)) : uf
        }, dhe(t, [{
            key: "token0Price",
            get: function() {
                var r = this.tokenAmounts[1].divide(this.tokenAmounts[0]);
                return new um(this.token0, this.token1, r.denominator, r.numerator)
            }
        }, {
            key: "token1Price",
            get: function() {
                var r = this.tokenAmounts[0].divide(this.tokenAmounts[1]);
                return new um(this.token1, this.token0, r.denominator, r.numerator)
            }
        }, {
            key: "chainId",
            get: function() {
                return this.token0.chainId
            }
        }, {
            key: "token0",
            get: function() {
                return this.tokenAmounts[0].currency
            }
        }, {
            key: "token1",
            get: function() {
                return this.tokenAmounts[1].currency
            }
        }, {
            key: "reserve0",
            get: function() {
                return this.tokenAmounts[0]
            }
        }, {
            key: "reserve1",
            get: function() {
                return this.tokenAmounts[1]
            }
        }]), t
    }(),
    kJ = function() {
        function t(e, n, r) {
            this._midPrice = null, e.length > 0 || fn();
            var i = e[0].chainId;
            e.every(function(y) {
                return y.chainId === i
            }) || fn();
            var s = n.wrapped;
            e[0].involvesToken(s) || fn(), typeof r > "u" || e[e.length - 1].involvesToken(r.wrapped) || fn();
            for (var o = [s], a = OJ(e.entries()), l; !(l = a()).done;) {
                var c = l.value,
                    u = c[0],
                    f = c[1],
                    h = o[u];
                h.equals(f.token0) || h.equals(f.token1) || fn();
                var g = h.equals(f.token0) ? f.token1 : f.token0;
                o.push(g)
            }
            this.pairs = e, this.path = o, this.input = n, this.output = r
        }
        return dhe(t, [{
            key: "midPrice",
            get: function() {
                if (this._midPrice !== null) return this._midPrice;
                for (var n = [], r = OJ(this.pairs.entries()), i; !(i = r()).done;) {
                    var s = i.value,
                        o = s[0],
                        a = s[1];
                    n.push(this.path[o].equals(a.token0) ? new um(a.reserve0.currency, a.reserve1.currency, a.reserve0.quotient, a.reserve1.quotient) : new um(a.reserve1.currency, a.reserve0.currency, a.reserve1.quotient, a.reserve0.quotient))
                }
                var l = n.slice(1).reduce(function(c, u) {
                    return c.multiply(u)
                }, n[0]);
                return this._midPrice = new um(this.input, this.output, l.denominator, l.numerator)
            }
        }, {
            key: "chainId",
            get: function() {
                return this.pairs[0].chainId
            }
        }]), t
    }();

function kdt(t, e) {
    return t.inputAmount.currency.equals(e.inputAmount.currency) || fn(), t.outputAmount.currency.equals(e.outputAmount.currency) || fn(), t.outputAmount.equalTo(e.outputAmount) ? t.inputAmount.equalTo(e.inputAmount) ? 0 : t.inputAmount.lessThan(e.inputAmount) ? -1 : 1 : t.outputAmount.lessThan(e.outputAmount) ? 1 : -1
}

function MJ(t, e) {
    var n = kdt(t, e);
    return n !== 0 ? n : t.priceImpact.lessThan(e.priceImpact) ? -1 : t.priceImpact.greaterThan(e.priceImpact) ? 1 : t.route.path.length - e.route.path.length
}
var DJ = function() {
    function t(n, r, i) {
        this.route = n, this.tradeType = i;
        var s = new Array(n.path.length);
        if (i === gc.EXACT_INPUT) {
            r.currency.equals(n.input) || fn(), s[0] = r.wrapped;
            for (var o = 0; o < n.path.length - 1; o++) {
                var a = n.pairs[o],
                    l = a.getOutputAmount(s[o]),
                    c = l[0];
                s[o + 1] = c
            }
            this.inputAmount = bs.fromFractionalAmount(n.input, r.numerator, r.denominator), this.outputAmount = bs.fromFractionalAmount(n.output, s[s.length - 1].numerator, s[s.length - 1].denominator)
        } else {
            r.currency.equals(n.output) || fn(), s[s.length - 1] = r.wrapped;
            for (var u = n.path.length - 1; u > 0; u--) {
                var f = n.pairs[u - 1],
                    h = f.getInputAmount(s[u]),
                    g = h[0];
                s[u - 1] = g
            }
            this.inputAmount = bs.fromFractionalAmount(n.input, s[0].numerator, s[0].denominator), this.outputAmount = bs.fromFractionalAmount(n.output, r.numerator, r.denominator)
        }
        this.executionPrice = new um(this.inputAmount.currency, this.outputAmount.currency, this.inputAmount.quotient, this.outputAmount.quotient), this.priceImpact = udt(n.midPrice, this.inputAmount, this.outputAmount)
    }
    t.exactIn = function(r, i) {
        return new t(r, i, gc.EXACT_INPUT)
    }, t.exactOut = function(r, i) {
        return new t(r, i, gc.EXACT_OUTPUT)
    };
    var e = t.prototype;
    return e.minimumAmountOut = function(r) {
        if (r.lessThan(Io) && fn(), this.tradeType === gc.EXACT_OUTPUT) return this.outputAmount;
        var i = new iy(xv).add(r).invert().multiply(this.outputAmount.quotient).quotient;
        return bs.fromRawAmount(this.outputAmount.currency, i)
    }, e.maximumAmountIn = function(r) {
        if (r.lessThan(Io) && fn(), this.tradeType === gc.EXACT_INPUT) return this.inputAmount;
        var i = new iy(xv).add(r).multiply(this.inputAmount.quotient).quotient;
        return bs.fromRawAmount(this.inputAmount.currency, i)
    }, t.bestTradeExactIn = function(r, i, s, o, a, l, c) {
        var u = o === void 0 ? {} : o,
            f = u.maxNumResults,
            h = f === void 0 ? 3 : f,
            g = u.maxHops,
            y = g === void 0 ? 3 : g;
        a === void 0 && (a = []), l === void 0 && (l = i), c === void 0 && (c = []), r.length > 0 || fn(), y > 0 || fn(), i === l || a.length > 0 || fn();
        for (var _ = l.wrapped, C = s.wrapped, b = 0; b < r.length; b++) {
            var w = r[b];
            if (!(!w.token0.equals(_.currency) && !w.token1.equals(_.currency)) && !(w.reserve0.equalTo(Io) || w.reserve1.equalTo(Io))) {
                var S = void 0;
                try {
                    var I = w.getOutputAmount(_);
                    S = I[0]
                } catch (M) {
                    if (M.isInsufficientInputAmountError) continue;
                    throw M
                }
                if (S.currency.equals(C)) xJ(c, new t(new kJ([].concat(a, [w]), i.currency, s), i, gc.EXACT_INPUT), h, MJ);
                else if (y > 1 && r.length > 1) {
                    var P = r.slice(0, b).concat(r.slice(b + 1, r.length));
                    t.bestTradeExactIn(P, i, s, {
                        maxNumResults: h,
                        maxHops: y - 1
                    }, [].concat(a, [w]), S, c)
                }
            }
        }
        return c
    }, e.worstExecutionPrice = function(r) {
        return new um(this.inputAmount.currency, this.outputAmount.currency, this.maximumAmountIn(r).quotient, this.minimumAmountOut(r).quotient)
    }, t.bestTradeExactOut = function(r, i, s, o, a, l, c) {
        var u = o === void 0 ? {} : o,
            f = u.maxNumResults,
            h = f === void 0 ? 3 : f,
            g = u.maxHops,
            y = g === void 0 ? 3 : g;
        a === void 0 && (a = []), l === void 0 && (l = s), c === void 0 && (c = []), r.length > 0 || fn(), y > 0 || fn(), s === l || a.length > 0 || fn();
        for (var _ = l.wrapped, C = i.wrapped, b = 0; b < r.length; b++) {
            var w = r[b];
            if (!(!w.token0.equals(_.currency) && !w.token1.equals(_.currency)) && !(w.reserve0.equalTo(Io) || w.reserve1.equalTo(Io))) {
                var S = void 0;
                try {
                    var I = w.getInputAmount(_);
                    S = I[0]
                } catch (M) {
                    if (M.isInsufficientReservesError) continue;
                    throw M
                }
                if (S.currency.equals(C)) xJ(c, new t(new kJ([w].concat(a), i, s.currency), s, gc.EXACT_OUTPUT), h, MJ);
                else if (y > 1 && r.length > 1) {
                    var P = r.slice(0, b).concat(r.slice(b + 1, r.length));
                    t.bestTradeExactOut(P, i, s, {
                        maxNumResults: h,
                        maxHops: y - 1
                    }, [w].concat(a), S, c)
                }
            }
        }
        return c
    }, t
}();

function Mdt(t, e) {
    for (var n = -1, r = e.length, i = t.length; ++n < r;) t[i + n] = e[n];
    return t
}
var mhe = Mdt,
    Ddt = typeof st == "object" && st && st.Object === Object && st,
    yhe = Ddt,
    $dt = yhe,
    Ldt = typeof self == "object" && self && self.Object === Object && self,
    Bdt = $dt || Ldt || Function("return this")(),
    Kh = Bdt,
    Fdt = Kh,
    Udt = Fdt.Symbol,
    A4 = Udt,
    $J = A4,
    whe = Object.prototype,
    jdt = whe.hasOwnProperty,
    Hdt = whe.toString,
    m3 = $J ? $J.toStringTag : void 0;

function zdt(t) {
    var e = jdt.call(t, m3),
        n = t[m3];
    try {
        t[m3] = void 0;
        var r = !0
    } catch {}
    var i = Hdt.call(t);
    return r && (e ? t[m3] = n : delete t[m3]), i
}
var Wdt = zdt,
    Vdt = Object.prototype,
    Gdt = Vdt.toString;

function qdt(t) {
    return Gdt.call(t)
}
var Kdt = qdt,
    LJ = A4,
    Ydt = Wdt,
    Zdt = Kdt,
    Qdt = "[object Null]",
    Jdt = "[object Undefined]",
    BJ = LJ ? LJ.toStringTag : void 0;

function Xdt(t) {
    return t == null ? t === void 0 ? Jdt : Qdt : BJ && BJ in Object(t) ? Ydt(t) : Zdt(t)
}
var T4 = Xdt;

function eht(t) {
    return t != null && typeof t == "object"
}
var I4 = eht,
    tht = T4,
    nht = I4,
    rht = "[object Arguments]";

function iht(t) {
    return nht(t) && tht(t) == rht
}
var sht = iht,
    FJ = sht,
    oht = I4,
    vhe = Object.prototype,
    aht = vhe.hasOwnProperty,
    lht = vhe.propertyIsEnumerable,
    cht = FJ(function() {
        return arguments
    }()) ? FJ : function(t) {
        return oht(t) && aht.call(t, "callee") && !lht.call(t, "callee")
    },
    QU = cht,
    uht = Array.isArray,
    gd = uht,
    UJ = A4,
    fht = QU,
    dht = gd,
    jJ = UJ ? UJ.isConcatSpreadable : void 0;

function hht(t) {
    return dht(t) || fht(t) || !!(jJ && t && t[jJ])
}
var pht = hht,
    ght = mhe,
    mht = pht;

function bhe(t, e, n, r, i) {
    var s = -1,
        o = t.length;
    for (n || (n = mht), i || (i = []); ++s < o;) {
        var a = t[s];
        e > 0 && n(a) ? e > 1 ? bhe(a, e - 1, n, r, i) : ght(i, a) : r || (i[i.length] = a)
    }
    return i
}
var yht = bhe;

function wht(t, e) {
    for (var n = -1, r = t == null ? 0 : t.length, i = Array(r); ++n < r;) i[n] = e(t[n], n, t);
    return i
}
var _he = wht;

function vht() {
    this.__data__ = [], this.size = 0
}
var bht = vht;

function _ht(t, e) {
    return t === e || t !== t && e !== e
}
var Ehe = _ht,
    Eht = Ehe;

function xht(t, e) {
    for (var n = t.length; n--;)
        if (Eht(t[n][0], e)) return n;
    return -1
}
var aI = xht,
    Sht = aI,
    Cht = Array.prototype,
    Aht = Cht.splice;

function Tht(t) {
    var e = this.__data__,
        n = Sht(e, t);
    if (n < 0) return !1;
    var r = e.length - 1;
    return n == r ? e.pop() : Aht.call(e, n, 1), --this.size, !0
}
var Iht = Tht,
    Rht = aI;

function Oht(t) {
    var e = this.__data__,
        n = Rht(e, t);
    return n < 0 ? void 0 : e[n][1]
}
var Nht = Oht,
    Pht = aI;

function kht(t) {
    return Pht(this.__data__, t) > -1
}
var Mht = kht,
    Dht = aI;

function $ht(t, e) {
    var n = this.__data__,
        r = Dht(n, t);
    return r < 0 ? (++this.size, n.push([t, e])) : n[r][1] = e, this
}
var Lht = $ht,
    Bht = bht,
    Fht = Iht,
    Uht = Nht,
    jht = Mht,
    Hht = Lht;

function a5(t) {
    var e = -1,
        n = t == null ? 0 : t.length;
    for (this.clear(); ++e < n;) {
        var r = t[e];
        this.set(r[0], r[1])
    }
}
a5.prototype.clear = Bht;
a5.prototype.delete = Fht;
a5.prototype.get = Uht;
a5.prototype.has = jht;
a5.prototype.set = Hht;
var lI = a5,
    zht = lI;

function Wht() {
    this.__data__ = new zht, this.size = 0
}
var Vht = Wht;

function Ght(t) {
    var e = this.__data__,
        n = e.delete(t);
    return this.size = e.size, n
}
var qht = Ght;

function Kht(t) {
    return this.__data__.get(t)
}
var Yht = Kht;

function Zht(t) {
    return this.__data__.has(t)
}
var Qht = Zht;

function Jht(t) {
    var e = typeof t;
    return t != null && (e == "object" || e == "function")
}
var JU = Jht,
    Xht = T4,
    e0t = JU,
    t0t = "[object AsyncFunction]",
    n0t = "[object Function]",
    r0t = "[object GeneratorFunction]",
    i0t = "[object Proxy]";

function s0t(t) {
    if (!e0t(t)) return !1;
    var e = Xht(t);
    return e == n0t || e == r0t || e == t0t || e == i0t
}
var xhe = s0t,
    o0t = Kh,
    a0t = o0t["__core-js_shared__"],
    l0t = a0t,
    TP = l0t,
    HJ = function() {
        var t = /[^.]+$/.exec(TP && TP.keys && TP.keys.IE_PROTO || "");
        return t ? "Symbol(src)_1." + t : ""
    }();

function c0t(t) {
    return !!HJ && HJ in t
}
var u0t = c0t,
    f0t = Function.prototype,
    d0t = f0t.toString;

function h0t(t) {
    if (t != null) {
        try {
            return d0t.call(t)
        } catch {}
        try {
            return t + ""
        } catch {}
    }
    return ""
}
var She = h0t,
    p0t = xhe,
    g0t = u0t,
    m0t = JU,
    y0t = She,
    w0t = /[\\^$.*+?()[\]{}|]/g,
    v0t = /^\[object .+?Constructor\]$/,
    b0t = Function.prototype,
    _0t = Object.prototype,
    E0t = b0t.toString,
    x0t = _0t.hasOwnProperty,
    S0t = RegExp("^" + E0t.call(x0t).replace(w0t, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");

function C0t(t) {
    if (!m0t(t) || g0t(t)) return !1;
    var e = p0t(t) ? S0t : v0t;
    return e.test(y0t(t))
}
var A0t = C0t;

function T0t(t, e) {
    return t == null ? void 0 : t[e]
}
var I0t = T0t,
    R0t = A0t,
    O0t = I0t;

function N0t(t, e) {
    var n = O0t(t, e);
    return R0t(n) ? n : void 0
}
var l5 = N0t,
    P0t = l5,
    k0t = Kh,
    M0t = P0t(k0t, "Map"),
    XU = M0t,
    D0t = l5,
    $0t = D0t(Object, "create"),
    cI = $0t,
    zJ = cI;

function L0t() {
    this.__data__ = zJ ? zJ(null) : {}, this.size = 0
}
var B0t = L0t;

function F0t(t) {
    var e = this.has(t) && delete this.__data__[t];
    return this.size -= e ? 1 : 0, e
}
var U0t = F0t,
    j0t = cI,
    H0t = "__lodash_hash_undefined__",
    z0t = Object.prototype,
    W0t = z0t.hasOwnProperty;

function V0t(t) {
    var e = this.__data__;
    if (j0t) {
        var n = e[t];
        return n === H0t ? void 0 : n
    }
    return W0t.call(e, t) ? e[t] : void 0
}
var G0t = V0t,
    q0t = cI,
    K0t = Object.prototype,
    Y0t = K0t.hasOwnProperty;

function Z0t(t) {
    var e = this.__data__;
    return q0t ? e[t] !== void 0 : Y0t.call(e, t)
}
var Q0t = Z0t,
    J0t = cI,
    X0t = "__lodash_hash_undefined__";

function ept(t, e) {
    var n = this.__data__;
    return this.size += this.has(t) ? 0 : 1, n[t] = J0t && e === void 0 ? X0t : e, this
}
var tpt = ept,
    npt = B0t,
    rpt = U0t,
    ipt = G0t,
    spt = Q0t,
    opt = tpt;

function c5(t) {
    var e = -1,
        n = t == null ? 0 : t.length;
    for (this.clear(); ++e < n;) {
        var r = t[e];
        this.set(r[0], r[1])
    }
}
c5.prototype.clear = npt;
c5.prototype.delete = rpt;
c5.prototype.get = ipt;
c5.prototype.has = spt;
c5.prototype.set = opt;
var apt = c5,
    WJ = apt,
    lpt = lI,
    cpt = XU;

function upt() {
    this.size = 0, this.__data__ = {
        hash: new WJ,
        map: new(cpt || lpt),
        string: new WJ
    }
}
var fpt = upt;

function dpt(t) {
    var e = typeof t;
    return e == "string" || e == "number" || e == "symbol" || e == "boolean" ? t !== "__proto__" : t === null
}
var hpt = dpt,
    ppt = hpt;

function gpt(t, e) {
    var n = t.__data__;
    return ppt(e) ? n[typeof e == "string" ? "string" : "hash"] : n.map
}
var uI = gpt,
    mpt = uI;

function ypt(t) {
    var e = mpt(this, t).delete(t);
    return this.size -= e ? 1 : 0, e
}
var wpt = ypt,
    vpt = uI;

function bpt(t) {
    return vpt(this, t).get(t)
}
var _pt = bpt,
    Ept = uI;

function xpt(t) {
    return Ept(this, t).has(t)
}
var Spt = xpt,
    Cpt = uI;

function Apt(t, e) {
    var n = Cpt(this, t),
        r = n.size;
    return n.set(t, e), this.size += n.size == r ? 0 : 1, this
}
var Tpt = Apt,
    Ipt = fpt,
    Rpt = wpt,
    Opt = _pt,
    Npt = Spt,
    Ppt = Tpt;

function u5(t) {
    var e = -1,
        n = t == null ? 0 : t.length;
    for (this.clear(); ++e < n;) {
        var r = t[e];
        this.set(r[0], r[1])
    }
}
u5.prototype.clear = Ipt;
u5.prototype.delete = Rpt;
u5.prototype.get = Opt;
u5.prototype.has = Npt;
u5.prototype.set = Ppt;
var ej = u5,
    kpt = lI,
    Mpt = XU,
    Dpt = ej,
    $pt = 200;

function Lpt(t, e) {
    var n = this.__data__;
    if (n instanceof kpt) {
        var r = n.__data__;
        if (!Mpt || r.length < $pt - 1) return r.push([t, e]), this.size = ++n.size, this;
        n = this.__data__ = new Dpt(r)
    }
    return n.set(t, e), this.size = n.size, this
}
var Bpt = Lpt,
    Fpt = lI,
    Upt = Vht,
    jpt = qht,
    Hpt = Yht,
    zpt = Qht,
    Wpt = Bpt;

function f5(t) {
    var e = this.__data__ = new Fpt(t);
    this.size = e.size
}
f5.prototype.clear = Upt;
f5.prototype.delete = jpt;
f5.prototype.get = Hpt;
f5.prototype.has = zpt;
f5.prototype.set = Wpt;
var Che = f5,
    Vpt = "__lodash_hash_undefined__";

function Gpt(t) {
    return this.__data__.set(t, Vpt), this
}
var qpt = Gpt;

function Kpt(t) {
    return this.__data__.has(t)
}
var Ypt = Kpt,
    Zpt = ej,
    Qpt = qpt,
    Jpt = Ypt;

function QA(t) {
    var e = -1,
        n = t == null ? 0 : t.length;
    for (this.__data__ = new Zpt; ++e < n;) this.add(t[e])
}
QA.prototype.add = QA.prototype.push = Qpt;
QA.prototype.has = Jpt;
var Xpt = QA;

function egt(t, e) {
    for (var n = -1, r = t == null ? 0 : t.length; ++n < r;)
        if (e(t[n], n, t)) return !0;
    return !1
}
var tgt = egt;

function ngt(t, e) {
    return t.has(e)
}
var rgt = ngt,
    igt = Xpt,
    sgt = tgt,
    ogt = rgt,
    agt = 1,
    lgt = 2;

function cgt(t, e, n, r, i, s) {
    var o = n & agt,
        a = t.length,
        l = e.length;
    if (a != l && !(o && l > a)) return !1;
    var c = s.get(t),
        u = s.get(e);
    if (c && u) return c == e && u == t;
    var f = -1,
        h = !0,
        g = n & lgt ? new igt : void 0;
    for (s.set(t, e), s.set(e, t); ++f < a;) {
        var y = t[f],
            _ = e[f];
        if (r) var C = o ? r(_, y, f, e, t, s) : r(y, _, f, t, e, s);
        if (C !== void 0) {
            if (C) continue;
            h = !1;
            break
        }
        if (g) {
            if (!sgt(e, function(b, w) {
                    if (!ogt(g, w) && (y === b || i(y, b, n, r, s))) return g.push(w)
                })) {
                h = !1;
                break
            }
        } else if (!(y === _ || i(y, _, n, r, s))) {
            h = !1;
            break
        }
    }
    return s.delete(t), s.delete(e), h
}
var Ahe = cgt,
    ugt = Kh,
    fgt = ugt.Uint8Array,
    dgt = fgt;

function hgt(t) {
    var e = -1,
        n = Array(t.size);
    return t.forEach(function(r, i) {
        n[++e] = [i, r]
    }), n
}
var pgt = hgt;

function ggt(t) {
    var e = -1,
        n = Array(t.size);
    return t.forEach(function(r) {
        n[++e] = r
    }), n
}
var mgt = ggt,
    VJ = A4,
    GJ = dgt,
    ygt = Ehe,
    wgt = Ahe,
    vgt = pgt,
    bgt = mgt,
    _gt = 1,
    Egt = 2,
    xgt = "[object Boolean]",
    Sgt = "[object Date]",
    Cgt = "[object Error]",
    Agt = "[object Map]",
    Tgt = "[object Number]",
    Igt = "[object RegExp]",
    Rgt = "[object Set]",
    Ogt = "[object String]",
    Ngt = "[object Symbol]",
    Pgt = "[object ArrayBuffer]",
    kgt = "[object DataView]",
    qJ = VJ ? VJ.prototype : void 0,
    IP = qJ ? qJ.valueOf : void 0;

function Mgt(t, e, n, r, i, s, o) {
    switch (n) {
        case kgt:
            if (t.byteLength != e.byteLength || t.byteOffset != e.byteOffset) return !1;
            t = t.buffer, e = e.buffer;
        case Pgt:
            return !(t.byteLength != e.byteLength || !s(new GJ(t), new GJ(e)));
        case xgt:
        case Sgt:
        case Tgt:
            return ygt(+t, +e);
        case Cgt:
            return t.name == e.name && t.message == e.message;
        case Igt:
        case Ogt:
            return t == e + "";
        case Agt:
            var a = vgt;
        case Rgt:
            var l = r & _gt;
            if (a || (a = bgt), t.size != e.size && !l) return !1;
            var c = o.get(t);
            if (c) return c == e;
            r |= Egt, o.set(t, e);
            var u = wgt(a(t), a(e), r, i, s, o);
            return o.delete(t), u;
        case Ngt:
            if (IP) return IP.call(t) == IP.call(e)
    }
    return !1
}
var Dgt = Mgt,
    $gt = mhe,
    Lgt = gd;

function Bgt(t, e, n) {
    var r = e(t);
    return Lgt(t) ? r : $gt(r, n(t))
}
var Fgt = Bgt;

function Ugt(t, e) {
    for (var n = -1, r = t == null ? 0 : t.length, i = 0, s = []; ++n < r;) {
        var o = t[n];
        e(o, n, t) && (s[i++] = o)
    }
    return s
}
var jgt = Ugt;

function Hgt() {
    return []
}
var zgt = Hgt,
    Wgt = jgt,
    Vgt = zgt,
    Ggt = Object.prototype,
    qgt = Ggt.propertyIsEnumerable,
    KJ = Object.getOwnPropertySymbols,
    Kgt = KJ ? function(t) {
        return t == null ? [] : (t = Object(t), Wgt(KJ(t), function(e) {
            return qgt.call(t, e)
        }))
    } : Vgt,
    Ygt = Kgt;

function Zgt(t, e) {
    for (var n = -1, r = Array(t); ++n < t;) r[n] = e(n);
    return r
}
var Qgt = Zgt,
    JA = {
        exports: {}
    };

function Jgt() {
    return !1
}
var Xgt = Jgt;
JA.exports;
(function(t, e) {
    var n = Kh,
        r = Xgt,
        i = e && !e.nodeType && e,
        s = i && !0 && t && !t.nodeType && t,
        o = s && s.exports === i,
        a = o ? n.Buffer : void 0,
        l = a ? a.isBuffer : void 0,
        c = l || r;
    t.exports = c
})(JA, JA.exports);
var The = JA.exports,
    e1t = 9007199254740991,
    t1t = /^(?:0|[1-9]\d*)$/;

function n1t(t, e) {
    var n = typeof t;
    return e = e ? ? e1t, !!e && (n == "number" || n != "symbol" && t1t.test(t)) && t > -1 && t % 1 == 0 && t < e
}
var Ihe = n1t,
    r1t = 9007199254740991;

function i1t(t) {
    return typeof t == "number" && t > -1 && t % 1 == 0 && t <= r1t
}
var tj = i1t,
    s1t = T4,
    o1t = tj,
    a1t = I4,
    l1t = "[object Arguments]",
    c1t = "[object Array]",
    u1t = "[object Boolean]",
    f1t = "[object Date]",
    d1t = "[object Error]",
    h1t = "[object Function]",
    p1t = "[object Map]",
    g1t = "[object Number]",
    m1t = "[object Object]",
    y1t = "[object RegExp]",
    w1t = "[object Set]",
    v1t = "[object String]",
    b1t = "[object WeakMap]",
    _1t = "[object ArrayBuffer]",
    E1t = "[object DataView]",
    x1t = "[object Float32Array]",
    S1t = "[object Float64Array]",
    C1t = "[object Int8Array]",
    A1t = "[object Int16Array]",
    T1t = "[object Int32Array]",
    I1t = "[object Uint8Array]",
    R1t = "[object Uint8ClampedArray]",
    O1t = "[object Uint16Array]",
    N1t = "[object Uint32Array]",
    ri = {};
ri[x1t] = ri[S1t] = ri[C1t] = ri[A1t] = ri[T1t] = ri[I1t] = ri[R1t] = ri[O1t] = ri[N1t] = !0;
ri[l1t] = ri[c1t] = ri[_1t] = ri[u1t] = ri[E1t] = ri[f1t] = ri[d1t] = ri[h1t] = ri[p1t] = ri[g1t] = ri[m1t] = ri[y1t] = ri[w1t] = ri[v1t] = ri[b1t] = !1;

function P1t(t) {
    return a1t(t) && o1t(t.length) && !!ri[s1t(t)]
}
var k1t = P1t;

function M1t(t) {
    return function(e) {
        return t(e)
    }
}
var D1t = M1t,
    XA = {
        exports: {}
    };
XA.exports;
(function(t, e) {
    var n = yhe,
        r = e && !e.nodeType && e,
        i = r && !0 && t && !t.nodeType && t,
        s = i && i.exports === r,
        o = s && n.process,
        a = function() {
            try {
                var l = i && i.require && i.require("util").types;
                return l || o && o.binding && o.binding("util")
            } catch {}
        }();
    t.exports = a
})(XA, XA.exports);
var $1t = XA.exports,
    L1t = k1t,
    B1t = D1t,
    YJ = $1t,
    ZJ = YJ && YJ.isTypedArray,
    F1t = ZJ ? B1t(ZJ) : L1t,
    Rhe = F1t,
    U1t = Qgt,
    j1t = QU,
    H1t = gd,
    z1t = The,
    W1t = Ihe,
    V1t = Rhe,
    G1t = Object.prototype,
    q1t = G1t.hasOwnProperty;

function K1t(t, e) {
    var n = H1t(t),
        r = !n && j1t(t),
        i = !n && !r && z1t(t),
        s = !n && !r && !i && V1t(t),
        o = n || r || i || s,
        a = o ? U1t(t.length, String) : [],
        l = a.length;
    for (var c in t)(e || q1t.call(t, c)) && !(o && (c == "length" || i && (c == "offset" || c == "parent") || s && (c == "buffer" || c == "byteLength" || c == "byteOffset") || W1t(c, l))) && a.push(c);
    return a
}
var Y1t = K1t,
    Z1t = Object.prototype;

function Q1t(t) {
    var e = t && t.constructor,
        n = typeof e == "function" && e.prototype || Z1t;
    return t === n
}
var J1t = Q1t;

function X1t(t, e) {
    return function(n) {
        return t(e(n))
    }
}
var emt = X1t,
    tmt = emt,
    nmt = tmt(Object.keys, Object),
    rmt = nmt,
    imt = J1t,
    smt = rmt,
    omt = Object.prototype,
    amt = omt.hasOwnProperty;

function lmt(t) {
    if (!imt(t)) return smt(t);
    var e = [];
    for (var n in Object(t)) amt.call(t, n) && n != "constructor" && e.push(n);
    return e
}
var cmt = lmt,
    umt = xhe,
    fmt = tj;

function dmt(t) {
    return t != null && fmt(t.length) && !umt(t)
}
var nj = dmt,
    hmt = Y1t,
    pmt = cmt,
    gmt = nj;

function mmt(t) {
    return gmt(t) ? hmt(t) : pmt(t)
}
var rj = mmt,
    ymt = Fgt,
    wmt = Ygt,
    vmt = rj;

function bmt(t) {
    return ymt(t, vmt, wmt)
}
var _mt = bmt,
    QJ = _mt,
    Emt = 1,
    xmt = Object.prototype,
    Smt = xmt.hasOwnProperty;

function Cmt(t, e, n, r, i, s) {
    var o = n & Emt,
        a = QJ(t),
        l = a.length,
        c = QJ(e),
        u = c.length;
    if (l != u && !o) return !1;
    for (var f = l; f--;) {
        var h = a[f];
        if (!(o ? h in e : Smt.call(e, h))) return !1
    }
    var g = s.get(t),
        y = s.get(e);
    if (g && y) return g == e && y == t;
    var _ = !0;
    s.set(t, e), s.set(e, t);
    for (var C = o; ++f < l;) {
        h = a[f];
        var b = t[h],
            w = e[h];
        if (r) var S = o ? r(w, b, h, e, t, s) : r(b, w, h, t, e, s);
        if (!(S === void 0 ? b === w || i(b, w, n, r, s) : S)) {
            _ = !1;
            break
        }
        C || (C = h == "constructor")
    }
    if (_ && !C) {
        var I = t.constructor,
            P = e.constructor;
        I != P && "constructor" in t && "constructor" in e && !(typeof I == "function" && I instanceof I && typeof P == "function" && P instanceof P) && (_ = !1)
    }
    return s.delete(t), s.delete(e), _
}
var Amt = Cmt,
    Tmt = l5,
    Imt = Kh,
    Rmt = Tmt(Imt, "DataView"),
    Omt = Rmt,
    Nmt = l5,
    Pmt = Kh,
    kmt = Nmt(Pmt, "Promise"),
    Mmt = kmt,
    Dmt = l5,
    $mt = Kh,
    Lmt = Dmt($mt, "Set"),
    Bmt = Lmt,
    Fmt = l5,
    Umt = Kh,
    jmt = Fmt(Umt, "WeakMap"),
    Hmt = jmt,
    c$ = Omt,
    u$ = XU,
    f$ = Mmt,
    d$ = Bmt,
    h$ = Hmt,
    Ohe = T4,
    d5 = She,
    JJ = "[object Map]",
    zmt = "[object Object]",
    XJ = "[object Promise]",
    eX = "[object Set]",
    tX = "[object WeakMap]",
    nX = "[object DataView]",
    Wmt = d5(c$),
    Vmt = d5(u$),
    Gmt = d5(f$),
    qmt = d5(d$),
    Kmt = d5(h$),
    Yg = Ohe;
(c$ && Yg(new c$(new ArrayBuffer(1))) != nX || u$ && Yg(new u$) != JJ || f$ && Yg(f$.resolve()) != XJ || d$ && Yg(new d$) != eX || h$ && Yg(new h$) != tX) && (Yg = function(t) {
    var e = Ohe(t),
        n = e == zmt ? t.constructor : void 0,
        r = n ? d5(n) : "";
    if (r) switch (r) {
        case Wmt:
            return nX;
        case Vmt:
            return JJ;
        case Gmt:
            return XJ;
        case qmt:
            return eX;
        case Kmt:
            return tX
    }
    return e
});
var Ymt = Yg,
    RP = Che,
    Zmt = Ahe,
    Qmt = Dgt,
    Jmt = Amt,
    rX = Ymt,
    iX = gd,
    sX = The,
    Xmt = Rhe,
    eyt = 1,
    oX = "[object Arguments]",
    aX = "[object Array]",
    WS = "[object Object]",
    tyt = Object.prototype,
    lX = tyt.hasOwnProperty;

function nyt(t, e, n, r, i, s) {
    var o = iX(t),
        a = iX(e),
        l = o ? aX : rX(t),
        c = a ? aX : rX(e);
    l = l == oX ? WS : l, c = c == oX ? WS : c;
    var u = l == WS,
        f = c == WS,
        h = l == c;
    if (h && sX(t)) {
        if (!sX(e)) return !1;
        o = !0, u = !1
    }
    if (h && !u) return s || (s = new RP), o || Xmt(t) ? Zmt(t, e, n, r, i, s) : Qmt(t, e, l, n, r, i, s);
    if (!(n & eyt)) {
        var g = u && lX.call(t, "__wrapped__"),
            y = f && lX.call(e, "__wrapped__");
        if (g || y) {
            var _ = g ? t.value() : t,
                C = y ? e.value() : e;
            return s || (s = new RP), i(_, C, n, r, s)
        }
    }
    return h ? (s || (s = new RP), Jmt(t, e, n, r, i, s)) : !1
}
var ryt = nyt,
    iyt = ryt,
    cX = I4;

function Nhe(t, e, n, r, i) {
    return t === e ? !0 : t == null || e == null || !cX(t) && !cX(e) ? t !== t && e !== e : iyt(t, e, n, r, Nhe, i)
}
var Phe = Nhe,
    syt = Che,
    oyt = Phe,
    ayt = 1,
    lyt = 2;

function cyt(t, e, n, r) {
    var i = n.length,
        s = i,
        o = !r;
    if (t == null) return !s;
    for (t = Object(t); i--;) {
        var a = n[i];
        if (o && a[2] ? a[1] !== t[a[0]] : !(a[0] in t)) return !1
    }
    for (; ++i < s;) {
        a = n[i];
        var l = a[0],
            c = t[l],
            u = a[1];
        if (o && a[2]) {
            if (c === void 0 && !(l in t)) return !1
        } else {
            var f = new syt;
            if (r) var h = r(c, u, l, t, e, f);
            if (!(h === void 0 ? oyt(u, c, ayt | lyt, r, f) : h)) return !1
        }
    }
    return !0
}
var uyt = cyt,
    fyt = JU;

function dyt(t) {
    return t === t && !fyt(t)
}
var khe = dyt,
    hyt = khe,
    pyt = rj;

function gyt(t) {
    for (var e = pyt(t), n = e.length; n--;) {
        var r = e[n],
            i = t[r];
        e[n] = [r, i, hyt(i)]
    }
    return e
}
var myt = gyt;

function yyt(t, e) {
    return function(n) {
        return n == null ? !1 : n[t] === e && (e !== void 0 || t in Object(n))
    }
}
var Mhe = yyt,
    wyt = uyt,
    vyt = myt,
    byt = Mhe;

function _yt(t) {
    var e = vyt(t);
    return e.length == 1 && e[0][2] ? byt(e[0][0], e[0][1]) : function(n) {
        return n === t || wyt(n, t, e)
    }
}
var Eyt = _yt,
    xyt = T4,
    Syt = I4,
    Cyt = "[object Symbol]";

function Ayt(t) {
    return typeof t == "symbol" || Syt(t) && xyt(t) == Cyt
}
var ij = Ayt,
    Tyt = gd,
    Iyt = ij,
    Ryt = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
    Oyt = /^\w*$/;

function Nyt(t, e) {
    if (Tyt(t)) return !1;
    var n = typeof t;
    return n == "number" || n == "symbol" || n == "boolean" || t == null || Iyt(t) ? !0 : Oyt.test(t) || !Ryt.test(t) || e != null && t in Object(e)
}
var sj = Nyt,
    Dhe = ej,
    Pyt = "Expected a function";

function oj(t, e) {
    if (typeof t != "function" || e != null && typeof e != "function") throw new TypeError(Pyt);
    var n = function() {
        var r = arguments,
            i = e ? e.apply(this, r) : r[0],
            s = n.cache;
        if (s.has(i)) return s.get(i);
        var o = t.apply(this, r);
        return n.cache = s.set(i, o) || s, o
    };
    return n.cache = new(oj.Cache || Dhe), n
}
oj.Cache = Dhe;
var kyt = oj,
    Myt = kyt,
    Dyt = 500;

function $yt(t) {
    var e = Myt(t, function(r) {
            return n.size === Dyt && n.clear(), r
        }),
        n = e.cache;
    return e
}
var Lyt = $yt,
    Byt = Lyt,
    Fyt = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g,
    Uyt = /\\(\\)?/g,
    jyt = Byt(function(t) {
        var e = [];
        return t.charCodeAt(0) === 46 && e.push(""), t.replace(Fyt, function(n, r, i, s) {
            e.push(i ? s.replace(Uyt, "$1") : r || n)
        }), e
    }),
    Hyt = jyt,
    uX = A4,
    zyt = _he,
    Wyt = gd,
    Vyt = ij,
    Gyt = 1 / 0,
    fX = uX ? uX.prototype : void 0,
    dX = fX ? fX.toString : void 0;

function $he(t) {
    if (typeof t == "string") return t;
    if (Wyt(t)) return zyt(t, $he) + "";
    if (Vyt(t)) return dX ? dX.call(t) : "";
    var e = t + "";
    return e == "0" && 1 / t == -Gyt ? "-0" : e
}
var qyt = $he,
    Kyt = qyt;

function Yyt(t) {
    return t == null ? "" : Kyt(t)
}
var Zyt = Yyt,
    Qyt = gd,
    Jyt = sj,
    Xyt = Hyt,
    ewt = Zyt;

function twt(t, e) {
    return Qyt(t) ? t : Jyt(t, e) ? [t] : Xyt(ewt(t))
}
var Lhe = twt,
    nwt = ij,
    rwt = 1 / 0;

function iwt(t) {
    if (typeof t == "string" || nwt(t)) return t;
    var e = t + "";
    return e == "0" && 1 / t == -rwt ? "-0" : e
}
var fI = iwt,
    swt = Lhe,
    owt = fI;

function awt(t, e) {
    e = swt(e, t);
    for (var n = 0, r = e.length; t != null && n < r;) t = t[owt(e[n++])];
    return n && n == r ? t : void 0
}
var Bhe = awt,
    lwt = Bhe;

function cwt(t, e, n) {
    var r = t == null ? void 0 : lwt(t, e);
    return r === void 0 ? n : r
}
var uwt = cwt;

function fwt(t, e) {
    return t != null && e in Object(t)
}
var dwt = fwt,
    hwt = Lhe,
    pwt = QU,
    gwt = gd,
    mwt = Ihe,
    ywt = tj,
    wwt = fI;

function vwt(t, e, n) {
    e = hwt(e, t);
    for (var r = -1, i = e.length, s = !1; ++r < i;) {
        var o = wwt(e[r]);
        if (!(s = t != null && n(t, o))) break;
        t = t[o]
    }
    return s || ++r != i ? s : (i = t == null ? 0 : t.length, !!i && ywt(i) && mwt(o, i) && (gwt(t) || pwt(t)))
}
var bwt = vwt,
    _wt = dwt,
    Ewt = bwt;

function xwt(t, e) {
    return t != null && Ewt(t, e, _wt)
}
var Swt = xwt,
    Cwt = Phe,
    Awt = uwt,
    Twt = Swt,
    Iwt = sj,
    Rwt = khe,
    Owt = Mhe,
    Nwt = fI,
    Pwt = 1,
    kwt = 2;

function Mwt(t, e) {
    return Iwt(t) && Rwt(e) ? Owt(Nwt(t), e) : function(n) {
        var r = Awt(n, t);
        return r === void 0 && r === e ? Twt(n, t) : Cwt(e, r, Pwt | kwt)
    }
}
var Dwt = Mwt;

function $wt(t) {
    return t
}
var Lwt = $wt;

function Bwt(t) {
    return function(e) {
        return e == null ? void 0 : e[t]
    }
}
var Fwt = Bwt,
    Uwt = Bhe;

function jwt(t) {
    return function(e) {
        return Uwt(e, t)
    }
}
var Hwt = jwt,
    zwt = Fwt,
    Wwt = Hwt,
    Vwt = sj,
    Gwt = fI;

function qwt(t) {
    return Vwt(t) ? zwt(Gwt(t)) : Wwt(t)
}
var Kwt = qwt,
    Ywt = Eyt,
    Zwt = Dwt,
    Qwt = Lwt,
    Jwt = gd,
    Xwt = Kwt;

function evt(t) {
    return typeof t == "function" ? t : t == null ? Qwt : typeof t == "object" ? Jwt(t) ? Zwt(t[0], t[1]) : Ywt(t) : Xwt(t)
}
var tvt = evt;

function nvt(t) {
    return function(e, n, r) {
        for (var i = -1, s = Object(e), o = r(e), a = o.length; a--;) {
            var l = o[t ? a : ++i];
            if (n(s[l], l, s) === !1) break
        }
        return e
    }
}
var rvt = nvt,
    ivt = rvt,
    svt = ivt(),
    ovt = svt,
    avt = ovt,
    lvt = rj;

function cvt(t, e) {
    return t && avt(t, e, lvt)
}
var uvt = cvt,
    fvt = nj;

function dvt(t, e) {
    return function(n, r) {
        if (n == null) return n;
        if (!fvt(n)) return t(n, r);
        for (var i = n.length, s = e ? i : -1, o = Object(n);
            (e ? s-- : ++s < i) && r(o[s], s, o) !== !1;);
        return n
    }
}
var hvt = dvt,
    pvt = uvt,
    gvt = hvt,
    mvt = gvt(pvt),
    yvt = mvt,
    wvt = yvt,
    vvt = nj;

function bvt(t, e) {
    var n = -1,
        r = vvt(t) ? Array(t.length) : [];
    return wvt(t, function(i, s, o) {
        r[++n] = e(i, s, o)
    }), r
}
var _vt = bvt,
    Evt = _he,
    xvt = tvt,
    Svt = _vt,
    Cvt = gd;

function Avt(t, e) {
    var n = Cvt(t) ? Evt : Svt;
    return n(t, xvt(e))
}
var Tvt = Avt,
    Ivt = yht,
    Rvt = Tvt;

function Ovt(t, e) {
    return Ivt(Rvt(t, e), 1)
}
var Nvt = Ovt;
const Pvt = co(Nvt),
    Sv = Ml("utils:uniswap"),
    kvt = (t, e) => {
        if (!t || !e) return [];
        const n = [x2[it.MAINNET], new Ui(it.MAINNET, "0x6B175474E89094C44Da98b954EedeAC495271d0F", 18, "DAI"), new Ui(it.MAINNET, "0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48", 6, "USDC"), new Ui(it.MAINNET, "0xdac17f958d2ee523a2206206994597c13d831ec7", 6, "USDT")];
        Sv("bases", n);
        const r = Pvt(n, s => n.map(o => [s, o])).filter(([s, o]) => s.address !== o.address);
        Sv("basePairs", r);
        const i = [
            [t, e], ...n.map(s => [t, s]), ...n.map(s => [e, s]), ...r
        ].filter(s => !!(s[0] && s[1])).filter(([s, o]) => s.address !== o.address);
        return Sv("allPairCombinations", i), i
    };
async function Mvt(t, e, n) {
    const r = PJ.getAddress(t, e),
        i = new Qr(r, Zst, n);
    let s;
    try {
        s = await i.getReserves()
    } catch {
        s = null
    }
    if (!s) return null;
    const [o, a] = s;
    Sv("reserves", s);
    const l = [t, e],
        [c, u] = l[0].sortsBefore(l[1]) ? l : [l[1], l[0]];
    return new PJ(bs.fromRawAmount(c, o.toString()), bs.fromRawAmount(u, a.toString()))
}
const y3 = {},
    Dvt = x2[it.MAINNET].address,
    $vt = 1e4;
async function hX(t, e, n) {
    var l, c;
    const r = "0x19C97dc2a25845C7f9d1d519c8C2d4809c58b43f",
        i = new Qr(r, Qst, n),
        s = [];
    t && y3[t] === void 0 && !zf(t) && !ey(x2[1].address, t) && s.push(t), e && y3[e] === void 0 && !zf(e) && !ey(x2[1].address, e) && s.push(e), Sv("getSwapTaxes addresses", s);
    try {
        if (s.length) {
            const u = await i.batchValidate.staticCall(s, Dvt, $vt);
            s.forEach((f, h) => {
                const [g, y] = u[h];
                Sv("getSwapTaxes contract call result data", {
                    sellFeeBps: g,
                    buyFeeBps: y
                }), y3[f] = {
                    sellFeeBps: g,
                    buyFeeBps: y
                }
            })
        }
    } catch (u) {
        console.warn("Failed to get swap taxes for token(s):", s, u)
    }
    const o = (t ? (l = y3[t]) == null ? void 0 : l.sellFeeBps : 0 n) ? ? 0 n,
        a = (e ? (c = y3[e]) == null ? void 0 : c.buyFeeBps : 0 n) ? ? 0 n;
    return {
        sellFeeBps: o,
        buyFeeBps: a
    }
}
const y0 = Ml("hooks:useUniswapTrade"),
    Lvt = (t, e, n, r, i) => {
        const [s, o] = ae.useState([]), [a, l] = ae.useState(null), [c, u] = ae.useState(null), [{
            appRpcProvider: f
        }] = Uo();
        ae.useEffect(() => {
            if (!t) return u(null);
            hX(t.address, void 0, f).then(({
                sellFeeBps: _,
                buyFeeBps: C
            }) => {
                if (y0("tokenIn taxes", {
                        buyFeeBps: C,
                        sellFeeBps: _
                    }), zf(t.address)) {
                    const b = x2[1];
                    u(b), y0("setTokenIn", b);
                    return
                }
                u(new Ui(1, t.address, t.decimals, t.symbol, t.name, void 0, Hi.from(C), Hi.from(_)))
            })
        }, [t]), ae.useEffect(() => {
            if (!e) return l(null);
            hX(void 0, e.address, f).then(({
                sellFeeBps: _,
                buyFeeBps: C
            }) => {
                if (y0("tokenOut taxes", {
                        buyFeeBps: C,
                        sellFeeBps: _
                    }), zf(e.address)) {
                    const b = lhe.onChain(1).wrapped;
                    l(b), y0("setTokenOut", b);
                    return
                }
                l(new Ui(1, e.address, e.decimals, e.symbol, e.name, void 0, Hi.from(C), Hi.from(_)))
            })
        }, [e]), ae.useEffect(() => {
            y(kvt(c, a))
        }, [c, a]);
        const h = ae.useMemo(() => {
                if (s.length === 0 || !i || !n) return null;
                const _ = DJ.bestTradeExactIn(s, bs.fromRawAmount(c, Is(n, c.decimals)), a, {
                    maxHops: 3,
                    maxNumResults: 1
                });
                return y0("tradeExactIn", _[0]), _[0]
            }, [s, i, n]),
            g = ae.useMemo(() => {
                if (s.length === 0 || i || !r) return null;
                const _ = DJ.bestTradeExactOut(s, c, bs.fromRawAmount(a, Is(r, a.decimals)), {
                    maxHops: 3,
                    maxNumResults: 1
                });
                return y0("tradeExactOut", _[0]), _[0]
            }, [s, i, r]),
            y = async _ => {
                y0("pairsAsTokens", _);
                const C = [],
                    b = (await Promise.all(_.map(([w, S]) => Mvt(w, S, f)))).filter(Boolean).filter(w => C.includes(w.liquidityToken.address) ? !1 : (C.push(w.liquidityToken.address), !0));
                y0("pairs", b), o(b)
            };
        return {
            tradeExactIn: h,
            tradeExactOut: g
        }
    },
    Bvt = t => new Promise(e => {
        setTimeout(() => e(null), t)
    }),
    Fvt = (t, e) => Promise.race([e, Bvt(t)]),
    Uvt = async () => (await Dr.get("https://raw.githubusercontent.com/trustwallet/assets/master/blockchains/ethereum/tokenlist.json")).data.tokens.map(n => ({ ...n,
        image: n.logoURI,
        balance: {
            raw: "0",
            formatted: "0",
            fullPrecision: "0"
        }
    })),
    p$ = {
        asset: "",
        chainId: 1,
        image: "/images/ic-eth.svg",
        logoURI: "/images/ic-eth.svg",
        type: "",
        ...pdt,
        balance: {
            raw: "0",
            formatted: "0",
            fullPrecision: "0"
        }
    },
    E0 = {
        tokens: [p$],
        setTokens: () => {},
        fetchingTokens: !0,
        token0: p$,
        token1: null,
        token0Amount: "",
        token1Amount: "",
        trade: null,
        tradeType: gc.EXACT_INPUT,
        swapError: "",
        onTokenSelect: () => {},
        setToken0Amount: () => {},
        setToken1Amount: () => {},
        setTradeType: () => {},
        onReverseTokens: () => {},
        fetchWalletBalances: () => {},
        tryToFetchCustomToken: () => Promise.resolve(null),
        onSwap: () => {}
    },
    Fhe = ae.createContext(E0),
    zg = Ml("providers:SwapProvider"),
    w3 = new sy("300", "10000"),
    jvt = ({
        children: t
    }) => {
        const [{
            chainConfig: e,
            appRpcProvider: n
        }] = Uo(), {
            address: r
        } = xs(), {
            walletProvider: i
        } = fg(), {
            open: s
        } = WL(), o = va(), {
            trackTx: a,
            trackError: l
        } = Ny(), [c, u] = ae.useState(E0.tokens), [f, h] = ae.useState(E0.token0), [g, y] = ae.useState(E0.token1), [_, C] = ae.useState(E0.token0Amount), [b, w] = ae.useState(E0.token1Amount), [S, I] = ae.useState(E0.fetchingTokens), [P, M] = ae.useState(E0.tradeType), {
            tradeExactIn: A,
            tradeExactOut: E
        } = Lvt(f, g, _, b, P === gc.EXACT_INPUT), [$, H] = Zfe(f.address, r, "0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D"), K = Qfe(f.address, "0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D", "Approving"), te = !zf(f.address) && ur($).lt(Is(_, f.decimals));
        ae.useEffect(() => {
            b || C("")
        }, [b]), ae.useEffect(() => {
            _ || w("")
        }, [_]), ae.useEffect(() => {
            A && w(A.outputAmount.toExact()), E && C(E.inputAmount.toExact())
        }, [A, E]), ae.useEffect(() => {
            v()
        }, []), ae.useEffect(() => {
            if (!S) {
                if (!r) {
                    N();
                    return
                }
                T()
            }
        }, [r, S]);
        const U = ae.useMemo(() => {
                const j = `Insufficient ${f==null?void 0:f.symbol} balance`;
                return f ? ur(_).gt(f.balance.fullPrecision) ? j : "" : "Select token for sell"
            }, [c, f, _]),
            m = async j => {
                if (S) return Fvt(300, m(j));
                zg("tryToFetchCustomToken", j);
                const R = c.find(Y => ey(j, Y.address));
                if (R) return R;
                try {
                    const Y = (await HA(e, n, [j], r))[0];
                    return Y ? (u(ve => [...ve, Y]), Y) : null
                } catch (Y) {
                    return console.error(Y), null
                }
            },
            v = async () => {
                let j = await Uvt();
                j.unshift(p$);
                const R = await HA(e, n, j.map(Y => Y.address), r);
                j = j.map((Y, ve) => ({ ...R[ve],
                    ...Y,
                    balance: R[ve].balance
                })), u([...j].sort((Y, ve) => ur(Y.balance.raw).gt(ve.balance.raw) ? -1 : ur(Y.balance.raw).lt(ve.balance.raw) ? 1 : 0)), h(j[0]), I(!1)
            },
            T = async () => {
                const j = new _U(e.id, n),
                    R = c.map(Y => new K7(Y.address, Xm).balanceOf(r));
                try {
                    const [Y, ve] = await Promise.all([j.tryAll(R), n.getBalance(r)]);
                    u(V => V.map((X, q) => {
                        var ie;
                        const ne = zf(X.address) ? ve.toString() : (ie = Y[q]) == null ? void 0 : ie.toString();
                        return X.balance = {
                            raw: ne || "0",
                            formatted: Os(ne || 0, {
                                decimals: X.decimals
                            }),
                            fullPrecision: Os(ne || 0, {
                                decimals: X.decimals,
                                cut: !1
                            })
                        }, X
                    }).sort((X, q) => ur(X.balance.fullPrecision).gt(q.balance.fullPrecision) ? -1 : ur(X.balance.fullPrecision).lt(q.balance.fullPrecision) ? 1 : 0))
                } catch (Y) {
                    console.error(Y)
                }
            },
            N = () => {
                u(j => j.map(R => (R.balance = {
                    raw: "0",
                    formatted: "0",
                    fullPrecision: "0"
                }, R)))
            },
            O = (j, R) => {
                j === "token0" && R ? h(R) : j === "token1" && y(R)
            },
            L = () => {
                const j = g ? JSON.parse(JSON.stringify(g)) : void 0,
                    R = f ? JSON.parse(JSON.stringify(f)) : void 0;
                h(j), y(R)
            },
            G = Qm(async () => {
                var me, Re;
                if (zg("handleSwap fired", {
                        address: r,
                        walletProvider: i,
                        token1: g
                    }), r || s(), !i || !g) return;
                const j = A || E;
                if (!j) return;
                te && (await K(G7), await H());
                let R, Y, ve;
                const V = zf(f.address),
                    X = zf(g.address),
                    q = P === gc.EXACT_INPUT,
                    ne = ((me = j.inputAmount.currency.sellFeeBps) == null ? void 0 : me.gt(0)) || ((Re = j.outputAmount.currency.buyFeeBps) == null ? void 0 : Re.gt(0));
                zg("trade", j), zg("isNativeTrade", V), zg("isExactIn", q);
                const ie = new vh(new Kf(i), r),
                    k = new Qr("0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D", Jst, ie),
                    z = j.route.path.map(He => He.address),
                    Z = r,
                    ge = Math.floor(Date.now() / 1e3) + 60 * 20;
                if (V) {
                    const He = Is(j.inputAmount.toExact());
                    let Be;
                    q ? (Be = Is(j.minimumAmountOut(w3).toExact(), j.outputAmount.currency.decimals), Y = ne ? "swapExactETHForTokensSupportingFeeOnTransferTokens" : "swapExactETHForTokens") : (Be = Is(j.outputAmount.toExact(), j.outputAmount.currency.decimals), Y = "swapETHForExactTokens"), ve = [Be, z, Z, ge, {
                        value: He
                    }]
                } else if (X)
                    if (q) {
                        const He = Is(j.inputAmount.toExact(), j.inputAmount.currency.decimals),
                            Be = Is(j.minimumAmountOut(w3).toExact());
                        Y = ne ? "swapExactTokensForETHSupportingFeeOnTransferTokens" : "swapExactTokensForETH", ve = [He, Be, z, Z, ge]
                    } else {
                        const He = Is(j.maximumAmountIn(w3).toExact(), j.inputAmount.currency.decimals),
                            Be = Is(j.outputAmount.toExact());
                        Y = "swapTokensForExactETH", ve = [Be, He, z, Z, ge]
                    }
                else if (q) {
                    const He = Is(j.inputAmount.toExact(), j.inputAmount.currency.decimals),
                        Be = Is(j.minimumAmountOut(w3).toExact(), j.outputAmount.currency.decimals);
                    Y = ne ? "swapExactTokensForTokensSupportingFeeOnTransferTokens" : "swapExactTokensForTokens", ve = [He, Be, z, Z, ge]
                } else {
                    const He = Is(j.maximumAmountIn(w3).toExact(), j.inputAmount.currency.decimals),
                        Be = Is(j.outputAmount.toExact(), j.outputAmount.currency.decimals);
                    Y = "swapTokensForExactTokens", ve = [Be, He, z, Z, ge]
                }
                try {
                    o({
                        modalKey: "loader",
                        title: "Confirm your transaction in the wallet"
                    }), zg("Swap methodName", Y), zg("Swap callParams", ve), R = await k[Y](...ve), o({
                        modalKey: "loader",
                        title: "Swap in process...",
                        txHash: R.hash
                    }), a(R), await R.wait(), await T(), o(null)
                } catch (He) {
                    throw l(He, R), o(null), console.error("payment failed", He), He
                }
            });
        return J.jsx(Fhe.Provider, {
            value: {
                tokens: c,
                setTokens: u,
                fetchingTokens: S,
                token0: f,
                token1: g,
                trade: A || E,
                token0Amount: _,
                token1Amount: b,
                tradeType: P,
                setToken0Amount: C,
                setToken1Amount: w,
                setTradeType: M,
                onTokenSelect: O,
                onReverseTokens: L,
                onSwap: G,
                tryToFetchCustomToken: m,
                fetchWalletBalances: T,
                swapError: U
            },
            children: t
        })
    },
    A3t = () => ae.useContext(Fhe),
    Hvt = t => ae.createElement("svg", {
        width: 117,
        height: 32,
        viewBox: "0 0 117 32",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg",
        ...t
    }, ae.createElement("path", {
        d: "M80.0972 32H65.8775C65.2012 32 64.8652 31.1799 65.3471 30.7055L79.6136 16.6585C79.9127 16.364 79.9145 15.8822 79.6177 15.5854L65.3228 1.29041C64.8466 0.814218 65.1838 0 65.8573 0H80.9791C81.1796 0 81.3718 0.0796398 81.5136 0.2214L91.5275 10.2353C91.6693 10.3771 91.8615 10.4567 92.062 10.4567H102.71C103.127 10.4567 103.465 10.7951 103.465 11.2126V19.9055C103.465 20.323 103.127 20.6614 102.71 20.6614H92.062C91.8615 20.6614 91.6693 20.7411 91.5275 20.8828L80.6317 31.7786C80.49 31.9204 80.2977 32 80.0972 32Z",
        fill: "url(#paint0_linear_902_4941)"
    }), ae.createElement("path", {
        d: "M90.2471 0.214657L80.0591 5.63904C79.5182 5.92703 79.5268 6.70519 80.0739 6.98117L86.8036 10.3757C86.9092 10.4289 87.0258 10.4567 87.1441 10.4567H99.4952C99.6191 10.4567 99.7411 10.4262 99.8505 10.368L116.414 1.54911C117.109 1.17914 116.846 0.125977 116.059 0.125977H90.6023C90.4784 0.125977 90.3564 0.15643 90.2471 0.214657Z",
        fill: "url(#paint1_linear_902_4941)"
    }), ae.createElement("path", {
        d: "M90.2471 30.7775L80.0591 25.3532C79.5182 25.0652 79.5268 24.287 80.0739 24.011L86.8036 20.6165C86.9092 20.5632 87.0258 20.5355 87.1441 20.5355H99.4952C99.6191 20.5355 99.7411 20.566 99.8505 20.6242L116.414 29.4431C117.109 29.813 116.846 30.8662 116.059 30.8662H90.6023C90.4784 30.8662 90.3564 30.8358 90.2471 30.7775Z",
        fill: "url(#paint2_linear_902_4941)"
    }), ae.createElement("path", {
        d: "M67.0987 19.651H68.3591V21.7378H66.6648C65.8522 21.7378 65.1497 21.5794 64.5574 21.2626C63.9651 20.9458 63.5105 20.4912 63.1937 19.8989C62.8769 19.2929 62.7185 18.5835 62.7185 17.7708V12.5435H60.7144V12.1096L64.5987 7.97729H64.9913V10.5806H68.2971V12.5435H65.0119V17.5849C65.0119 18.246 65.191 18.7557 65.5491 19.1138C65.9073 19.4719 66.4238 19.651 67.0987 19.651Z",
        fill: "white"
    }), ae.createElement("path", {
        d: "M54.8735 10.3328C56.1683 10.3328 57.1945 10.7667 57.9521 11.6344C58.7234 12.5022 59.1091 13.6317 59.1091 15.0229V21.7379H56.8157V15.4775C56.8157 14.4719 56.5953 13.7075 56.1545 13.184C55.7275 12.6468 55.0939 12.3782 54.2537 12.3782C53.3859 12.3782 52.6696 12.6951 52.1049 13.3287C51.5401 13.9623 51.2578 14.775 51.2578 15.7667V21.7379H48.9644V10.5807H50.5553L51.0098 12.1303C51.4368 11.5656 51.9809 11.1248 52.6421 10.808C53.317 10.4912 54.0608 10.3328 54.8735 10.3328Z",
        fill: "white"
    }), ae.createElement("path", {
        d: "M46.529 16.1799C46.529 16.3865 46.5153 16.6413 46.4877 16.9443H37.438C37.5758 17.8397 37.9477 18.549 38.5537 19.0725C39.1736 19.5959 39.938 19.8576 40.8471 19.8576C41.2879 19.8576 41.7012 19.7956 42.0868 19.6716C42.4725 19.5339 42.81 19.3479 43.0992 19.1138C43.4023 18.8658 43.6502 18.5697 43.8431 18.2253H46.2604C45.8197 19.4099 45.1172 20.3397 44.153 21.0146C43.1888 21.6758 42.0868 22.0064 40.8471 22.0064C39.208 22.0064 37.8375 21.4485 36.7355 20.3328C35.6474 19.2171 35.1033 17.8259 35.1033 16.1592C35.1033 14.4925 35.6474 13.1013 36.7355 11.9856C37.8375 10.8699 39.208 10.312 40.8471 10.312C41.9629 10.312 42.9546 10.5806 43.8224 11.1178C44.6902 11.6412 45.3582 12.3506 45.8266 13.2459C46.2949 14.1275 46.529 15.1055 46.529 16.1799ZM40.8471 12.3782C39.9931 12.3782 39.2631 12.6192 38.657 13.1013C38.0647 13.5834 37.6722 14.2446 37.4793 15.0848H44.2356C44.0979 14.5201 43.8706 14.038 43.5538 13.6385C43.237 13.2253 42.8444 12.9154 42.3761 12.7087C41.9215 12.4883 41.4119 12.3782 40.8471 12.3782Z",
        fill: "white"
    }), ae.createElement("path", {
        d: "M31.1592 10.5806H32.6675V20.2708C32.6675 21.4554 32.4402 22.4747 31.9857 23.3287C31.5449 24.1965 30.9044 24.8576 30.0642 25.3122C29.224 25.7805 28.2322 26.0147 27.0889 26.0147C25.6702 26.0147 24.4787 25.6634 23.5145 24.961C22.5503 24.2722 21.9236 23.308 21.6343 22.0684H23.9277C24.1344 22.6744 24.5269 23.1428 25.1054 23.4733C25.6977 23.8039 26.352 23.9692 27.0683 23.9692C28.06 23.9692 28.8658 23.6662 29.4857 23.0601C30.1055 22.454 30.4154 21.6276 30.4154 20.5807V20.0849C29.3824 20.9664 28.1496 21.4072 26.717 21.4072C25.1743 21.4072 23.8658 20.8769 22.7914 19.8163C21.7307 18.7419 21.2004 17.4264 21.2004 15.8699C21.2004 14.3134 21.7307 12.998 22.7914 11.9236C23.8658 10.8492 25.1743 10.312 26.717 10.312C28.3562 10.312 29.7129 10.8836 30.7873 12.0269L31.1592 10.5806ZM26.9856 19.2791C27.4677 19.2791 27.9223 19.1964 28.3493 19.0311C28.7763 18.8521 29.1413 18.6179 29.4443 18.3286C29.7474 18.0256 29.9815 17.6606 30.1468 17.2336C30.3259 16.8066 30.4154 16.352 30.4154 15.8699C30.4154 14.8782 30.0917 14.0586 29.4443 13.4112C28.797 12.7638 27.9774 12.4401 26.9856 12.4401C25.9939 12.4401 25.1674 12.7707 24.5063 13.4319C23.8589 14.0793 23.5352 14.892 23.5352 15.8699C23.5352 16.8479 23.8589 17.6606 24.5063 18.308C25.1674 18.9554 25.9939 19.2791 26.9856 19.2791Z",
        fill: "white"
    }), ae.createElement("path", {
        d: "M16.3423 21.7379V7.2749H18.7183V21.7379H16.3423Z",
        fill: "white"
    }), ae.createElement("path", {
        d: "M11.6509 21.7377L10.3906 18.5971H3.94422L2.70453 21.7377H0.183838L6.01036 7.27466H8.24179L14.2129 21.7377H11.6509ZM7.14674 10.3739L4.77067 16.469H9.56412L7.14674 10.3739Z",
        fill: "white"
    }), ae.createElement("defs", null, ae.createElement("linearGradient", {
        id: "paint0_linear_902_4941",
        x1: 73.2292,
        y1: 17.2598,
        x2: 101.828,
        y2: 17.6378,
        gradientUnits: "userSpaceOnUse"
    }, ae.createElement("stop", {
        stopColor: "#6015FF"
    }), ae.createElement("stop", {
        offset: .619792,
        stopColor: "#FB1FFF",
        stopOpacity: .46
    }), ae.createElement("stop", {
        offset: 1,
        stopColor: "#FB1FFF",
        stopOpacity: 0
    })), ae.createElement("linearGradient", {
        id: "paint1_linear_902_4941",
        x1: 112.404,
        y1: .699905,
        x2: 93.528,
        y2: 19.4684,
        gradientUnits: "userSpaceOnUse"
    }, ae.createElement("stop", {
        stopColor: "#6015FF"
    }), ae.createElement("stop", {
        offset: 1,
        stopColor: "#6232CA",
        stopOpacity: 0
    })), ae.createElement("linearGradient", {
        id: "paint2_linear_902_4941",
        x1: 112.404,
        y1: 30.2923,
        x2: 93.528,
        y2: 11.5237,
        gradientUnits: "userSpaceOnUse"
    }, ae.createElement("stop", {
        stopColor: "#6015FF"
    }), ae.createElement("stop", {
        offset: 1,
        stopColor: "#6232CA",
        stopOpacity: 0
    })))),
    zvt = Tu.memo(() => {
        const {
            walletProvider: t
        } = fg(), {
            address: e
        } = xs(), {
            transactions: n,
            getTransactionsFromStorage: r,
            resetTransactionsStore: i,
            trackTx: s
        } = Ny();
        ae.useEffect(() => {
            if (i(), !e || !t) return;
            const a = new Kf(t),
                l = r()[Hn(e)] || {};
            Object.values(l).forEach(c => {
                c.status === B0.Pending && a.getTransaction(c.hash).then(u => {
                    u && s(u)
                }).catch(u => console.error("Failed to get Transaction:", u))
            })
        }, [e, t]);
        const o = ae.useMemo(() => e ? Object.values(r()[Hn(e)] || {}).filter(a => a.status === B0.Pending).length : 0, [e, r, n]);
        return o ? J.jsxs(Bo, {
            buttonType: "stroke",
            children: [J.jsx("div", {
                className: "mr-4 w-4 h-4",
                children: J.jsx(D7, {
                    spinnerSize: "full",
                    className: "fill-white"
                })
            }), o, " pending"]
        }) : null
    }),
    Wvt = () => J.jsxs("div", {
        className: "flex justify-between items-center px-6 py-4 border-b border-opacity-10 border-white ",
        children: [J.jsx(Hvt, {}), J.jsxs("div", {
            className: "flex items-center space-x-6",
            children: [J.jsx(zvt, {}), J.jsx(Kde, {})]
        })]
    }),
    Vvt = () => {
        const [{
            chainConfig: t,
            appRpcProvider: e
        }] = Uo(), [n, r] = ae.useState({
            totalAllocated: "0",
            totalStaked: "0",
            fetching: !0
        });
        ae.useEffect(() => {
            (async () => {
                try {
                    const c = new Qr(t.contracts.AIXRevenueSharing, gU, e),
                        [u, f] = await Promise.all([c.totalStaked(), c.totalAssignedRewards()]);
                    r({
                        totalStaked: u.toString(),
                        totalAllocated: f.toString(),
                        fetching: !1
                    })
                } catch (c) {
                    console.error("Error fetching staking data:", c)
                }
            })()
        }, [t, e]);
        const {
            totalAllocated: i,
            totalStaked: s,
            fetching: o
        } = n, a = () => J.jsxs(J.Fragment, {
            children: [J.jsxs("div", {
                className: " mb-3",
                children: [J.jsx("div", {
                    className: "mb-0.5 whitespace-nowrap",
                    children: o ? "Loading..." : `${jQ(Os(i,{round:2}))} ETH`
                }), J.jsx("div", {
                    className: "text-xs opacity-40",
                    children: "Allocated rewards"
                })]
            }), J.jsxs("div", {
                children: [J.jsx("div", {
                    className: "mb-0.5 whitespace-nowrap",
                    children: o ? "Loading..." : `${jQ(Os(s,{round:0}))} AIX`
                }), J.jsx("div", {
                    className: "text-xs opacity-40",
                    children: "Total staked amount"
                })]
            })]
        });
        return J.jsxs(V7, {
            className: "mx-6 rounded-2xl mt-6",
            children: [J.jsxs("div", {
                className: "flex items-center mb-5",
                children: [J.jsx(Xr, {
                    className: "text-white text-xl mr-1",
                    icon: "cib:ethereum"
                }), J.jsx("span", {
                    className: "-mb-1 text-xs",
                    children: "ETH Rewards"
                })]
            }), J.jsx("div", {
                className: "flex flex-col flex-wrap",
                children: a()
            })]
        })
    },
    Gvt = [{
        name: "Conversations",
        to: "/conversations",
        icon: "fa6-solid:comments"
    }, {
        name: "Exchange",
        to: "/exchange",
        icon: "fa6-solid:coins"
    }, {
        name: "Dashboard",
        to: "/dashboard",
        icon: "fa6-solid:gauge-high"
    }, {
        name: "My Aigents",
        to: "/my-bots",
        icon: "fa6-solid:robot"
    }, {
        name: "NFT Generation",
        to: "/nft-generator",
        icon: "fa6-solid:images"
    }, {
        name: "Product Suite",
        to: "/product-suite",
        icon: "fa6-solid:file-invoice-dollar"
    }, {
        name: "Staking",
        to: "/staking",
        icon: "fa6-solid:layer-group"
    }, {
        name: "Affiliate Program",
        to: "/affiliate-program",
        icon: "fa6-solid:link"
    }, {
        name: "Team Verification",
        to: "/team-verification",
        icon: "fa6-solid:user-secret"
    }, {
        name: "Migration",
        to: "/migration",
        icon: "fa6-solid:hands-holding-circle"
    }, {
        name: "Docs",
        href: "https://docs.aigentx.xyz",
        icon: "fa6-solid:file-lines"
    }],
    qvt = ({
        item: t
    }) => {
        const e = J.jsxs(J.Fragment, {
            children: [J.jsx("div", {
                className: "w-[18px] h-[18px] -mt-[2px] mr-2 flex items-center justify-center",
                children: J.jsx(Xr, {
                    icon: t.icon
                })
            }), J.jsx("span", {
                className: "mr-6",
                children: t.name
            }), t.disabled ? J.jsx("span", {
                className: "text-xs ml-auto px-2 py-0.5 rounded-xl text-black bg-white",
                children: "soon"
            }) : J.jsx(Xr, {
                className: "ml-auto w-5",
                icon: "fa6-solid:angle-right"
            })]
        });
        return t.to ? J.jsx(ant, {
            to: t.disabled ? "#" : t.to,
            className: ({
                isActive: n
            }) => `px-6 py-3 flex items-center cursor-pointer text-xs xl:text-base ${t.disabled||!n?"opacity-40":""}`,
            children: e
        }, t.to) : J.jsx("a", {
            href: t.href,
            target: "_blank",
            rel: "noopener noreferrer",
            className: `px-6 py-3 flex items-center cursor-pointer ${t.disabled?"opacity-40":""}`,
            children: e
        }, t.href)
    },
    Kvt = () => J.jsxs("div", {
        className: "flex flex-col",
        children: [Gvt.map(t => J.jsx(qvt, {
            item: t
        }, t.to || t.href)), J.jsx(Vvt, {})]
    }),
    Yvt = () => J.jsxs("div", {
        className: "h-screen flex flex-col overflow-hidden",
        children: [J.jsx(Wvt, {}), J.jsxs("div", {
            className: "flex flex-1 pt-6 overflow-hidden",
            children: [J.jsx(Kvt, {}), J.jsx("div", {
                className: "flex flex-col flex-1 pl-4 pr-6 pb-6 overflow-auto",
                children: J.jsx(ae.Suspense, {
                    fallback: null,
                    children: J.jsx(tU, {})
                })
            })]
        })]
    }),
    Zvt = ae.lazy(() => Pi(async () => {
        const {
            AffiliateProgram: t
        } = await
        import ("./affiliate-program-Dp2yZnjm.js");
        return {
            AffiliateProgram: t
        }
    }, __vite__mapDeps([0, 1, 2])).then(({
        AffiliateProgram: t
    }) => ({
        default: t
    }))),
    Qvt = ae.lazy(() => Pi(async () => {
        const {
            Conversations: t
        } = await
        import ("./conversations-DyraImN2.js");
        return {
            Conversations: t
        }
    }, __vite__mapDeps([3, 4, 5, 6])).then(({
        Conversations: t
    }) => ({
        default: t
    }))),
    Jvt = ae.lazy(() => Pi(async () => {
        const {
            Dashboard: t
        } = await
        import ("./dashboard-nxZ0TEun.js");
        return {
            Dashboard: t
        }
    }, __vite__mapDeps([7, 8, 9, 6, 10])).then(({
        Dashboard: t
    }) => ({
        default: t
    }))),
    Xvt = ae.lazy(() => Pi(async () => {
        const {
            Exchange: t
        } = await
        import ("./exchange-DRIoKPGm.js");
        return {
            Exchange: t
        }
    }, __vite__mapDeps([11, 12, 5, 6])).then(({
        Exchange: t
    }) => ({
        default: t
    }))),
    ebt = ae.lazy(() => Pi(async () => {
        const {
            KnowledgeBaseId: t
        } = await
        import ("./knowledgeBaseId-D2TCrlRJ.js");
        return {
            KnowledgeBaseId: t
        }
    }, []).then(({
        KnowledgeBaseId: t
    }) => ({
        default: t
    }))),
    tbt = ae.lazy(() => Pi(async () => {
        const {
            BotId: t
        } = await
        import ("./botId-mZO8aHMT.js");
        return {
            BotId: t
        }
    }, __vite__mapDeps([13, 14, 15, 10, 16, 8, 9, 6])).then(({
        BotId: t
    }) => ({
        default: t
    }))),
    nbt = ae.lazy(() => Pi(async () => {
        const {
            MyBots: t
        } = await
        import ("./my-bots-D_HzAKqj.js");
        return {
            MyBots: t
        }
    }, __vite__mapDeps([17, 10])).then(({
        MyBots: t
    }) => ({
        default: t
    }))),
    rbt = ae.lazy(() => Pi(async () => {
        const {
            NewBot: t
        } = await
        import ("./new-bot-DSIteUrs.js");
        return {
            NewBot: t
        }
    }, __vite__mapDeps([18, 15, 16, 8, 9, 6, 10])).then(({
        NewBot: t
    }) => ({
        default: t
    }))),
    ibt = ae.lazy(() => Pi(async () => {
        const {
            NotFound: t
        } = await
        import ("./not-found-Cx6DF_IT.js");
        return {
            NotFound: t
        }
    }, []).then(({
        NotFound: t
    }) => ({
        default: t
    }))),
    sbt = ae.lazy(() => Pi(async () => {
        const {
            Pricing: t
        } = await
        import ("./pricing-Dsv9dCiq.js");
        return {
            Pricing: t
        }
    }, __vite__mapDeps([19, 15])).then(({
        Pricing: t
    }) => ({
        default: t
    }))),
    obt = ae.lazy(() => Pi(async () => {
        const {
            Staking: t
        } = await
        import ("./staking-BNE0v0-z.js");
        return {
            Staking: t
        }
    }, __vite__mapDeps([20, 21, 1])).then(({
        Staking: t
    }) => ({
        default: t
    }))),
    OP = ae.lazy(() => Pi(async () => {
        const {
            BotsProvider: t
        } = await
        import ("./BotsProvider-IfGpE4IX.js");
        return {
            BotsProvider: t
        }
    }, []).then(({
        BotsProvider: t
    }) => ({
        default: t
    }))),
    abt = ae.lazy(() => Pi(async () => {
        const {
            NftGenerator: t
        } = await
        import ("./nft-generator-C8tP2uwe.js");
        return {
            NftGenerator: t
        }
    }, __vite__mapDeps([22, 2, 14])).then(({
        NftGenerator: t
    }) => ({
        default: t
    }))),
    lbt = ae.lazy(() => Pi(async () => {
        const {
            NftGeneratorSettings: t
        } = await
        import ("./nft-generator_settings-CdXxTFgR.js");
        return {
            NftGeneratorSettings: t
        }
    }, []).then(({
        NftGeneratorSettings: t
    }) => ({
        default: t
    }))),
    cbt = ae.lazy(() => Pi(async () => {
        const {
            Migration: t
        } = await
        import ("./migration-Be-njFAo.js");
        return {
            Migration: t
        }
    }, __vite__mapDeps([23, 21, 1])).then(({
        Migration: t
    }) => ({
        default: t
    }))),
    ubt = ae.lazy(() => Pi(async () => {
        const {
            TeamVerification: t
        } = await
        import ("./team-verification-xjsORUYn.js");
        return {
            TeamVerification: t
        }
    }, __vite__mapDeps([24, 25])).then(({
        TeamVerification: t
    }) => ({
        default: t
    }))),
    fbt = ae.lazy(() => Pi(async () => {
        const {
            BuildAgent: t
        } = await
        import ("./build-agent-CS71JEu4.js");
        return {
            BuildAgent: t
        }
    }, __vite__mapDeps([26, 8, 9, 6])).then(({
        BuildAgent: t
    }) => ({
        default: t
    }))),
    dbt = ae.lazy(() => Pi(async () => {
        const {
            AiMarketplace: t
        } = await
        import ("./ai-marketplace-B9SUU8oe.js");
        return {
            AiMarketplace: t
        }
    }, __vite__mapDeps([27, 28])).then(({
        AiMarketplace: t
    }) => ({
        default: t
    }))),
    hbt = ae.lazy(() => Pi(async () => {
        const {
            AGI: t
        } = await
        import ("./agi-B5CtDf5n.js");
        return {
            AGI: t
        }
    }, __vite__mapDeps([29, 4, 25, 12, 5, 9, 6])).then(({
        AGI: t
    }) => ({
        default: t
    }))),
    pbt = ae.lazy(() => Pi(async () => {
        const {
            ToolName: t
        } = await
        import ("./toolName-CSfs3Pwj.js");
        return {
            ToolName: t
        }
    }, __vite__mapDeps([30, 5])).then(({
        ToolName: t
    }) => ({
        default: t
    }))),
    gbt = [{
        path: "/",
        element: J.jsxs(J.Fragment, {
            children: [J.jsx(cft, {}), J.jsx(Yvt, {})]
        }),
        children: [{
            index: !0,
            element: J.jsx(Btt, {
                to: "/staking",
                replace: !0
            })
        }, {
            path: "exchange",
            element: J.jsx(jvt, {
                children: J.jsx(Xvt, {})
            })
        }, {
            path: "conversations",
            children: [{
                index: !0,
                element: J.jsx(gw, {
                    children: J.jsx(OP, {
                        children: J.jsx(dft, {
                            children: J.jsx(Qvt, {})
                        })
                    })
                })
            }]
        }, {
            path: "dashboard",
            element: J.jsx(gw, {
                children: J.jsx(OP, {
                    children: J.jsx(Jvt, {})
                })
            })
        }, {
            path: "staking",
            element: J.jsxs(fJ, {
                children: [J.jsx(uJ, {}), J.jsx(obt, {})]
            })
        }, {
            path: "affiliate-program",
            element: J.jsx(gw, {
                children: J.jsx(Zvt, {})
            })
        }, {
            path: "product-suite",
            element: J.jsxs(gw, {
                children: [J.jsx(uJ, {}), J.jsx(sbt, {})]
            })
        }, {
            path: "my-bots",
            element: J.jsx(gw, {
                children: J.jsx(OP, {})
            }),
            children: [{
                index: !0,
                element: J.jsx(nbt, {})
            }, {
                path: "new-bot",
                element: J.jsx(rbt, {})
            }, {
                path: ":botId",
                children: [{
                    index: !0,
                    element: J.jsx(tbt, {})
                }, {
                    path: ":knowledgeBaseId",
                    element: J.jsx(ebt, {})
                }]
            }]
        }, {
            path: "team-verification",
            element: J.jsx(ubt, {})
        }, {
            path: "ai-marketplace",
            children: [{
                index: !0,
                element: J.jsx(dbt, {})
            }, {
                path: ":toolName",
                element: J.jsx(pbt, {})
            }]
        }, {
            path: "migration",
            element: J.jsx(fJ, {
                children: J.jsx(cbt, {})
            })
        }, {
            path: "agi",
            element: J.jsx(hbt, {})
        }, {
            path: "nft-generator",
            element: J.jsx(gw, {}),
            children: [{
                index: !0,
                element: J.jsx(abt, {})
            }, {
                path: "settings",
                element: J.jsx(lbt, {})
            }]
        }, {
            path: "build-agent",
            element: J.jsx(fbt, {})
        }, {
            path: "*",
            element: J.jsx(ibt, {})
        }]
    }],
    mbt = qtt(gbt),
    ybt = "9a5549efdeb169133be9f26cfd7200b2",
    wbt = {
        chainId: 1,
        name: "Ethereum",
        currency: "ETH",
        explorerUrl: "https://etherscan.io",
        rpcUrl: "https://cloudflare-eth.com"
    },
    vbt = {
        name: "My Website",
        description: "My Website description",
        url: "https://mywebsite.com",
        icons: ["https://avatars.mywebsite.com/"]
    };
gJe({
    ethersConfig: pJe({
        metadata: vbt
    }),
    chains: [wbt],
    projectId: ybt
});
const bbt = document.getElementById("root"),
    _bt = new ave;
MM.createRoot(bbt).render(J.jsx(lve, {
    client: _bt,
    children: J.jsx(rot, {
        children: J.jsx(iit, {
            children: J.jsx(oot, {
                children: J.jsx(Hst, {
                    children: J.jsxs(hot, {
                        children: [J.jsx(ift, {}), J.jsx(tnt, {
                            router: mbt
                        }), J.jsx(oft, {})]
                    })
                })
            })
        })
    })
}));
export {
    D7 as $, Np as A, JN as B, Qr as C, ont as D, W7 as E, Kf as F, Kfe as G, Tu as H, Xr as I, Fo as J, Uu as K, Jfe as L, q8 as M, Pi as N, V7 as O, Qut as P, Qm as Q, vh as R, lft as S, gU as T, $7 as U, $A as V, Dnt as W, Hfe as X, gt as Y, aft as Z, xc as _, eU as a, Yfe as a0, E3t as a1, x3t as a2, got as a3, uft as a4, S3t as a5, cT as a6, Wwe as a7, xbt as a8, hz as a9, tu as aa, uT as ab, Hwe as ac, zwe as ad, jX as ae, eve as af, Gwe as ag, na as ah, Sbt as ai, A3t as aj, sit as ak, gc as al, Eot as am, sy as an, zf as ao, st as ap, co as aq, v3t as ar, cit as as, Fu as at, uE as au, z7 as b, lit as c, Bo as d, Ml as e, xs as f, tU as g, unt as h, pot as i, J as j, Dr as k, va as l, Os as m, C3t as n, fg as o, Uo as p, Ny as q, ae as r, _3t as s, Zfe as t, b3t as u, Qfe as v, ur as w, Is as x, Xm as y, FA as z
};
//# sourceMappingURL=index-ew_iRevO.js.map